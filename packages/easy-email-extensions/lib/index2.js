var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target2 = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target2[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target2[prop] = source[prop];
    }
  return target2;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
import * as React from "react";
import React__default, { Children, isValidElement, cloneElement, createContext, useContext, Component, useMemo, memo, forwardRef, useEffect, useRef, useLayoutEffect, useState, useImperativeHandle, PureComponent, useCallback, useReducer, createRef, Fragment, createElement, Suspense } from "react";
import { IconFont, useEditorProps, useRefState, Stack as Stack$4, getShadowRoot, DATA_CONTENT_EDITABLE_TYPE, ContentEditableType, TextStyle, useEditorContext, useBlock, useFocusIdx, useFocusBlockLayout, MergeTagBadge, FIXED_CONTAINER_ID, getPluginElement, RICH_TEXT_BAR_ID, CONTENT_EDITABLE_CLASS_NAME, getEditorRoot, DATA_CONTENT_EDITABLE_IDX, scrollBlockEleIntoView, useHoverIdx, useDataTransfer, getBlockNodeByChildEle, getDirectionPosition, DATA_ATTRIBUTE_DROP_CONTAINER, BlockAvatarWrapper, isTextBlock, getBlockNodeByIdx, useLazyState, useActiveTab, ActiveTabKeys } from "easy-email-editor";
import { BasicType, ImageManager, EMAIL_BLOCK_CLASS_NAME, BlockManager, createBlockDataByType, AdvancedType, Operator, OperatorSymbol, I18nType, isAdvancedBlock, getParentByIdx, getParentIdx, getIndexByIdx, getSiblingIdx, getNodeIdxFromClassName, getNodeIdxClassName, getPageIdx, getChildIdx, MjmlToJson, JsonToMjml, getNodeTypeFromClassName } from "easy-email-core";
import ReactDOM, { findDOMNode, createPortal } from "react-dom";
import { useField, Field, useForm as useForm$1, Form as Form$3, version as version$2, useFormState } from "react-final-form";
var index$2 = "";
const title = "_title_1f523_1";
var styles$a = {
  title
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(module, exports) {
  (function() {
    var undefined$1;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE2 = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT2 = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE2 = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG2 = 1, CLONE_FLAT_FLAG2 = 2, CLONE_SYMBOLS_FLAG2 = 4;
    var COMPARE_PARTIAL_FLAG2 = 1, COMPARE_UNORDERED_FLAG2 = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT2 = 800, HOT_SPAN2 = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN2 = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", domExcTag = "[object DOMException]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", nullTag2 = "[object Null]", objectTag2 = "[object Object]", promiseTag2 = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag2 = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp2 = /^\w*$/, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar2.source);
    var reTrimStart2 = /^\s+/;
    var reWhitespace2 = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar2 = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags2 = /\w*$/;
    var reIsBadHex2 = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary2 = /^0b[01]+$/i;
    var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
    var reIsOctal2 = /^0o[0-7]+$/i;
    var reIsUint2 = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags2 = {};
    typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
    typedArrayTags2[argsTag2] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag2] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
    var cloneableTags2 = {};
    cloneableTags2[argsTag2] = cloneableTags2[arrayTag2] = cloneableTags2[arrayBufferTag2] = cloneableTags2[dataViewTag2] = cloneableTags2[boolTag2] = cloneableTags2[dateTag2] = cloneableTags2[float32Tag2] = cloneableTags2[float64Tag2] = cloneableTags2[int8Tag2] = cloneableTags2[int16Tag2] = cloneableTags2[int32Tag2] = cloneableTags2[mapTag2] = cloneableTags2[numberTag2] = cloneableTags2[objectTag2] = cloneableTags2[regexpTag2] = cloneableTags2[setTag2] = cloneableTags2[stringTag2] = cloneableTags2[symbolTag2] = cloneableTags2[uint8Tag2] = cloneableTags2[uint8ClampedTag2] = cloneableTags2[uint16Tag2] = cloneableTags2[uint32Tag2] = true;
    cloneableTags2[errorTag2] = cloneableTags2[funcTag2] = cloneableTags2[weakMapTag2] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt2 = parseInt;
    var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal2.process;
    var nodeUtil2 = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil2 && nodeUtil2.isArrayBuffer, nodeIsDate = nodeUtil2 && nodeUtil2.isDate, nodeIsMap2 = nodeUtil2 && nodeUtil2.isMap, nodeIsRegExp = nodeUtil2 && nodeUtil2.isRegExp, nodeIsSet2 = nodeUtil2 && nodeUtil2.isSet, nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
    function apply2(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index2 = -1, length2 = array == null ? 0 : array.length;
      while (++index2 < length2) {
        var value = array[index2];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach2(array, iteratee) {
      var index2 = -1, length2 = array == null ? 0 : array.length;
      while (++index2 < length2) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length2 = array == null ? 0 : array.length;
      while (length2--) {
        if (iteratee(array[length2], length2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index2 = -1, length2 = array == null ? 0 : array.length;
      while (++index2 < length2) {
        if (!predicate(array[index2], index2, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter2(array, predicate) {
      var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value = array[index2];
        if (predicate(value, index2, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length2 = array == null ? 0 : array.length;
      return !!length2 && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index2 = -1, length2 = array == null ? 0 : array.length;
      while (++index2 < length2) {
        if (comparator(value, array[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap2(array, iteratee) {
      var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
      while (++index2 < length2) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    function arrayPush2(array, values2) {
      var index2 = -1, length2 = values2.length, offset = array.length;
      while (++index2 < length2) {
        array[offset + index2] = values2[index2];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length2 = array == null ? 0 : array.length;
      if (initAccum && length2) {
        accumulator = array[++index2];
      }
      while (++index2 < length2) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length2 = array == null ? 0 : array.length;
      if (initAccum && length2) {
        accumulator = array[--length2];
      }
      while (length2--) {
        accumulator = iteratee(accumulator, array[length2], length2, array);
      }
      return accumulator;
    }
    function arraySome2(array, predicate) {
      var index2 = -1, length2 = array == null ? 0 : array.length;
      while (++index2 < length2) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length2 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length2) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index2 = fromIndex - 1, length2 = array.length;
      while (++index2 < length2) {
        if (comparator(array[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length2 = array == null ? 0 : array.length;
      return length2 ? baseSum(array, iteratee) / length2 : NAN2;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length2 = array.length;
      array.sort(comparer);
      while (length2--) {
        array[length2] = array[length2].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index2 = -1, length2 = array.length;
      while (++index2 < length2) {
        var current = iteratee(array[index2]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes2(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap2(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim2(string) {
      return string ? string.slice(0, trimmedEndIndex2(string) + 1).replace(reTrimStart2, "") : string;
    }
    function baseUnary2(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap2(props, function(key) {
        return object[key];
      });
    }
    function cacheHas2(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length2 = strSymbols.length;
      while (++index2 < length2 && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array, placeholder) {
      var length2 = array.length, result = 0;
      while (length2--) {
        if (array[length2] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue2(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray2(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg2(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index2 = -1, length2 = array.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value = array[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray2(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    function setToPairs(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index2 = fromIndex - 1, length2 = array.length;
      while (++index2 < length2) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex2(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace2.test(string.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root2 : _.defaults(root2.Object(), context, _.pick(root2, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto2 = Array2.prototype, funcProto2 = Function2.prototype, objectProto2 = Object2.prototype;
      var coreJsData2 = context["__core-js_shared__"];
      var funcToString2 = funcProto2.toString;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey2 = function() {
        var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString2 = objectProto2.toString;
      var objectCtorString2 = funcToString2.call(Object2);
      var oldDash = root2._;
      var reIsNative2 = RegExp2("^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype2 = overArg2(Object2.getPrototypeOf, Object2), objectCreate2 = Object2.create, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, spreadableSymbol2 = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty2 = function() {
        try {
          var func = getNative2(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols2 = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto2.join, nativeKeys2 = overArg2(Object2.keys, Object2), nativeMax2 = Math2.max, nativeMin2 = Math2.min, nativeNow2 = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto2.reverse;
      var DataView2 = getNative2(context, "DataView"), Map2 = getNative2(context, "Map"), Promise2 = getNative2(context, "Promise"), Set2 = getNative2(context, "Set"), WeakMap2 = getNative2(context, "WeakMap"), nativeCreate2 = getNative2(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map2), promiseCtorString2 = toSource2(Promise2), setCtorString2 = toSource2(Set2), weakMapCtorString2 = toSource2(WeakMap2);
      var symbolProto2 = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : undefined$1, symbolToString2 = symbolProto2 ? symbolProto2.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate2 = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate2) {
            return objectCreate2(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        "escape": reEscape,
        "evaluate": reEvaluate,
        "interpolate": reInterpolate,
        "variable": "",
        "imports": {
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate2(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray2(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray2(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray2(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length2 = end - start2, index2 = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin2(length2, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length2-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array[index2];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate2(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash2(entries) {
        var index2 = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length2) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear2() {
        this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
        this.size = 0;
      }
      function hashDelete2(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet2(key) {
        var data = this.__data__;
        if (nativeCreate2) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED2 ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
      }
      function hashHas2(key) {
        var data = this.__data__;
        return nativeCreate2 ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
      }
      function hashSet2(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate2 && value === undefined$1 ? HASH_UNDEFINED2 : value;
        return this;
      }
      Hash2.prototype.clear = hashClear2;
      Hash2.prototype["delete"] = hashDelete2;
      Hash2.prototype.get = hashGet2;
      Hash2.prototype.has = hashHas2;
      Hash2.prototype.set = hashSet2;
      function ListCache2(entries) {
        var index2 = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length2) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear2() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete2(key) {
        var data = this.__data__, index2 = assocIndexOf2(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice2.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet2(key) {
        var data = this.__data__, index2 = assocIndexOf2(data, key);
        return index2 < 0 ? undefined$1 : data[index2][1];
      }
      function listCacheHas2(key) {
        return assocIndexOf2(this.__data__, key) > -1;
      }
      function listCacheSet2(key, value) {
        var data = this.__data__, index2 = assocIndexOf2(data, key);
        if (index2 < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      ListCache2.prototype.clear = listCacheClear2;
      ListCache2.prototype["delete"] = listCacheDelete2;
      ListCache2.prototype.get = listCacheGet2;
      ListCache2.prototype.has = listCacheHas2;
      ListCache2.prototype.set = listCacheSet2;
      function MapCache2(entries) {
        var index2 = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length2) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear2() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash2(),
          "map": new (Map2 || ListCache2)(),
          "string": new Hash2()
        };
      }
      function mapCacheDelete2(key) {
        var result2 = getMapData2(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet2(key) {
        return getMapData2(this, key).get(key);
      }
      function mapCacheHas2(key) {
        return getMapData2(this, key).has(key);
      }
      function mapCacheSet2(key, value) {
        var data = getMapData2(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache2.prototype.clear = mapCacheClear2;
      MapCache2.prototype["delete"] = mapCacheDelete2;
      MapCache2.prototype.get = mapCacheGet2;
      MapCache2.prototype.has = mapCacheHas2;
      MapCache2.prototype.set = mapCacheSet2;
      function SetCache2(values3) {
        var index2 = -1, length2 = values3 == null ? 0 : values3.length;
        this.__data__ = new MapCache2();
        while (++index2 < length2) {
          this.add(values3[index2]);
        }
      }
      function setCacheAdd2(value) {
        this.__data__.set(value, HASH_UNDEFINED2);
        return this;
      }
      function setCacheHas2(value) {
        return this.__data__.has(value);
      }
      SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
      SetCache2.prototype.has = setCacheHas2;
      function Stack2(entries) {
        var data = this.__data__ = new ListCache2(entries);
        this.size = data.size;
      }
      function stackClear2() {
        this.__data__ = new ListCache2();
        this.size = 0;
      }
      function stackDelete2(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet2(key) {
        return this.__data__.get(key);
      }
      function stackHas2(key) {
        return this.__data__.has(key);
      }
      function stackSet2(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache2) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache2(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack2.prototype.clear = stackClear2;
      Stack2.prototype["delete"] = stackDelete2;
      Stack2.prototype.get = stackGet2;
      Stack2.prototype.has = stackHas2;
      Stack2.prototype.set = stackSet2;
      function arrayLikeKeys2(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes2(value.length, String2) : [], length2 = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex2(key, length2)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length2 = array.length;
        return length2 ? array[baseRandom(0, length2 - 1)] : undefined$1;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray2(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray2(array));
      }
      function assignMergeValue2(object, key, value) {
        if (value !== undefined$1 && !eq2(object[key], value) || value === undefined$1 && !(key in object)) {
          baseAssignValue2(object, key, value);
        }
      }
      function assignValue2(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === undefined$1 && !(key in object)) {
          baseAssignValue2(object, key, value);
        }
      }
      function assocIndexOf2(array, key) {
        var length2 = array.length;
        while (length2--) {
          if (eq2(array[length2][0], key)) {
            return length2;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign2(object, source) {
        return object && copyObject2(source, keys2(source), object);
      }
      function baseAssignIn2(object, source) {
        return object && copyObject2(source, keysIn2(source), object);
      }
      function baseAssignValue2(object, key, value) {
        if (key == "__proto__" && defineProperty2) {
          defineProperty2(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index2 = -1, length2 = paths.length, result2 = Array2(length2), skip = object == null;
        while (++index2 < length2) {
          result2[index2] = skip ? undefined$1 : get2(object, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined$1) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined$1) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone2(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG2, isFlat = bitmask & CLONE_FLAT_FLAG2, isFull = bitmask & CLONE_SYMBOLS_FLAG2;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray2(value);
          if (!isDeep) {
            return copyArray2(value, result2);
          }
        } else {
          var tag = getTag2(value), isFunc = tag == funcTag2 || tag == genTag2;
          if (isBuffer2(value)) {
            return cloneBuffer2(value, isDeep);
          }
          if (tag == objectTag2 || tag == argsTag2 || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject2(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn2(value, baseAssignIn2(result2, value)) : copySymbols2(value, baseAssign2(result2, value));
            }
          } else {
            if (!cloneableTags2[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag2(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack2());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet2(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone2(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap2(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone2(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn2 : getAllKeys2 : isFlat ? keysIn2 : keys2;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach2(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue2(result2, key2, baseClone2(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys2(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length2 = props.length;
        if (object == null) {
          return !length2;
        }
        object = Object2(object);
        while (length2--) {
          var key = props[length2], predicate = source[key], value = object[key];
          if (value === undefined$1 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array, values3, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length2 = array.length, result2 = [], valuesLength = values3.length;
        if (!length2) {
          return result2;
        }
        if (iteratee2) {
          values3 = arrayMap2(values3, baseUnary2(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values3.length >= LARGE_ARRAY_SIZE2) {
          includes2 = cacheHas2;
          isCommon = false;
          values3 = new SetCache2(values3);
        }
        outer:
          while (++index2 < length2) {
            var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values3[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values3, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index2, collection2) {
          result2 = !!predicate(value, index2, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index2 = -1, length2 = array.length;
        while (++index2 < length2) {
          var value = array[index2], current = iteratee2(value);
          if (current != null && (computed === undefined$1 ? current === current && !isSymbol2(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start2, end) {
        var length2 = array.length;
        start2 = toInteger(start2);
        if (start2 < 0) {
          start2 = -start2 > length2 ? 0 : length2 + start2;
        }
        end = end === undefined$1 || end > length2 ? length2 : toInteger(end);
        if (end < 0) {
          end += length2;
        }
        end = start2 > end ? 0 : toLength(end);
        while (start2 < end) {
          array[start2++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index2, collection2) {
          if (predicate(value, index2, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten2(array, depth, predicate, isStrict, result2) {
        var index2 = -1, length2 = array.length;
        predicate || (predicate = isFlattenable2);
        result2 || (result2 = []);
        while (++index2 < length2) {
          var value = array[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten2(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush2(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor2 = createBaseFor2();
      var baseForRight = createBaseFor2(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor2(object, iteratee2, keys2);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys2);
      }
      function baseFunctions(object, props) {
        return arrayFilter2(props, function(key) {
          return isFunction2(object[key]);
        });
      }
      function baseGet2(object, path) {
        path = castPath2(path, object);
        var index2 = 0, length2 = path.length;
        while (object != null && index2 < length2) {
          object = object[toKey2(path[index2++])];
        }
        return index2 && index2 == length2 ? object : undefined$1;
      }
      function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush2(result2, symbolsFunc(object));
      }
      function baseGetTag2(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag2 : nullTag2;
        }
        return symToStringTag2 && symToStringTag2 in Object2(value) ? getRawTag2(value) : objectToString2(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas2(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start2, end) {
        return number >= nativeMin2(start2, end) && number < nativeMax2(start2, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap2(array, baseUnary2(iteratee2));
          }
          maxLength = nativeMin2(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array.length >= 120) ? new SetCache2(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index2 = -1, seen = caches[0];
        outer:
          while (++index2 < length2 && result2.length < maxLength) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas2(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas2(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath2(path, object);
        object = parent2(object, path);
        var func = object == null ? object : object[toKey2(last2(path))];
        return func == null ? undefined$1 : apply2(func, object, args);
      }
      function baseIsArguments2(value) {
        return isObjectLike2(value) && baseGetTag2(value) == argsTag2;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike2(value) && baseGetTag2(value) == arrayBufferTag2;
      }
      function baseIsDate(value) {
        return isObjectLike2(value) && baseGetTag2(value) == dateTag2;
      }
      function baseIsEqual2(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep2(value, other, bitmask, customizer, baseIsEqual2, stack);
      }
      function baseIsEqualDeep2(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag2 : getTag2(object), othTag = othIsArr ? arrayTag2 : getTag2(other);
        objTag = objTag == argsTag2 ? objectTag2 : objTag;
        othTag = othTag == argsTag2 ? objectTag2 : othTag;
        var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object)) {
          if (!isBuffer2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack2());
          return objIsArr || isTypedArray2(object) ? equalArrays2(object, other, bitmask, customizer, equalFunc, stack) : equalByTag2(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG2)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack2());
        return equalObjects2(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap2(value) {
        return isObjectLike2(value) && getTag2(value) == mapTag2;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length2;
        }
        object = Object2(object);
        while (index2--) {
          var data = matchData[index2];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index2 < length2) {
          data = matchData[index2];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack2();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined$1 ? baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG2 | COMPARE_UNORDERED_FLAG2, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative2(value) {
        if (!isObject2(value) || isMasked2(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
        return pattern.test(toSource2(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike2(value) && baseGetTag2(value) == regexpTag2;
      }
      function baseIsSet2(value) {
        return isObjectLike2(value) && getTag2(value) == setTag2;
      }
      function baseIsTypedArray2(value) {
        return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity2;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys2(object) {
        if (!isPrototype2(object)) {
          return nativeKeys2(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn2(object) {
        if (!isObject2(object)) {
          return nativeKeysIn2(object);
        }
        var isProto = isPrototype2(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index2] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey2(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey2(path), srcValue);
        }
        return function(object) {
          var objValue = get2(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG2 | COMPARE_UNORDERED_FLAG2);
        };
      }
      function baseMerge2(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor2(source, function(srcValue, key) {
          stack || (stack = new Stack2());
          if (isObject2(srcValue)) {
            baseMergeDeep2(object, source, key, srcIndex, baseMerge2, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet2(object, key), srcValue, key + "", object, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue2(object, key, newValue);
          }
        }, keysIn2);
      }
      function baseMergeDeep2(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet2(object, key), srcValue = safeGet2(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue2(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject2(objValue)) {
              newValue = copyArray2(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer2(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray2(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments2(srcValue)) {
            newValue = objValue;
            if (isArguments2(objValue)) {
              newValue = toPlainObject2(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject2(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue2(object, key, newValue);
      }
      function baseNth(array, n) {
        var length2 = array.length;
        if (!length2) {
          return;
        }
        n += n < 0 ? length2 : 0;
        return isIndex2(n, length2) ? array[n] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap2(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet2(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity2];
        }
        var index2 = -1;
        iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap2(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length2 = paths.length, result2 = {};
        while (++index2 < length2) {
          var path = paths[index2], value = baseGet2(object, path);
          if (predicate(value, path)) {
            baseSet2(result2, castPath2(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet2(object, path);
        };
      }
      function basePullAll(array, values3, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length2 = values3.length, seen = array;
        if (array === values3) {
          values3 = copyArray2(values3);
        }
        if (iteratee2) {
          seen = arrayMap2(array, baseUnary2(iteratee2));
        }
        while (++index2 < length2) {
          var fromIndex = 0, value = values3[index2], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice2.call(seen, fromIndex, 1);
            }
            splice2.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length2 = array ? indexes.length : 0, lastIndex = length2 - 1;
        while (length2--) {
          var index2 = indexes[length2];
          if (length2 == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex2(index2)) {
              splice2.call(array, index2, 1);
            } else {
              baseUnset2(array, index2);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start2, end, step, fromRight) {
        var index2 = -1, length2 = nativeMax2(nativeCeil((end - start2) / (step || 1)), 0), result2 = Array2(length2);
        while (length2--) {
          result2[fromRight ? length2 : ++index2] = start2;
          start2 += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER2) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest2(func, start2) {
        return setToString2(overRest2(func, start2, identity2), func + "");
      }
      function baseSample(collection) {
        return arraySample(values2(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values2(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet2(object, path, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath2(path, object);
        var index2 = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
        while (nested != null && ++index2 < length2) {
          var key = toKey2(path[index2]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject2(objValue) ? objValue : isIndex2(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue2(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity2 : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString2 = !defineProperty2 ? identity2 : function(func, string) {
        return defineProperty2(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant2(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values2(collection));
      }
      function baseSlice2(array, start2, end) {
        var index2 = -1, length2 = array.length;
        if (start2 < 0) {
          start2 = -start2 > length2 ? 0 : length2 + start2;
        }
        end = end > length2 ? length2 : end;
        if (end < 0) {
          end += length2;
        }
        length2 = start2 > end ? 0 : end - start2 >>> 0;
        start2 >>>= 0;
        var result2 = Array2(length2);
        while (++index2 < length2) {
          result2[index2] = array[index2 + start2];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index2, collection2) {
          result2 = predicate(value, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol2(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity2, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol2(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin2(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index2 = -1, length2 = array.length, resIndex = 0, result2 = [];
        while (++index2 < length2) {
          var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq2(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN2;
        }
        return +value;
      }
      function baseToString2(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap2(value, baseToString2) + "";
        }
        if (isSymbol2(value)) {
          return symbolToString2 ? symbolToString2.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, length2 = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length2 >= LARGE_ARRAY_SIZE2) {
          var set3 = iteratee2 ? null : createSet(array);
          if (set3) {
            return setToArray2(set3);
          }
          isCommon = false;
          includes2 = cacheHas2;
          seen = new SetCache2();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length2) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset2(object, path) {
        path = castPath2(path, object);
        object = parent2(object, path);
        return object == null || delete object[toKey2(last2(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet2(object, path, updater(baseGet2(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length2 = array.length, index2 = fromRight ? length2 : -1;
        while ((fromRight ? index2-- : ++index2 < length2) && predicate(array[index2], index2, array)) {
        }
        return isDrop ? baseSlice2(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length2) : baseSlice2(array, fromRight ? index2 + 1 : 0, fromRight ? length2 : index2);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush2([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length2 = arrays.length;
        if (length2 < 2) {
          return length2 ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length2);
        while (++index2 < length2) {
          var array = arrays[index2], othIndex = -1;
          while (++othIndex < length2) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten2(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values3, assignFunc) {
        var index2 = -1, length2 = props.length, valsLength = values3.length, result2 = {};
        while (++index2 < length2) {
          var value = index2 < valsLength ? values3[index2] : undefined$1;
          assignFunc(result2, props[index2], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject2(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity2;
      }
      function castPath2(value, object) {
        if (isArray2(value)) {
          return value;
        }
        return isKey2(value, object) ? [value] : stringToPath2(toString2(value));
      }
      var castRest = baseRest2;
      function castSlice(array, start2, end) {
        var length2 = array.length;
        end = end === undefined$1 ? length2 : end;
        return !start2 && end >= length2 ? array : baseSlice2(array, start2, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root2.clearTimeout(id);
      };
      function cloneBuffer2(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length2 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer2(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView2(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp2(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags2.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol2(symbol) {
        return symbolValueOf2 ? Object2(symbolValueOf2.call(symbol)) : {};
      }
      function cloneTypedArray2(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length2) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order = orders[index2];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray2(source, array) {
        var index2 = -1, length2 = source.length;
        array || (array = Array2(length2));
        while (++index2 < length2) {
          array[index2] = source[index2];
        }
        return array;
      }
      function copyObject2(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length2 = props.length;
        while (++index2 < length2) {
          var key = props[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue2(object, key, newValue);
          } else {
            assignValue2(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols2(source, object) {
        return copyObject2(source, getSymbols2(source), object);
      }
      function copySymbolsIn2(source, object) {
        return copyObject2(source, getSymbolsIn2(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner2(assigner) {
        return baseRest2(function(object, sources) {
          var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined$1, guard = length2 > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined$1;
          if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
            customizer = length2 < 3 ? undefined$1 : customizer;
            length2 = 1;
          }
          object = Object2(object);
          while (++index2 < length2) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike2(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length2) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor2(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object), props = keysFunc(object), length2 = props.length;
          while (length2--) {
            var key = props[fromRight ? length2 : ++index2];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper2() {
          var fn = this && this !== root2 && this instanceof wrapper2 ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper2;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString2(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate2(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper2() {
          var length2 = arguments.length, args = Array2(length2), index2 = length2, placeholder = getHolder(wrapper2);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length2 -= holders.length;
          if (length2 < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper2.placeholder, undefined$1, args, holders, undefined$1, undefined$1, arity - length2);
          }
          var fn = this && this !== root2 && this instanceof wrapper2 ? Ctor : func;
          return apply2(fn, this, args);
        }
        return wrapper2;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike2(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest2(function(funcs) {
          var length2 = funcs.length, index2 = length2, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            if (prereq && !wrapper2 && getFuncName(func) == "wrapper") {
              var wrapper2 = new LodashWrapper([], true);
            }
          }
          index2 = wrapper2 ? index2 : length2;
          while (++index2 < length2) {
            func = funcs[index2];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper2 = wrapper2[getFuncName(data[0])].apply(wrapper2, data[3]);
            } else {
              wrapper2 = func.length == 1 && isLaziable(func) ? wrapper2[funcName]() : wrapper2.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper2 && args.length == 1 && isArray2(value)) {
              return wrapper2.plant(value).value();
            }
            var index3 = 0, result2 = length2 ? funcs[index3].apply(this, args) : value;
            while (++index3 < length2) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper2() {
          var length2 = arguments.length, args = Array2(length2), index2 = length2;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper2), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length2 -= holdersCount;
          if (isCurried && length2 < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper2.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length2);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length2 = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length2 > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length2) {
            args.length = ary2;
          }
          if (this && this !== root2 && this instanceof wrapper2) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper2;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString2(value);
              other = baseToString2(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest2(function(iteratees) {
          iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
          return baseRest2(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply2(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length2, chars) {
        chars = chars === undefined$1 ? " " : baseToString2(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length2) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length2 / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length2).join("") : result2.slice(0, length2);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper2() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper2 ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply2(fn, isBind ? thisArg : this, args);
        }
        return wrapper2;
      }
      function createRange(fromRight) {
        return function(start2, end, step) {
          if (step && typeof step != "number" && isIterateeCall2(start2, end, step)) {
            end = step = undefined$1;
          }
          start2 = toFinite(start2);
          if (end === undefined$1) {
            end = start2;
            start2 = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$1 ? start2 < end ? 1 : -1 : toFinite(step);
          return baseRange(start2, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber2(value);
            other = toNumber2(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber2(number);
          precision = precision == null ? 0 : nativeMin2(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray2(new Set2([, -0]))[1] == INFINITY2) ? noop2 : function(values3) {
        return new Set2(values3);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag2(object);
          if (tag == mapTag2) {
            return mapToArray2(object);
          }
          if (tag == setTag2) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        var length2 = partials ? partials.length : 0;
        if (!length2) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax2(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length2 -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax2(newData[9] - length2, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq2(objValue, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge2(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone2(value) {
        return isPlainObject2(value) ? undefined$1 : value;
      }
      function equalArrays2(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG2 ? new SetCache2() : undefined$1;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome2(other, function(othValue2, othIndex) {
              if (!cacheHas2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag2(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag2:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag2:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag2:
          case dateTag2:
          case numberTag2:
            return eq2(+object, +other);
          case errorTag2:
            return object.name == other.name && object.message == other.message;
          case regexpTag2:
          case stringTag2:
            return object == other + "";
          case mapTag2:
            var convert2 = mapToArray2;
          case setTag2:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
            convert2 || (convert2 = setToArray2);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG2;
            stack.set(object, other);
            var result2 = equalArrays2(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag2:
            if (symbolValueOf2) {
              return symbolValueOf2.call(object) == symbolValueOf2.call(other);
            }
        }
        return false;
      }
      function equalObjects2(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, objProps = getAllKeys2(object), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest2(func) {
        return setToString2(overRest2(func, undefined$1, flatten2), func + "");
      }
      function getAllKeys2(object) {
        return baseGetAllKeys2(object, keys2, getSymbols2);
      }
      function getAllKeysIn2(object) {
        return baseGetAllKeys2(object, keysIn2, getSymbolsIn2);
      }
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length2 = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length2--) {
          var data = array[length2], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData2(map2, key) {
        var data = map2.__data__;
        return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys2(object), length2 = result2.length;
        while (length2--) {
          var key = result2[length2], value = object[key];
          result2[length2] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative2(object, key) {
        var value = getValue2(object, key);
        return baseIsNative2(value) ? value : undefined$1;
      }
      function getRawTag2(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag2), tag = value[symToStringTag2];
        try {
          value[symToStringTag2] = undefined$1;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString2.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag2] = tag;
          } else {
            delete value[symToStringTag2];
          }
        }
        return result2;
      }
      var getSymbols2 = !nativeGetSymbols2 ? stubArray2 : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter2(nativeGetSymbols2(object), function(symbol) {
          return propertyIsEnumerable2.call(object, symbol);
        });
      };
      var getSymbolsIn2 = !nativeGetSymbols2 ? stubArray2 : function(object) {
        var result2 = [];
        while (object) {
          arrayPush2(result2, getSymbols2(object));
          object = getPrototype2(object);
        }
        return result2;
      };
      var getTag2 = baseGetTag2;
      if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
        getTag2 = function(value) {
          var result2 = baseGetTag2(value), Ctor = result2 == objectTag2 ? value.constructor : undefined$1, ctorString = Ctor ? toSource2(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString2:
                return dataViewTag2;
              case mapCtorString2:
                return mapTag2;
              case promiseCtorString2:
                return promiseTag2;
              case setCtorString2:
                return setTag2;
              case weakMapCtorString2:
                return weakMapTag2;
            }
          }
          return result2;
        };
      }
      function getView(start2, end, transforms) {
        var index2 = -1, length2 = transforms.length;
        while (++index2 < length2) {
          var data = transforms[index2], size2 = data.size;
          switch (data.type) {
            case "drop":
              start2 += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin2(end, start2 + size2);
              break;
            case "takeRight":
              start2 = nativeMax2(start2, end - size2);
              break;
          }
        }
        return { "start": start2, "end": end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath2(object, path, hasFunc) {
        path = castPath2(path, object);
        var index2 = -1, length2 = path.length, result2 = false;
        while (++index2 < length2) {
          var key = toKey2(path[index2]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index2 != length2) {
          return result2;
        }
        length2 = object == null ? 0 : object.length;
        return !!length2 && isLength2(length2) && isIndex2(key, length2) && (isArray2(object) || isArguments2(object));
      }
      function initCloneArray2(array) {
        var length2 = array.length, result2 = new array.constructor(length2);
        if (length2 && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject2(object) {
        return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate2(getPrototype2(object)) : {};
      }
      function initCloneByTag2(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag2:
            return cloneArrayBuffer2(object);
          case boolTag2:
          case dateTag2:
            return new Ctor(+object);
          case dataViewTag2:
            return cloneDataView2(object, isDeep);
          case float32Tag2:
          case float64Tag2:
          case int8Tag2:
          case int16Tag2:
          case int32Tag2:
          case uint8Tag2:
          case uint8ClampedTag2:
          case uint16Tag2:
          case uint32Tag2:
            return cloneTypedArray2(object, isDeep);
          case mapTag2:
            return new Ctor();
          case numberTag2:
          case stringTag2:
            return new Ctor(object);
          case regexpTag2:
            return cloneRegExp2(object);
          case setTag2:
            return new Ctor();
          case symbolTag2:
            return cloneSymbol2(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length2 = details.length;
        if (!length2) {
          return source;
        }
        var lastIndex = length2 - 1;
        details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length2 > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable2(value) {
        return isArray2(value) || isArguments2(value) || !!(spreadableSymbol2 && value && value[spreadableSymbol2]);
      }
      function isIndex2(value, length2) {
        var type = typeof value;
        length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
        return !!length2 && (type == "number" || type != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
      }
      function isIterateeCall2(value, index2, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike2(object) && isIndex2(index2, object.length) : type == "string" && index2 in object) {
          return eq2(object[index2], value);
        }
        return false;
      }
      function isKey2(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
          return true;
        }
        return reIsPlainProp2.test(value) || !reIsDeepProp2.test(value) || object != null && value in Object2(object);
      }
      function isKeyable2(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked2(func) {
        return !!maskSrcKey2 && maskSrcKey2 in func;
      }
      var isMaskable = coreJsData2 ? isFunction2 : stubFalse2;
      function isPrototype2(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      function memoizeCapped2(func) {
        var result2 = memoize2(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE2) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin2(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn2(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString2(value) {
        return nativeObjectToString2.call(value);
      }
      function overRest2(func, start2, transform2) {
        start2 = nativeMax2(start2 === undefined$1 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index2 = -1, length2 = nativeMax2(args.length - start2, 0), array = Array2(length2);
          while (++index2 < length2) {
            array[index2] = args[start2 + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start2 + 1);
          while (++index2 < start2) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start2] = transform2(array);
          return apply2(func, this, otherArgs);
        };
      }
      function parent2(object, path) {
        return path.length < 2 ? object : baseGet2(object, baseSlice2(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length2 = nativeMin2(indexes.length, arrLength), oldArray = copyArray2(array);
        while (length2--) {
          var index2 = indexes[length2];
          array[length2] = isIndex2(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array;
      }
      function safeGet2(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut2(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root2.setTimeout(func, wait);
      };
      var setToString2 = shortOut2(baseSetToString2);
      function setWrapToString(wrapper2, reference, bitmask) {
        var source = reference + "";
        return setToString2(wrapper2, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut2(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow2(), remaining = HOT_SPAN2 - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT2) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index2 = -1, length2 = array.length, lastIndex = length2 - 1;
        size2 = size2 === undefined$1 ? length2 : size2;
        while (++index2 < size2) {
          var rand = baseRandom(index2, lastIndex), value = array[rand];
          array[rand] = array[index2];
          array[index2] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath2 = memoizeCapped2(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName2, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar2, "$1") : number || match);
        });
        return result2;
      });
      function toKey2(value) {
        if (typeof value == "string" || isSymbol2(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
      }
      function toSource2(func) {
        if (func != null) {
          try {
            return funcToString2.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach2(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper2) {
        if (wrapper2 instanceof LazyWrapper) {
          return wrapper2.clone();
        }
        var result2 = new LodashWrapper(wrapper2.__wrapped__, wrapper2.__chain__);
        result2.__actions__ = copyArray2(wrapper2.__actions__);
        result2.__index__ = wrapper2.__index__;
        result2.__values__ = wrapper2.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall2(array, size2, guard) : size2 === undefined$1) {
          size2 = 1;
        } else {
          size2 = nativeMax2(toInteger(size2), 0);
        }
        var length2 = array == null ? 0 : array.length;
        if (!length2 || size2 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size2));
        while (index2 < length2) {
          result2[resIndex++] = baseSlice2(array, index2, index2 += size2);
        }
        return result2;
      }
      function compact(array) {
        var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index2 < length2) {
          var value = array[index2];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat2() {
        var length2 = arguments.length;
        if (!length2) {
          return [];
        }
        var args = Array2(length2 - 1), array = arguments[0], index2 = length2;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush2(isArray2(array) ? copyArray2(array) : [array], baseFlatten2(args, 1));
      }
      var difference = baseRest2(function(array, values3) {
        return isArrayLikeObject2(array) ? baseDifference(array, baseFlatten2(values3, 1, isArrayLikeObject2, true)) : [];
      });
      var differenceBy = baseRest2(function(array, values3) {
        var iteratee2 = last2(values3);
        if (isArrayLikeObject2(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject2(array) ? baseDifference(array, baseFlatten2(values3, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest2(function(array, values3) {
        var comparator = last2(values3);
        if (isArrayLikeObject2(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject2(array) ? baseDifference(array, baseFlatten2(values3, 1, isArrayLikeObject2, true), undefined$1, comparator) : [];
      });
      function drop(array, n, guard) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice2(array, n < 0 ? 0 : n, length2);
      }
      function dropRight(array, n, guard) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length2 - n;
        return baseSlice2(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start2, end) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        if (start2 && typeof start2 != "number" && isIterateeCall2(array, value, start2)) {
          start2 = 0;
          end = length2;
        }
        return baseFill(array, value, start2, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax2(length2 + index2, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return -1;
        }
        var index2 = length2 - 1;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = fromIndex < 0 ? nativeMax2(length2 + index2, 0) : nativeMin2(index2, length2 - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
      }
      function flatten2(array) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? baseFlatten2(array, 1) : [];
      }
      function flattenDeep(array) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? baseFlatten2(array, INFINITY2) : [];
      }
      function flattenDepth(array, depth) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten2(array, depth);
      }
      function fromPairs(pairs) {
        var index2 = -1, length2 = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length2) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf(array, value, fromIndex) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax2(length2 + index2, 0);
        }
        return baseIndexOf(array, value, index2);
      }
      function initial(array) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? baseSlice2(array, 0, -1) : [];
      }
      var intersection = baseRest2(function(arrays) {
        var mapped = arrayMap2(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest2(function(arrays) {
        var iteratee2 = last2(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
        if (iteratee2 === last2(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest2(function(arrays) {
        var comparator = last2(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last2(array) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? array[length2 - 1] : undefined$1;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return -1;
        }
        var index2 = length2;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = index2 < 0 ? nativeMax2(length2 + index2, 0) : nativeMin2(index2, length2 - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
      }
      var pull = baseRest2(pullAll);
      function pullAll(array, values3) {
        return array && array.length && values3 && values3.length ? basePullAll(array, values3) : array;
      }
      function pullAllBy(array, values3, iteratee2) {
        return array && array.length && values3 && values3.length ? basePullAll(array, values3, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values3, comparator) {
        return array && array.length && values3 && values3.length ? basePullAll(array, values3, undefined$1, comparator) : array;
      }
      var pullAt = flatRest2(function(array, indexes) {
        var length2 = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap2(indexes, function(index2) {
          return isIndex2(index2, length2) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length2 = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length2) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result2.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice2(array, start2, end) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall2(array, start2, end)) {
          start2 = 0;
          end = length2;
        } else {
          start2 = start2 == null ? 0 : toInteger(start2);
          end = end === undefined$1 ? length2 : toInteger(end);
        }
        return baseSlice2(array, start2, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length2 = array == null ? 0 : array.length;
        if (length2) {
          var index2 = baseSortedIndex(array, value);
          if (index2 < length2 && eq2(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length2 = array == null ? 0 : array.length;
        if (length2) {
          var index2 = baseSortedIndex(array, value, true) - 1;
          if (eq2(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? baseSlice2(array, 1, length2) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice2(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length2 - n;
        return baseSlice2(array, n < 0 ? 0 : n, length2);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest2(function(arrays) {
        return baseUniq(baseFlatten2(arrays, 1, isArrayLikeObject2, true));
      });
      var unionBy = baseRest2(function(arrays) {
        var iteratee2 = last2(arrays);
        if (isArrayLikeObject2(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten2(arrays, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest2(function(arrays) {
        var comparator = last2(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten2(arrays, 1, isArrayLikeObject2, true), undefined$1, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length2 = 0;
        array = arrayFilter2(array, function(group) {
          if (isArrayLikeObject2(group)) {
            length2 = nativeMax2(group.length, length2);
            return true;
          }
        });
        return baseTimes2(length2, function(index2) {
          return arrayMap2(array, baseProperty(index2));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap2(result2, function(group) {
          return apply2(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest2(function(array, values3) {
        return isArrayLikeObject2(array) ? baseDifference(array, values3) : [];
      });
      var xor = baseRest2(function(arrays) {
        return baseXor(arrayFilter2(arrays, isArrayLikeObject2));
      });
      var xorBy = baseRest2(function(arrays) {
        var iteratee2 = last2(arrays);
        if (isArrayLikeObject2(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter2(arrays, isArrayLikeObject2), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest2(function(arrays) {
        var comparator = last2(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter2(arrays, isArrayLikeObject2), undefined$1, comparator);
      });
      var zip = baseRest2(unzip);
      function zipObject(props, values3) {
        return baseZipObject(props || [], values3 || [], assignValue2);
      }
      function zipObjectDeep(props, values3) {
        return baseZipObject(props || [], values3 || [], baseSet2);
      }
      var zipWith = baseRest2(function(arrays) {
        var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest2(function(paths) {
        var length2 = paths.length, start2 = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex2(start2)) {
          return this.thru(interceptor);
        }
        value = value.slice(start2, +start2 + (length2 ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length2 && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent3 = this;
        while (parent3 instanceof baseLodash) {
          var clone2 = wrapperClone(parent3);
          clone2.__index__ = 0;
          clone2.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent3 = parent3.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue2(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall2(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter2 : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten2(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten2(map(collection, iteratee2), INFINITY2);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten2(map(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach2 : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue2(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike2(collection) ? collection : values2(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length2 = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax2(length2 + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest2(function(collection, path, args) {
        var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index2] = isFunc ? apply2(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue2(result2, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap2 : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter2 : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall2(collection, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike2(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag2(collection);
        if (tag == mapTag2 || tag == setTag2) {
          return collection.size;
        }
        return baseKeys2(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome2 : baseSome;
        if (guard && isIterateeCall2(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest2(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length2 = iteratees.length;
        if (length2 > 1 && isIterateeCall2(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length2 > 2 && isIterateeCall2(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten2(iteratees, 1), []);
      });
      var now2 = ctxNow || function() {
        return root2.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined$1 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind = baseRest2(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest2(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce2(func, wait, options2) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        wait = toNumber2(wait) || 0;
        if (isObject2(options2)) {
          leading = !!options2.leading;
          maxing = "maxWait" in options2;
          maxWait = maxing ? nativeMax2(toNumber2(options2.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options2 ? !!options2.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin2(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest2(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest2(function(func, wait, args) {
        return baseDelay(func, toNumber2(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize2(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize2.Cache || MapCache2)();
        return memoized;
      }
      memoize2.Cache = MapCache2;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap2(transforms[0], baseUnary2(getIteratee())) : arrayMap2(baseFlatten2(transforms, 1), baseUnary2(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest2(function(args) {
          var index2 = -1, length2 = nativeMin2(args.length, funcsLength);
          while (++index2 < length2) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply2(func, this, args);
        });
      });
      var partial = baseRest2(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest2(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest2(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        start2 = start2 === undefined$1 ? start2 : toInteger(start2);
        return baseRest2(func, start2);
      }
      function spread(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        start2 = start2 == null ? 0 : nativeMax2(toInteger(start2), 0);
        return baseRest2(function(args) {
          var array = args[start2], otherArgs = castSlice(args, 0, start2);
          if (array) {
            arrayPush2(otherArgs, array);
          }
          return apply2(func, this, otherArgs);
        });
      }
      function throttle2(func, wait, options2) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        if (isObject2(options2)) {
          leading = "leading" in options2 ? !!options2.leading : leading;
          trailing = "trailing" in options2 ? !!options2.trailing : trailing;
        }
        return debounce2(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap2(value, wrapper2) {
        return partial(castFunction(wrapper2), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone(value) {
        return baseClone2(value, CLONE_SYMBOLS_FLAG2);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone2(value, CLONE_SYMBOLS_FLAG2, customizer);
      }
      function cloneDeep2(value) {
        return baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2);
      }
      function cloneDeepWith2(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys2(source));
      }
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments2 = baseIsArguments2(function() {
        return arguments;
      }()) ? baseIsArguments2 : function(value) {
        return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary2(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike2(value) {
        return value != null && isLength2(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject2(value) {
        return isObjectLike2(value) && isArrayLike2(value);
      }
      function isBoolean2(value) {
        return value === true || value === false || isObjectLike2(value) && baseGetTag2(value) == boolTag2;
      }
      var isBuffer2 = nativeIsBuffer || stubFalse2;
      var isDate = nodeIsDate ? baseUnary2(nodeIsDate) : baseIsDate;
      function isElement2(value) {
        return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments2(value))) {
          return !value.length;
        }
        var tag = getTag2(value);
        if (tag == mapTag2 || tag == setTag2) {
          return !value.size;
        }
        if (isPrototype2(value)) {
          return !baseKeys2(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual2(value, other) {
        return baseIsEqual2(value, other);
      }
      function isEqualWith2(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual2(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike2(value)) {
          return false;
        }
        var tag = baseGetTag2(value);
        return tag == errorTag2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag2(value);
        return tag == funcTag2 || tag == genTag2 || tag == asyncTag2 || tag == proxyTag2;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength2(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
      }
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike2(value) {
        return value != null && typeof value == "object";
      }
      var isMap2 = nodeIsMap2 ? baseUnary2(nodeIsMap2) : baseIsMap2;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative2(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike2(value) && baseGetTag2(value) == numberTag2;
      }
      function isPlainObject2(value) {
        if (!isObjectLike2(value) || baseGetTag2(value) != objectTag2) {
          return false;
        }
        var proto = getPrototype2(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString2;
      }
      var isRegExp = nodeIsRegExp ? baseUnary2(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER2 && value <= MAX_SAFE_INTEGER2;
      }
      var isSet2 = nodeIsSet2 ? baseUnary2(nodeIsSet2) : baseIsSet2;
      function isString2(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag2;
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag2;
      }
      var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
      function isUndefined2(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike2(value) && getTag2(value) == weakMapTag2;
      }
      function isWeakSet(value) {
        return isObjectLike2(value) && baseGetTag2(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike2(value)) {
          return isString2(value) ? stringToArray(value) : copyArray2(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag2(value), func = tag == mapTag2 ? mapToArray2 : tag == setTag2 ? setToArray2 : values2;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber2(value);
        if (value === INFINITY2 || value === -INFINITY2) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber2(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN2;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim2(value);
        var isBinary = reIsBinary2.test(value);
        return isBinary || reIsOctal2.test(value) ? freeParseInt2(value.slice(2), isBinary ? 2 : 8) : reIsBadHex2.test(value) ? NAN2 : +value;
      }
      function toPlainObject2(value) {
        return copyObject2(value, keysIn2(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2) : value === 0 ? value : 0;
      }
      function toString2(value) {
        return value == null ? "" : baseToString2(value);
      }
      var assign = createAssigner2(function(object, source) {
        if (isPrototype2(source) || isArrayLike2(source)) {
          copyObject2(source, keys2(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue2(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner2(function(object, source) {
        copyObject2(source, keysIn2(source), object);
      });
      var assignInWith = createAssigner2(function(object, source, srcIndex, customizer) {
        copyObject2(source, keysIn2(source), object, customizer);
      });
      var assignWith = createAssigner2(function(object, source, srcIndex, customizer) {
        copyObject2(source, keys2(source), object, customizer);
      });
      var at = flatRest2(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate2(prototype);
        return properties == null ? result2 : baseAssign2(result2, properties);
      }
      var defaults = baseRest2(function(object, sources) {
        object = Object2(object);
        var index2 = -1;
        var length2 = sources.length;
        var guard = length2 > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
          length2 = 1;
        }
        while (++index2 < length2) {
          var source = sources[index2];
          var props = keysIn2(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined$1 || eq2(value, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest2(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply2(mergeWith, undefined$1, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor2(object, getIteratee(iteratee2, 3), keysIn2);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn2);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys2(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn2(object));
      }
      function get2(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet2(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has2(object, path) {
        return object != null && hasPath2(object, path, baseHas2);
      }
      function hasIn(object, path) {
        return object != null && hasPath2(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString2.call(value);
        }
        result2[value] = key;
      }, constant2(identity2));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString2.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest2(baseInvoke);
      function keys2(object) {
        return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
      }
      function keysIn2(object) {
        return isArrayLike2(object) ? arrayLikeKeys2(object, true) : baseKeysIn2(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue2(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue2(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge2 = createAssigner2(function(object, source, srcIndex) {
        baseMerge2(object, source, srcIndex);
      });
      var mergeWith = createAssigner2(function(object, source, srcIndex, customizer) {
        baseMerge2(object, source, srcIndex, customizer);
      });
      var omit2 = flatRest2(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap2(paths, function(path) {
          path = castPath2(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject2(object, getAllKeysIn2(object), result2);
        if (isDeep) {
          result2 = baseClone2(result2, CLONE_DEEP_FLAG2 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG2, customOmitClone2);
        }
        var length2 = paths.length;
        while (length2--) {
          baseUnset2(result2, paths[length2]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick2 = flatRest2(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap2(getAllKeysIn2(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath2(path, object);
        var index2 = -1, length2 = path.length;
        if (!length2) {
          length2 = 1;
          object = undefined$1;
        }
        while (++index2 < length2) {
          var value = object == null ? undefined$1 : object[toKey2(path[index2])];
          if (value === undefined$1) {
            index2 = length2;
            value = defaultValue;
          }
          object = isFunction2(value) ? value.call(object) : value;
        }
        return object;
      }
      function set2(object, path, value) {
        return object == null ? object : baseSet2(object, path, value);
      }
      function setWith2(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet2(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys2);
      var toPairsIn = createToPairs(keysIn2);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate2(getPrototype2(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach2 : baseForOwn)(object, function(value, index2, object2) {
          return iteratee2(accumulator, value, index2, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset2(object, path);
      }
      function update2(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values2(object) {
        return object == null ? [] : baseValues(object, keys2(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn2(object));
      }
      function clamp2(number, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber2(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber2(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber2(number), lower, upper);
      }
      function inRange(number, start2, end) {
        start2 = toFinite(start2);
        if (end === undefined$1) {
          end = start2;
          start2 = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber2(number);
        return baseInRange(number, start2, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall2(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin2(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString2(string).toLowerCase());
      }
      function deburr(string) {
        string = toString2(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target2, position) {
        string = toString2(string);
        target2 = baseToString2(target2);
        var length2 = string.length;
        position = position === undefined$1 ? length2 : baseClamp(toInteger(position), 0, length2);
        var end = position;
        position -= target2.length;
        return position >= 0 && string.slice(position, end) == target2;
      }
      function escape(string) {
        string = toString2(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString2(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length2, chars) {
        string = toString2(string);
        length2 = toInteger(length2);
        var strLength = length2 ? stringSize(string) : 0;
        if (!length2 || strLength >= length2) {
          return string;
        }
        var mid = (length2 - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length2, chars) {
        string = toString2(string);
        length2 = toInteger(length2);
        var strLength = length2 ? stringSize(string) : 0;
        return length2 && strLength < length2 ? string + createPadding(length2 - strLength, chars) : string;
      }
      function padStart2(string, length2, chars) {
        string = toString2(string);
        length2 = toInteger(length2);
        var strLength = length2 ? stringSize(string) : 0;
        return length2 && strLength < length2 ? createPadding(length2 - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString2(string).replace(reTrimStart2, ""), radix || 0);
      }
      function repeat(string, n, guard) {
        if (guard ? isIterateeCall2(string, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString2(string), n);
      }
      function replace() {
        var args = arguments, string = toString2(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall2(string, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString2(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString2(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target2, position) {
        string = toString2(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target2 = baseToString2(target2);
        return string.slice(position, position + target2.length) == target2;
      }
      function template(string, options2, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall2(string, options2, guard)) {
          options2 = undefined$1;
        }
        string = toString2(string);
        options2 = assignInWith({}, options2, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options2.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options2, "variable") && options2.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString2(value).toLowerCase();
      }
      function toUpper(value) {
        return toString2(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim2(string);
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start2, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex2(string) + 1);
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart2, "");
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start2).join("");
      }
      function truncate(string, options2) {
        var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options2)) {
          var separator = "separator" in options2 ? options2.separator : separator;
          length2 = "length" in options2 ? toInteger(options2.length) : length2;
          omission = "omission" in options2 ? baseToString2(options2.omission) : omission;
        }
        string = toString2(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length2 >= strLength) {
          return string;
        }
        var end = length2 - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString2(reFlags2.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString2(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape(string) {
        string = toString2(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString2(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest2(function(func, args) {
        try {
          return apply2(func, undefined$1, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest2(function(object, methodNames) {
        arrayEach2(methodNames, function(key) {
          key = toKey2(key);
          baseAssignValue2(object, key, bind(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length2 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length2 ? [] : arrayMap2(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT2);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest2(function(args) {
          var index2 = -1;
          while (++index2 < length2) {
            var pair = pairs[index2];
            if (apply2(pair[0], this, args)) {
              return apply2(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone2(source, CLONE_DEEP_FLAG2));
      }
      function constant2(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity2(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone2(func, CLONE_DEEP_FLAG2));
      }
      function matches(source) {
        return baseMatches(baseClone2(source, CLONE_DEEP_FLAG2));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone2(srcValue, CLONE_DEEP_FLAG2));
      }
      var method = baseRest2(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest2(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options2) {
        var props = keys2(source), methodNames = baseFunctions(source, props);
        if (options2 == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options2 = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys2(source));
        }
        var chain2 = !(isObject2(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction2(object);
        arrayEach2(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray2(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush2([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root2._ === this) {
          root2._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest2(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap2);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome2);
      function property(path) {
        return isKey2(path) ? baseProperty(toKey2(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet2(object, path);
        };
      }
      var range2 = createRange();
      var rangeRight = createRange(true);
      function stubArray2() {
        return [];
      }
      function stubFalse2() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times2(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER2) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length2 = nativeMin2(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes2(length2, iteratee2);
        while (++index2 < n) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap2(value, toKey2);
        }
        return isSymbol2(value) ? [value] : copyArray2(stringToPath2(toString2(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString2(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide2 = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array) {
        return baseMean(array, identity2);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined$1;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round2 = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity2) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat2;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant2;
      lodash2.countBy = countBy;
      lodash2.create = create;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce2;
      lodash2.defaults = defaults;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten2;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys2;
      lodash2.keysIn = keysIn2;
      lodash2.map = map;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize2;
      lodash2.merge = merge2;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit2;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick2;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range2;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set2;
      lodash2.setWith = setWith2;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice2;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle2;
      lodash2.thru = thru;
      lodash2.toArray = toArray2;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject2;
      lodash2.transform = transform;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update2;
      lodash2.updateWith = updateWith;
      lodash2.values = values2;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap2;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp2;
      lodash2.clone = clone;
      lodash2.cloneDeep = cloneDeep2;
      lodash2.cloneDeepWith = cloneDeepWith2;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide2;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq2;
      lodash2.escape = escape;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get2;
      lodash2.gt = gt;
      lodash2.gte = gte;
      lodash2.has = has2;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity2;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments2;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer;
      lodash2.isArrayLike = isArrayLike2;
      lodash2.isArrayLikeObject = isArrayLikeObject2;
      lodash2.isBoolean = isBoolean2;
      lodash2.isBuffer = isBuffer2;
      lodash2.isDate = isDate;
      lodash2.isElement = isElement2;
      lodash2.isEmpty = isEmpty;
      lodash2.isEqual = isEqual2;
      lodash2.isEqualWith = isEqualWith2;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength2;
      lodash2.isMap = isMap2;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike2;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet2;
      lodash2.isString = isString2;
      lodash2.isSymbol = isSymbol2;
      lodash2.isTypedArray = isTypedArray2;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last2;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt;
      lodash2.lte = lte;
      lodash2.max = max;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray2;
      lodash2.stubFalse = stubFalse2;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now2;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart2;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace;
      lodash2.result = result;
      lodash2.round = round2;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times2;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber2;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString2;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION;
      arrayEach2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach2(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$1 ? 1 : nativeMax2(toInteger(n), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin2(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin2(n, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach2(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach2(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach2(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity2);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest2(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start2, end) {
        start2 = toInteger(start2);
        var result2 = this;
        if (result2.__filtered__ && (start2 > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start2 < 0) {
          result2 = result2.takeRight(-start2);
        } else if (start2) {
          result2 = result2.drop(start2);
        }
        if (end !== undefined$1) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush2([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach2(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto2[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _ = runInContext();
    if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root2._ = _;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
function EyeIcon$1({
  blockData,
  hidden,
  onToggleVisible
}) {
  if (hidden)
    return /* @__PURE__ */ React__default.createElement("div", {
      style: { visibility: "hidden" }
    }, /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-eye"
    }));
  if (blockData.type === BasicType.PAGE)
    return null;
  return blockData.data.hidden ? /* @__PURE__ */ React__default.createElement(IconFont, {
    onClick: (ev) => onToggleVisible(blockData, ev),
    iconName: "icon-eye-invisible"
  }) : /* @__PURE__ */ React__default.createElement(IconFont, {
    onClick: (ev) => onToggleVisible(blockData, ev),
    iconName: "icon-eye"
  });
}
function _extends() {
  _extends = Object.assign || function(target2) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  factoryWithThrowingShims();
}
function hasClass(element, className) {
  if (element.classList)
    return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
function addClass(element, className) {
  if (element.classList)
    element.classList.add(className);
  else if (!hasClass(element, className))
    if (typeof element.className === "string")
      element.className = element.className + " " + className;
    else
      element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}
var config = {
  disabled: false
};
var TransitionGroupContext = React__default.createContext(null);
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref2, prevState) {
    var nextIn = _ref2.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;
    if (timeout != null && typeof timeout !== "number") {
      exit = timeout.exit;
      enter = timeout.enter;
      appear = timeout.appear !== void 0 ? timeout.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event2) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event2);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return /* @__PURE__ */ React__default.createElement(TransitionGroupContext.Provider, {
      value: null
    }, typeof children === "function" ? children(status, childProps) : React__default.cloneElement(React__default.Children.only(children), childProps));
  };
  return Transition2;
}(React__default.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop$2() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$2,
  onEntering: noop$2,
  onEntered: noop$2,
  onExit: noop$2,
  onExiting: noop$2,
  onExited: noop$2
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition$1 = Transition;
var _addClass = function addClass$1(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return addClass(node, c);
  });
};
var removeClass = function removeClass2(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return removeClass$1(node, c);
  });
};
var CSSTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node, "exit");
      _this.addClass(node, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node, type);
      _this.addClass(node, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
      _this.removeClasses(node, "appear");
      _this.removeClasses(node, "enter");
      _this.addClass(node, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
      _this.addClass(node, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
      _this.removeClasses(node, "exit");
      _this.addClass(node, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === "string";
      var prefix = isStringClassNames && classNames ? classNames + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass2(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      node && node.scrollTop;
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node, className);
    }
  };
  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass(node, baseClassName);
    }
    if (activeClassName) {
      removeClass(node, activeClassName);
    }
    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props;
    _this$props.classNames;
    var props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
    return /* @__PURE__ */ React__default.createElement(Transition$1, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(React__default.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = {};
var CSSTransition$1 = CSSTransition;
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && isValidElement(child) ? mapFn(child) : child;
  };
  var result = Object.create(null);
  if (children)
    Children.map(children, function(c) {
      return c;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
  return result;
}
function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};
  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  }
  var nextKeysPending = Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i2;
  var childMapping = {};
  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i2 = 0; i2 < nextKeysPending[nextKey].length; i2++) {
        var pendingNextKey = nextKeysPending[nextKey][i2];
        childMapping[nextKeysPending[nextKey][i2]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i2 = 0; i2 < pendingKeys.length; i2++) {
    childMapping[pendingKeys[i2]] = getValueForKey(pendingKeys[i2]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!isValidElement(child))
      return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key] = cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key] = cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && isValidElement(prevChild)) {
      children[key] = cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k) {
    return obj[k];
  });
};
var defaultProps$y = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref2) {
    var prevChildMapping = _ref2.children, handleExited = _ref2.handleExited, firstRender = _ref2.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping)
      return;
    if (child.props.onExited) {
      child.props.onExited(node);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children = _extends({}, state.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component2 = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component2 === null) {
      return /* @__PURE__ */ React__default.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React__default.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React__default.createElement(Component2, props, children));
  };
  return TransitionGroup2;
}(React__default.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps$y;
var TransitionGroup$1 = TransitionGroup;
var _leaveRenders, _enterRenders;
function areChildrenDifferent(oldChildren, newChildren) {
  if (oldChildren === newChildren)
    return false;
  if (React__default.isValidElement(oldChildren) && React__default.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
    return false;
  }
  return true;
}
var modes = {
  out: "out-in",
  in: "in-out"
};
var callHook = function callHook2(element, name2, cb) {
  return function() {
    var _element$props;
    element.props[name2] && (_element$props = element.props)[name2].apply(_element$props, arguments);
    cb();
  };
};
var leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(_ref2) {
  var current = _ref2.current, changeState = _ref2.changeState;
  return React__default.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERING, null);
    })
  });
}, _leaveRenders[modes.in] = function(_ref2) {
  var current = _ref2.current, changeState = _ref2.changeState, children = _ref2.children;
  return [current, React__default.cloneElement(children, {
    in: true,
    onEntered: callHook(children, "onEntered", function() {
      changeState(ENTERING);
    })
  })];
}, _leaveRenders);
var enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(_ref3) {
  var children = _ref3.children, changeState = _ref3.changeState;
  return React__default.cloneElement(children, {
    in: true,
    onEntered: callHook(children, "onEntered", function() {
      changeState(ENTERED, React__default.cloneElement(children, {
        in: true
      }));
    })
  });
}, _enterRenders[modes.in] = function(_ref4) {
  var current = _ref4.current, children = _ref4.children, changeState = _ref4.changeState;
  return [React__default.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERED, React__default.cloneElement(children, {
        in: true
      }));
    })
  }), React__default.cloneElement(children, {
    in: true
  })];
}, _enterRenders);
var SwitchTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(SwitchTransition2, _React$Component);
  function SwitchTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      status: ENTERED,
      current: null
    };
    _this.appeared = false;
    _this.changeState = function(status, current) {
      if (current === void 0) {
        current = _this.state.current;
      }
      _this.setState({
        status,
        current
      });
    };
    return _this;
  }
  var _proto = SwitchTransition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
  };
  SwitchTransition2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (props.children == null) {
      return {
        current: null
      };
    }
    if (state.status === ENTERING && props.mode === modes.in) {
      return {
        status: ENTERING
      };
    }
    if (state.current && areChildrenDifferent(state.current, props.children)) {
      return {
        status: EXITING
      };
    }
    return {
      current: React__default.cloneElement(props.children, {
        in: true
      })
    };
  };
  _proto.render = function render() {
    var _this$props = this.props, children = _this$props.children, mode = _this$props.mode, _this$state = this.state, status = _this$state.status, current = _this$state.current;
    var data = {
      children,
      current,
      changeState: this.changeState,
      status
    };
    var component;
    switch (status) {
      case ENTERING:
        component = enterRenders[mode](data);
        break;
      case EXITING:
        component = leaveRenders[mode](data);
        break;
      case ENTERED:
        component = current;
    }
    return /* @__PURE__ */ React__default.createElement(TransitionGroupContext.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, component);
  };
  return SwitchTransition2;
}(React__default.Component);
SwitchTransition.propTypes = {};
SwitchTransition.defaultProps = {
  mode: modes.out
};
var SwitchTransition$1 = SwitchTransition;
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var IconContext = createContext({
  prefixCls: "arco"
});
function ownKeys$B(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$B(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$B(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$B(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconCheckCircleFillComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$B(_objectSpread$B({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-check-circle-fill")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    fill: "currentColor",
    fillRule: "evenodd",
    stroke: "none",
    d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm10.207-24.379a1 1 0 0 0 0-1.414l-1.414-1.414a1 1 0 0 0-1.414 0L22 26.172l-4.878-4.88a1 1 0 0 0-1.415 0l-1.414 1.415a1 1 0 0 0 0 1.414l7 7a1 1 0 0 0 1.414 0l11.5-11.5Z",
    clipRule: "evenodd"
  }));
}
var IconCheckCircleFill = /* @__PURE__ */ React__default.forwardRef(IconCheckCircleFillComponent);
IconCheckCircleFill.defaultProps = {
  isIcon: true
};
IconCheckCircleFill.displayName = "IconCheckCircleFill";
var IconCheckCircleFill$1 = IconCheckCircleFill;
function ownKeys$A(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$A(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$A(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$A(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconCloseCircleFillComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$A(_objectSpread$A({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-close-circle-fill")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    fill: "currentColor",
    fillRule: "evenodd",
    stroke: "none",
    d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm4.955-27.771-4.95 4.95-4.95-4.95a1 1 0 0 0-1.414 0l-1.414 1.414a1 1 0 0 0 0 1.414l4.95 4.95-4.95 4.95a1 1 0 0 0 0 1.414l1.414 1.414a1 1 0 0 0 1.414 0l4.95-4.95 4.95 4.95a1 1 0 0 0 1.414 0l1.414-1.414a1 1 0 0 0 0-1.414l-4.95-4.95 4.95-4.95a1 1 0 0 0 0-1.414l-1.414-1.414a1 1 0 0 0-1.414 0Z",
    clipRule: "evenodd"
  }));
}
var IconCloseCircleFill = /* @__PURE__ */ React__default.forwardRef(IconCloseCircleFillComponent);
IconCloseCircleFill.defaultProps = {
  isIcon: true
};
IconCloseCircleFill.displayName = "IconCloseCircleFill";
var IconCloseCircleFill$1 = IconCloseCircleFill;
function ownKeys$z(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$z(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$z(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$z(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconInfoCircleFillComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$z(_objectSpread$z({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-info-circle-fill")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    fill: "currentColor",
    fillRule: "evenodd",
    stroke: "none",
    d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm2-30a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2Zm0 17h1a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-6a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h1v-8a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h3a1 1 0 0 1 1 1v11Z",
    clipRule: "evenodd"
  }));
}
var IconInfoCircleFill = /* @__PURE__ */ React__default.forwardRef(IconInfoCircleFillComponent);
IconInfoCircleFill.defaultProps = {
  isIcon: true
};
IconInfoCircleFill.displayName = "IconInfoCircleFill";
var IconInfoCircleFill$1 = IconInfoCircleFill;
function ownKeys$y(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$y(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$y(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$y(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconExclamationCircleFillComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$y(_objectSpread$y({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-exclamation-circle-fill")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    fill: "currentColor",
    fillRule: "evenodd",
    stroke: "none",
    d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm-2-11a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v2Zm4-18a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V15Z",
    clipRule: "evenodd"
  }));
}
var IconExclamationCircleFill = /* @__PURE__ */ React__default.forwardRef(IconExclamationCircleFillComponent);
IconExclamationCircleFill.defaultProps = {
  isIcon: true
};
IconExclamationCircleFill.displayName = "IconExclamationCircleFill";
var IconExclamationCircleFill$1 = IconExclamationCircleFill;
function ownKeys$x(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$x(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$x(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$x(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconCloseComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$x(_objectSpread$x({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-close")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M9.857 9.858 24 24m0 0 14.142 14.142M24 24 38.142 9.858M24 24 9.857 38.142"
  }));
}
var IconClose = /* @__PURE__ */ React__default.forwardRef(IconCloseComponent);
IconClose.defaultProps = {
  isIcon: true
};
IconClose.displayName = "IconClose";
var IconClose$1 = IconClose;
var opt$1 = Object.prototype.toString;
function isArray$c(obj) {
  return opt$1.call(obj) === "[object Array]";
}
function isObject$e(obj) {
  return opt$1.call(obj) === "[object Object]";
}
function isString$1(obj) {
  return opt$1.call(obj) === "[object String]";
}
function isNumber$1(obj) {
  return opt$1.call(obj) === "[object Number]" && obj === obj;
}
function isUndefined(obj) {
  return obj === void 0;
}
function isNullOrUndefined(obj) {
  return obj === null || obj === void 0;
}
function isFunction$5(obj) {
  return typeof obj === "function";
}
function isEmptyObject$1(obj) {
  return isObject$e(obj) && Object.keys(obj).length === 0;
}
function isDayjs(time) {
  return isObject$e(time) && ("$y" in time && "$M" in time && "$D" in time && "$d" in time && "$H" in time && "$m" in time && "$s" in time || time._isAMomentObject);
}
var __read$1j = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$x = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function cs$1() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var length2 = args.length;
  var classNames = [];
  var _loop_1 = function(i3) {
    var v = args[i3];
    if (!v) {
      return "continue";
    }
    if (isString$1(v)) {
      classNames.push(v);
    } else if (isArray$c(v)) {
      classNames = classNames.concat(v);
    } else if (isObject$e(v)) {
      Object.keys(v).forEach(function(k) {
        if (v[k]) {
          classNames.push(k);
        }
      });
    } else
      ;
  };
  for (var i2 = 0; i2 < length2; i2++) {
    _loop_1(i2);
  }
  return __spreadArray$x([], __read$1j(new Set(classNames)), false).join(" ");
}
var zhCn = { exports: {} };
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t2, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e = 6e4, n = 36e5, r = "millisecond", i2 = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", $ = "Invalid Date", l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m = function(t3, e2, n2) {
      var r2 = String(t3);
      return !r2 || r2.length >= e2 ? t3 : "" + Array(e2 + 1 - r2.length).join(n2) + t3;
    }, g = { s: m, z: function(t3) {
      var e2 = -t3.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i3 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i3, 2, "0");
    }, m: function t3(e2, n2) {
      if (e2.date() < n2.date())
        return -t3(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i3 = e2.clone().add(r2, f), s2 = n2 - i3 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), f);
      return +(-(r2 + (n2 - i3) / (s2 ? i3 - u2 : u2 - i3)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i2, ms: r, Q: h }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return t3 === void 0;
    } }, D = "en", v = {};
    v[D] = M;
    var p = function(t3) {
      return t3 instanceof _;
    }, S = function(t3, e2, n2) {
      var r2;
      if (!t3)
        return D;
      if (typeof t3 == "string")
        v[t3] && (r2 = t3), e2 && (v[t3] = e2, r2 = t3);
      else {
        var i3 = t3.name;
        v[i3] = t3, r2 = i3;
      }
      return !n2 && r2 && (D = r2), r2 || !n2 && D;
    }, w = function(t3, e2) {
      if (p(t3))
        return t3.clone();
      var n2 = typeof e2 == "object" ? e2 : {};
      return n2.date = t3, n2.args = arguments, new _(n2);
    }, O = g;
    O.l = S, O.i = p, O.w = function(t3, e2) {
      return w(t3, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _ = function() {
      function M2(t3) {
        this.$L = S(t3.locale, null, true), this.parse(t3);
      }
      var m2 = M2.prototype;
      return m2.parse = function(t3) {
        this.$d = function(t4) {
          var e2 = t4.date, n2 = t4.utc;
          if (e2 === null)
            return new Date(NaN);
          if (O.u(e2))
            return new Date();
          if (e2 instanceof Date)
            return new Date(e2);
          if (typeof e2 == "string" && !/Z$/i.test(e2)) {
            var r2 = e2.match(l);
            if (r2) {
              var i3 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i3, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i3, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t3), this.$x = t3.x || {}, this.init();
      }, m2.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m2.$utils = function() {
        return O;
      }, m2.isValid = function() {
        return !(this.$d.toString() === $);
      }, m2.isSame = function(t3, e2) {
        var n2 = w(t3);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t3, e2) {
        return w(t3) < this.startOf(e2);
      }, m2.isBefore = function(t3, e2) {
        return this.endOf(e2) < w(t3);
      }, m2.$g = function(t3, e2, n2) {
        return O.u(t3) ? this[e2] : this.set(n2, t3);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t3, e2) {
        var n2 = this, r2 = !!O.u(e2) || e2, h2 = O.p(t3), $2 = function(t4, e3) {
          var i3 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t4) : new Date(n2.$y, e3, t4), n2);
          return r2 ? i3 : i3.endOf(a);
        }, l2 = function(t4, e3) {
          return O.w(n2.toDate()[t4].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, g2 = "set" + (this.$u ? "UTC" : "");
        switch (h2) {
          case c:
            return r2 ? $2(1, 0) : $2(31, 11);
          case f:
            return r2 ? $2(1, M3) : $2(0, M3 + 1);
          case o:
            var D2 = this.$locale().weekStart || 0, v2 = (y2 < D2 ? y2 + 7 : y2) - D2;
            return $2(r2 ? m3 - v2 : m3 + (6 - v2), M3);
          case a:
          case d:
            return l2(g2 + "Hours", 0);
          case u:
            return l2(g2 + "Minutes", 1);
          case s:
            return l2(g2 + "Seconds", 2);
          case i2:
            return l2(g2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m2.$set = function(t3, e2) {
        var n2, o2 = O.p(t3), h2 = "set" + (this.$u ? "UTC" : ""), $2 = (n2 = {}, n2[a] = h2 + "Date", n2[d] = h2 + "Date", n2[f] = h2 + "Month", n2[c] = h2 + "FullYear", n2[u] = h2 + "Hours", n2[s] = h2 + "Minutes", n2[i2] = h2 + "Seconds", n2[r] = h2 + "Milliseconds", n2)[o2], l2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === f || o2 === c) {
          var y2 = this.clone().set(d, 1);
          y2.$d[$2](l2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else
          $2 && this.$d[$2](l2);
        return this.init(), this;
      }, m2.set = function(t3, e2) {
        return this.clone().$set(t3, e2);
      }, m2.get = function(t3) {
        return this[O.p(t3)]();
      }, m2.add = function(r2, h2) {
        var d2, $2 = this;
        r2 = Number(r2);
        var l2 = O.p(h2), y2 = function(t3) {
          var e2 = w($2);
          return O.w(e2.date(e2.date() + Math.round(t3 * r2)), $2);
        };
        if (l2 === f)
          return this.set(f, this.$M + r2);
        if (l2 === c)
          return this.set(c, this.$y + r2);
        if (l2 === a)
          return y2(1);
        if (l2 === o)
          return y2(7);
        var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i2] = t2, d2)[l2] || 1, m3 = this.$d.getTime() + r2 * M3;
        return O.w(m3, this);
      }, m2.subtract = function(t3, e2) {
        return this.add(-1 * t3, e2);
      }, m2.format = function(t3) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || $;
        var r2 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, f2 = n2.months, h2 = function(t4, n3, i4, s3) {
          return t4 && (t4[n3] || t4(e2, r2)) || i4[n3].substr(0, s3);
        }, c2 = function(t4) {
          return O.s(s2 % 12 || 12, t4, "0");
        }, d2 = n2.meridiem || function(t4, e3, n3) {
          var r3 = t4 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        }, l2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h2(n2.monthsShort, a2, f2, 3), MMMM: h2(f2, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h2(n2.weekdaysMin, this.$W, o2, 2), ddd: h2(n2.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i3 };
        return r2.replace(y, function(t4, e3) {
          return e3 || l2[t4] || i3.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, $2) {
        var l2, y2 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, g2 = this - M3, D2 = O.m(this, M3);
        return D2 = (l2 = {}, l2[c] = D2 / 12, l2[f] = D2, l2[h] = D2 / 3, l2[o] = (g2 - m3) / 6048e5, l2[a] = (g2 - m3) / 864e5, l2[u] = g2 / n, l2[s] = g2 / e, l2[i2] = g2 / t2, l2)[y2] || g2, $2 ? D2 : O.a(D2);
      }, m2.daysInMonth = function() {
        return this.endOf(f).$D;
      }, m2.$locale = function() {
        return v[this.$L];
      }, m2.locale = function(t3, e2) {
        if (!t3)
          return this.$L;
        var n2 = this.clone(), r2 = S(t3, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return O.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), b = _.prototype;
    return w.prototype = b, [["$ms", r], ["$s", i2], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t3) {
      b[t3[1]] = function(e2) {
        return this.$g(e2, t3[0], t3[1]);
      };
    }), w.extend = function(t3, e2) {
      return t3.$i || (t3(e2, _, w), t3.$i = true), w;
    }, w.locale = S, w.isDayjs = p, w.unix = function(t3) {
      return w(1e3 * t3);
    }, w.en = v[D], w.Ls = v, w.p = {}, w;
  });
})(dayjs_min);
var dayjs$1 = dayjs_min.exports;
(function(module, exports) {
  !function(e, _) {
    module.exports = _(dayjs_min.exports);
  }(commonjsGlobal, function(e) {
    function _(e2) {
      return e2 && typeof e2 == "object" && "default" in e2 ? e2 : { default: e2 };
    }
    var t2 = _(e), d = { name: "zh-cn", weekdays: "\u661F\u671F\u65E5_\u661F\u671F\u4E00_\u661F\u671F\u4E8C_\u661F\u671F\u4E09_\u661F\u671F\u56DB_\u661F\u671F\u4E94_\u661F\u671F\u516D".split("_"), weekdaysShort: "\u5468\u65E5_\u5468\u4E00_\u5468\u4E8C_\u5468\u4E09_\u5468\u56DB_\u5468\u4E94_\u5468\u516D".split("_"), weekdaysMin: "\u65E5_\u4E00_\u4E8C_\u4E09_\u56DB_\u4E94_\u516D".split("_"), months: "\u4E00\u6708_\u4E8C\u6708_\u4E09\u6708_\u56DB\u6708_\u4E94\u6708_\u516D\u6708_\u4E03\u6708_\u516B\u6708_\u4E5D\u6708_\u5341\u6708_\u5341\u4E00\u6708_\u5341\u4E8C\u6708".split("_"), monthsShort: "1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"), ordinal: function(e2, _2) {
      switch (_2) {
        case "W":
          return e2 + "\u5468";
        default:
          return e2 + "\u65E5";
      }
    }, weekStart: 1, yearStart: 4, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY\u5E74M\u6708D\u65E5", LLL: "YYYY\u5E74M\u6708D\u65E5Ah\u70B9mm\u5206", LLLL: "YYYY\u5E74M\u6708D\u65E5ddddAh\u70B9mm\u5206", l: "YYYY/M/D", ll: "YYYY\u5E74M\u6708D\u65E5", lll: "YYYY\u5E74M\u6708D\u65E5 HH:mm", llll: "YYYY\u5E74M\u6708D\u65E5dddd HH:mm" }, relativeTime: { future: "%s\u5185", past: "%s\u524D", s: "\u51E0\u79D2", m: "1 \u5206\u949F", mm: "%d \u5206\u949F", h: "1 \u5C0F\u65F6", hh: "%d \u5C0F\u65F6", d: "1 \u5929", dd: "%d \u5929", M: "1 \u4E2A\u6708", MM: "%d \u4E2A\u6708", y: "1 \u5E74", yy: "%d \u5E74" }, meridiem: function(e2, _2) {
      var t3 = 100 * e2 + _2;
      return t3 < 600 ? "\u51CC\u6668" : t3 < 900 ? "\u65E9\u4E0A" : t3 < 1100 ? "\u4E0A\u5348" : t3 < 1300 ? "\u4E2D\u5348" : t3 < 1800 ? "\u4E0B\u5348" : "\u665A\u4E0A";
    } };
    return t2.default.locale(d, null, true), d;
  });
})(zhCn);
var Calendar$1 = {
  formatYear: "YYYY \u5E74",
  formatMonth: "YYYY \u5E74 MM \u6708",
  today: "\u4ECA\u5929",
  view: {
    month: "\u6708",
    year: "\u5E74",
    week: "\u5468",
    day: "\u65E5"
  },
  month: {
    long: {
      January: "\u4E00\u6708",
      February: "\u4E8C\u6708",
      March: "\u4E09\u6708",
      April: "\u56DB\u6708",
      May: "\u4E94\u6708",
      June: "\u516D\u6708",
      July: "\u4E03\u6708",
      August: "\u516B\u6708",
      September: "\u4E5D\u6708",
      October: "\u5341\u6708",
      November: "\u5341\u4E00\u6708",
      December: "\u5341\u4E8C\u6708"
    },
    short: {
      January: "\u4E00\u6708",
      February: "\u4E8C\u6708",
      March: "\u4E09\u6708",
      April: "\u56DB\u6708",
      May: "\u4E94\u6708",
      June: "\u516D\u6708",
      July: "\u4E03\u6708",
      August: "\u516B\u6708",
      September: "\u4E5D\u6708",
      October: "\u5341\u6708",
      November: "\u5341\u4E00\u6708",
      December: "\u5341\u4E8C\u6708"
    }
  },
  week: {
    long: {
      self: "\u5468",
      monday: "\u5468\u4E00",
      tuesday: "\u5468\u4E8C",
      wednesday: "\u5468\u4E09",
      thursday: "\u5468\u56DB",
      friday: "\u5468\u4E94",
      saturday: "\u5468\u516D",
      sunday: "\u5468\u65E5"
    },
    short: {
      self: "\u5468",
      monday: "\u4E00",
      tuesday: "\u4E8C",
      wednesday: "\u4E09",
      thursday: "\u56DB",
      friday: "\u4E94",
      saturday: "\u516D",
      sunday: "\u65E5"
    }
  }
};
var zhCN = {
  locale: "zh-CN",
  dayjsLocale: "zh-cn",
  Calendar: Calendar$1,
  DatePicker: {
    Calendar: Calendar$1,
    placeholder: {
      date: "\u8BF7\u9009\u62E9\u65E5\u671F",
      week: "\u8BF7\u9009\u62E9\u5468",
      month: "\u8BF7\u9009\u62E9\u6708\u4EFD",
      year: "\u8BF7\u9009\u62E9\u5E74\u4EFD",
      quarter: "\u8BF7\u9009\u62E9\u5B63\u5EA6"
    },
    placeholders: {
      date: ["\u5F00\u59CB\u65E5\u671F", "\u7ED3\u675F\u65E5\u671F"],
      week: ["\u5F00\u59CB\u5468", "\u7ED3\u675F\u5468"],
      month: ["\u5F00\u59CB\u6708\u4EFD", "\u7ED3\u675F\u6708\u4EFD"],
      year: ["\u5F00\u59CB\u5E74\u4EFD", "\u7ED3\u675F\u5E74\u4EFD"],
      quarter: ["\u5F00\u59CB\u5B63\u5EA6", "\u7ED3\u675F\u5B63\u5EA6"]
    },
    selectTime: "\u9009\u62E9\u65F6\u95F4",
    selectDate: "\u9009\u62E9\u65E5\u671F",
    today: "\u4ECA\u5929",
    now: "\u6B64\u523B",
    ok: "\u786E\u5B9A"
  },
  Drawer: {
    okText: "\u786E\u5B9A",
    cancelText: "\u53D6\u6D88"
  },
  Empty: {
    noData: "\u6682\u65E0\u6570\u636E"
  },
  Modal: {
    okText: "\u786E\u5B9A",
    cancelText: "\u53D6\u6D88"
  },
  Pagination: {
    goto: "\u524D\u5F80",
    page: "\u9875",
    countPerPage: "\u6761/\u9875",
    total: "\u5171 {0} \u6761",
    prev: "\u4E0A\u4E00\u9875",
    next: "\u4E0B\u4E00\u9875",
    currentPage: "\u7B2C {0} \u9875",
    prevSomePages: "\u5411\u524D {0} \u9875",
    nextSomePages: "\u5411\u540E {0} \u9875",
    pageSize: "\u9875\u7801"
  },
  Popconfirm: {
    okText: "\u786E\u5B9A",
    cancelText: "\u53D6\u6D88"
  },
  Table: {
    okText: "\u786E\u5B9A",
    resetText: "\u91CD\u7F6E",
    sortAscend: "\u70B9\u51FB\u5347\u5E8F",
    sortDescend: "\u70B9\u51FB\u964D\u5E8F",
    cancelSort: "\u53D6\u6D88\u6392\u5E8F"
  },
  TimePicker: {
    ok: "\u786E\u5B9A",
    placeholder: "\u8BF7\u9009\u62E9\u65F6\u95F4",
    placeholders: ["\u5F00\u59CB\u65F6\u95F4", "\u7ED3\u675F\u65F6\u95F4"],
    now: "\u6B64\u523B"
  },
  Progress: {
    success: "\u5B8C\u6210",
    error: "\u5931\u8D25"
  },
  Upload: {
    start: "\u5F00\u59CB",
    cancel: "\u53D6\u6D88",
    delete: "\u5220\u9664",
    reupload: "\u70B9\u51FB\u91CD\u8BD5",
    upload: "\u70B9\u51FB\u4E0A\u4F20",
    preview: "\u9884\u89C8",
    drag: "\u70B9\u51FB\u6216\u62D6\u62FD\u6587\u4EF6\u5230\u6B64\u5904\u4E0A\u4F20",
    dragHover: "\u91CA\u653E\u6587\u4EF6\u5E76\u5F00\u59CB\u4E0A\u4F20",
    error: "\u4E0A\u4F20\u5931\u8D25"
  },
  Typography: {
    copy: "\u590D\u5236",
    copied: "\u5DF2\u590D\u5236",
    edit: "\u7F16\u8F91",
    fold: "\u6298\u53E0",
    unfold: "\u5C55\u5F00"
  },
  Transfer: {
    resetText: "\u91CD\u7F6E"
  },
  ImagePreview: {
    fullScreen: "\u5168\u5C4F",
    rotateRight: "\u5411\u53F3\u65CB\u8F6C",
    rotateLeft: "\u5411\u5DE6\u65CB\u8F6C",
    zoomIn: "\u653E\u5927",
    zoomOut: "\u7F29\u5C0F",
    originalSize: "\u539F\u59CB\u5C3A\u5BF8"
  },
  Form: {
    validateMessages: {
      required: "#{field} \u662F\u5FC5\u586B\u9879",
      type: {
        string: "#{value} \u4E0D\u662F\u5408\u6CD5\u7684\u6587\u672C\u7C7B\u578B",
        number: "#{value} \u4E0D\u662F\u5408\u6CD5\u7684\u6570\u5B57\u7C7B\u578B",
        boolean: "#{value} \u4E0D\u662F\u5408\u6CD5\u7684\u5E03\u5C14\u7C7B\u578B",
        array: "#{value} \u4E0D\u662F\u5408\u6CD5\u7684\u6570\u7EC4\u7C7B\u578B",
        object: "#{value} \u4E0D\u662F\u5408\u6CD5\u7684\u5BF9\u8C61\u7C7B\u578B",
        url: "#{value} \u4E0D\u662F\u5408\u6CD5\u7684 url \u5730\u5740",
        email: "#{value} \u4E0D\u662F\u5408\u6CD5\u7684\u90AE\u7BB1\u5730\u5740",
        ip: "#{value} \u4E0D\u662F\u5408\u6CD5\u7684 IP \u5730\u5740"
      },
      number: {
        min: "`#{value}` \u5C0F\u4E8E\u6700\u5C0F\u503C `#{min}`",
        max: "`#{value}` \u5927\u4E8E\u6700\u5927\u503C `#{max}`",
        equal: "`#{value}` \u4E0D\u7B49\u4E8E `#{equal}`",
        range: "`#{value}` \u4E0D\u5728 `#{min} ~ #{max}` \u8303\u56F4\u5185",
        positive: "`#{value}` \u4E0D\u662F\u6B63\u6570",
        negative: "`#{value}` \u4E0D\u662F\u8D1F\u6570"
      },
      array: {
        length: "`#{value}` \u4E2A\u6570\u4E0D\u7B49\u4E8E #{length}",
        minLength: "`#{value}` \u4E2A\u6570\u6700\u5C11\u4E3A #{minLength}",
        maxLength: "`#{value}` \u4E2A\u6570\u6700\u591A\u4E3A #{maxLength}",
        includes: "#{value} \u4E0D\u5305\u542B #{includes}",
        deepEqual: "#{value} \u4E0D\u7B49\u4E8E #{deepEqual}",
        empty: "`#{value}` \u4E0D\u662F\u7A7A\u6570\u7EC4"
      },
      string: {
        minLength: "\u5B57\u7B26\u6570\u6700\u5C11\u4E3A #{minLength}",
        maxLength: "\u5B57\u7B26\u6570\u6700\u591A\u4E3A #{maxLength}",
        length: "`#{value}` \u5B57\u7B26\u6570\u4E0D\u7B49\u4E8E #{length}",
        match: "`#{value}` \u4E0D\u7B26\u5408\u6A21\u5F0F #{pattern}",
        uppercase: "`#{value}` \u4E0D\u662F\u5168\u5927\u5199",
        lowercase: "`#{value}` \u4E0D\u662F\u5168\u5C0F\u5199"
      },
      object: {
        deepEqual: "`#{value}` \u4E0D\u7B49\u4E8E #{deepEqual}",
        hasKeys: "`#{value}` \u4E0D\u5305\u542B\u5B57\u6BB5 #{keys}",
        empty: "`#{value}` \u4E0D\u662F\u5BF9\u8C61"
      },
      boolean: {
        true: "\u671F\u671B\u662F `true`",
        false: "\u671F\u671B\u662F `false`"
      }
    }
  }
};
function hexToRgb(hex) {
  var rgb = [];
  var _hex = hex.substr(1);
  if (hex.length === 3) {
    _hex = hex.replace(/(.)/g, "$1$1");
  }
  _hex.replace(/../g, function(color2) {
    rgb.push(parseInt(color2, 16));
  });
  return {
    r: rgb[0],
    g: rgb[1],
    b: rgb[2],
    rgb: "rgb(" + rgb.join(",") + ")"
  };
}
function getRgb(color2) {
  var rgb = hexToRgb(color2);
  return { r: rgb.r, g: rgb.g, b: rgb.b };
}
function getHsl(color2) {
  var rgb = getRgb(color2);
  var hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
  return { h: hsl.h, s: hsl.s, l: hsl.l };
}
function rgbToHsl(r, g, b) {
  var _r = r / 255;
  var _g = g / 255;
  var _b = b / 255;
  var max = Math.max(_r, _g, _b);
  var min = Math.min(_r, _g, _b);
  var l = (max + min) / 2;
  var h;
  var s;
  if (max === min) {
    h = 0;
    s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case _r:
        h = (_g - _b) / d + (_g < _b ? 6 : 0);
        break;
      case _g:
        h = (_b - _r) / d + 2;
        break;
      case _b:
        h = (_r - _g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s,
    l,
    hsl: "hsl(" + h * 360 + ", " + s * 100 + "%, " + l * 100 + "%)"
  };
}
function lighten(color2, percent) {
  var hsl = getHsl(color2);
  var h = +hsl.h;
  var s = +hsl.s;
  var l = +hsl.l * 100 + +percent;
  var res = hsltorgb([h * 360, s * 100, l]);
  return res.join(",");
}
function hsltorgb(hsl) {
  var h = hsl[0] / 360;
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var t2;
  var t3;
  var val;
  if (s === 0) {
    val = l * 255;
    return [val, val, val];
  }
  if (l < 0.5) {
    t2 = l * (1 + s);
  } else {
    t2 = l + s - l * s;
  }
  var t1 = 2 * l - t2;
  var rgb = [0, 0, 0];
  for (var i2 = 0; i2 < 3; i2++) {
    t3 = h + 1 / 3 * -(i2 - 1);
    if (t3 < 0) {
      t3++;
    }
    if (t3 > 1) {
      t3--;
    }
    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }
    rgb[i2] = val * 255;
  }
  return rgb;
}
var __extends$b = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$1O = globalThis && globalThis.__assign || function() {
  __assign$1O = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1O.apply(this, arguments);
};
function getId(noticeProps) {
  if (noticeProps.id) {
    return noticeProps.id;
  }
  return "arco_notice_id_" + Math.random().toFixed(10).slice(2);
}
var BaseNotice = function(_super) {
  __extends$b(BaseNotice2, _super);
  function BaseNotice2(props) {
    var _this = _super.call(this, props) || this;
    _this.add = function(noticeProps) {
      var id = getId(noticeProps);
      _this.setState(function(prevState) {
        var oldNotices = prevState.notices;
        if (noticeProps.id && ~oldNotices.findIndex(function(notice) {
          return notice.id === noticeProps.id;
        })) {
          _this.update(noticeProps);
          return prevState;
        }
        return {
          notices: oldNotices.concat(__assign$1O(__assign$1O({}, noticeProps), { id })),
          position: noticeProps.position
        };
      });
      return id;
    };
    _this.update = function(newNotice) {
      var updatedNotices = _this.state.notices.map(function(oldNotice) {
        if (newNotice.id === oldNotice.id) {
          newNotice.update = true;
          return newNotice;
        }
        return oldNotice;
      });
      _this.setState({
        notices: updatedNotices
      }, function() {
        var notices = _this.state.notices.map(function(oldNotice) {
          if (newNotice.id === oldNotice.id && oldNotice.update) {
            delete oldNotice.update;
          }
          return oldNotice;
        });
        _this.setState({ notices });
      });
    };
    _this.clear = function() {
      _this.setState({
        notices: []
      });
    };
    _this.state = {
      notices: [],
      position: "topRight"
    };
    _this.remove = _this.remove.bind(_this);
    return _this;
  }
  BaseNotice2.prototype.remove = function(id) {
    var newNotices = this.state.notices.filter(function(notice) {
      return notice.id !== id;
    });
    this.setState({
      notices: newNotices
    });
  };
  return BaseNotice2;
}(Component);
var BaseNotification = BaseNotice;
function ownKeys$w(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$w(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$w(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$w(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconLoadingComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$w(_objectSpread$w({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-loading")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M42 24c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6"
  }));
}
var IconLoading = /* @__PURE__ */ React__default.forwardRef(IconLoadingComponent);
IconLoading.defaultProps = {
  isIcon: true
};
IconLoading.displayName = "IconLoading";
var IconLoading$1 = IconLoading;
var __assign$1N = globalThis && globalThis.__assign || function() {
  __assign$1N = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1N.apply(this, arguments);
};
var __rest$R = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function IconHover(props) {
  var _a;
  var children = props.children, className = props.className, disabled = props.disabled, prefix = props.prefix, _b = props.size, size = _b === void 0 ? "default" : _b, rest = __rest$R(props, ["children", "className", "disabled", "prefix", "size"]);
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var prefixCls2 = getPrefixCls("icon-hover");
  return React__default.createElement("span", __assign$1N({ className: cs$1(prefixCls2, (_a = {}, _a[prefix + "-icon-hover"] = prefix, _a[prefixCls2 + "-size-" + size] = size && size !== "default", _a[prefixCls2 + "-disabled"] = disabled, _a), className), onClick: props.onClick }, rest), children);
}
var __extends$a = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Notice = function(_super) {
  __extends$a(Notice2, _super);
  function Notice2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.startTimer = function() {
      var _a = _this.props, duration2 = _a.duration, onClose = _a.onClose, id = _a.id;
      if (duration2 !== 0) {
        _this.timer = window.setTimeout(function() {
          onClose && onClose(id);
          _this.removeTimer();
        }, duration2);
      }
    };
    _this.removeTimer = function() {
      if (_this.timer) {
        window.clearTimeout(_this.timer);
        _this.timer = null;
      }
    };
    _this.onClose = function() {
      _this.props.onClose && _this.props.onClose(_this.props.id);
    };
    _this.renderIcon = function() {
      var _a = _this.props, showIcon = _a.showIcon, icon = _a.icon, type = _a.type, prefixCls2 = _a.prefixCls, iconPrefix = _a.iconPrefix;
      var content;
      if (icon) {
        content = icon;
      } else if (showIcon) {
        switch (type) {
          case "info":
            content = React__default.createElement(IconInfoCircleFill$1, null);
            break;
          case "success":
            content = React__default.createElement(IconCheckCircleFill$1, null);
            break;
          case "error":
            content = React__default.createElement(IconCloseCircleFill$1, null);
            break;
          case "warning":
            content = React__default.createElement(IconExclamationCircleFill$1, null);
            break;
          case "loading":
            content = React__default.createElement(IconLoading$1, null);
            break;
        }
        content = React__default.createElement(IconContext.Provider, { value: iconPrefix ? { prefixCls: iconPrefix } : {} }, content);
      }
      return React__default.createElement("span", { className: prefixCls2 + "-icon" }, content);
    };
    _this.onMouseEnter = function() {
      _this.removeTimer();
    };
    _this.onMouseLeave = function() {
      _this.startTimer();
    };
    return _this;
  }
  Notice2.prototype.componentDidMount = function() {
    this.startTimer();
  };
  Notice2.prototype.componentDidUpdate = function(nextProps) {
    if (nextProps.duration !== this.props.duration || this.props.update) {
      this.removeTimer();
      this.startTimer();
    }
  };
  Notice2.prototype.componentWillUnmount = function() {
    this.removeTimer();
  };
  Notice2.prototype.render = function() {
    var _a;
    var _b = this.props, title2 = _b.title, content = _b.content, showIcon = _b.showIcon, className = _b.className, style = _b.style, type = _b.type, btn = _b.btn, icon = _b.icon, prefixCls2 = _b.prefixCls, closable = _b.closable, noticeType = _b.noticeType, iconPrefix = _b.iconPrefix;
    var classNames = cs$1(prefixCls2, prefixCls2 + "-" + type, (_a = {}, _a[prefixCls2 + "-closable"] = closable, _a), className);
    var _closable = "closable" in this.props ? closable : true;
    var shouldRenderIcon = showIcon;
    if (type === "normal" && !icon) {
      shouldRenderIcon = false;
    }
    if (noticeType === "message") {
      _closable = closable;
      return React__default.createElement("div", { style: { textAlign: "center" }, onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave }, React__default.createElement("div", { className: classNames, style, role: "alert" }, shouldRenderIcon && this.renderIcon(), React__default.createElement("span", { className: prefixCls2 + "-content" }, content), _closable && React__default.createElement(IconHover, { prefix: prefixCls2, className: prefixCls2 + "-close-btn", onClick: this.onClose }, React__default.createElement(IconClose$1, null))));
    }
    if (noticeType === "notification") {
      return React__default.createElement("div", { onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave }, React__default.createElement("div", { className: classNames, style, role: "alert" }, shouldRenderIcon && React__default.createElement("div", { className: prefixCls2 + "-left" }, this.renderIcon()), React__default.createElement("div", { className: prefixCls2 + "-right" }, title2 && React__default.createElement("div", { className: prefixCls2 + "-title" }, title2), React__default.createElement("div", { className: prefixCls2 + "-content" }, content), btn && React__default.createElement("div", { className: prefixCls2 + "-btn-wrapper" }, btn)), _closable && React__default.createElement(IconHover, { prefix: prefixCls2, className: prefixCls2 + "-close-btn", onClick: this.onClose }, React__default.createElement(IconContext.Provider, { value: iconPrefix ? { prefixCls: iconPrefix } : {} }, React__default.createElement(IconClose$1, null)))));
    }
  };
  Notice2.defaultProps = {
    type: "info",
    showIcon: true,
    noticeType: "message",
    duration: 3e3
  };
  return Notice2;
}(Component);
var Notice$1 = Notice;
var __extends$9 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$1M = globalThis && globalThis.__assign || function() {
  __assign$1M = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1M.apply(this, arguments);
};
var messageTypes = ["info", "success", "error", "warning", "loading", "normal"];
var messageInstance = {};
var maxCount$1;
var prefixCls$1;
var duration$1;
var container$2;
function addInstance(noticeProps) {
  var _noticeProps = __assign$1M({ position: "top", duration: duration$1 }, noticeProps);
  var position = _noticeProps.position, transitionClassNames = _noticeProps.transitionClassNames;
  var id;
  if (messageInstance[position]) {
    var notices = messageInstance[position].state.notices;
    if (notices.length >= maxCount$1) {
      var updated = notices[0];
      id = updated.id;
      notices.shift();
      messageInstance[position].add(__assign$1M(__assign$1M({}, _noticeProps), { id }));
    } else {
      id = messageInstance[position].add(_noticeProps);
    }
  } else {
    var div = document.createElement("div");
    (container$2 || document.body).appendChild(div);
    ReactDOM.render(React__default.createElement(Message, { transitionClassNames, ref: function(instance) {
      messageInstance[position] = instance;
      id = messageInstance[position].add(_noticeProps);
    } }), div);
  }
  var result = function() {
    if (messageInstance[position]) {
      messageInstance[position].remove(id);
    }
  };
  return result;
}
var Message = function(_super) {
  __extends$9(Message2, _super);
  function Message2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.remove = function(id) {
      var noticeItem = _this.state.notices.find(function(item2) {
        return item2.id === id;
      });
      if (noticeItem) {
        _this.update(__assign$1M(__assign$1M({}, noticeItem), { style: __assign$1M(__assign$1M({}, noticeItem.style), { opacity: 0 }) }));
      }
      setTimeout(function() {
        _super.prototype.remove.call(_this, id);
      }, 100);
    };
    return _this;
  }
  Message2.prototype.render = function() {
    var _this = this;
    var transitionClassNames = this.props.transitionClassNames;
    var _a = this.state, notices = _a.notices, position = _a.position;
    var prefixClsMessage = prefixCls$1 ? prefixCls$1 + "-message" : "arco-message";
    var classNames = cs$1(prefixClsMessage + "-wrapper", prefixClsMessage + "-wrapper-" + position);
    return React__default.createElement("div", { className: classNames }, React__default.createElement(TransitionGroup$1, { component: null }, notices.map(function(notice) {
      return React__default.createElement(CSSTransition$1, { key: notice.id, timeout: {
        enter: 100,
        exit: 300
      }, classNames: transitionClassNames || "fadeMessage", onExit: function(e) {
        e.style.height = e.scrollHeight + "px";
      }, onExiting: function(e) {
        e.style.height = 0;
      }, onExited: function(e) {
        e.style.height = 0;
        notice.onClose && notice.onClose();
      } }, React__default.createElement(Notice$1, __assign$1M({}, notice, { prefixCls: prefixClsMessage, iconPrefix: prefixCls$1, onClose: _this.remove, noticeType: "message" })));
    })));
  };
  Message2.config = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (options2.maxCount) {
      maxCount$1 = options2.maxCount;
    }
    if (options2.prefixCls) {
      prefixCls$1 = options2.prefixCls;
    }
    if (options2.duration) {
      duration$1 = options2.duration;
    }
    if (options2.getContainer && options2.getContainer() !== container$2) {
      container$2 = options2.getContainer();
      Object.keys(messageInstance).forEach(function(notice) {
        return messageInstance[notice].clear();
      });
      messageInstance = {};
    }
  };
  Message2.clear = function() {
    Object.keys(messageInstance).forEach(function(ins) {
      messageInstance[ins].clear();
    });
  };
  Message2.addInstance = addInstance;
  return Message2;
}(BaseNotification);
messageTypes.forEach(function(type) {
  Message[type] = function(noticeProps) {
    var props = typeof noticeProps === "string" ? { content: noticeProps } : noticeProps;
    return addInstance(__assign$1M(__assign$1M({}, props), { type }));
  };
});
var Message$1 = Message;
var __extends$8 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$1L = globalThis && globalThis.__assign || function() {
  __assign$1L = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1L.apply(this, arguments);
};
var notificationTypes = ["info", "success", "error", "warning", "normal"];
var notificationInstance = {};
var maxCount;
var prefixCls;
var duration;
var container$1;
var Notification = function(_super) {
  __extends$8(Notification2, _super);
  function Notification2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.remove = function(id) {
      var noticeItem = _this.state.notices.find(function(item2) {
        return item2.id === id;
      });
      if (noticeItem) {
        _this.update(__assign$1L(__assign$1L({}, noticeItem), { style: __assign$1L(__assign$1L({}, noticeItem.style), { opacity: 0 }) }));
      }
      setTimeout(function() {
        _super.prototype.remove.call(_this, id);
      }, 200);
    };
    return _this;
  }
  Notification2.prototype.render = function() {
    var _this = this;
    var _a = this.state, notices = _a.notices, _b = _a.position, position = _b === void 0 ? "topRight" : _b;
    var prefixClsNotification = prefixCls ? prefixCls + "-notification" : "arco-notification";
    var transitionClass;
    if (position === "topLeft" || position === "bottomLeft") {
      transitionClass = "slideNoticeLeft";
    } else {
      transitionClass = "slideNoticeRight";
    }
    var classNames = cs$1(prefixClsNotification + "-wrapper", prefixClsNotification + "-wrapper-" + position);
    return React__default.createElement("div", { className: classNames }, React__default.createElement(TransitionGroup$1, { component: null }, notices.map(function(notice) {
      return React__default.createElement(CSSTransition$1, { key: notice.id, timeout: {
        enter: 400,
        exit: 300
      }, classNames: transitionClass, onExit: function(e) {
        e.style.height = e.scrollHeight + "px";
      }, onExiting: function(e) {
        e.style.height = 0;
      }, onExited: function(e) {
        e.style.height = 0;
        notice.onClose && notice.onClose();
      } }, React__default.createElement(Notice$1, __assign$1L({}, notice, { onClose: _this.remove, prefixCls: prefixClsNotification, iconPrefix: prefixCls, noticeType: "notification" })));
    })));
  };
  Notification2.config = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (options2.maxCount) {
      maxCount = options2.maxCount;
    }
    if (options2.prefixCls) {
      prefixCls = options2.prefixCls;
    }
    if (isNumber$1(options2.duration)) {
      duration = options2.duration;
    }
    if (options2.getContainer && options2.getContainer() !== container$1) {
      container$1 = options2.getContainer();
      Object.keys(notificationInstance).forEach(function(notice) {
        return notificationInstance[notice].clear();
      });
      notificationInstance = {};
    }
  };
  Notification2.clear = function() {
    Object.keys(notificationInstance).forEach(function(ins) {
      notificationInstance[ins].clear();
    });
  };
  Notification2.remove = function(id) {
    Object.keys(notificationInstance).forEach(function(ins) {
      notificationInstance[ins].remove(id);
    });
  };
  Notification2.addInstance = function(noticeProps) {
    var _a = noticeProps.position, position = _a === void 0 ? "topRight" : _a;
    var _noticeProps = __assign$1L({ duration }, noticeProps);
    if (notificationInstance[position]) {
      var notices = notificationInstance[position].state.notices;
      if (notices.length >= maxCount) {
        var updated = notices[0];
        notices.shift();
        notificationInstance[position].add(__assign$1L(__assign$1L({}, _noticeProps), { id: updated.id }));
      } else {
        notificationInstance[position].add(_noticeProps);
      }
      return notificationInstance[position];
    }
    var div = document.createElement("div");
    var instance = null;
    (container$1 || document.body).appendChild(div);
    ReactDOM.render(React__default.createElement(Notification2, { ref: function(ref) {
      notificationInstance[position] = ref;
      notificationInstance[position].add(_noticeProps);
      instance = notificationInstance[position];
      return instance;
    } }), div);
  };
  return Notification2;
}(BaseNotification);
notificationTypes.forEach(function(type) {
  Notification[type] = function(noticeProps) {
    return Notification.addInstance(__assign$1L(__assign$1L({}, noticeProps), { type }));
  };
});
var Notification$1 = Notification;
function ownKeys$v(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$v(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$v(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$v(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconEmptyComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$v(_objectSpread$v({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-empty")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M24 5v6m7 1 4-4m-18 4-4-4m28.5 22H28s-1 3-4 3-4-3-4-3H6.5M40 41H8a2 2 0 0 1-2-2v-8.46a2 2 0 0 1 .272-1.007l6.15-10.54A2 2 0 0 1 14.148 18H33.85a2 2 0 0 1 1.728.992l6.149 10.541A2 2 0 0 1 42 30.541V39a2 2 0 0 1-2 2Z"
  }));
}
var IconEmpty = /* @__PURE__ */ React__default.forwardRef(IconEmptyComponent);
IconEmpty.defaultProps = {
  isIcon: true
};
IconEmpty.displayName = "IconEmpty";
var IconEmpty$1 = IconEmpty;
var __assign$1K = globalThis && globalThis.__assign || function() {
  __assign$1K = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1K.apply(this, arguments);
};
function omit$1(obj, keys2) {
  var clone = __assign$1K({}, obj);
  keys2.forEach(function(key) {
    if (key in clone) {
      delete clone[key];
    }
  });
  return clone;
}
var __assign$1J = globalThis && globalThis.__assign || function() {
  __assign$1J = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1J.apply(this, arguments);
};
function useMergeProps(componentProps, defaultProps2, globalComponentConfig) {
  var _ignorePropsFromGlobal = componentProps._ignorePropsFromGlobal;
  var _defaultProps = useMemo(function() {
    return __assign$1J(__assign$1J({}, defaultProps2), _ignorePropsFromGlobal ? {} : globalComponentConfig);
  }, [defaultProps2, globalComponentConfig, _ignorePropsFromGlobal]);
  var props = useMemo(function() {
    var mProps = omit$1(componentProps, ["_ignorePropsFromGlobal"]);
    for (var propName in _defaultProps) {
      if (mProps[propName] === void 0) {
        mProps[propName] = _defaultProps[propName];
      }
    }
    return mProps;
  }, [componentProps, _defaultProps]);
  return props;
}
function Empty(baseProps, ref) {
  var _a = useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, globalLocale = _a.locale, componentConfig2 = _a.componentConfig;
  var props = useMergeProps(baseProps, {}, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Empty);
  var style = props.style, className = props.className, description = props.description, icon = props.icon, imgSrc = props.imgSrc;
  var prefixCls2 = getPrefixCls("empty");
  var classNames = cs$1(prefixCls2, className);
  var noData = globalLocale.Empty.noData;
  var alt = typeof description === "string" ? description : "empty";
  return React__default.createElement("div", { ref, className: classNames, style }, React__default.createElement("div", { className: prefixCls2 + "-wrapper" }, React__default.createElement("div", { className: prefixCls2 + "-image" }, imgSrc ? React__default.createElement("img", { alt, src: imgSrc }) : icon || React__default.createElement(IconEmpty$1, null)), React__default.createElement("div", { className: prefixCls2 + "-description" }, description || noData)));
}
var EmptyComponent = forwardRef(Empty);
EmptyComponent.displayName = "Empty";
var Empty$1 = memo(EmptyComponent);
var __assign$1I = globalThis && globalThis.__assign || function() {
  __assign$1I = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1I.apply(this, arguments);
};
var configProvider = {};
function setConfigProviderProps(configProviderProps) {
  configProvider = __assign$1I({}, configProviderProps);
}
function getConfigProviderProps() {
  return configProvider;
}
var modalConfig = {
  simple: true
};
var setModalConfig = function(config2) {
  modalConfig = __assign$1I(__assign$1I({}, modalConfig), config2);
};
var getModalConfig = function() {
  return modalConfig;
};
var destroyList = [];
var __assign$1H = globalThis && globalThis.__assign || function() {
  __assign$1H = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1H.apply(this, arguments);
};
var colorList = {
  primaryColor: {
    default: "--arcoblue-6",
    hover: "--arcoblue-5",
    active: "--arcoblue-7"
  },
  successColor: {
    default: "--green-6",
    hover: "--green-5",
    active: "--green-7"
  },
  infoColor: {
    default: "--arcoblue-6",
    hover: "--arcoblue-5",
    active: "--arcoblue-7"
  },
  warningColor: {
    default: "--orangered-6",
    hover: "--orangered-5",
    active: "--orangered-7"
  },
  dangerColor: {
    default: "--red-6",
    hover: "--red-5",
    active: "--red-7"
  }
};
function setTheme(theme) {
  if (theme && isObject$e(theme)) {
    var root_1 = document.body;
    Object.keys(colorList).forEach(function(color2) {
      if (theme[color2]) {
        root_1.style.setProperty(colorList[color2].default, lighten(theme[color2], 0));
        if (!theme[color2 + "Hover"]) {
          root_1.style.setProperty(colorList[color2].hover, lighten(theme[color2], 10));
        }
        if (!theme[color2 + "Active"]) {
          root_1.style.setProperty(colorList[color2].active, lighten(theme[color2], -10));
        }
      }
    });
  }
}
function renderEmpty(componentName) {
  switch (componentName) {
    default:
      return React__default.createElement(Empty$1, null);
  }
}
var defaultProps$x = {
  locale: zhCN,
  prefixCls: "arco",
  getPopupContainer: function() {
    return document.body;
  },
  size: "default",
  renderEmpty,
  focusLock: {
    modal: { autoFocus: true },
    drawer: { autoFocus: true }
  }
};
var componentConfig = {};
var ConfigContext = createContext(__assign$1H({ getPrefixCls: function(componentName, customPrefix) {
  return (customPrefix || "arco") + "-" + componentName;
} }, defaultProps$x));
function ConfigProvider(baseProps) {
  var props = useMergeProps(baseProps, defaultProps$x, componentConfig);
  var theme = props.theme, prefixCls2 = props.prefixCls, children = props.children, locale = props.locale;
  useEffect(function() {
    setTheme(theme);
  }, [theme]);
  useEffect(function() {
    Message$1.config({ prefixCls: prefixCls2 });
    Notification$1.config({ prefixCls: prefixCls2 });
  }, [prefixCls2]);
  function getPrefixCls(componentName, customPrefix) {
    return (customPrefix || prefixCls2) + "-" + componentName;
  }
  var config2 = __assign$1H(__assign$1H({}, omit$1(props, ["children"])), { getPrefixCls });
  useEffect(function() {
    setConfigProviderProps({ locale, prefixCls: prefixCls2 });
  }, [locale, prefixCls2]);
  var child = children;
  if (prefixCls2 && prefixCls2 !== "arco") {
    child = React__default.createElement(IconContext.Provider, { value: { prefixCls: prefixCls2 } }, children);
  }
  return React__default.createElement(ConfigContext.Provider, { value: config2 }, child);
}
ConfigProvider.ConfigContext = ConfigContext;
ConfigProvider.displayName = "ConfigProvider";
ConfigContext.Consumer;
function isObject$d(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$d;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$9 = freeGlobal || freeSelf || Function("return this")();
var _root = root$9;
var root$8 = _root;
var now$1 = function() {
  return root$8.Date.now();
};
var now_1 = now$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var root$7 = _root;
var Symbol$7 = root$7.Symbol;
var _Symbol = Symbol$7;
var Symbol$6 = _Symbol;
var objectProto$g = Object.prototype;
var hasOwnProperty$e = objectProto$g.hasOwnProperty;
var nativeObjectToString$1 = objectProto$g.toString;
var symToStringTag$1 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$e.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$f = Object.prototype;
var nativeObjectToString = objectProto$f.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$5 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$5 ? Symbol$5.toStringTag : void 0;
function baseGetTag$6(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$6;
function isObjectLike$9(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$9;
var baseGetTag$5 = _baseGetTag, isObjectLike$8 = isObjectLike_1;
var symbolTag$3 = "[object Symbol]";
function isSymbol$4(value) {
  return typeof value == "symbol" || isObjectLike$8(value) && baseGetTag$5(value) == symbolTag$3;
}
var isSymbol_1 = isSymbol$4;
var baseTrim = _baseTrim, isObject$c = isObject_1, isSymbol$3 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$3(value)) {
    return NAN;
  }
  if (isObject$c(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$c(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$1;
var isObject$b = isObject_1, now = now_1, toNumber = toNumber_1;
var FUNC_ERROR_TEXT$2 = "Expected a function";
var nativeMax$1 = Math.max, nativeMin = Math.min;
function debounce$1(func, wait, options2) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  wait = toNumber(wait) || 0;
  if (isObject$b(options2)) {
    leading = !!options2.leading;
    maxing = "maxWait" in options2;
    maxWait = maxing ? nativeMax$1(toNumber(options2.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options2 ? !!options2.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$1;
var debounce = debounce_1, isObject$a = isObject_1;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function throttle$1(func, wait, options2) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  if (isObject$a(options2)) {
    leading = "leading" in options2 ? !!options2.leading : leading;
    trailing = "trailing" in options2 ? !!options2.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1 = throttle$1;
function isElement(el) {
  return el != null && typeof el === "object" && el.nodeType === 1;
}
function canOverflow(overflow, skipOverflowHiddenElements) {
  if (skipOverflowHiddenElements && overflow === "hidden") {
    return false;
  }
  return overflow !== "visible" && overflow !== "clip";
}
function isScrollable(el, skipOverflowHiddenElements) {
  if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {
    var style = getComputedStyle(el, null);
    return canOverflow(style.overflowY, skipOverflowHiddenElements) || canOverflow(style.overflowX, skipOverflowHiddenElements);
  }
  return false;
}
function alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {
  if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {
    return 0;
  }
  if (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize || elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize) {
    return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;
  }
  if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {
    return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;
  }
  return 0;
}
var compute = function(target2, options2) {
  var scrollMode = options2.scrollMode, block2 = options2.block, inline = options2.inline, boundary = options2.boundary, skipOverflowHiddenElements = options2.skipOverflowHiddenElements;
  var checkBoundary2 = typeof boundary === "function" ? boundary : function(node) {
    return node !== boundary;
  };
  if (!isElement(target2)) {
    throw new TypeError("Invalid target");
  }
  var scrollingElement = document.scrollingElement || document.documentElement;
  var frames = [];
  var cursor = target2;
  while (isElement(cursor) && checkBoundary2(cursor)) {
    cursor = cursor.parentNode;
    if (cursor === scrollingElement) {
      frames.push(cursor);
      break;
    }
    if (cursor === document.body && isScrollable(cursor) && !isScrollable(document.documentElement)) {
      continue;
    }
    if (isScrollable(cursor, skipOverflowHiddenElements)) {
      frames.push(cursor);
    }
  }
  var viewportWidth = window.visualViewport ? visualViewport.width : innerWidth;
  var viewportHeight = window.visualViewport ? visualViewport.height : innerHeight;
  var viewportX = window.scrollX || pageXOffset;
  var viewportY = window.scrollY || pageYOffset;
  var _target$getBoundingCl = target2.getBoundingClientRect(), targetHeight = _target$getBoundingCl.height, targetWidth = _target$getBoundingCl.width, targetTop = _target$getBoundingCl.top, targetRight = _target$getBoundingCl.right, targetBottom = _target$getBoundingCl.bottom, targetLeft = _target$getBoundingCl.left;
  var targetBlock = block2 === "start" || block2 === "nearest" ? targetTop : block2 === "end" ? targetBottom : targetTop + targetHeight / 2;
  var targetInline = inline === "center" ? targetLeft + targetWidth / 2 : inline === "end" ? targetRight : targetLeft;
  var computations = [];
  for (var index2 = 0; index2 < frames.length; index2++) {
    var frame = frames[index2];
    var _frame$getBoundingCli = frame.getBoundingClientRect(), _height = _frame$getBoundingCli.height, _width = _frame$getBoundingCli.width, _top = _frame$getBoundingCli.top, right = _frame$getBoundingCli.right, bottom = _frame$getBoundingCli.bottom, _left = _frame$getBoundingCli.left;
    if (scrollMode === "if-needed" && targetTop >= 0 && targetLeft >= 0 && targetBottom <= viewportHeight && targetRight <= viewportWidth && targetTop >= _top && targetBottom <= bottom && targetLeft >= _left && targetRight <= right) {
      return computations;
    }
    var frameStyle = getComputedStyle(frame);
    var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);
    var borderTop = parseInt(frameStyle.borderTopWidth, 10);
    var borderRight = parseInt(frameStyle.borderRightWidth, 10);
    var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);
    var blockScroll = 0;
    var inlineScroll = 0;
    var scrollbarWidth = "offsetWidth" in frame ? frame.offsetWidth - frame.clientWidth - borderLeft - borderRight : 0;
    var scrollbarHeight = "offsetHeight" in frame ? frame.offsetHeight - frame.clientHeight - borderTop - borderBottom : 0;
    if (scrollingElement === frame) {
      if (block2 === "start") {
        blockScroll = targetBlock;
      } else if (block2 === "end") {
        blockScroll = targetBlock - viewportHeight;
      } else if (block2 === "nearest") {
        blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);
      } else {
        blockScroll = targetBlock - viewportHeight / 2;
      }
      if (inline === "start") {
        inlineScroll = targetInline;
      } else if (inline === "center") {
        inlineScroll = targetInline - viewportWidth / 2;
      } else if (inline === "end") {
        inlineScroll = targetInline - viewportWidth;
      } else {
        inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);
      }
      blockScroll = Math.max(0, blockScroll + viewportY);
      inlineScroll = Math.max(0, inlineScroll + viewportX);
    } else {
      if (block2 === "start") {
        blockScroll = targetBlock - _top - borderTop;
      } else if (block2 === "end") {
        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;
      } else if (block2 === "nearest") {
        blockScroll = alignNearest(_top, bottom, _height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);
      } else {
        blockScroll = targetBlock - (_top + _height / 2) + scrollbarHeight / 2;
      }
      if (inline === "start") {
        inlineScroll = targetInline - _left - borderLeft;
      } else if (inline === "center") {
        inlineScroll = targetInline - (_left + _width / 2) + scrollbarWidth / 2;
      } else if (inline === "end") {
        inlineScroll = targetInline - right + borderRight + scrollbarWidth;
      } else {
        inlineScroll = alignNearest(_left, right, _width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);
      }
      var scrollLeft = frame.scrollLeft, scrollTop = frame.scrollTop;
      blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, frame.scrollHeight - _height + scrollbarHeight));
      inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, frame.scrollWidth - _width + scrollbarWidth));
      targetBlock += scrollTop - blockScroll;
      targetInline += scrollLeft - inlineScroll;
    }
    computations.push({
      el: frame,
      top: blockScroll,
      left: inlineScroll
    });
  }
  return computations;
};
function isOptionsObject(options2) {
  return options2 === Object(options2) && Object.keys(options2).length !== 0;
}
function defaultBehavior(actions, behavior) {
  if (behavior === void 0) {
    behavior = "auto";
  }
  var canSmoothScroll = "scrollBehavior" in document.body.style;
  actions.forEach(function(_ref2) {
    var el = _ref2.el, top = _ref2.top, left = _ref2.left;
    if (el.scroll && canSmoothScroll) {
      el.scroll({
        top,
        left,
        behavior
      });
    } else {
      el.scrollTop = top;
      el.scrollLeft = left;
    }
  });
}
function getOptions(options2) {
  if (options2 === false) {
    return {
      block: "end",
      inline: "nearest"
    };
  }
  if (isOptionsObject(options2)) {
    return options2;
  }
  return {
    block: "start",
    inline: "nearest"
  };
}
function scrollIntoView(target2, options2) {
  var targetIsDetached = !target2.ownerDocument.documentElement.contains(target2);
  if (isOptionsObject(options2) && typeof options2.behavior === "function") {
    return options2.behavior(targetIsDetached ? [] : compute(target2, options2));
  }
  if (targetIsDetached) {
    return;
  }
  var computeOptions = getOptions(options2);
  return defaultBehavior(compute(target2, computeOptions), computeOptions.behavior);
}
function pick(obj, keys2) {
  var clone = {};
  keys2.forEach(function(key) {
    var k = key;
    if (key in obj) {
      clone[k] = obj[k];
    }
  });
  return clone;
}
var NOOP = function() {
};
function newArray(length2) {
  return Array.apply(null, Array(length2));
}
function pickTriggerPropsFromRest(rest) {
  return pick(rest, [
    "onMouseEnter",
    "onMouseLeave",
    "onMouseMove",
    "onContextMenu",
    "onClick",
    "onFocus",
    "onBlur",
    "tabIndex"
  ]);
}
var isServerRendering = function() {
  try {
    return !(typeof window !== "undefined" && document !== void 0);
  } catch (e) {
    return true;
  }
}();
var on = function() {
  if (isServerRendering) {
    return NOOP;
  }
  return function(element, event2, handler, options2) {
    element && element.addEventListener(event2, handler, options2 || false);
  };
}();
var off = function() {
  if (isServerRendering) {
    return NOOP;
  }
  return function(element, event2, handler, options2) {
    element && element.removeEventListener(event2, handler, options2 || false);
  };
}();
var contains = function(root2, ele) {
  var node = ele;
  while (node) {
    if (node === root2) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
};
var isScrollElement = function(element) {
  return element.scrollHeight > element.offsetHeight || element.scrollWidth > element.offsetWidth;
};
var getScrollElements = function(container2, top) {
  if (top === void 0) {
    top = document.documentElement;
  }
  var scrollElements = [];
  var element = container2;
  while (element && element !== top) {
    if (isScrollElement(element)) {
      scrollElements.push(element);
    }
    element = element.parentElement;
  }
  return scrollElements;
};
function useIsFirstRender() {
  var isFirst = useRef(true);
  useEffect(function() {
    isFirst.current = false;
  }, []);
  return isFirst.current;
}
var target = typeof window === "undefined" ? global : window;
var vendors = ["webkit", "ms", "moz", "o"];
var raf = target.requestAnimationFrame;
var caf = target.cancelAnimationFrame;
if (!raf || !caf) {
  vendors.some(function(prefix) {
    raf = target[prefix + "RequestAnimationFrame"];
    caf = target[prefix + "CancelAnimationFrame"] || target[prefix + "CancelRequestAnimationFrame"];
    return raf && caf;
  });
  if (!raf || !caf) {
    var lastTime_1 = 0;
    raf = function(cb) {
      var currentTime = Date.now();
      var diff = Math.max(0, 16 - (currentTime - lastTime_1));
      var timer = setTimeout(function() {
        cb();
        lastTime_1 = currentTime + diff;
      }, diff);
      return timer;
    };
    caf = function(timer) {
      clearTimeout(timer);
    };
  }
}
raf = raf.bind(target);
caf = caf.bind(target);
var __read$1i = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$w = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function throttleByRaf(cb) {
  var timer = null;
  var throttle2 = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    timer && caf(timer);
    timer = raf(function() {
      cb.apply(void 0, __spreadArray$w([], __read$1i(args), false));
      timer = null;
    });
  };
  throttle2.cancel = function() {
    caf(timer);
    timer = null;
  };
  return throttle2;
}
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return function() {
    function class_1() {
      this.__entries__ = [];
    }
    Object.defineProperty(class_1.prototype, "size", {
      get: function() {
        return this.__entries__.length;
      },
      enumerable: true,
      configurable: true
    });
    class_1.prototype.get = function(key) {
      var index2 = getIndex(this.__entries__, key);
      var entry = this.__entries__[index2];
      return entry && entry[1];
    };
    class_1.prototype.set = function(key, value) {
      var index2 = getIndex(this.__entries__, key);
      if (~index2) {
        this.__entries__[index2][1] = value;
      } else {
        this.__entries__.push([key, value]);
      }
    };
    class_1.prototype.delete = function(key) {
      var entries = this.__entries__;
      var index2 = getIndex(entries, key);
      if (~index2) {
        entries.splice(index2, 1);
      }
    };
    class_1.prototype.has = function(key) {
      return !!~getIndex(this.__entries__, key);
    };
    class_1.prototype.clear = function() {
      this.__entries__.splice(0);
    };
    class_1.prototype.forEach = function(callback, ctx) {
      if (ctx === void 0) {
        ctx = null;
      }
      for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
        var entry = _a[_i];
        callback.call(ctx, entry[1], entry[0]);
      }
    };
    return class_1;
  }();
}();
var isBrowser$1 = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = function() {
  function ResizeObserverController2() {
    this.connected_ = false;
    this.mutationEventsAdded_ = false;
    this.mutationsObserver_ = null;
    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  ResizeObserverController2.prototype.addObserver = function(observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    }
    if (!this.connected_) {
      this.connect_();
    }
  };
  ResizeObserverController2.prototype.removeObserver = function(observer) {
    var observers2 = this.observers_;
    var index2 = observers2.indexOf(observer);
    if (~index2) {
      observers2.splice(index2, 1);
    }
    if (!observers2.length && this.connected_) {
      this.disconnect_();
    }
  };
  ResizeObserverController2.prototype.refresh = function() {
    var changesDetected = this.updateObservers_();
    if (changesDetected) {
      this.refresh();
    }
  };
  ResizeObserverController2.prototype.updateObservers_ = function() {
    var activeObservers = this.observers_.filter(function(observer) {
      return observer.gatherActive(), observer.hasActive();
    });
    activeObservers.forEach(function(observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  ResizeObserverController2.prototype.connect_ = function() {
    if (!isBrowser$1 || this.connected_) {
      return;
    }
    document.addEventListener("transitionend", this.onTransitionEnd_);
    window.addEventListener("resize", this.refresh);
    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener("DOMSubtreeModified", this.refresh);
      this.mutationEventsAdded_ = true;
    }
    this.connected_ = true;
  };
  ResizeObserverController2.prototype.disconnect_ = function() {
    if (!isBrowser$1 || !this.connected_) {
      return;
    }
    document.removeEventListener("transitionend", this.onTransitionEnd_);
    window.removeEventListener("resize", this.refresh);
    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }
    if (this.mutationEventsAdded_) {
      document.removeEventListener("DOMSubtreeModified", this.refresh);
    }
    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
    var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
    var isReflowProperty = transitionKeys.some(function(key) {
      return !!~propertyName.indexOf(key);
    });
    if (isReflowProperty) {
      this.refresh();
    }
  };
  ResizeObserverController2.getInstance = function() {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController2();
    }
    return this.instance_;
  };
  ResizeObserverController2.instance_ = null;
  return ResizeObserverController2;
}();
var defineConfigurable = function(target2, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target2, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target2;
};
var getWindowOf = function(target2) {
  var ownerGlobal = target2 && target2.ownerDocument && target2.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles2) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value = styles2["border-" + position + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles2) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles2["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target2) {
  var bbox = target2.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target2) {
  var clientWidth = target2.clientWidth, clientHeight = target2.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles2 = getWindowOf(target2).getComputedStyle(target2);
  var paddings = getPaddings(styles2);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles2.width), height = toFloat(styles2.height);
  if (styles2.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles2, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles2, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target2)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target2) {
      return target2 instanceof getWindowOf(target2).SVGGraphicsElement;
    };
  }
  return function(target2) {
    return target2 instanceof getWindowOf(target2).SVGElement && typeof target2.getBBox === "function";
  };
}();
function isDocumentElement(target2) {
  return target2 === getWindowOf(target2).document.documentElement;
}
function getContentRect(target2) {
  if (!isBrowser$1) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target2)) {
    return getSVGContentRect(target2);
  }
  return getHTMLElementContentRect(target2);
}
function createReadOnlyRect(_a) {
  var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
function createRectInit(x, y, width, height) {
  return { x, y, width, height };
}
var ResizeObservation = function() {
  function ResizeObservation2(target2) {
    this.broadcastWidth = 0;
    this.broadcastHeight = 0;
    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target2;
  }
  ResizeObservation2.prototype.isActive = function() {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  ResizeObservation2.prototype.broadcastRect = function() {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };
  return ResizeObservation2;
}();
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target2, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);
    defineConfigurable(this, { target: target2, contentRect });
  }
  return ResizeObserverEntry2;
}();
var ResizeObserverSPI = function() {
  function ResizeObserverSPI2(callback, controller, callbackCtx) {
    this.activeObservations_ = [];
    this.observations_ = new MapShim();
    if (typeof callback !== "function") {
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    }
    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  ResizeObserverSPI2.prototype.observe = function(target2) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target2 instanceof getWindowOf(target2).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (observations.has(target2)) {
      return;
    }
    observations.set(target2, new ResizeObservation(target2));
    this.controller_.addObserver(this);
    this.controller_.refresh();
  };
  ResizeObserverSPI2.prototype.unobserve = function(target2) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target2 instanceof getWindowOf(target2).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (!observations.has(target2)) {
      return;
    }
    observations.delete(target2);
    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  ResizeObserverSPI2.prototype.disconnect = function() {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  ResizeObserverSPI2.prototype.gatherActive = function() {
    var _this = this;
    this.clearActive();
    this.observations_.forEach(function(observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  ResizeObserverSPI2.prototype.broadcastActive = function() {
    if (!this.hasActive()) {
      return;
    }
    var ctx = this.callbackCtx_;
    var entries = this.activeObservations_.map(function(observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  ResizeObserverSPI2.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  };
  ResizeObserverSPI2.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  };
  return ResizeObserverSPI2;
}();
var observers = typeof WeakMap !== "undefined" ? new WeakMap() : new MapShim();
var ResizeObserver$1 = function() {
  function ResizeObserver2(callback) {
    if (!(this instanceof ResizeObserver2)) {
      throw new TypeError("Cannot call a class as a function.");
    }
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }
  return ResizeObserver2;
}();
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver$1.prototype[method] = function() {
    var _a;
    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});
var index$1 = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver$1;
}();
var __extends$7 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ResizeObserverComponent = function(_super) {
  __extends$7(ResizeObserverComponent2, _super);
  function ResizeObserverComponent2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.componentWillUnmount = function() {
      if (_this.resizeObserver) {
        _this.destroyResizeObserver();
      }
    };
    _this.createResizeObserver = function() {
      _this.resizeObserver = new index$1(function(entry) {
        var onResize = _this.props.onResize;
        onResize && onResize(entry);
      });
      _this.resizeObserver.observe(findDOMNode(_this));
    };
    _this.destroyResizeObserver = function() {
      _this.resizeObserver && _this.resizeObserver.disconnect();
      _this.resizeObserver = null;
    };
    return _this;
  }
  ResizeObserverComponent2.prototype.componentDidMount = function() {
    if (!React__default.isValidElement(this.props.children)) {
      console.warn("The children of ResizeObserver is invalid.");
    } else {
      this.createResizeObserver();
    }
  };
  ResizeObserverComponent2.prototype.componentDidUpdate = function() {
    if (!this.resizeObserver && findDOMNode(this)) {
      this.createResizeObserver();
    }
  };
  ResizeObserverComponent2.prototype.render = function() {
    return this.props.children;
  };
  return ResizeObserverComponent2;
}(React__default.Component);
var ResizeObserver = ResizeObserverComponent;
var useIsomorphicLayoutEffect = isServerRendering ? useEffect : useLayoutEffect;
var useIsomorphicLayoutEffect$1 = useIsomorphicLayoutEffect;
var easeInBy = function(power) {
  return function(t2) {
    return Math.pow(t2, power);
  };
};
var easeOutBy = function(power) {
  return function(t2) {
    return 1 - Math.abs(Math.pow(t2 - 1, power));
  };
};
var easeInOutBy = function(power) {
  return function(t2) {
    return t2 < 0.5 ? easeInBy(power)(t2 * 2) / 2 : easeOutBy(power)(t2 * 2 - 1) / 2 + 0.5;
  };
};
var linear = function(t2) {
  return t2;
};
var quadIn = easeInBy(2);
var quadOut = easeOutBy(2);
var quadInOut = easeInOutBy(2);
var cubicIn = easeInBy(3);
var cubicOut = easeOutBy(3);
var cubicInOut = easeInOutBy(3);
var quartIn = easeInBy(4);
var quartOut = easeOutBy(4);
var quartInOut = easeInOutBy(4);
var quintIn = easeInBy(5);
var quintOut = easeOutBy(5);
var quintInOut = easeInOutBy(5);
var sineIn = function(t2) {
  return 1 + Math.sin(Math.PI / 2 * t2 - Math.PI / 2);
};
var sineOut = function(t2) {
  return Math.sin(Math.PI / 2 * t2);
};
var sineInOut = function(t2) {
  return (1 + Math.sin(Math.PI * t2 - Math.PI / 2)) / 2;
};
var bounceOut = function(t2) {
  var s = 7.5625;
  var p = 2.75;
  if (t2 < 1 / p) {
    return s * t2 * t2;
  }
  if (t2 < 2 / p) {
    t2 -= 1.5 / p;
    return s * t2 * t2 + 0.75;
  }
  if (t2 < 2.5 / p) {
    t2 -= 2.25 / p;
    return s * t2 * t2 + 0.9375;
  }
  t2 -= 2.625 / p;
  return s * t2 * t2 + 0.984375;
};
var bounceIn = function(t2) {
  return 1 - bounceOut(1 - t2);
};
var bounceInOut = function(t2) {
  return t2 < 0.5 ? bounceIn(t2 * 2) * 0.5 : bounceOut(t2 * 2 - 1) * 0.5 + 0.5;
};
var easing = /* @__PURE__ */ Object.freeze({
  linear,
  quadIn,
  quadOut,
  quadInOut,
  cubicIn,
  cubicOut,
  cubicInOut,
  quartIn,
  quartOut,
  quartInOut,
  quintIn,
  quintOut,
  quintInOut,
  sineIn,
  sineOut,
  sineInOut,
  bounceOut,
  bounceIn,
  bounceInOut
});
var Tween = function Tween2(settings) {
  var from = settings.from;
  var to = settings.to;
  var duration2 = settings.duration;
  var delay = settings.delay;
  var easing2 = settings.easing;
  var onStart = settings.onStart;
  var onUpdate = settings.onUpdate;
  var onFinish = settings.onFinish;
  for (var key in from) {
    if (to[key] === void 0) {
      to[key] = from[key];
    }
  }
  for (var key$1 in to) {
    if (from[key$1] === void 0) {
      from[key$1] = to[key$1];
    }
  }
  this.from = from;
  this.to = to;
  this.duration = duration2 || 500;
  this.delay = delay || 0;
  this.easing = easing2 || "linear";
  this.onStart = onStart;
  this.onUpdate = onUpdate || function() {
  };
  this.onFinish = onFinish;
  this.startTime = Date.now() + this.delay;
  this.started = false;
  this.finished = false;
  this.timer = null;
  this.keys = {};
};
Tween.prototype.update = function update() {
  this.time = Date.now();
  if (this.time < this.startTime) {
    return;
  }
  if (this.finished) {
    return;
  }
  if (this.elapsed === this.duration) {
    if (!this.finished) {
      this.finished = true;
      this.onFinish && this.onFinish(this.keys);
    }
    return;
  }
  this.elapsed = this.time - this.startTime;
  this.elapsed = this.elapsed > this.duration ? this.duration : this.elapsed;
  for (var key in this.to) {
    this.keys[key] = this.from[key] + (this.to[key] - this.from[key]) * easing[this.easing](this.elapsed / this.duration);
  }
  if (!this.started) {
    this.onStart && this.onStart(this.keys);
    this.started = true;
  }
  this.onUpdate(this.keys);
};
Tween.prototype.start = function start() {
  var this$1$1 = this;
  this.startTime = Date.now() + this.delay;
  var tick = function() {
    this$1$1.update();
    this$1$1.timer = requestAnimationFrame(tick);
    if (this$1$1.finished) {
      cancelAnimationFrame(this$1$1.timer);
      this$1$1.timer = null;
    }
  };
  tick();
};
Tween.prototype.stop = function stop() {
  cancelAnimationFrame(this.timer);
  this.timer = null;
};
var __read$1h = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function useStateWithPromise(defaultVal) {
  var _a = __read$1h(useState({
    value: defaultVal,
    resolve: function(e) {
    }
  }), 2), state = _a[0], setState = _a[1];
  useEffect(function() {
    state.resolve(state.value);
  }, [state]);
  return [
    state.value,
    function(updater) {
      return new Promise(function(resolve) {
        setState(function(prevState) {
          var nextVal = updater;
          if (typeof updater === "function") {
            nextVal = updater(prevState.value);
          }
          return {
            value: nextVal,
            resolve
          };
        });
      });
    }
  ];
}
function Group$5(props, ref) {
  var className = props.className, style = props.style, children = props.children;
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var prefixCls2 = getPrefixCls("btn-group");
  var classNames = cs$1(prefixCls2, className);
  return React__default.createElement("div", { ref, className: classNames, style }, children);
}
var GroupComponent = React__default.forwardRef(Group$5);
GroupComponent.displayName = "ButtonGroup";
var Group$6 = GroupComponent;
var __assign$1G = globalThis && globalThis.__assign || function() {
  __assign$1G = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1G.apply(this, arguments);
};
var __rest$Q = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$1g = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var regexTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
function processChildren$1(children) {
  var childrenList = [];
  var isPrevChildPure = false;
  React__default.Children.forEach(children, function(child) {
    var isCurrentChildPure = typeof child === "string" || typeof child === "number";
    if (isCurrentChildPure && isPrevChildPure) {
      var lastIndex = childrenList.length - 1;
      var lastChild = childrenList[lastIndex];
      childrenList[lastIndex] = "" + lastChild + child;
    } else {
      childrenList.push(child);
    }
    isPrevChildPure = isCurrentChildPure;
  });
  return React__default.Children.map(childrenList, function(child) {
    return typeof child === "string" ? React__default.createElement("span", null, child) : child;
  });
}
var defaultProps$w = {
  htmlType: "button",
  type: "default",
  shape: "square"
};
function Button$3(baseProps, ref) {
  var _a;
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, ctxSize = _b.size, autoInsertSpaceInButton = _b.autoInsertSpaceInButton, componentConfig2 = _b.componentConfig, rtl = _b.rtl;
  var props = useMergeProps(baseProps, defaultProps$w, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Button);
  var style = props.style, className = props.className, children = props.children, htmlType = props.htmlType, type = props.type, status = props.status, size = props.size, shape = props.shape, href = props.href, anchorProps = props.anchorProps, disabled = props.disabled, loading = props.loading, loadingFixedWidth = props.loadingFixedWidth, icon = props.icon, iconOnly = props.iconOnly, onClick = props.onClick, long = props.long, rest = __rest$Q(props, ["style", "className", "children", "htmlType", "type", "status", "size", "shape", "href", "anchorProps", "disabled", "loading", "loadingFixedWidth", "icon", "iconOnly", "onClick", "long"]);
  var iconNode = loading ? React__default.createElement(IconLoading$1, null) : icon;
  var _c = __read$1g(useState(false), 2), isTwoCNChar = _c[0], setIsTwoCNChar = _c[1];
  var innerButtonRef = useRef();
  var buttonRef = ref || innerButtonRef;
  useEffect(function() {
    if (autoInsertSpaceInButton && buttonRef && buttonRef.current) {
      var textContent = buttonRef.current.textContent;
      if (regexTwoCNChar.test(textContent)) {
        if (!isTwoCNChar) {
          setIsTwoCNChar(true);
        }
      } else if (isTwoCNChar) {
        setIsTwoCNChar(false);
      }
    }
  }, [buttonRef.current, autoInsertSpaceInButton]);
  var prefixCls2 = getPrefixCls("btn");
  var _type = type === "default" ? "secondary" : type;
  var classNames = cs$1(prefixCls2, prefixCls2 + "-" + _type, prefixCls2 + "-size-" + (size || ctxSize), prefixCls2 + "-shape-" + shape, (_a = {}, _a[prefixCls2 + "-long"] = long, _a[prefixCls2 + "-status-" + status] = status, _a[prefixCls2 + "-loading-fixed-width"] = loadingFixedWidth, _a[prefixCls2 + "-loading"] = loading, _a[prefixCls2 + "-link"] = href, _a[prefixCls2 + "-icon-only"] = iconOnly || !children && children !== 0 && iconNode, _a[prefixCls2 + "-disabled"] = disabled, _a[prefixCls2 + "-two-chinese-chars"] = isTwoCNChar, _a[prefixCls2 + "-rtl"] = rtl, _a), className);
  var handleClick = function(event2) {
    if (loading) {
      typeof (event2 === null || event2 === void 0 ? void 0 : event2.preventDefault) === "function" && event2.preventDefault();
      return;
    }
    onClick && onClick(event2);
  };
  var InnerContent = React__default.createElement(React__default.Fragment, null, iconNode, processChildren$1(children));
  if (href) {
    var _anchorProps = __assign$1G({}, anchorProps);
    if (disabled) {
      delete _anchorProps.href;
    } else {
      _anchorProps.href = href;
    }
    return React__default.createElement("a", __assign$1G({ ref: buttonRef }, rest, _anchorProps, { style, className: classNames, onClick: handleClick }), InnerContent);
  }
  return React__default.createElement("button", __assign$1G({ ref: buttonRef }, rest, { style, className: classNames, type: htmlType, disabled, onClick: handleClick }), InnerContent);
}
var ForwardRefButton = forwardRef(Button$3);
var ButtonComponent$1 = ForwardRefButton;
ButtonComponent$1.__BYTE_BUTTON = true;
ButtonComponent$1.Group = Group$6;
ButtonComponent$1.displayName = "Button";
var Button$4 = ButtonComponent$1;
function ownKeys$u(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$u(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$u(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$u(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconSearchComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$u(_objectSpread$u({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-search")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M33.072 33.071c6.248-6.248 6.248-16.379 0-22.627-6.249-6.249-16.38-6.249-22.628 0-6.248 6.248-6.248 16.379 0 22.627 6.248 6.248 16.38 6.248 22.628 0Zm0 0 8.485 8.485"
  }));
}
var IconSearch = /* @__PURE__ */ React__default.forwardRef(IconSearchComponent);
IconSearch.defaultProps = {
  isIcon: true
};
IconSearch.displayName = "IconSearch";
var IconSearch$1 = IconSearch;
var __read$1f = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function useMergeValue(defaultStateValue, props) {
  var _a = props || {}, defaultValue = _a.defaultValue, value = _a.value;
  var firstRenderRef = useRef(true);
  var _b = __read$1f(useState(!isUndefined(value) ? value : !isUndefined(defaultValue) ? defaultValue : defaultStateValue), 2), stateValue = _b[0], setStateValue = _b[1];
  useEffect(function() {
    if (firstRenderRef.current) {
      firstRenderRef.current = false;
      return;
    }
    if (value === void 0) {
      setStateValue(value);
    }
  }, [value]);
  var mergedValue = isUndefined(value) ? stateValue : value;
  return [mergedValue, setStateValue, stateValue];
}
var __assign$1F = globalThis && globalThis.__assign || function() {
  __assign$1F = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1F.apply(this, arguments);
};
var __rest$P = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$1e = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var Search = React__default.forwardRef(function(props, ref) {
  var _a;
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var _b = __read$1e(useMergeValue("", {
    defaultValue: "defaultValue" in props ? formatValue$1(props.defaultValue, props.maxLength) : void 0,
    value: "value" in props ? formatValue$1(props.value, props.maxLength) : void 0
  }), 2), value = _b[0], setValue = _b[1];
  var className = props.className, style = props.style, placeholder = props.placeholder, disabled = props.disabled, searchButton = props.searchButton, loading = props.loading, defaultValue = props.defaultValue, rest = __rest$P(props, ["className", "style", "placeholder", "disabled", "searchButton", "loading", "defaultValue"]);
  var prefixCls2 = getPrefixCls("input-search");
  var classNames = cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-button"] = searchButton, _a), className);
  var onSearch = function(e) {
    !disabled && props.onSearch && props.onSearch(value);
    props.onPressEnter && props.onPressEnter(e);
  };
  return React__default.createElement(Input$5, __assign$1F({}, omit$1(rest, ["onSearch"]), { disabled, className: classNames, style, ref, placeholder, addAfter: searchButton ? React__default.createElement(Button$4, { disabled, size: rest.size, className: prefixCls2 + "-btn", type: "primary", onClick: onSearch, loading, loadingFixedWidth: true, icon: searchButton === true && !loading && React__default.createElement(IconSearch$1, null) }, searchButton !== true && searchButton) : null, suffix: !searchButton && (loading ? React__default.createElement(IconLoading$1, null) : React__default.createElement(IconSearch$1, { onClick: onSearch })), onChange: function(value2, e) {
    setValue(value2);
    props.onChange && props.onChange(value2, e);
  }, defaultValue, onPressEnter: onSearch }));
});
Search.displayName = "Search";
var Search$1 = Search;
var mirrorTextAreaStyle = "\n  position: absolute;\n  min-height: 0 !important;\n  max-height: none;\n  height:0;\n  visibility: hidden;\n  z-index: -100;\n  top: 0;\n  right: 0;\n";
var mirrorTextAreaSizing = [
  "border-width",
  "box-sizing",
  "font-family",
  "font-weight",
  "font-size",
  "font-variant",
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "padding-left",
  "padding-right",
  "text-indent",
  "text-rendering",
  "text-transform",
  "width"
];
var mirrorTextArea;
function setMirrorTextArea(originTextArea) {
  if (!mirrorTextArea) {
    mirrorTextArea = document.createElement("textarea");
    document.body.appendChild(mirrorTextArea);
  }
  var originStyle = window.getComputedStyle(originTextArea);
  var originSizingStyle = "\n    " + mirrorTextAreaSizing.map(function(attr) {
    return attr + ":" + originStyle.getPropertyValue(attr);
  }).join(";") + "\n  ";
  mirrorTextArea.setAttribute("style", "" + mirrorTextAreaStyle + originSizingStyle);
  var paddingSize = parseFloat(originStyle.getPropertyValue("padding-top")) + parseFloat(originStyle.getPropertyValue("padding-bottom"));
  var boxSizing = originStyle.getPropertyValue("box-sizing");
  var borderSize = parseFloat(originStyle.getPropertyValue("border-top-width")) + parseFloat(originStyle.getPropertyValue("border-bottom-width"));
  return {
    paddingSize,
    boxSizing,
    borderSize
  };
}
function autoSizeTextAreaHeight(autoSize, node) {
  var getRows = function() {
    var minRows2;
    var maxRows2;
    if (isObject$e(autoSize)) {
      minRows2 = autoSize.minRows;
      maxRows2 = autoSize.maxRows;
    }
    return {
      minRows: minRows2,
      maxRows: maxRows2
    };
  };
  if (autoSize) {
    var _a = getRows(), minRows = _a.minRows, maxRows = _a.maxRows;
    var originTextNode = node;
    var _b = setMirrorTextArea(originTextNode), paddingSize = _b.paddingSize, boxSizing = _b.boxSizing, borderSize = _b.borderSize;
    mirrorTextArea.value = originTextNode.value || originTextNode.placeholder || "";
    var mirrorTextAreaHeight = mirrorTextArea.scrollHeight + borderSize;
    var minHeight = void 0;
    var maxHeight = void 0;
    var overflowY = void 0;
    if (minRows || maxRows) {
      mirrorTextArea.value = "";
      var singleRowHeight = mirrorTextArea.scrollHeight - paddingSize;
      if (isNumber$1(minRows)) {
        minHeight = singleRowHeight * minRows;
        if (boxSizing === "border-box") {
          minHeight += paddingSize;
          minHeight += borderSize;
        }
        mirrorTextAreaHeight = Math.max(mirrorTextAreaHeight, minHeight);
      }
      if (isNumber$1(maxRows)) {
        maxHeight = singleRowHeight * maxRows;
        if (boxSizing === "border-box") {
          maxHeight += paddingSize;
          maxHeight += borderSize;
        }
        overflowY = mirrorTextAreaHeight > maxHeight ? "auto" : "";
        maxHeight = Math.min(mirrorTextAreaHeight, maxHeight);
      }
    }
    var textAreaStyle = {};
    textAreaStyle.height = mirrorTextAreaHeight;
    if (minHeight) {
      textAreaStyle.minHeight = minHeight;
    }
    if (maxHeight) {
      textAreaStyle.maxHeight = maxHeight;
    }
    if (overflowY) {
      textAreaStyle.overflowY = overflowY;
    }
    return textAreaStyle;
  }
}
var Enter = {
  key: "Enter",
  code: 13
};
var Esc = {
  key: "Escape",
  code: 27
};
var Backspace = {
  key: "Backspace",
  code: 8
};
var Tab = {
  key: "Tab",
  code: 9
};
var ArrowUp = {
  key: "ArrowUp",
  code: 38
};
var ArrowDown = {
  key: "ArrowDown",
  code: 40
};
var __read$1d = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function useComposition(_a) {
  var value = _a.value, maxLength = _a.maxLength, onChange = _a.onChange, onKeyDown = _a.onKeyDown, onPressEnter = _a.onPressEnter, beforeTriggerValueChangeCallback = _a.beforeTriggerValueChangeCallback;
  var refIsComposition = useRef(false);
  var _b = __read$1d(useState(""), 2), compositionValue = _b[0], setCompositionValue = _b[1];
  var triggerValueChangeCallback = function(newValue, e) {
    if (beforeTriggerValueChangeCallback) {
      beforeTriggerValueChangeCallback(newValue);
    }
    if (onChange && newValue !== value && (maxLength === void 0 || newValue.length <= maxLength)) {
      onChange(newValue, e);
    }
  };
  return {
    compositionValue,
    triggerValueChangeCallback,
    compositionHandler: function(e) {
      refIsComposition.current = e.type !== "compositionend";
      if (!refIsComposition.current) {
        setCompositionValue(void 0);
        triggerValueChangeCallback(e.target.value, e);
      }
    },
    valueChangeHandler: function(e) {
      var newValue = e.target.value;
      if (!refIsComposition.current) {
        compositionValue && setCompositionValue(void 0);
        triggerValueChangeCallback(newValue, e);
      } else {
        refIsComposition.current = false;
        setCompositionValue(newValue);
      }
    },
    keyDownHandler: function(e) {
      var keyCode = e.keyCode || e.which;
      if (!refIsComposition.current) {
        onKeyDown && onKeyDown(e);
        if (keyCode === Enter.code) {
          onPressEnter && onPressEnter(e);
        }
      }
    }
  };
}
var __assign$1E = globalThis && globalThis.__assign || function() {
  __assign$1E = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1E.apply(this, arguments);
};
var __rest$O = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$1c = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var TextArea = function(props, ref) {
  var _a, _b, _c;
  var className = props.className, style = props.style, wrapperStyle = props.wrapperStyle, placeholder = props.placeholder, disabled = props.disabled, error2 = props.error, propMaxLength = props.maxLength, showWordLimit = props.showWordLimit, allowClear = props.allowClear, onChange = props.onChange, onClear = props.onClear, onKeyDown = props.onKeyDown, onPressEnter = props.onPressEnter, rest = __rest$O(props, ["className", "style", "wrapperStyle", "placeholder", "disabled", "error", "maxLength", "showWordLimit", "allowClear", "onChange", "onClear", "onKeyDown", "onPressEnter"]);
  var wordLimitMaxLength = isObject$e(propMaxLength) ? propMaxLength.length : propMaxLength;
  var maxLength = isObject$e(propMaxLength) ? propMaxLength.errorOnly ? void 0 : propMaxLength.length : propMaxLength;
  var textareaRef = useRef();
  var _d = __read$1c(useState({}), 2), textAreaStyle = _d[0], setTextAreaStyle = _d[1];
  var _e = __read$1c(useMergeValue("", {
    defaultValue: "defaultValue" in props ? formatValue$1(props.defaultValue, maxLength) : void 0,
    value: "value" in props ? formatValue$1(props.value, maxLength) : void 0
  }), 2), value = _e[0], setValue = _e[1];
  var _f = useComposition({
    value,
    maxLength,
    onChange,
    onKeyDown,
    onPressEnter,
    beforeTriggerValueChangeCallback: function(v) {
      if (!("value" in props) && (maxLength === void 0 || v.length <= maxLength)) {
        setValue(v);
      }
    }
  }), compositionValue = _f.compositionValue, compositionHandler = _f.compositionHandler, valueChangeHandler = _f.valueChangeHandler, keyDownHandler = _f.keyDownHandler, triggerValueChangeCallback = _f.triggerValueChangeCallback;
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var prefixCls2 = getPrefixCls("textarea");
  if (disabled) {
    textAreaStyle.resize = "none";
  }
  var onFocus3 = function() {
    if (textareaRef.current && textareaRef.current.focus) {
      if (textareaRef.current.setSelectionRange) {
        var caretPos = textareaRef.current.textContent.length;
        textareaRef.current.setSelectionRange(caretPos, caretPos);
      }
      textareaRef.current.focus();
    }
  };
  var resizeTextAreaHeight = function() {
    var textAreaStyle2 = autoSizeTextAreaHeight(props.autoSize, textareaRef.current);
    if (textAreaStyle2) {
      setTextAreaStyle(textAreaStyle2);
    }
  };
  var handleClearClick = function(e) {
    e.stopPropagation();
    onFocus3();
    triggerValueChangeCallback("", e);
    onClear && onClear();
  };
  useIsomorphicLayoutEffect$1(function() {
    resizeTextAreaHeight();
  }, [value]);
  useImperativeHandle(ref, function() {
    return {
      dom: textareaRef.current,
      focus: function() {
        onFocus3();
      },
      blur: function() {
        textareaRef.current && textareaRef.current.blur && textareaRef.current.blur();
      }
    };
  }, []);
  var valueLength = value ? value.length : 0;
  var withWrapper = wordLimitMaxLength && showWordLimit || allowClear;
  var lengthError = useMemo(function() {
    if (!maxLength && wordLimitMaxLength) {
      return valueLength > wordLimitMaxLength;
    }
    return false;
  }, [valueLength, wordLimitMaxLength, maxLength]);
  var classNames = cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-error"] = error2 || lengthError, _a[prefixCls2 + "-disabled"] = disabled, _a), className);
  var TextAreaElement = React__default.createElement("textarea", __assign$1E({}, omit$1(rest, ["autoSize", "defaultValue"]), { maxLength, ref: textareaRef, style: __assign$1E(__assign$1E({}, style), textAreaStyle), className: classNames, placeholder, disabled, value: compositionValue || value || "", onChange: valueChangeHandler, onKeyDown: keyDownHandler, onCompositionStart: compositionHandler, onCompositionUpdate: compositionHandler, onCompositionEnd: compositionHandler }));
  if (withWrapper) {
    var showClearIcon = !disabled && allowClear && value;
    return React__default.createElement("div", { className: cs$1(prefixCls2 + "-wrapper", (_b = {}, _b[prefixCls2 + "-clear-wrapper"] = allowClear, _b)), style: wrapperStyle }, TextAreaElement, showClearIcon ? React__default.createElement(IconHover, { className: prefixCls2 + "-clear-icon" }, React__default.createElement(IconClose$1, {
      onClick: handleClearClick,
      onMouseDown: function(e) {
        e.preventDefault();
      }
    })) : null, wordLimitMaxLength && showWordLimit && React__default.createElement("span", { className: cs$1(prefixCls2 + "-word-limit", (_c = {}, _c[prefixCls2 + "-word-limit-error"] = lengthError, _c)) }, valueLength, "/", wordLimitMaxLength));
  }
  return TextAreaElement;
};
var TextAreaRef = React__default.forwardRef(TextArea);
TextAreaRef.displayName = "TextArea";
var TextArea$1 = TextAreaRef;
function ownKeys$t(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$t(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$t(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$t(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconEyeComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$t(_objectSpread$t({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-eye")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M24 37c6.627 0 12.627-4.333 18-13-5.373-8.667-11.373-13-18-13-6.627 0-12.627 4.333-18 13 5.373 8.667 11.373 13 18 13Z",
    clipRule: "evenodd"
  }), /* @__PURE__ */ React__default.createElement("path", {
    d: "M29 24a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"
  }));
}
var IconEye = /* @__PURE__ */ React__default.forwardRef(IconEyeComponent);
IconEye.defaultProps = {
  isIcon: true
};
IconEye.displayName = "IconEye";
var IconEye$1 = IconEye;
function ownKeys$s(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$s(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$s(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$s(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconEyeInvisibleComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$s(_objectSpread$s({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-eye-invisible")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M14 14.5c-2.69 2-5.415 5.33-8 9.5 5.373 8.667 11.373 13 18 13 3.325 0 6.491-1.09 9.5-3.271M17.463 12.5C19 11 21.75 11 24 11c6.627 0 12.627 4.333 18 13-1.766 2.848-3.599 5.228-5.5 7.14"
  }), /* @__PURE__ */ React__default.createElement("path", {
    d: "M29 24a5 5 0 1 1-10 0 5 5 0 0 1 10 0ZM6.852 7.103l34.294 34.294"
  }));
}
var IconEyeInvisible = /* @__PURE__ */ React__default.forwardRef(IconEyeInvisibleComponent);
IconEyeInvisible.defaultProps = {
  isIcon: true
};
IconEyeInvisible.displayName = "IconEyeInvisible";
var IconEyeInvisible$1 = IconEyeInvisible;
var __assign$1D = globalThis && globalThis.__assign || function() {
  __assign$1D = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1D.apply(this, arguments);
};
var __rest$N = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$1b = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var Password = React__default.forwardRef(function(props, ref) {
  var _a;
  var _b = __read$1b(useMergeValue(false, {
    defaultValue: props.defaultVisibility,
    value: props.visibility
  }), 2), visibility = _b[0], setVisibility = _b[1];
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var className = props.className, visibilityToggle = props.visibilityToggle, onVisibilityChange = props.onVisibilityChange, rest = __rest$N(props, ["className", "visibilityToggle", "onVisibilityChange"]);
  var prefixCls2 = getPrefixCls("input-password");
  var classNames = cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-visibility"] = visibilityToggle, _a), className);
  var onClickVisibility = function(v) {
    if (!("visibility" in props)) {
      setVisibility(v);
    }
    onVisibilityChange && onVisibilityChange(v);
  };
  var icon = props.suffix;
  if (visibilityToggle) {
    var IconProps = {
      onClick: function() {
        return onClickVisibility(!visibility);
      },
      onMouseDown: function(e) {
        return e.preventDefault();
      },
      onMouseUp: function(e) {
        return e.preventDefault();
      }
    };
    if (props.suffix) {
      icon = React__default.createElement("span", __assign$1D({}, IconProps), props.suffix);
    } else {
      var IconComponent = visibility ? IconEye$1 : IconEyeInvisible$1;
      icon = React__default.createElement(IconComponent, __assign$1D({}, IconProps));
    }
  }
  return React__default.createElement(Input$5, __assign$1D({}, omit$1(rest, ["visibility", "defaultVisibility"]), { type: visibility ? "text" : "password", className: classNames, ref, suffix: icon }));
});
Password.displayName = "Password";
Password.defaultProps = {
  visibilityToggle: true
};
var Password$1 = Password;
var __assign$1C = globalThis && globalThis.__assign || function() {
  __assign$1C = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1C.apply(this, arguments);
};
var __rest$M = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var InputComponent = React__default.forwardRef(function(props, ref) {
  var _a;
  var allowClear = props.allowClear, error2 = props.error, disabled = props.disabled, placeholder = props.placeholder, className = props.className, style = props.style, height = props.height, prefixCls2 = props.prefixCls, hasParent = props.hasParent, size = props.size, value = props.value, autoFitWidth = props.autoFitWidth, onClear = props.onClear, readOnly = props.readOnly, onChange = props.onChange, onKeyDown = props.onKeyDown, onPressEnter = props.onPressEnter, propMaxLength = props.maxLength, rest = __rest$M(props, ["allowClear", "error", "disabled", "placeholder", "className", "style", "height", "prefixCls", "hasParent", "size", "value", "autoFitWidth", "onClear", "readOnly", "onChange", "onKeyDown", "onPressEnter", "maxLength"]);
  var otherProps = omit$1(rest, [
    "showWordLimit",
    "className",
    "defaultValue",
    "addBefore",
    "addAfter",
    "afterStyle",
    "beforeStyle",
    "prefix",
    "suffix"
  ]);
  var refInput = useRef();
  var refInputMirror = useRef();
  var refPrevInputWidth = useRef(null);
  var maxLength = isObject$e(propMaxLength) ? propMaxLength.errorOnly ? void 0 : propMaxLength.length : propMaxLength;
  var _b = useComposition({ value, maxLength, onChange, onKeyDown, onPressEnter }), compositionValue = _b.compositionValue, valueChangeHandler = _b.valueChangeHandler, compositionHandler = _b.compositionHandler, keyDownHandler = _b.keyDownHandler, triggerValueChangeCallback = _b.triggerValueChangeCallback;
  var inputClassNames = cs$1(prefixCls2, prefixCls2 && (_a = {}, _a[prefixCls2 + "-size-" + size] = size, _a[prefixCls2 + "-error"] = error2, _a[prefixCls2 + "-disabled"] = disabled, _a), hasParent ? void 0 : className);
  useImperativeHandle(ref, function() {
    return {
      dom: refInput.current,
      focus: function() {
        refInput.current && refInput.current.focus && refInput.current.focus();
      },
      blur: function() {
        refInput.current && refInput.current.blur && refInput.current.blur();
      }
    };
  }, []);
  var updateInputWidth = function() {
    if (refInputMirror.current && refInput.current) {
      var width = refInputMirror.current.offsetWidth;
      refInput.current.style.width = width + (width ? 8 : 4) + "px";
    }
  };
  useEffect(function() {
    return autoFitWidth && updateInputWidth();
  }, []);
  var inputProps = __assign$1C(__assign$1C({ "aria-invalid": error2 }, otherProps), { readOnly, maxLength, disabled, placeholder, value: compositionValue || value || "", className: inputClassNames, onKeyDown: keyDownHandler, onChange: valueChangeHandler, onCompositionStart: compositionHandler, onCompositionUpdate: compositionHandler, onCompositionEnd: compositionHandler });
  var mirrorValue = inputProps.value || placeholder;
  return React__default.createElement(React__default.Fragment, null, allowClear ? React__default.createElement(React__default.Fragment, null, React__default.createElement("input", __assign$1C({ ref: refInput }, inputProps)), !readOnly && !disabled && allowClear && value ? React__default.createElement(IconHover, { className: prefixCls2 + "-clear-icon", onClick: function(e) {
    e.stopPropagation();
    if (refInput.current && refInput.current.focus) {
      refInput.current.focus();
    }
    triggerValueChangeCallback("", e);
    onClear && onClear();
  } }, React__default.createElement(IconClose$1, {
    onMouseDown: function(e) {
      e.preventDefault();
    }
  })) : null) : React__default.createElement("input", __assign$1C({ ref: refInput }, inputProps, { style: hasParent ? {} : __assign$1C(__assign$1C({}, style), "height" in props ? { height } : {}) })), autoFitWidth && React__default.createElement(ResizeObserver, { onResize: function() {
    var inputWidth = refInputMirror.current.offsetWidth;
    if (typeof autoFitWidth === "object") {
      var delay = typeof autoFitWidth.delay === "function" ? autoFitWidth.delay(inputWidth, refPrevInputWidth.current) : autoFitWidth.delay;
      delay ? setTimeout(updateInputWidth, delay) : updateInputWidth();
    } else {
      updateInputWidth();
    }
    refPrevInputWidth.current = inputWidth;
  } }, React__default.createElement("span", { className: prefixCls2 + "-mirror", ref: refInputMirror }, mirrorValue && mirrorValue.replace(/\s/g, "\xA0"))));
});
InputComponent.displayName = "InputComponent";
var InputComponent$1 = InputComponent;
var __assign$1B = globalThis && globalThis.__assign || function() {
  __assign$1B = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1B.apply(this, arguments);
};
var __rest$L = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var Group$3 = React__default.forwardRef(function(props, ref) {
  var _a;
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var className = props.className, style = props.style, children = props.children, compact = props.compact, rest = __rest$L(props, ["className", "style", "children", "compact"]);
  var prefixCls2 = getPrefixCls("input-group");
  var classNames = cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-compact"] = compact, _a), className);
  return React__default.createElement("div", __assign$1B({ ref, className: classNames, style }, rest), children);
});
Group$3.displayName = "InputGroup";
var Group$4 = Group$3;
var __assign$1A = globalThis && globalThis.__assign || function() {
  __assign$1A = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1A.apply(this, arguments);
};
var __read$1a = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var keepFocus$1 = function(e) {
  e.target.tagName !== "INPUT" && e.preventDefault();
};
var inputAddon = function(className, node, style, onClick) {
  if (style === void 0) {
    style = {};
  }
  return node ? React__default.createElement("span", { style, className, onClick }, node) : null;
};
function formatValue$1(value, maxLength) {
  var str = value !== null && !isUndefined(value) && !isString$1(value) ? String(value) : value || "";
  if (maxLength) {
    return str.slice(0, maxLength);
  }
  return str;
}
function Input$4(baseProps, ref) {
  var _a, _b, _c;
  var _d = useContext(ConfigContext), getPrefixCls = _d.getPrefixCls, ctxSize = _d.size, componentConfig2 = _d.componentConfig;
  var props = useMergeProps(baseProps, {}, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Input);
  var className = props.className, style = props.style, addBefore = props.addBefore, addAfter = props.addAfter, suffix = props.suffix, prefix = props.prefix, beforeStyle = props.beforeStyle, afterStyle = props.afterStyle, height = props.height, disabled = props.disabled, maxLength = props.maxLength, showWordLimit = props.showWordLimit, allowClear = props.allowClear;
  var trueMaxLength = isObject$e(maxLength) ? maxLength.length : maxLength;
  var mergedMaxLength = isObject$e(maxLength) && maxLength.errorOnly ? void 0 : trueMaxLength;
  var _e = __read$1a(useState(false), 2), focus = _e[0], setFocus2 = _e[1];
  var inputRef = useRef();
  var inputWrapperRef = useRef();
  var _f = __read$1a(useMergeValue("", {
    defaultValue: "defaultValue" in props ? formatValue$1(props.defaultValue, mergedMaxLength) : void 0,
    value: "value" in props ? formatValue$1(props.value, mergedMaxLength) : void 0
  }), 2), value = _f[0], setValue = _f[1];
  useImperativeHandle(ref, function() {
    return inputRef.current;
  }, []);
  var onChange = function(value2, e) {
    if (!("value" in props)) {
      setValue(value2);
    }
    props.onChange && props.onChange(value2, e);
  };
  var prefixCls2 = getPrefixCls("input");
  var size = props.size || ctxSize;
  var isCustomHeight = "height" in props;
  var suffixElement = suffix;
  var valueLength = value ? value.length : 0;
  var lengthError = useMemo(function() {
    if (!mergedMaxLength && trueMaxLength) {
      return valueLength > trueMaxLength;
    }
    return false;
  }, [valueLength, trueMaxLength, mergedMaxLength]);
  if (trueMaxLength && showWordLimit) {
    suffixElement = React__default.createElement("span", { className: cs$1(prefixCls2 + "-word-limit", (_a = {}, _a[prefixCls2 + "-word-limit-error"] = lengthError, _a)) }, valueLength, "/", trueMaxLength);
  }
  var classnames2 = cs$1(prefixCls2 + "-group-wrapper", prefixCls2 + "-group-wrapper-" + size, (_b = {}, _b[prefixCls2 + "-custom-height"] = isCustomHeight, _b[prefixCls2 + "-has-suffix"] = suffixElement, _b[prefixCls2 + "-group-wrapper-disabled"] = disabled, _b), className);
  var needWrapper = addBefore || addAfter || suffixElement || prefix;
  var inputElement = React__default.createElement(InputComponent$1, __assign$1A({ ref: inputRef }, props, { onFocus: function(e) {
    setFocus2(true);
    props.onFocus && props.onFocus(e);
  }, onBlur: function(e) {
    setFocus2(false);
    props.onBlur && props.onBlur(e);
  }, onChange, prefixCls: prefixCls2, value, hasParent: !!needWrapper || allowClear, size }));
  var innerWrapperClassnames = cs$1(prefixCls2 + "-inner-wrapper", (_c = {}, _c[prefixCls2 + "-inner-wrapper-error"] = props.error || lengthError, _c[prefixCls2 + "-inner-wrapper-disabled"] = disabled, _c[prefixCls2 + "-inner-wrapper-focus"] = focus, _c[prefixCls2 + "-inner-wrapper-has-prefix"] = prefix, _c[prefixCls2 + "-inner-wrapper-" + size] = size, _c[prefixCls2 + "-clear-wrapper"] = allowClear, _c));
  return needWrapper ? React__default.createElement("div", { className: classnames2, style: __assign$1A(__assign$1A({}, style), isCustomHeight ? { height } : {}) }, React__default.createElement("span", { className: prefixCls2 + "-group" }, inputAddon(prefixCls2 + "-group-addbefore", addBefore, beforeStyle), React__default.createElement("span", { className: innerWrapperClassnames, ref: inputWrapperRef, onMouseDown: function(e) {
    if (e.target.tagName !== "INPUT") {
      if (inputWrapperRef.current && contains(inputWrapperRef.current, e.target)) {
        e.preventDefault();
      }
    }
  }, onClick: function(e) {
    if (inputWrapperRef.current && contains(inputWrapperRef.current, e.target)) {
      inputRef.current && inputRef.current.focus();
    }
  } }, inputAddon(prefixCls2 + "-group-prefix", prefix), inputElement, inputAddon(prefixCls2 + "-group-suffix", suffixElement)), inputAddon(prefixCls2 + "-group-addafter", addAfter, afterStyle))) : allowClear ? React__default.createElement("span", { className: cs$1(className, innerWrapperClassnames), style: __assign$1A(__assign$1A({}, style), isCustomHeight ? { height } : {}), onMouseDown: keepFocus$1, onClick: function() {
    inputRef.current && inputRef.current.focus();
  } }, inputElement) : inputElement;
}
var InputElement = React__default.forwardRef(Input$4);
InputElement.displayName = "Input";
InputElement.Search = Search$1;
InputElement.TextArea = TextArea$1;
InputElement.Password = Password$1;
InputElement.Group = Group$4;
var Input$5 = InputElement;
var Portal$3 = function(props) {
  var getContainer = props.getContainer, children = props.children;
  var containerRef = useRef();
  var isFirstRender = useIsFirstRender();
  if (isFirstRender && !isServerRendering) {
    containerRef.current = getContainer();
  }
  useEffect(function() {
    return function() {
      var container2 = containerRef.current;
      if (container2 && container2.parentNode) {
        container2.parentNode.removeChild(container2);
      }
    };
  }, []);
  return containerRef.current ? ReactDOM.createPortal(children, containerRef.current) : null;
};
var Portal$4 = Portal$3;
var __assign$1z = globalThis && globalThis.__assign || function() {
  __assign$1z = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1z.apply(this, arguments);
};
function getElementPosition(element, elementRect, root2) {
  if (!root2 || !element || isServerRendering) {
    return { left: 0, width: 0, height: 0, top: 0 };
  }
  var bodyScroll = function(direction) {
    return document.documentElement[direction] || document.body[direction];
  };
  var pageScrollTop = root2 === document.body ? bodyScroll("scrollTop") : root2.scrollTop;
  var pageScrollLeft = root2 === document.body ? bodyScroll("scrollLeft") : root2.scrollLeft;
  var left = elementRect.left, top = elementRect.top, width = elementRect.width, height = elementRect.height;
  var rootLeft = root2 === document.body ? 0 : root2.getBoundingClientRect().left;
  var rootTop = root2 === document.body ? 0 : root2.getBoundingClientRect().top;
  var pTop = top + pageScrollTop - rootTop;
  var pLeft = left + pageScrollLeft - rootLeft;
  return {
    left: pLeft,
    top: pTop,
    width,
    height
  };
}
var getInsideValue = function(min, max, value) {
  if (value < min) {
    return min;
  }
  if (value > max) {
    return max;
  }
  return value;
};
var getPopupAlign = function(propsPopupAlign, showArrow) {
  var horizontalOffset = 0;
  var verticalOffset = 0;
  var resultPopupAlign = {};
  if (!showArrow) {
    resultPopupAlign = __assign$1z({}, propsPopupAlign);
  } else {
    resultPopupAlign = __assign$1z({ left: 12, right: 12, top: 12, bottom: 12 }, propsPopupAlign);
  }
  for (var key in resultPopupAlign) {
    if (isArray$c(resultPopupAlign[key])) {
      var index2 = 0;
      if (["top", "bottom"].indexOf(key) > -1) {
        index2 = 1;
        horizontalOffset = resultPopupAlign[key][0];
      } else {
        verticalOffset = resultPopupAlign[key][1];
      }
      resultPopupAlign[key] = resultPopupAlign[key][index2];
    }
  }
  return __assign$1z(__assign$1z({}, resultPopupAlign), { horizontalOffset, verticalOffset });
};
var getChildRect = function(child, mouseLocation) {
  return mouseLocation ? {
    left: mouseLocation.clientX,
    top: mouseLocation.clientY,
    width: 0,
    height: 0,
    right: mouseLocation.clientX,
    bottom: mouseLocation.clientY
  } : child.getBoundingClientRect();
};
var getStyle$1 = function(props, content, child, mountContainer, mouseLocation) {
  var autoAlignPopupWidth = props.autoAlignPopupWidth, autoAlignPopupMinWidth = props.autoAlignPopupMinWidth, alignPoint = props.alignPoint, propsStyle = props.style;
  if (!child || !content || !mountContainer) {
    return {};
  }
  var style = {};
  var childRect = getChildRect(child, alignPoint && mouseLocation);
  var _a = getElementPosition(child, childRect, mountContainer), left = _a.left, top = _a.top, width = _a.width, height = _a.height;
  var popupAlign = getPopupAlign(props.popupAlign, props.showArrow);
  var alignLeft = popupAlign.left || 0;
  var alignRight = popupAlign.right || 0;
  var alignTop = popupAlign.top || 0;
  var alignBottom = popupAlign.bottom || 0;
  if (autoAlignPopupWidth && (propsStyle === null || propsStyle === void 0 ? void 0 : propsStyle.width) === void 0) {
    content.style.width = child.offsetWidth + "px";
  }
  if (autoAlignPopupMinWidth) {
    content.style.minWidth = child.offsetWidth + "px";
  }
  var realPosition = props.position;
  var arrowStyle = {};
  var autoPosition = function(direction) {
    var _a2, _b;
    if (!props.autoFitPosition) {
      return;
    }
    var windowHeight = ((_a2 = document.documentElement) === null || _a2 === void 0 ? void 0 : _a2.clientHeight) || window.innerHeight;
    var windowWidth = ((_b = document.documentElement) === null || _b === void 0 ? void 0 : _b.clientWidth) || window.innerWidth;
    var result = false;
    var boundnary = {
      left: left - childRect.left,
      top: top - childRect.top
    };
    var _c = style.top, styleTop = _c === void 0 ? 0 : _c, _d = style.left, styleLeft = _d === void 0 ? 0 : _d;
    if (direction === "top" || direction === "bottom") {
      if (boundnary.left > styleLeft && childRect.right > 12) {
        style.left = Math.max(boundnary.left, left - content.clientWidth);
        style.left = Math.max(style.left, left - content.clientWidth + 24);
      } else if (styleLeft - boundnary.left + content.clientWidth > windowWidth && windowWidth - childRect.left > 12) {
        style.left = Math.max(boundnary.left, boundnary.left + windowWidth - content.clientWidth);
        style.left = Math.max(style.left, left - content.clientWidth + 24);
      }
    }
    if (direction === "left" || direction === "right") {
      if (boundnary.top > styleTop && childRect.bottom > 12) {
        style.top = boundnary.top;
        style.top = Math.max(style.top, top - content.clientHeight + childRect.height / 2);
      } else if (styleTop - boundnary.top + content.clientHeight > windowHeight && windowHeight - childRect.top > 12) {
        style.top = Math.max(boundnary.top, boundnary.top + windowHeight - content.clientHeight);
        style.top = Math.max(style.top, top - content.clientHeight + childRect.height / 2);
      }
    }
    if (direction === "top" && boundnary.top > styleTop) {
      if (childRect.top < windowHeight - childRect.bottom) {
        style.top = Math.min(top + height + (alignTop || 0), boundnary.top + windowHeight - content.clientHeight);
        result = true;
      } else {
        style.top = boundnary.top;
      }
    }
    if (direction === "bottom" && styleTop - boundnary.top + content.clientHeight > windowHeight) {
      if (windowHeight - childRect.bottom < childRect.top) {
        style.top = Math.max(top - content.clientHeight - (alignBottom || 0), boundnary.top);
        result = true;
      } else {
        style.top = boundnary.top + windowHeight - content.clientHeight;
      }
    }
    if (direction === "left" && boundnary.left > styleLeft) {
      if (childRect.left < windowWidth - childRect.right) {
        style.left = Math.min(width + left + alignRight, boundnary.left + windowWidth - content.clientWidth);
        result = true;
      } else {
        style.left = boundnary.left;
      }
    }
    if (direction === "right" && styleLeft - boundnary.left + content.clientWidth > windowWidth) {
      if (windowWidth - childRect.right < childRect.left) {
        style.left = Math.max(left - content.clientWidth - alignLeft, boundnary.left);
        result = true;
      } else {
        style.left = boundnary.left + windowWidth - content.clientWidth;
      }
    }
    if (style.left < 0) {
      style.left = 0;
    } else {
      var maxLeft = mountContainer.scrollWidth - content.clientWidth;
      style.left = Math.min(maxLeft, style.left);
    }
    return result;
  };
  var horizontalOffset = popupAlign.horizontalOffset || 0;
  var verticalOffset = popupAlign.verticalOffset || 0;
  switch (props.position) {
    case "top": {
      style.top = top - content.clientHeight - alignTop;
      style.left = left + width / 2 - content.clientWidth / 2;
      autoPosition("top") && (realPosition = "bottom");
      style.left += horizontalOffset;
      var arrowLeft_1 = left - Number(style.left) + width / 2;
      arrowStyle.left = getInsideValue(12, content.clientWidth - 12, arrowLeft_1);
      break;
    }
    case "tl":
      style.top = top - content.clientHeight - alignTop;
      style.left = left;
      autoPosition("top") && (realPosition = "bl");
      style.left += horizontalOffset;
      var arrowLeft = left - Number(style.left) + Math.min(width / 2, 50);
      arrowStyle.left = getInsideValue(12, content.clientWidth - 12, arrowLeft);
      break;
    case "tr":
      style.top = -content.clientHeight + top - alignTop;
      style.left = left + width - content.clientWidth;
      autoPosition("top") && (realPosition = "br");
      style.left += horizontalOffset;
      arrowLeft = left - Number(style.left) + Math.max(width / 2, width - 50);
      arrowStyle.left = getInsideValue(12, content.clientWidth - 12, arrowLeft);
      break;
    case "bottom": {
      style.top = height + top + alignBottom;
      style.left = left + width / 2 - content.clientWidth / 2;
      autoPosition("bottom") && (realPosition = "top");
      style.left += horizontalOffset;
      var arrowLeft_2 = left - Number(style.left) + width / 2;
      arrowStyle.left = getInsideValue(12, content.clientWidth - 12, arrowLeft_2);
      break;
    }
    case "bl":
      style.top = height + top + alignBottom;
      style.left = left;
      autoPosition("bottom") && (realPosition = "tl");
      style.left += horizontalOffset;
      arrowLeft = left - Number(style.left) + Math.min(width / 2, 50);
      arrowStyle.left = getInsideValue(12, content.clientWidth - 12, arrowLeft);
      break;
    case "br":
      style.top = height + top + alignBottom;
      style.left = left + width - content.clientWidth;
      autoPosition("bottom") && (realPosition = "tr");
      style.left += horizontalOffset;
      arrowLeft = left - Number(style.left) + Math.max(width / 2, width - 50);
      arrowStyle.left = getInsideValue(12, content.clientWidth - 12, arrowLeft);
      break;
    case "left": {
      style.top = top + height / 2 - content.clientHeight / 2;
      style.left = left - content.clientWidth - alignLeft;
      autoPosition("left") && (realPosition = "right");
      style.top += verticalOffset;
      var arrowTop_1 = top - Number(style.top) + height / 2;
      arrowStyle.top = getInsideValue(12, content.clientHeight - 12, arrowTop_1);
      break;
    }
    case "lt":
      style.top = top;
      style.left = left - content.clientWidth - alignLeft;
      autoPosition("left") && (realPosition = "rt");
      style.top += verticalOffset;
      var arrowTop = top - Number(style.top) + Math.min(height / 2, 50);
      arrowStyle.top = getInsideValue(12, content.clientHeight - 12, arrowTop);
      break;
    case "lb":
      style.top = top + height - content.clientHeight;
      style.left = left - content.clientWidth - alignLeft;
      autoPosition("left") && (realPosition = "rb");
      style.top += verticalOffset;
      arrowTop = top - Number(style.top) + Math.max(height / 2, height - 50);
      arrowStyle.top = getInsideValue(12, content.clientHeight - 12, arrowTop);
      break;
    case "right": {
      style.top = top + height / 2 - content.clientHeight / 2;
      style.left = width + left + alignRight;
      autoPosition("right") && (realPosition = "left");
      style.top += verticalOffset;
      var arrowTop_2 = top - Number(style.top) + height / 2;
      arrowStyle.top = getInsideValue(12, content.clientHeight - 12, arrowTop_2);
      break;
    }
    case "rt":
      style.top = top;
      style.left = width + left + alignRight;
      autoPosition("right") && (realPosition = "lt");
      style.top += verticalOffset;
      arrowTop = top - Number(style.top) + Math.min(height / 2, 50);
      arrowStyle.top = getInsideValue(12, content.clientHeight - 12, arrowTop);
      break;
    case "rb":
      style.top = top + height - content.clientHeight;
      style.left = width + left + alignRight;
      autoPosition("right") && (realPosition = "lb");
      style.top += verticalOffset;
      arrowTop = top - Number(style.top) + Math.max(height / 2, height - 50);
      arrowStyle.top = getInsideValue(12, content.clientHeight - 12, arrowTop);
      break;
  }
  return {
    style,
    arrowStyle,
    realPosition
  };
};
var __assign$1y = globalThis && globalThis.__assign || function() {
  __assign$1y = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1y.apply(this, arguments);
};
function mergeProps(componentProps, defaultProps2, globalComponentConfig) {
  var _defaultProps = __assign$1y(__assign$1y({}, defaultProps2), globalComponentConfig);
  var props = __assign$1y({}, componentProps);
  for (var propName in _defaultProps) {
    if (props[propName] === void 0) {
      props[propName] = _defaultProps[propName];
    }
  }
  return props;
}
var __extends$6 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$1x = globalThis && globalThis.__assign || function() {
  __assign$1x = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1x.apply(this, arguments);
};
function getDOMPos(dom) {
  if (!dom) {
    return {};
  }
  var _a = dom.getBoundingClientRect(), width = _a.width, height = _a.height, left = _a.left, right = _a.right;
  return {
    width,
    height,
    left,
    right
  };
}
var EventsByTriggerNeed = [
  "onClick",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onFocus",
  "onBlur",
  "onContextMenu",
  "onKeyDown"
];
function splitChildrenStyle(obj, keys2) {
  var picked = {};
  var omitted = __assign$1x({}, obj);
  keys2.forEach(function(key) {
    if (obj && key in obj) {
      picked[key] = obj[key];
      delete omitted[key];
    }
  });
  return { picked, omitted };
}
var defaultProps$v = {
  blurToHide: true,
  clickToClose: true,
  classNames: "fadeIn",
  trigger: "hover",
  position: "bottom",
  duration: 200,
  unmountOnExit: true,
  popupAlign: {},
  popupHoverStay: true,
  clickOutsideToClose: true,
  escToClose: false,
  mouseLeaveToClose: true,
  containerScrollToClose: false,
  getDocument: function() {
    return window.document;
  },
  autoFixPosition: true,
  mouseEnterDelay: 100,
  mouseLeaveDelay: 100,
  autoFitPosition: true
};
var Trigger = function(_super) {
  __extends$6(Trigger2, _super);
  function Trigger2(props, context) {
    var _this = _super.call(this, props, context) || this;
    _this.delayTimer = null;
    _this.updatePositionTimer = null;
    _this.popupOpen = false;
    _this.mousedownToHide = false;
    _this.hasPopupMouseDown = false;
    _this.unmount = false;
    _this.mouseLocation = {
      clientX: 0,
      clientY: 0
    };
    _this.observerContainer = null;
    _this.scrollElements = null;
    _this.resizeObserver = new index$1(function() {
      _this.handleUpdatePosition();
    });
    _this.childrenDom = null;
    _this.childrenDomSize = {};
    _this.getMergedProps = function(baseProps) {
      var componentConfig2 = _this.context.componentConfig;
      var props2 = mergeProps(baseProps || _this.props, defaultProps$v, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Trigger);
      return props2;
    };
    _this.getRootElement = function() {
      return findDOMNode(_this);
    };
    _this.isDidMount = false;
    _this.offScrollListeners = function() {
      (_this.scrollElements || []).forEach(function(item2) {
        off(item2, "scroll", _this.handleScroll);
      });
      _this.scrollElements = null;
    };
    _this.offWindowResize = function() {
      _this.handleWindowResize = false;
      off(window, "resize", _this.handleUpdatePosition);
    };
    _this.offContainerResize = function() {
      if (_this.resizeObserver && _this.observerContainer) {
        _this.resizeObserver.unobserve(_this.observerContainer);
        _this.observerContainer = null;
      }
    };
    _this.handleScroll = function() {
      var currentProps = _this.getMergedProps();
      if (currentProps.containerScrollToClose) {
        _this.setPopupVisible(false);
      } else if (currentProps.updateOnScroll) {
        _this.handleUpdatePosition();
      }
    };
    _this.onContainersScroll = function() {
      var _a;
      if (_this.scrollElements) {
        return;
      }
      _this.scrollElements = getScrollElements(_this.childrenDom, (_a = _this.popupContainer) === null || _a === void 0 ? void 0 : _a.parentNode);
      _this.scrollElements.forEach(function(item2) {
        on(item2, "scroll", _this.handleScroll);
      });
    };
    _this.onContainerResize = function() {
      var _a;
      var containerParent = (_a = _this.popupContainer) === null || _a === void 0 ? void 0 : _a.parentNode;
      if (_this.resizeObserver && _this.observerContainer !== containerParent) {
        _this.offContainerResize();
        containerParent && _this.resizeObserver.observe(containerParent);
        _this.observerContainer = containerParent;
      }
    };
    _this.handleUpdatePosition = throttleByRaf(function() {
      _this.updatePopupPosition();
    });
    _this.isClickTrigger = function() {
      var trigger = _this.getMergedProps().trigger;
      return [].concat(trigger).indexOf("click") > -1;
    };
    _this.isFocusTrigger = function() {
      var trigger = _this.getMergedProps().trigger;
      return [].concat(trigger).indexOf("focus") > -1;
    };
    _this.isHoverTrigger = function() {
      var trigger = _this.getMergedProps().trigger;
      return [].concat(trigger).indexOf("hover") > -1;
    };
    _this.isContextMenuTrigger = function() {
      var trigger = _this.getMergedProps().trigger;
      return [].concat(trigger).indexOf("contextMenu") > -1;
    };
    _this.isMouseLeaveToClose = function() {
      return _this.isHoverTrigger() && _this.getMergedProps().mouseLeaveToClose;
    };
    _this.isPopupHoverHide = function() {
      return _this.isHoverTrigger() && !_this.getMergedProps().popupHoverStay;
    };
    _this.isClickToHide = function() {
      return (_this.isClickTrigger() || _this.isContextMenuTrigger()) && _this.getMergedProps().clickToClose;
    };
    _this.isBlurToHide = function() {
      return _this.isFocusTrigger() && _this.getMergedProps().blurToHide;
    };
    _this.clearTimer = function() {
      if (_this.updatePositionTimer) {
        if (_this.updatePositionTimer.cancel) {
          _this.updatePositionTimer.cancel();
        } else {
          clearTimeout(_this.updatePositionTimer);
          _this.updatePositionTimer = null;
        }
      }
      if (_this.delayTimer) {
        clearTimeout(_this.delayTimer);
        _this.delayTimer = null;
      }
      if (_this.mouseDownTimeout) {
        clearTimeout(_this.mouseDownTimeout);
        _this.mouseDownTimeout = null;
      }
    };
    _this.offClickOutside = function() {
      if (_this.handleClickOutside) {
        var getDocument = _this.getMergedProps().getDocument;
        var root2 = isFunction$5(getDocument) && getDocument();
        off(root2, "mousedown", _this.onClickOutside);
        _this.handleClickOutside = false;
      }
    };
    _this.getTransformOrigin = function(position) {
      var _a, _b;
      var content = findDOMNode(_this.triggerRef);
      if (!content)
        return {};
      var _c = _this.getMergedProps(), showArrow = _c.showArrow, classNames = _c.classNames;
      var top = showArrow && ((_a = _this.arrowStyle) === null || _a === void 0 ? void 0 : _a.top) || 0;
      var left = showArrow && ((_b = _this.arrowStyle) === null || _b === void 0 ? void 0 : _b.left) || 0;
      top = top ? top + "px" : "";
      left = left ? left + "px" : "";
      var transformOrigin = {
        top: (left || "50%") + " 100% 0",
        tl: (left || "15px") + " 100% 0",
        tr: (left || content.clientWidth - 15 + "px") + " 100% 0",
        bottom: (left || "50%") + " 0 0",
        bl: (left || "15px") + " 0 0",
        br: (left || content.clientWidth - 15 + "px") + " 0 0",
        left: "100% " + (top || "50%") + " 0",
        lt: "100% " + (top || "15px") + " 0",
        lb: "100% " + (top || content.clientHeight - 15 + "px") + " 0",
        right: "0 " + (top || "50%") + " 0",
        rt: "0 " + (top || "15px") + " 0",
        rb: "0 " + (top || content.clientHeight - 15 + "px") + " 0"
      };
      if (classNames && classNames.indexOf("zoom") > -1) {
        return {
          transformOrigin: transformOrigin[position]
        };
      }
      if (classNames === "slideDynamicOrigin") {
        var origin_1 = "0% 0%";
        if (["top", "tl", "tr"].indexOf(position) > -1) {
          origin_1 = "100% 100%";
        }
        return {
          transformOrigin: origin_1
        };
      }
      return {};
    };
    _this.getTransformTranslate = function() {
      if (_this.getMergedProps().classNames !== "slideDynamicOrigin") {
        return "";
      }
      switch (_this.realPosition) {
        case "bottom":
        case "bl":
        case "br":
          return "scaleY(0.9) translateY(-4px)";
        case "top":
        case "tl":
        case "tr":
          return "scaleY(0.9) translateY(4px)";
        default:
          return "";
      }
    };
    _this.getPopupStyle = function() {
      if (_this.unmount || !_this.popupContainer) {
        return;
      }
      var mountContainer = _this.popupContainer;
      var content = findDOMNode(_this.triggerRef);
      var child = findDOMNode(_this);
      var _a = getStyle$1(_this.getMergedProps(), content, child, mountContainer, _this.mouseLocation), style = _a.style, arrowStyle = _a.arrowStyle, realPosition = _a.realPosition;
      _this.realPosition = realPosition || _this.getMergedProps().position;
      _this.arrowStyle = arrowStyle || {};
      return __assign$1x(__assign$1x({}, style), _this.getTransformOrigin(_this.realPosition));
    };
    _this.showPopup = function(callback) {
      if (callback === void 0) {
        callback = function() {
        };
      }
      var popupStyle = _this.getPopupStyle();
      _this.setState({
        popupStyle
      }, callback);
    };
    _this.update = throttleByRaf(function(callback) {
      if (_this.unmount || !_this.state.popupVisible) {
        return;
      }
      var popupStyle = _this.getPopupStyle();
      _this.setState({
        popupStyle
      }, function() {
        callback && callback();
      });
    });
    _this.updatePopupPosition = function(delay, callback) {
      if (delay === void 0) {
        delay = 0;
      }
      var currentVisible = _this.state.popupVisible;
      if (!currentVisible) {
        return;
      }
      if (delay < 4) {
        _this.updatePositionTimer = _this.update(callback);
        return;
      }
      _this.updatePositionTimer = setTimeout(function() {
        var popupStyle = _this.getPopupStyle();
        _this.setState({
          popupStyle
        }, function() {
          callback && callback();
        });
      }, delay);
    };
    _this.setPopupVisible = function(visible, delay, callback) {
      if (delay === void 0) {
        delay = 0;
      }
      var mergedProps2 = _this.getMergedProps();
      var onVisibleChange = mergedProps2.onVisibleChange;
      var currentVisible = _this.state.popupVisible;
      if (visible !== currentVisible) {
        _this.delayToDo(delay, function() {
          onVisibleChange && onVisibleChange(visible);
          if (!("popupVisible" in mergedProps2)) {
            if (visible) {
              _this.setState({
                popupVisible: true
              }, function() {
                _this.showPopup(callback);
              });
            } else {
              _this.setState({
                popupVisible: false
              }, function() {
                callback && callback();
              });
            }
          } else {
            callback && callback();
          }
        });
      } else {
        callback && callback();
      }
    };
    _this.delayToDo = function(delay, callback) {
      if (delay) {
        _this.clearDelayTimer();
        _this.delayTimer = setTimeout(function() {
          callback();
          _this.clearDelayTimer();
        }, delay);
      } else {
        callback();
      }
    };
    _this.onClickOutside = function(e) {
      var _a = _this.getMergedProps(), onClickOutside = _a.onClickOutside, clickOutsideToClose = _a.clickOutsideToClose;
      var triggerNode = findDOMNode(_this.triggerRef);
      var childrenDom = findDOMNode(_this);
      if (!contains(triggerNode, e.target) && !contains(childrenDom, e.target) && !_this.hasPopupMouseDown) {
        onClickOutside && onClickOutside();
        if (clickOutsideToClose) {
          if (!_this.isBlurToHide() && !_this.isHoverTrigger()) {
            _this.setPopupVisible(false);
          }
        }
      }
    };
    _this.onKeyDown = function(e) {
      var keyCode = e.keyCode || e.which;
      _this.triggerPropsEvent("onKeyDown", e);
      if (keyCode === Esc.code) {
        _this.onPressEsc(e);
      }
    };
    _this.onPressEsc = function(e) {
      var escToClose = _this.getMergedProps().escToClose;
      if (escToClose && e && e.key === Esc.key && _this.state.popupVisible) {
        _this.setPopupVisible(false);
      }
    };
    _this.onMouseEnter = function(e) {
      var mouseEnterDelay = _this.getMergedProps().mouseEnterDelay;
      _this.triggerPropsEvent("onMouseEnter", e);
      _this.clearDelayTimer();
      _this.setPopupVisible(true, mouseEnterDelay || 0);
    };
    _this.onMouseMove = function(e) {
      _this.triggerPropsEvent("onMouseMove", e);
      _this.setMouseLocation(e);
      if (_this.state.popupVisible) {
        _this.update();
      }
    };
    _this.onMouseLeave = function(e) {
      var mouseLeaveDelay = _this.getMergedProps().mouseLeaveDelay;
      _this.clearDelayTimer();
      _this.triggerPropsEvent("onMouseLeave", e);
      if (_this.isMouseLeaveToClose()) {
        if (_this.state.popupVisible) {
          _this.setPopupVisible(false, mouseLeaveDelay || 0);
        }
      }
    };
    _this.onPopupMouseEnter = function() {
      _this.clearDelayTimer();
    };
    _this.onPopupMouseLeave = function(e) {
      _this.onMouseLeave(e);
    };
    _this.setMouseLocation = function(e) {
      if (_this.getMergedProps().alignPoint) {
        _this.mouseLocation = {
          clientX: e.clientX,
          clientY: e.clientY
        };
      }
    };
    _this.onContextMenu = function(e) {
      e.preventDefault();
      _this.triggerPropsEvent("onContextMenu", e);
      _this.setMouseLocation(e);
      if (!_this.state.popupVisible) {
        _this.setPopupVisible(true, 0);
      } else {
        _this.getMergedProps().alignPoint && _this.update();
      }
    };
    _this.hideContextMenu = function(e) {
      var popupVisible2 = _this.state.popupVisible;
      if (popupVisible2) {
        _this.mousedownToHide = true;
      }
      _this.triggerPropsEvent("onClick", e);
      if (_this.isClickToHide() && popupVisible2) {
        _this.setPopupVisible(!popupVisible2, 0);
      }
    };
    _this.onClick = function(e) {
      var popupVisible2 = _this.state.popupVisible;
      if (popupVisible2) {
        _this.mousedownToHide = true;
      }
      _this.triggerPropsEvent("onClick", e);
      _this.setMouseLocation(e);
      if (!_this.isClickToHide() && popupVisible2) {
        return;
      }
      _this.setPopupVisible(!popupVisible2, 0);
    };
    _this.onFocus = function(e) {
      var focusDelay = _this.getMergedProps().focusDelay;
      var onFocus3 = function() {
        _this.triggerPropsEvent("onFocus", e);
      };
      _this.clearDelayTimer();
      if (!_this.mousedownToHide) {
        if (_this.state.popupVisible) {
          onFocus3 && onFocus3();
        } else {
          _this.setPopupVisible(true, focusDelay || 0, onFocus3);
        }
      }
      _this.mousedownToHide = false;
    };
    _this.onBlur = function(e) {
      _this.setPopupVisible(false, 200, function() {
        return _this.triggerPropsEvent("onBlur", e);
      });
    };
    _this.onResize = function() {
      if (_this.getMergedProps().autoFixPosition && _this.state.popupVisible) {
        _this.updatePopupPosition();
      }
    };
    _this.onPopupMouseDown = function() {
      _this.hasPopupMouseDown = true;
      clearTimeout(_this.mouseDownTimeout);
      _this.mouseDownTimeout = setTimeout(function() {
        _this.hasPopupMouseDown = false;
      }, 0);
    };
    _this.getChild = function() {
      var children = _this.props.children;
      var element = children;
      var elementType = element && typeof element !== "string" && element.type;
      var child = children;
      if (["string", "number"].indexOf(typeof children) > -1 || React__default.Children.count(children) > 1) {
        child = React__default.createElement("span", null, children);
      } else if (element && elementType && (elementType.__BYTE_BUTTON === true || elementType.__BYTE_CHECKBOX === true || elementType.__BYTE_SWITCH === true || elementType.__BYTE_RADIO === true || elementType === "button") && element.props.disabled) {
        var _a = splitChildrenStyle(element.props.style, [
          "position",
          "left",
          "right",
          "top",
          "bottom",
          "float",
          "display",
          "zIndex"
        ]), picked = _a.picked, omitted = _a.omitted;
        child = React__default.createElement("span", { className: element.props.className, style: __assign$1x(__assign$1x({ display: "inline-block" }, picked), { cursor: "not-allowed" }) }, React__default.cloneElement(element, {
          style: __assign$1x(__assign$1x({}, omitted), { pointerEvents: "none" }),
          className: void 0
        }));
      }
      return child || React__default.createElement("span", null);
    };
    _this.appendToContainer = function(node) {
      caf(_this.rafId);
      if (_this.isDidMount) {
        var getGlobalPopupContainer = _this.context.getPopupContainer;
        var getPopupContainer = _this.getMergedProps().getPopupContainer;
        var gpc = getPopupContainer || getGlobalPopupContainer;
        var rootElement = _this.getRootElement();
        var parent_1 = gpc(rootElement);
        if (parent_1) {
          parent_1.appendChild(node);
          return;
        }
      }
      _this.rafId = raf(function() {
        _this.appendToContainer(node);
      });
    };
    _this.getContainer = function() {
      var popupContainer = document.createElement("div");
      popupContainer.style.width = "100%";
      popupContainer.style.position = "absolute";
      popupContainer.style.top = "0";
      popupContainer.style.left = "0";
      _this.popupContainer = popupContainer;
      _this.appendToContainer(popupContainer);
      return popupContainer;
    };
    _this.triggerPropsEvent = function(eventName, e) {
      var child = _this.getChild();
      var childHandler = child && child.props && child.props[eventName];
      var props2 = _this.getMergedProps();
      if (isFunction$5(childHandler)) {
        childHandler(e);
      }
      if (isFunction$5(props2[eventName])) {
        props2[eventName](e);
      }
    };
    _this.triggerOriginEvent = function(eventName) {
      var child = _this.getChild();
      var childHandler = child && child.props && child.props[eventName];
      var propsHandler = _this.getMergedProps()[eventName];
      if (isFunction$5(propsHandler) && isFunction$5(childHandler)) {
        return function(e) {
          childHandler(e);
          propsHandler(e);
        };
      }
      return childHandler || propsHandler;
    };
    var mergedProps = _this.getMergedProps(props);
    var popupVisible = "popupVisible" in mergedProps ? mergedProps.popupVisible : mergedProps.defaultPopupVisible;
    _this.popupOpen = !!popupVisible;
    _this.state = {
      popupVisible: !!popupVisible,
      popupStyle: {}
    };
    return _this;
  }
  Trigger2.getDerivedStateFromProps = function(nextProps, state) {
    if ("popupVisible" in nextProps && nextProps.popupVisible !== state.popupVisible) {
      return {
        popupVisible: nextProps.popupVisible
      };
    }
    return null;
  };
  Trigger2.prototype.componentDidMount = function() {
    this.componentDidUpdate(this.getMergedProps());
    this.isDidMount = true;
    this.childrenDom = findDOMNode(this);
    if (this.state.popupVisible) {
      this.childrenDomSize = getDOMPos(this.childrenDom);
    }
  };
  Trigger2.prototype.componentDidUpdate = function(_prevProps) {
    var prevProps = this.getMergedProps(_prevProps);
    var currentProps = this.getMergedProps();
    if (!prevProps.popupVisible && currentProps.popupVisible) {
      this.update();
    }
    var popupVisible = this.state.popupVisible;
    this.popupOpen = popupVisible;
    var getDocument = currentProps.getDocument;
    if (!popupVisible) {
      this.offClickOutside();
      this.offContainerResize();
      this.offWindowResize();
      this.offScrollListeners();
      return;
    }
    var rect = getDOMPos(this.childrenDom);
    if (JSON.stringify(rect) !== JSON.stringify(this.childrenDomSize)) {
      this.updatePopupPosition();
      this.childrenDomSize = rect;
    }
    this.onContainerResize();
    if (currentProps.updateOnScroll || currentProps.containerScrollToClose) {
      this.onContainersScroll();
    }
    if (!this.handleWindowResize) {
      on(window, "resize", this.handleUpdatePosition);
      this.handleWindowResize = true;
    }
    if (!this.handleClickOutside) {
      var root2 = isFunction$5(getDocument) && getDocument();
      if (root2) {
        on(root2, "mousedown", this.onClickOutside);
        this.handleClickOutside = true;
      }
    }
  };
  Trigger2.prototype.componentWillUnmount = function() {
    this.unmount = true;
    this.offClickOutside();
    this.clearTimer();
    this.offWindowResize();
    this.offScrollListeners();
    this.offContainerResize();
    caf(this.rafId);
  };
  Trigger2.prototype.clearDelayTimer = function() {
    if (this.delayTimer) {
      clearTimeout(this.delayTimer);
      this.delayTimer = null;
    }
  };
  Trigger2.prototype.render = function() {
    var _a, _b;
    var _this = this;
    var _c;
    var _d = this.getMergedProps(), children = _d.children, style = _d.style, className = _d.className, arrowProps = _d.arrowProps, disabled = _d.disabled, popup = _d.popup, classNames = _d.classNames, duration2 = _d.duration, unmountOnExit = _d.unmountOnExit, alignPoint = _d.alignPoint, autoAlignPopupWidth = _d.autoAlignPopupWidth, position = _d.position, childrenPrefix = _d.childrenPrefix, showArrow = _d.showArrow, dropdownPopupStyle = _d.popupStyle;
    var isExistChildren = children || children === 0;
    var _e = this.context, getPrefixCls = _e.getPrefixCls, zIndex = _e.zIndex;
    var _f = this.state, popupVisible = _f.popupVisible, popupStyle = _f.popupStyle;
    if (!popup) {
      return null;
    }
    var mergeProps2 = {};
    var popupEventProps = {
      onMouseDown: this.onPopupMouseDown
    };
    if (this.isHoverTrigger() && !disabled) {
      mergeProps2.onMouseEnter = this.onMouseEnter;
      mergeProps2.onMouseLeave = this.onMouseLeave;
      if (alignPoint) {
        mergeProps2.onMouseMove = this.onMouseMove;
      }
      if (!this.isPopupHoverHide()) {
        popupEventProps.onMouseEnter = this.onPopupMouseEnter;
        popupEventProps.onMouseLeave = this.onPopupMouseLeave;
      }
    } else {
      mergeProps2.onMouseEnter = this.triggerOriginEvent("onMouseEnter");
      mergeProps2.onMouseLeave = this.triggerOriginEvent("onMouseLeave");
    }
    if (this.isContextMenuTrigger() && !disabled) {
      mergeProps2.onContextMenu = this.onContextMenu;
      mergeProps2.onClick = this.hideContextMenu;
    } else {
      mergeProps2.onContextMenu = this.triggerOriginEvent("onContextMenu");
    }
    if (this.isClickTrigger() && !disabled) {
      mergeProps2.onClick = this.onClick;
    } else {
      mergeProps2.onClick = mergeProps2.onClick || this.triggerOriginEvent("onClick");
    }
    if (this.isFocusTrigger() && !disabled) {
      mergeProps2.onFocus = this.onFocus;
      if (this.isBlurToHide()) {
        mergeProps2.onBlur = this.onBlur;
      }
    } else {
      mergeProps2.onFocus = this.triggerOriginEvent("onFocus");
      mergeProps2.onBlur = this.triggerOriginEvent("onBlur");
    }
    if (!disabled) {
      mergeProps2.onKeyDown = this.onKeyDown;
    } else {
      mergeProps2.onKeyDown = this.triggerOriginEvent("onKeyDown");
    }
    var child = this.getChild();
    var popupChildren = React__default.Children.only(popup());
    if (child.props.className) {
      mergeProps2.className = child.props.className;
    }
    if (childrenPrefix && popupVisible) {
      mergeProps2.className = mergeProps2.className ? mergeProps2.className + " " + childrenPrefix + "-open" : childrenPrefix + "-open";
    }
    if (this.isFocusTrigger()) {
      mergeProps2.tabIndex = disabled ? -1 : 0;
    }
    var prefixCls2 = getPrefixCls("trigger");
    var popupClassName = cs$1(prefixCls2, childrenPrefix, prefixCls2 + "-position-" + position, className);
    var childrenComponent = isExistChildren && React__default.createElement(ResizeObserver, { onResize: this.onResize }, React__default.cloneElement(child, __assign$1x({}, mergeProps2)));
    var portalContent = React__default.createElement(CSSTransition$1, { in: !!popupVisible, timeout: duration2, classNames, unmountOnExit, appear: true, mountOnEnter: true, onEnter: function(e) {
      e.style.display = "initial";
      e.style.pointerEvents = "none";
      if (classNames === "slideDynamicOrigin") {
        e.style.transform = _this.getTransformTranslate();
      }
    }, onEntering: function(e) {
      if (classNames === "slideDynamicOrigin") {
        e.style.transform = "";
      }
    }, onEntered: function(e) {
      e.style.pointerEvents = "auto";
      _this.forceUpdate();
    }, onExit: function(e) {
      e.style.pointerEvents = "none";
    }, onExited: function(e) {
      e.style.display = "none";
      if (unmountOnExit) {
        _this.triggerRef = null;
      }
      _this.setState({ popupStyle: {} });
    } }, React__default.createElement(ResizeObserver, { onResize: this.onResize }, React__default.createElement("span", __assign$1x({ ref: function(node) {
      return _this.triggerRef = node;
    }, "trigger-placement": this.realPosition, style: __assign$1x(__assign$1x(__assign$1x({ width: autoAlignPopupWidth && (style === null || style === void 0 ? void 0 : style.width) === void 0 ? (_c = this.childrenDomSize) === null || _c === void 0 ? void 0 : _c.width : "" }, popupStyle), { position: "absolute", zIndex: zIndex || "" }), style) }, popupEventProps, { className: popupClassName }), React__default.createElement(popupChildren.type, __assign$1x({ ref: popupChildren.ref }, popupChildren.props, { style: __assign$1x(__assign$1x({}, popupChildren.props.style), dropdownPopupStyle) })), (showArrow || arrowProps) && React__default.createElement("div", { className: cs$1(prefixCls2 + "-arrow-container", (_a = {}, _a[childrenPrefix + "-arrow-container"] = childrenPrefix, _a)) }, React__default.createElement("div", __assign$1x({}, arrowProps, { className: cs$1(prefixCls2 + "-arrow", (_b = {}, _b[childrenPrefix + "-arrow"] = childrenPrefix, _b), arrowProps === null || arrowProps === void 0 ? void 0 : arrowProps.className), style: __assign$1x(__assign$1x({}, this.arrowStyle), arrowProps === null || arrowProps === void 0 ? void 0 : arrowProps.style) }))))));
    var portal = popupVisible || this.triggerRef ? React__default.createElement(Portal$4, { getContainer: this.getContainer }, portalContent) : null;
    return isExistChildren ? React__default.createElement(React__default.Fragment, null, childrenComponent, portal) : portal;
  };
  Trigger2.displayName = "Trigger";
  Trigger2.contextType = ConfigContext;
  return Trigger2;
}(PureComponent);
var Trigger$1 = Trigger;
var __assign$1w = globalThis && globalThis.__assign || function() {
  __assign$1w = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1w.apply(this, arguments);
};
var __rest$K = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function OptGroup(props, ref) {
  var prefixCls2 = props.prefixCls, label = props.label, rest = __rest$K(props, ["prefixCls", "label"]);
  return React__default.createElement("li", __assign$1w({ ref, className: prefixCls2 + "-group-title" }, omit$1(rest, ["_key", "children", "isSelectOptGroup"])), label);
}
var OptGroupComponent = React__default.forwardRef(OptGroup);
OptGroupComponent.defaultProps = {
  isSelectOptGroup: true
};
var OptGroup$1 = OptGroupComponent;
var __read$19 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$v = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var CheckboxGroupContext = createContext({
  isCheckboxGroup: false,
  checkboxGroupValue: [],
  onGroupChange: function() {
  },
  registerValue: function() {
  },
  unRegisterValue: function() {
  }
});
function Group$2(props) {
  var _a;
  var _b = __read$19(useMergeValue([], {
    defaultValue: "defaultValue" in props ? props.defaultValue || [] : void 0,
    value: "value" in props ? props.value || [] : void 0
  }), 2), value = _b[0], setValue = _b[1];
  var _c = __read$19(useState([]), 2), allOptionValues = _c[0], setAllOptionValues = _c[1];
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var disabled = props.disabled, options2 = props.options, style = props.style, className = props.className, error2 = props.error, children = props.children, _d = props.direction, direction = _d === void 0 ? "horizontal" : _d;
  var prefixCls2 = getPrefixCls("checkbox");
  var classNames = cs$1(prefixCls2 + "-group", (_a = {}, _a[prefixCls2 + "-group-is-error"] = error2, _a[prefixCls2 + "-group-direction-" + direction] = direction, _a), className);
  var onChange = useCallback(function(optionValue, checked, e) {
    var newVal = value.slice();
    if (checked) {
      newVal.push(optionValue);
    } else {
      newVal.splice(value.indexOf(optionValue), 1);
    }
    setValue(newVal);
    props.onChange && props.onChange(newVal.filter(function(v) {
      return allOptionValues.indexOf(v) > -1;
    }), e);
  }, [value, props.onChange, allOptionValues]);
  return React__default.createElement("span", { className: classNames, style }, React__default.createElement(CheckboxGroupContext.Provider, { value: {
    isCheckboxGroup: true,
    checkboxGroupValue: value,
    onGroupChange: onChange,
    disabled,
    registerValue: function(value2) {
      setAllOptionValues(function(allOptionValues2) {
        return Array.from(new Set(__spreadArray$v(__spreadArray$v([], __read$19(allOptionValues2), false), [value2], false)));
      });
    },
    unRegisterValue: function(value2) {
      setAllOptionValues(function(allOptionValues2) {
        return allOptionValues2.filter(function(x) {
          return x !== value2;
        });
      });
    }
  } }, isArray$c(options2) ? options2.map(function(option) {
    var label = isObject$e(option) ? option.label : option;
    var checkValue = isObject$e(option) ? option.value : option;
    return React__default.createElement(Checkbox$1, { disabled: disabled || isObject$e(option) && option.disabled, key: checkValue, value: checkValue }, label);
  }) : children));
}
Group$2.displayName = "CheckboxGroup";
var __read$18 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$u = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var useCheckbox = function(values2, defaultSelected) {
  var _a = __read$18(useState(__spreadArray$u([], __read$18(defaultSelected || []), false)), 2), selected = _a[0], setSelected = _a[1];
  var _b = useMemo(function() {
    var isSelected2 = function(value) {
      return selected.indexOf(value) > -1;
    };
    var setValueSelected2 = function(value, selectStatus) {
      var list2 = isArray$c(value) ? value : [value];
      var newSelected;
      if (selectStatus) {
        newSelected = __spreadArray$u(__spreadArray$u([], __read$18(selected), false), __read$18(list2), false);
      } else {
        newSelected = selected.filter(function(x) {
          return list2.indexOf(x) === -1;
        });
      }
      setSelected(Array.from(new Set(newSelected)));
    };
    return {
      isSelected: isSelected2,
      setValueSelected: setValueSelected2
    };
  }, [selected]), isSelected = _b.isSelected, setValueSelected = _b.setValueSelected;
  var _c = useMemo(function() {
    var selectAll2 = function() {
      setSelected(values2);
    };
    var unSelectAll2 = function() {
      setSelected([]);
    };
    var toggle2 = function(value) {
      if (value === void 0) {
        value = values2;
      }
      var list2 = isArray$c(value) ? value : [value];
      var newSelected = __spreadArray$u([], __read$18(selected), false);
      list2.forEach(function(x) {
        var index2 = newSelected.indexOf(x);
        if (index2 > -1) {
          newSelected.splice(index2, 1);
        } else {
          newSelected.push(x);
        }
      });
      setSelected(newSelected);
    };
    var isAllSelected2 = function() {
      return values2.every(function(x) {
        return isSelected(x);
      });
    };
    var isPartialSelected2 = function() {
      return values2.some(function(x) {
        return isSelected(x);
      }) && !isAllSelected2();
    };
    return {
      selectAll: selectAll2,
      unSelectAll: unSelectAll2,
      toggle: toggle2,
      isAllSelected: isAllSelected2,
      isPartialSelected: isPartialSelected2
    };
  }, [selected, values2, isSelected]), selectAll = _c.selectAll, unSelectAll = _c.unSelectAll, toggle = _c.toggle, isAllSelected = _c.isAllSelected, isPartialSelected = _c.isPartialSelected;
  return {
    selected,
    setSelected,
    setValueSelected,
    selectAll,
    unSelectAll,
    toggle,
    isSelected,
    isAllSelected,
    isPartialSelected
  };
};
var useCheckbox$1 = useCheckbox;
function IconCheck(_a) {
  var className = _a.className;
  return React__default.createElement("svg", { className, "aria-hidden": true, focusable: false, viewBox: "0 0 1024 1024", width: "200", height: "200", fill: "currentColor" }, React__default.createElement("path", { d: "M877.44815445 206.10060629a64.72691371 64.72691371 0 0 0-95.14856334 4.01306852L380.73381888 685.46812814 235.22771741 533.48933518a64.72691371 64.72691371 0 0 0-92.43003222-1.03563036l-45.82665557 45.82665443a64.72691371 64.72691371 0 0 0-0.90617629 90.61767965l239.61903446 250.10479331a64.72691371 64.72691371 0 0 0 71.19960405 15.14609778 64.33855261 64.33855261 0 0 0 35.08198741-21.23042702l36.24707186-42.71976334 40.5190474-40.77795556-3.36579926-3.49525333 411.40426297-486.74638962a64.72691371 64.72691371 0 0 0-3.88361443-87.64024149l-45.3088404-45.43829334z", "p-id": "840" }));
}
var __assign$1v = globalThis && globalThis.__assign || function() {
  __assign$1v = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1v.apply(this, arguments);
};
var __rest$J = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$17 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function Checkbox(baseProps, ref) {
  var _a;
  var inputRef = useRef(null);
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig2 = _b.componentConfig;
  var props = useMergeProps(baseProps, {}, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Checkbox);
  var context = useContext(CheckboxGroupContext);
  var prefixCls2 = getPrefixCls("checkbox");
  var onGroupChange = context.onGroupChange;
  var mergeProps2 = __assign$1v({}, props);
  if (context.isCheckboxGroup) {
    mergeProps2.checked = context.checkboxGroupValue.indexOf(props.value) !== -1;
    mergeProps2.disabled = "disabled" in props ? props.disabled : context.disabled;
  }
  var disabled = mergeProps2.disabled, children = mergeProps2.children, className = mergeProps2.className, value = mergeProps2.value, style = mergeProps2.style, indeterminate = mergeProps2.indeterminate, error2 = mergeProps2.error, rest = __rest$J(mergeProps2, ["disabled", "children", "className", "value", "style", "indeterminate", "error"]);
  var _c = __read$17(useMergeValue(false, {
    value: mergeProps2.checked,
    defaultValue: mergeProps2.defaultChecked
  }), 2), checked = _c[0], setChecked = _c[1];
  var classNames = cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-disabled"] = !!disabled, _a[prefixCls2 + "-indeterminate"] = !!indeterminate, _a[prefixCls2 + "-checked"] = checked, _a.error = error2, _a), className);
  useEffect(function() {
    context.registerValue(value);
    return function() {
      context.unRegisterValue(value);
    };
  }, [value]);
  var onChange = useCallback(function(e) {
    e.persist();
    e.stopPropagation();
    setChecked(e.target.checked);
    if (context.isCheckboxGroup) {
      onGroupChange && onGroupChange(props.value, e.target.checked, e);
    }
    props.onChange && props.onChange(e.target.checked, e);
  }, [onGroupChange, context.isCheckboxGroup, props.onChange, props.value]);
  var onLabelClick = React__default.useCallback(function(e) {
    if (isFunction$5(props.children)) {
      e.preventDefault();
      inputRef.current && inputRef.current.click();
    }
    rest.onClick && rest.onClick(e);
  }, [props.children, rest.onClick]);
  return React__default.createElement("label", __assign$1v({ ref, "aria-disabled": disabled }, omit$1(rest, ["onChange"]), { onClick: onLabelClick, className: classNames, style }), React__default.createElement("input", {
    value,
    disabled: !!disabled,
    ref: inputRef,
    checked: !!checked,
    onChange,
    onClick: function(e) {
      return e.stopPropagation();
    },
    type: "checkbox"
  }), isFunction$5(children) ? children({ checked, indeterminate }) : React__default.createElement(React__default.Fragment, null, React__default.createElement(IconHover, { prefix: prefixCls2, className: prefixCls2 + "-mask-wrapper", disabled: checked || disabled || indeterminate }, React__default.createElement("div", { className: prefixCls2 + "-mask" }, React__default.createElement(IconCheck, { className: prefixCls2 + "-mask-icon" }))), children && React__default.createElement("span", { className: prefixCls2 + "-text" }, children)));
}
var CheckboxComponent = React__default.forwardRef(Checkbox);
CheckboxComponent.displayName = "Checkbox";
CheckboxComponent.Group = Group$2;
CheckboxComponent.useCheckbox = useCheckbox$1;
var Checkbox$1 = CheckboxComponent;
var __assign$1u = globalThis && globalThis.__assign || function() {
  __assign$1u = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1u.apply(this, arguments);
};
var __rest$I = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function Option$2(props, ref) {
  var _a, _b;
  var style = props.style, className = props.className, wrapperClassName = props.wrapperClassName, disabled = props.disabled, prefixCls2 = props.prefixCls, propValue = props.value, propChildren = props.children, _isMultipleMode = props._isMultipleMode, _isUserCreatedOption = props._isUserCreatedOption, _isUserCreatingOption = props._isUserCreatingOption, _valueActive = props._valueActive, _valueSelect = props._valueSelect, _onMouseEnter = props._onMouseEnter, _onMouseLeave = props._onMouseLeave, _onClick = props._onClick, rest = __rest$I(props, ["style", "className", "wrapperClassName", "disabled", "prefixCls", "value", "children", "_isMultipleMode", "_isUserCreatedOption", "_isUserCreatingOption", "_valueActive", "_valueSelect", "_onMouseEnter", "_onMouseLeave", "_onClick"]);
  var value = "value" in props ? propValue : "" + propChildren;
  var childNode = "children" in props ? propChildren : "" + propValue;
  var isChecked = _isMultipleMode ? _valueSelect.indexOf(value) !== -1 : _valueSelect === value;
  var optionLabelProps = __assign$1u({ style, className: cs$1(prefixCls2 + "-option", (_a = {}, _a[prefixCls2 + "-option-selected"] = isChecked, _a[prefixCls2 + "-option-disabled"] = disabled, _a[prefixCls2 + "-option-hover"] = value === _valueActive, _a[prefixCls2 + "-option-empty"] = !childNode && childNode !== 0, _a), className), onMouseEnter: function(event2) {
    _onMouseEnter && _onMouseEnter(value);
    rest.onMouseEnter && rest.onMouseEnter(event2);
  }, onMouseLeave: function(event2) {
    _onMouseLeave && _onMouseLeave();
    rest.onMouseLeave && rest.onMouseLeave(event2);
  }, onClick: function(event2) {
    _onClick && _onClick(value, disabled);
    rest.onClick && rest.onClick(event2);
  } }, omit$1(rest, ["_key", "extra", "isSelectOption", "onClick", "onMouseEnter", "onMouseLeave"]));
  var wrapperProps = {
    ref,
    role: "option",
    "aria-selected": isChecked
  };
  _isUserCreatedOption && Object.assign(wrapperProps, { "data-user-created": true });
  _isUserCreatingOption && Object.assign(wrapperProps, { "data-user-creating": true });
  if (_isMultipleMode) {
    return React__default.createElement("li", __assign$1u({}, wrapperProps, { className: cs$1(prefixCls2 + "-option-wrapper", (_b = {}, _b[prefixCls2 + "-option-wrapper-selected"] = isChecked, _b[prefixCls2 + "-option-wrapper-disabled"] = disabled, _b), wrapperClassName) }), React__default.createElement(Checkbox$1, { "aria-hidden": "true", className: prefixCls2 + "-checkbox", checked: isChecked, disabled, onChange: optionLabelProps.onClick }), React__default.createElement("span", __assign$1u({}, optionLabelProps), childNode));
  }
  return React__default.createElement("li", __assign$1u({}, wrapperProps, optionLabelProps), childNode);
}
var OptionComponent = React__default.forwardRef(Option$2);
OptionComponent.defaultProps = {
  isSelectOption: true
};
var Option$3 = OptionComponent;
var stringifyHotkey = function(k) {
  return JSON.stringify({
    code: k.code,
    ctrl: !!k.ctrl,
    shift: !!k.shift,
    alt: !!k.alt,
    meta: !!k.meta
  });
};
function getHotkeyHandler(hotkeyMap) {
  var map = {};
  hotkeyMap.forEach(function(callback, hotkey) {
    hotkey = typeof hotkey === "number" ? { code: hotkey } : hotkey;
    map[stringifyHotkey(hotkey)] = callback;
  });
  return function(event2) {
    var key = stringifyHotkey({
      code: event2.keyCode || event2.which,
      ctrl: !!event2.ctrlKey,
      shift: !!event2.shiftKey,
      alt: !!event2.altKey,
      meta: !!event2.metaKey
    });
    var callback = map[key];
    if (callback) {
      event2.stopPropagation();
      if (callback(event2) === false) {
        event2.preventDefault();
      }
    }
  };
}
function ownKeys$r(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$r(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$r(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$r(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconDownComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$r(_objectSpread$r({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-down")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M39.6 17.443 24.043 33 8.487 17.443"
  }));
}
var IconDown = /* @__PURE__ */ React__default.forwardRef(IconDownComponent);
IconDown.defaultProps = {
  isIcon: true
};
IconDown.displayName = "IconDown";
var IconDown$1 = IconDown;
function ownKeys$q(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$q(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$q(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$q(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconExpandComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$q(_objectSpread$q({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-expand")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M7 26v14c0 .552.444 1 .996 1H22m19-19V8c0-.552-.444-1-.996-1H26"
  }));
}
var IconExpand = /* @__PURE__ */ React__default.forwardRef(IconExpandComponent);
IconExpand.defaultProps = {
  isIcon: true
};
IconExpand.displayName = "IconExpand";
var IconExpand$1 = IconExpand;
var __assign$1t = globalThis && globalThis.__assign || function() {
  __assign$1t = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1t.apply(this, arguments);
};
var __rest$H = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$16 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var COLORS = [
  "red",
  "orangered",
  "orange",
  "gold",
  "lime",
  "green",
  "cyan",
  "blue",
  "arcoblue",
  "purple",
  "pinkpurple",
  "magenta",
  "gray"
];
var defaultProps$u = {
  size: "default"
};
function Tag(baseProps, ref) {
  var _a;
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig2 = _b.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$u, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Tag);
  var className = props.className, style = props.style, children = props.children, color2 = props.color, closable = props.closable, checkable = props.checkable, defaultChecked = props.defaultChecked, size = props.size, onClose = props.onClose, onCheck = props.onCheck, icon = props.icon, closeIcon = props.closeIcon, bordered = props.bordered, rest = __rest$H(props, ["className", "style", "children", "color", "closable", "checkable", "defaultChecked", "size", "onClose", "onCheck", "icon", "closeIcon", "bordered"]);
  var prefixCls2 = getPrefixCls("tag");
  var _c = __read$16(useState("visible" in props ? props.visible : true), 2), visible = _c[0], setVisible = _c[1];
  var _d = __read$16(useState("checked" in props ? props.checked : defaultChecked), 2), checked = _d[0], setChecked = _d[1];
  var _e = __read$16(useState(), 2), loading = _e[0], setLoading = _e[1];
  var mergedChecked = "checked" in props ? props.checked : checked;
  var mergedVisible = "visible" in props ? props.visible : visible;
  function onHandleClose(e) {
    var ret = onClose && onClose(e);
    if (ret && ret.then) {
      setLoading(true);
      ret.then(function() {
        setLoading(false);
        setVisible(false);
      }).catch(function() {
        setLoading(false);
      });
    } else {
      setVisible(false);
    }
  }
  function onHandleCheck() {
    var newChecked = !mergedChecked;
    if (!("checked" in props)) {
      setChecked(newChecked);
    }
    onCheck && onCheck(newChecked);
  }
  var _color = color2 ? COLORS.indexOf(color2) !== -1 ? color2 : "" : "";
  var _checked = checkable ? mergedChecked : true;
  var classNames = cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-loading"] = loading, _a[prefixCls2 + "-hide"] = !mergedVisible, _a[prefixCls2 + "-" + _color] = _color, _a[prefixCls2 + "-checkable"] = checkable, _a[prefixCls2 + "-checked"] = _checked, _a[prefixCls2 + "-size-" + size] = size, _a[prefixCls2 + "-bordered"] = bordered, _a[prefixCls2 + "-custom-color"] = _checked && color2 && !_color, _a), className);
  var colorStyle = __assign$1t({}, style);
  if (color2 && !_color && _checked) {
    colorStyle.backgroundColor = color2;
    colorStyle.borderColor = color2;
  }
  var otherProps = omit$1(rest, ["visible"]);
  if (checkable) {
    otherProps.onClick = onHandleCheck;
  }
  return React__default.createElement("div", __assign$1t({ ref, style: colorStyle, className: classNames }, otherProps), icon && React__default.createElement("span", { className: prefixCls2 + "-icon" }, icon), children, closable && !loading && closeIcon !== null && React__default.createElement(IconHover, { prefix: prefixCls2, className: prefixCls2 + "-close-btn", onClick: onHandleClose, role: "button", "aria-label": "Close" }, closeIcon !== void 0 ? closeIcon : React__default.createElement(IconClose$1, null)), loading && React__default.createElement("span", { className: prefixCls2 + "-loading-icon" }, React__default.createElement(IconLoading$1, null)));
}
var TagComponent = forwardRef(Tag);
TagComponent.displayName = "Tag";
var Tag$1 = TagComponent;
var __read$15 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function Item$6(props) {
  var _a;
  var prefixCls2 = props.prefixCls, style = props.style, children = props.children, direction = props.direction, disabled = props.disabled, droppable = props.droppable, onDrop = props.onDrop, onDragStart = props.onDragStart, onDragEnd = props.onDragEnd, onDragOver = props.onDragOver, onDragLeave = props.onDragLeave;
  var refItem = useRef(null);
  var refDraggedTimer = useRef(null);
  var _b = __read$15(useState("none"), 2), dragStatus = _b[0], setDragStatus = _b[1];
  var _c = __read$15(useState(false), 2), dragOver = _c[0], setDragOver = _c[1];
  var _d = __read$15(useState(null), 2), dragPosition = _d[0], setDragPosition = _d[1];
  useEffect(function() {
    return function() {
      refDraggedTimer.current && clearTimeout(refDraggedTimer.current);
    };
  }, []);
  useEffect(function() {
    if (dragStatus === "dragged") {
      refDraggedTimer.current = setTimeout(function() {
        return setDragStatus("none");
      }, 1e3);
    }
  }, [dragStatus]);
  return React__default.createElement("li", { draggable: true, ref: refItem, style, className: cs$1(prefixCls2 + "-item", (_a = {}, _a[prefixCls2 + "-item-" + dragStatus] = dragStatus !== "none", _a[prefixCls2 + "-item-gap-" + dragPosition] = dragPosition, _a[prefixCls2 + "-item-disabled"] = disabled, _a[prefixCls2 + "-item-dragover"] = dragOver, _a)), onDragStart: function(event2) {
    event2.stopPropagation();
    setDragStatus("dragging");
    try {
      event2.dataTransfer.setData("text/plain", "");
    } catch (error2) {
    }
    onDragStart && onDragStart(event2);
  }, onDragEnd: function(event2) {
    event2.stopPropagation();
    setDragOver(false);
    setDragStatus("dragged");
    onDragEnd && onDragEnd(event2);
  }, onDragOver: function(event2) {
    if (droppable) {
      event2.stopPropagation();
      event2.preventDefault();
      var rect = refItem.current.getBoundingClientRect();
      if (direction === "vertical") {
        setDragPosition(event2.pageY > window.pageYOffset + rect.top + rect.height / 2 ? "bottom" : "top");
      } else {
        setDragPosition(event2.pageX > window.pageXOffset + rect.left + rect.width / 2 ? "right" : "left");
      }
      setDragOver(true);
      onDragOver && onDragOver(event2);
    }
  }, onDragLeave: function(event2) {
    if (droppable) {
      event2.stopPropagation();
      setDragOver(false);
      onDragLeave && onDragLeave(event2);
    }
  }, onDrop: function(event2) {
    if (droppable) {
      event2.stopPropagation();
      event2.preventDefault();
      setDragOver(false);
      setDragPosition(null);
      setDragStatus("none");
      onDrop && onDrop(event2, dragPosition);
    }
  } }, children);
}
Item$6.defaultProps = {
  droppable: true
};
var __read$14 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function Draggable(props) {
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var prefixCls2 = getPrefixCls("draggable");
  var className = props.className, children = props.children, direction = props.direction, onIndexChange = props.onIndexChange, itemWrapperStyle = props.itemWrapperStyle;
  var _a = __read$14(useState(null), 2), dragItemIndex = _a[0], setDragItemIndex = _a[1];
  return React__default.createElement("div", { className: cs$1(prefixCls2, className) }, React__default.Children.map(children, function(child, index2) {
    return React__default.createElement(Item$6, { style: itemWrapperStyle, prefixCls: prefixCls2, direction, onDragStart: function() {
      return setDragItemIndex(index2);
    }, onDragEnd: function() {
      return setDragItemIndex(null);
    }, onDrop: function(_, dropPosition) {
      var prevIndex = dragItemIndex;
      var nextIndex = dropPosition === "left" || dropPosition === "top" ? index2 : index2 + 1;
      if (onIndexChange && prevIndex !== nextIndex) {
        onIndexChange(nextIndex, prevIndex);
      }
    } }, child);
  }));
}
Draggable.defaultProps = {
  direction: "vertical"
};
var __assign$1s = globalThis && globalThis.__assign || function() {
  __assign$1s = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1s.apply(this, arguments);
};
var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$6 = globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
          return t2;
        if (y = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __read$13 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$t = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var CSS_TRANSITION_DURATION = 300;
var REACT_KEY_FOR_INPUT = "__input_" + Math.random().toFixed(10).slice(2);
var keepFocus = function(e) {
  e.target.tagName !== "INPUT" && e.preventDefault();
};
var formatValue = function(value) {
  if (!isArray$c(value)) {
    return [];
  }
  return value.map(function(item2) {
    return isObject$e(item2) ? __assign$1s(__assign$1s({}, item2), { label: "label" in item2 ? item2.label : item2.value, value: item2.value, closable: item2.closable }) : {
      label: item2,
      value: item2
    };
  });
};
var useComputeAutoWidthDelay = function(value) {
  var refDelay = useRef(0);
  var refPrevValueLength = useRef(value.length);
  useEffect(function() {
    refDelay.current = value.length === 0 && refPrevValueLength.current > 0 ? CSS_TRANSITION_DURATION : 0;
    refPrevValueLength.current = value.length;
  }, [value]);
  return refDelay;
};
var UsedTransitionGroup = function(_a) {
  var prefixCls2 = _a.prefixCls, children = _a.children, animation = _a.animation;
  return animation ? React__default.createElement(TransitionGroup$1, { component: "div", className: prefixCls2 + "-inner" }, children) : React__default.createElement("div", { className: prefixCls2 + "-inner" }, children);
};
var defaultProps$t = {
  animation: true,
  validate: function(inputValue, values2) {
    return inputValue && values2.every(function(item2) {
      return item2.value !== inputValue;
    });
  }
};
function InputTag(baseProps, ref) {
  var _a;
  var _this = this;
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, ctxSize = _b.size, componentConfig2 = _b.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$t, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.InputTag);
  var className = props.className, style = props.style, placeholder = props.placeholder, error2 = props.error, disabled = props.disabled, readOnly = props.readOnly, allowClear = props.allowClear, autoFocus = props.autoFocus, labelInValue = props.labelInValue, disableInput = props.disableInput, animation = props.animation, saveOnBlur = props.saveOnBlur, dragToSort = props.dragToSort, icon = props.icon, suffix = props.suffix, validate3 = props.validate, renderTag = props.renderTag, tagClassName = props.tagClassName, onInputChange = props.onInputChange, onKeyDown = props.onKeyDown, onPaste = props.onPaste, onChange = props.onChange, onFocus3 = props.onFocus, onBlur3 = props.onBlur, onPressEnter = props.onPressEnter, onRemove = props.onRemove, onClear = props.onClear, onClick = props.onClick;
  var prefixCls2 = getPrefixCls("input-tag");
  var size = "size" in props ? props.size : ctxSize;
  var inputRef = useRef();
  var _c = __read$13(useState(false), 2), focused = _c[0], setFocused = _c[1];
  var _d = __read$13(useMergeValue([], {
    defaultValue: "defaultValue" in props ? formatValue(props.defaultValue) : void 0,
    value: "value" in props ? formatValue(props.value) : void 0
  }), 2), value = _d[0], setValue = _d[1];
  var _e = __read$13(useMergeValue("", {
    value: props.inputValue
  }), 2), inputValue = _e[0], setInputValue = _e[1];
  var refDelay = useComputeAutoWidthDelay(value);
  var draggable = !!(dragToSort && !readOnly && !disabled);
  useImperativeHandle(ref, function() {
    return {
      blur: inputRef.current && inputRef.current.blur,
      focus: inputRef.current && inputRef.current.focus
    };
  }, []);
  var valueChangeHandler = function(value2, reason) {
    if (disabled || readOnly) {
      return;
    }
    if (!("value" in props)) {
      setValue(value2);
    }
    onChange && onChange(labelInValue ? value2 : value2.map(function(x) {
      return x.value;
    }), reason);
  };
  var tagCloseHandler = function(itemValue, index2, event2) {
    onRemove && onRemove(itemValue, index2, event2);
    valueChangeHandler(__spreadArray$t(__spreadArray$t([], __read$13(value.slice(0, index2)), false), __read$13(value.slice(index2 + 1)), false), "remove");
  };
  var hotkeyHandler = getHotkeyHandler(new Map([
    [
      Backspace.code,
      function(event2) {
        if (!event2.target.value && value.length) {
          for (var index2 = value.length - 1; index2 >= 0; index2--) {
            var itemValue = value[index2];
            if (itemValue.closable !== false) {
              tagCloseHandler(itemValue, index2, event2);
              return;
            }
          }
        }
      }
    ]
  ]));
  var tryAddInputValueToTag = function() {
    return __awaiter$6(_this, void 0, void 0, function() {
      var isLegal, _a2, error_1;
      return __generator$6(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            _b2.trys.push([0, 4, , 5]);
            if (!(typeof validate3 === "function"))
              return [3, 2];
            return [4, validate3(inputValue, value)];
          case 1:
            _a2 = _b2.sent();
            return [3, 3];
          case 2:
            _a2 = true;
            _b2.label = 3;
          case 3:
            isLegal = _a2;
            if (isLegal) {
              valueChangeHandler(value.concat({ value: inputValue, label: inputValue }), "add");
              setInputValue("");
            }
            return [3, 5];
          case 4:
            error_1 = _b2.sent();
            console.error(error_1);
            return [3, 5];
          case 5:
            return [2];
        }
      });
    });
  };
  var mergedRenderTag = function(item2, index2) {
    var _a2;
    var itemValue = item2.value, label = item2.label;
    var closable = !readOnly && !disabled && item2.closable !== false;
    var onClose = function(event2) {
      tagCloseHandler(item2, index2, event2);
    };
    if (renderTag) {
      return renderTag({
        value: itemValue,
        label,
        closable,
        onClose
      }, index2, value);
    }
    return React__default.createElement(Tag$1, { visible: true, className: cs$1(prefixCls2 + "-tag", (_a2 = {}, _a2[tagClassName] = tagClassName, _a2)), closable, closeIcon: icon && icon.removeIcon, onClose }, React__default.createElement("span", { title: typeof label === "string" ? label : void 0, className: prefixCls2 + "-tag-content" }, typeof label === "string" ? label.replace(/\s/g, "\xA0") : label));
  };
  var clearIcon = allowClear && !disabled && !readOnly && value.length ? React__default.createElement(IconHover, { size, key: "clearIcon", className: prefixCls2 + "-clear-icon", onClick: function(e) {
    e.stopPropagation();
    valueChangeHandler([], "clear");
    if (!focused) {
      inputRef.current && inputRef.current.focus();
    }
    onClear && onClear();
  }, onMouseDown: keepFocus }, icon && icon.clearIcon || React__default.createElement(IconClose$1, null)) : null;
  var hasSuffix = !!(clearIcon || suffix);
  var childrenWithAnimation = value.map(function(x, i2) {
    var isRepeat = value.findIndex(function(item2) {
      return item2.value === x.value;
    }) !== i2;
    var eleTag = mergedRenderTag(x, i2);
    return React__default.isValidElement(eleTag) ? React__default.createElement(CSSTransition$1, { key: typeof x.value === "object" ? i2 : isRepeat ? x.value + "-" + i2 : x.value, timeout: CSS_TRANSITION_DURATION, classNames: "zoomIn" }, eleTag) : eleTag;
  }).concat(React__default.createElement(CSSTransition$1, { key: REACT_KEY_FOR_INPUT, timeout: CSS_TRANSITION_DURATION, classNames: "zoomIn" }, React__default.createElement(InputComponent$1, { autoComplete: "off", size, disabled: disabled || disableInput, readOnly, ref: inputRef, autoFocus, placeholder: !value.length ? placeholder : "", prefixCls: prefixCls2 + "-input", autoFitWidth: {
    delay: function() {
      return refDelay.current;
    }
  }, onPressEnter: function(e) {
    return __awaiter$6(_this, void 0, void 0, function() {
      return __generator$6(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            inputValue && e.preventDefault();
            onPressEnter && onPressEnter(e);
            return [4, tryAddInputValueToTag()];
          case 1:
            _a2.sent();
            return [2];
        }
      });
    });
  }, onFocus: function(e) {
    if (!disabled && !readOnly) {
      setFocused(true);
      onFocus3 && onFocus3(e);
    }
  }, onBlur: function(e) {
    return __awaiter$6(_this, void 0, void 0, function() {
      return __generator$6(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            setFocused(false);
            onBlur3 && onBlur3(e);
            if (!saveOnBlur)
              return [3, 2];
            return [4, tryAddInputValueToTag()];
          case 1:
            _a2.sent();
            _a2.label = 2;
          case 2:
            setInputValue("");
            return [2];
        }
      });
    });
  }, value: inputValue, onChange: function(v, e) {
    setInputValue(v);
    onInputChange && onInputChange(v, e);
  }, onKeyDown: function(event2) {
    hotkeyHandler(event2);
    onKeyDown && onKeyDown(event2);
  }, onPaste })));
  return React__default.createElement("div", __assign$1s({}, pickTriggerPropsFromRest(props), { style, className: cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-size-" + size] = size, _a[prefixCls2 + "-disabled"] = disabled, _a[prefixCls2 + "-error"] = error2, _a[prefixCls2 + "-focus"] = focused, _a[prefixCls2 + "-readonly"] = readOnly, _a[prefixCls2 + "-has-suffix"] = hasSuffix, _a[prefixCls2 + "-has-placeholder"] = !value.length, _a), className), onMouseDown: function(event2) {
    focused && keepFocus(event2);
  }, onClick: function(e) {
    !focused && inputRef.current && inputRef.current.focus();
    if (onClick) {
      onClick(e);
    }
  } }), React__default.createElement("div", { className: prefixCls2 + "-view" }, React__default.createElement(UsedTransitionGroup, { prefixCls: prefixCls2, animation }, draggable ? React__default.createElement(Draggable, { itemWrapperStyle: { display: "inline-block" }, direction: "horizontal", onIndexChange: function(index2, prevIndex) {
    var moveItem = function(arr, fromIndex, toIndex) {
      arr = arr.slice();
      var isMoveLeft = fromIndex > toIndex;
      var _a2 = __read$13(arr.splice(fromIndex, 1), 1), item2 = _a2[0];
      arr.splice(isMoveLeft ? toIndex : toIndex - 1, 0, item2);
      return arr;
    };
    valueChangeHandler(moveItem(value, prevIndex, index2), "sort");
  } }, childrenWithAnimation) : childrenWithAnimation), hasSuffix && React__default.createElement("div", { className: prefixCls2 + "-suffix", onMouseDown: keepFocus }, clearIcon, suffix)));
}
var InputTagRef = React__default.forwardRef(InputTag);
InputTagRef.displayName = "InputTag";
var InputTag$1 = InputTagRef;
function include(obj, keys2) {
  var clone = {};
  Object.keys(obj).forEach(function(key) {
    if (keys2.indexOf(key) !== -1) {
      clone[key] = obj[key];
    }
  });
  return clone;
}
var __read$12 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function useForceUpdate() {
  var _a = __read$12(useReducer(function(v) {
    return v + 1;
  }, 0), 2), dispatch = _a[1];
  return dispatch;
}
var __assign$1r = globalThis && globalThis.__assign || function() {
  __assign$1r = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1r.apply(this, arguments);
};
var __rest$G = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$11 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var SearchStatus = {
  BEFORE: 0,
  EDITING: 1,
  NONE: 2
};
var SelectView = function(props, ref) {
  var _a, _b;
  var style = props.style, className = props.className, size = props.size, bordered = props.bordered, allowClear = props.allowClear, allowCreate = props.allowCreate, error2 = props.error, loading = props.loading, disabled = props.disabled, animation = props.animation, prefixCls2 = props.prefixCls, suffixIcon = props.suffixIcon, arrowIcon = props.arrowIcon, removeIcon = props.removeIcon, clearIcon = props.clearIcon, placeholder = props.placeholder, renderText = props.renderText, value = props.value, inputValue = props.inputValue, popupVisible = props.popupVisible, maxTagCount = props.maxTagCount, isMultiple = props.isMultiple, isEmptyValue2 = props.isEmptyValue, prefix = props.prefix, ariaControls = props.ariaControls, renderTag = props.renderTag, dragToSort = props.dragToSort, onKeyDown = props.onKeyDown, onChangeInputValue = props.onChangeInputValue, onPaste = props.onPaste, onClear = props.onClear, onFocus3 = props.onFocus, onBlur3 = props.onBlur, onRemoveCheckedItem = props.onRemoveCheckedItem, onSort = props.onSort, rest = __rest$G(props, ["style", "className", "size", "bordered", "allowClear", "allowCreate", "error", "loading", "disabled", "animation", "prefixCls", "suffixIcon", "arrowIcon", "removeIcon", "clearIcon", "placeholder", "renderText", "value", "inputValue", "popupVisible", "maxTagCount", "isMultiple", "isEmptyValue", "prefix", "ariaControls", "renderTag", "dragToSort", "onKeyDown", "onChangeInputValue", "onPaste", "onClear", "onFocus", "onBlur", "onRemoveCheckedItem", "onSort"]);
  var refInput = useRef(null);
  var refWrapper = useRef(null);
  var _c = useContext(ConfigContext), ctxSize = _c.size, getPrefixCls = _c.getPrefixCls;
  var _d = __read$11(useState(SearchStatus.NONE), 2), searchStatus = _d[0], setSearchStatus = _d[1];
  var _e = __read$11(useState(false), 2), focused = _e[0], setFocused = _e[1];
  var forceUpdate = useForceUpdate();
  var showSearch = "showSearch" in props ? props.showSearch : isMultiple;
  var canFocusInput = showSearch || allowCreate;
  var mergedSize = size || ctxSize;
  var mergedFocused = focused || popupVisible;
  var isRetainInputValueSearch = isObject$e(showSearch) && showSearch.retainInputValue;
  var renderedValue = !isMultiple && value !== void 0 ? renderText(value).text : "";
  var keepFocus2 = function(event2) {
    event2 && event2.preventDefault();
  };
  var handleFocus = function(action) {
    var element = canFocusInput ? refInput.current : refWrapper.current;
    if (element) {
      action === "focus" ? element.focus() : element.blur();
    }
  };
  var tryTriggerFocusChange = function(action, event2) {
    if (canFocusInput && event2.target === refWrapper.current) {
      return;
    }
    if (action === "focus") {
      setFocused(true);
      onFocus3 && onFocus3(event2);
    } else {
      setFocused(false);
      onBlur3 && onBlur3(event2);
    }
  };
  var tryTriggerKeyDown = function(event2) {
    if (canFocusInput && event2.currentTarget === refWrapper.current) {
      return;
    }
    var keyCode = event2.keyCode || event2.which;
    if (keyCode === Enter.code) {
      event2.preventDefault();
    }
    onKeyDown && onKeyDown(event2);
  };
  useEffect(function() {
    handleFocus(popupVisible ? "focus" : "blur");
    if (canFocusInput) {
      setSearchStatus(popupVisible ? SearchStatus.BEFORE : SearchStatus.NONE);
    }
  }, [popupVisible]);
  useImperativeHandle(ref, function() {
    return {
      dom: refWrapper.current,
      focus: handleFocus.bind(null, "focus"),
      blur: handleFocus.bind(null, "blur"),
      getWidth: function() {
        return refWrapper.current && refWrapper.current.clientWidth;
      }
    };
  });
  var mergedArrowIcon = "arrowIcon" in props ? arrowIcon === null ? null : React__default.createElement("div", { className: prefixCls2 + "-arrow-icon" }, arrowIcon) : canFocusInput ? React__default.createElement("div", { className: prefixCls2 + "-expand-icon" }, React__default.createElement(IconExpand$1, { style: { transform: "rotate(-45deg)" } })) : React__default.createElement("div", { className: prefixCls2 + "-arrow-icon" }, React__default.createElement(IconDown$1, null));
  var mergedSuffixIcon = loading ? React__default.createElement("span", { className: prefixCls2 + "-loading-icon" }, React__default.createElement(IconLoading$1, null)) : suffixIcon ? React__default.createElement("span", { className: prefixCls2 + "-suffix-icon" }, suffixIcon) : props.showSearch && popupVisible ? React__default.createElement("div", { className: prefixCls2 + "-search-icon" }, React__default.createElement(IconSearch$1, null)) : mergedArrowIcon;
  var inputEventHandlers = {
    paste: onPaste,
    keyDown: tryTriggerKeyDown,
    focus: function(event2) {
      event2.stopPropagation();
      tryTriggerFocusChange("focus", event2);
    },
    blur: function(event2) {
      event2.stopPropagation();
      tryTriggerFocusChange("blur", event2);
    },
    change: function(newValue, event2) {
      setSearchStatus(SearchStatus.EDITING);
      onChangeInputValue && onChangeInputValue(newValue, event2);
    }
  };
  var renderSingle = function() {
    var _a2, _b2;
    var _inputValue;
    switch (searchStatus) {
      case SearchStatus.BEFORE:
        _inputValue = inputValue || (isRetainInputValueSearch ? renderedValue : "");
        break;
      case SearchStatus.EDITING:
        _inputValue = inputValue || "";
        break;
      default:
        _inputValue = renderedValue;
        break;
    }
    var inputProps = {
      style: { width: "100%" },
      value: typeof _inputValue !== "object" ? _inputValue : "",
      placeholder: canFocusInput && renderedValue && typeof renderedValue !== "object" ? renderedValue : placeholder
    };
    if (canFocusInput) {
      inputProps.onPaste = inputEventHandlers.paste;
      inputProps.onKeyDown = inputEventHandlers.keyDown;
      inputProps.onFocus = inputEventHandlers.focus;
      inputProps.onBlur = inputEventHandlers.blur;
      inputProps.onChange = inputEventHandlers.change;
    } else {
      inputProps.tabIndex = -1;
      inputProps.style.pointerEvents = "none";
    }
    var needShowInput = !!(mergedFocused && canFocusInput || isEmptyValue2);
    return React__default.createElement(React__default.Fragment, null, React__default.createElement(InputComponent$1, __assign$1r({ "aria-hidden": !needShowInput || void 0, ref: refInput, disabled, className: cs$1(prefixCls2 + "-view-input", (_a2 = {}, _a2[prefixCls2 + "-hidden"] = !needShowInput, _a2)), autoComplete: "off" }, inputProps)), React__default.createElement("span", { "aria-hidden": needShowInput || void 0, className: cs$1(prefixCls2 + "-view-value", (_b2 = {}, _b2[prefixCls2 + "-hidden"] = needShowInput, _b2)) }, _inputValue));
  };
  var renderMultiple = function() {
    var usedValue = isUndefined(value) ? [] : [].concat(value);
    var usedMaxTagCount = typeof maxTagCount === "number" ? Math.max(maxTagCount, 0) : usedValue.length;
    var tagsToShow = [];
    var lastClosableTagIndex = -1;
    for (var i2 = usedValue.length - 1; i2 >= 0; i2--) {
      var v = usedValue[i2];
      var result = renderText(v);
      if (i2 < usedMaxTagCount) {
        tagsToShow.unshift({
          value: v,
          label: result.text,
          closable: !result.disabled
        });
      }
      if (!result.disabled && lastClosableTagIndex === -1) {
        lastClosableTagIndex = i2;
      }
    }
    var invisibleTagCount = usedValue.length - usedMaxTagCount;
    if (invisibleTagCount > 0) {
      tagsToShow.push({
        label: "+" + invisibleTagCount + "...",
        closable: false,
        value: "__arco_value_tag_placeholder"
      });
    }
    var eventHandlers = {
      onPaste: inputEventHandlers.paste,
      onKeyDown: inputEventHandlers.keyDown,
      onFocus: inputEventHandlers.focus,
      onBlur: inputEventHandlers.blur,
      onInputChange: inputEventHandlers.change,
      onRemove: function(value2, index2, event2) {
        var keyCode = event2.keyCode || event2.which;
        if (keyCode === Backspace.code && lastClosableTagIndex > -1) {
          value2 = usedValue[lastClosableTagIndex];
          index2 = lastClosableTagIndex;
        }
        maxTagCount && forceUpdate();
        onRemoveCheckedItem && onRemoveCheckedItem(value2, index2, event2);
      }
    };
    return React__default.createElement(InputTag$1, __assign$1r({
      className: mergedFocused ? getPrefixCls("input-tag") + "-focus" : "",
      ref: refInput,
      disabled,
      dragToSort,
      disableInput: !showSearch,
      animation,
      placeholder,
      value: tagsToShow,
      inputValue,
      size: mergedSize,
      tagClassName: prefixCls2 + "-tag",
      renderTag,
      icon: { removeIcon },
      onChange: function(value2, reason) {
        if (onSort && reason === "sort") {
          onSort(value2);
        }
      }
    }, eventHandlers));
  };
  var classNames = cs$1(prefixCls2, prefixCls2 + "-" + (isMultiple ? "multiple" : "single"), (_a = {}, _a[prefixCls2 + "-show-search"] = showSearch, _a[prefixCls2 + "-open"] = popupVisible, _a[prefixCls2 + "-size-" + mergedSize] = mergedSize, _a[prefixCls2 + "-focused"] = mergedFocused, _a[prefixCls2 + "-error"] = error2, _a[prefixCls2 + "-disabled"] = disabled, _a[prefixCls2 + "-no-border"] = !bordered, _a), className);
  var mergedClearIcon = !disabled && !isEmptyValue2 && allowClear ? React__default.createElement(IconHover, { size: mergedSize, key: "clearIcon", className: prefixCls2 + "-clear-icon", onClick: onClear, onMouseDown: keepFocus2 }, clearIcon !== void 0 && clearIcon !== null ? clearIcon : React__default.createElement(IconClose$1, null)) : null;
  return React__default.createElement("div", __assign$1r({ role: "combobox", "aria-haspopup": "listbox", "aria-autocomplete": "list", "aria-expanded": popupVisible, "aria-disabled": disabled, "aria-controls": ariaControls }, include(rest, ["onClick", "onMouseEnter", "onMouseLeave"]), {
    ref: refWrapper,
    tabIndex: disabled ? -1 : 0,
    style,
    className: classNames,
    onKeyDown: tryTriggerKeyDown,
    onFocus: function(event2) {
      if (!disabled && !dragToSort) {
        if (canFocusInput) {
          refInput.current && refInput.current.focus();
        } else {
          tryTriggerFocusChange("focus", event2);
        }
      }
    },
    onBlur: function(event2) {
      return tryTriggerFocusChange("blur", event2);
    }
  }), React__default.createElement("div", { title: typeof renderedValue === "string" ? renderedValue : void 0, className: cs$1(prefixCls2 + "-view", (_b = {}, _b[prefixCls2 + "-view-with-prefix"] = prefix, _b)), onClick: function(e) {
    return popupVisible && canFocusInput && e.stopPropagation();
  } }, prefix && React__default.createElement("div", { "aria-hidden": "true", className: cs$1(prefixCls2 + "-prefix"), onMouseDown: function(event2) {
    return focused && keepFocus2(event2);
  } }, prefix), isMultiple ? renderMultiple() : renderSingle(), React__default.createElement("div", { "aria-hidden": "true", className: prefixCls2 + "-suffix", onMouseDown: function(event2) {
    return focused && keepFocus2(event2);
  } }, mergedClearIcon, mergedSuffixIcon)));
};
var SelectViewComponent = React__default.forwardRef(SelectView);
SelectViewComponent.displayName = "SelectView";
var SelectView$1 = SelectViewComponent;
function getStringLength(str) {
  var len = 0;
  for (var i2 = 0; i2 < str.length; i2++) {
    if (str.charCodeAt(i2) > 127 || str.charCodeAt(i2) === 94) {
      len += 2;
    } else {
      len++;
    }
  }
  return len;
}
var __rest$F = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var GHOST_ITEM_KEY = "__rc_ghost_item__";
function getLocationItem(scrollPtg, total) {
  var itemIndex = Math.floor(scrollPtg * total);
  var itemTopPtg = itemIndex / total;
  var offsetPtg = (scrollPtg - itemTopPtg) / (1 / total);
  return {
    index: itemIndex,
    offsetPtg: Number.isNaN(offsetPtg) ? 0 : offsetPtg
  };
}
function getNodeHeight(node) {
  var element = findDOMNode(node);
  return element ? element.offsetHeight : 0;
}
function getValidScrollTop(scrollTop, scrollRange) {
  return scrollTop < 0 ? 0 : scrollTop > scrollRange ? scrollRange : scrollTop;
}
function getScrollPercentage(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  var scrollRange = scrollHeight - clientHeight;
  return scrollRange <= 0 ? 0 : getValidScrollTop(scrollTop, scrollRange) / scrollRange;
}
function getRangeIndex(scrollPtg, itemCount, visibleCount) {
  var _a = getLocationItem(scrollPtg, itemCount), index2 = _a.index, offsetPtg = _a.offsetPtg;
  var beforeCount = Math.ceil(scrollPtg * visibleCount);
  var afterCount = Math.ceil((1 - scrollPtg) * visibleCount);
  return {
    itemIndex: index2,
    itemOffsetPtg: offsetPtg,
    startIndex: Math.max(0, index2 - beforeCount),
    endIndex: Math.min(itemCount - 1, index2 + afterCount)
  };
}
function getItemRelativeTop(_a) {
  var itemHeight = _a.itemHeight, itemOffsetPtg = _a.itemOffsetPtg, scrollPtg = _a.scrollPtg, clientHeight = _a.clientHeight;
  return Math.floor(clientHeight * scrollPtg - itemHeight * itemOffsetPtg);
}
function getItemAbsoluteTop(_a) {
  var scrollTop = _a.scrollTop, rest = __rest$F(_a, ["scrollTop"]);
  return scrollTop + getItemRelativeTop(rest);
}
function getCompareItemRelativeTop(_a) {
  var locatedItemRelativeTop = _a.locatedItemRelativeTop, locatedItemIndex = _a.locatedItemIndex, compareItemIndex = _a.compareItemIndex, startIndex = _a.startIndex, endIndex = _a.endIndex, getItemKey = _a.getItemKey, itemElementHeights = _a.itemElementHeights, itemHeight = _a.itemHeight;
  var compareItemTop = locatedItemRelativeTop;
  var compareItemKey = getItemKey(compareItemIndex);
  if (compareItemIndex <= locatedItemIndex) {
    for (var index2 = locatedItemIndex; index2 >= startIndex; index2 -= 1) {
      var key = getItemKey(index2);
      if (key === compareItemKey) {
        break;
      }
      var prevItemKey = getItemKey(index2 - 1);
      compareItemTop -= itemElementHeights[prevItemKey] || itemHeight;
    }
  } else {
    for (var index2 = locatedItemIndex; index2 <= endIndex; index2 += 1) {
      var key = getItemKey(index2);
      if (key === compareItemKey) {
        break;
      }
      compareItemTop += itemElementHeights[key] || itemHeight;
    }
  }
  return compareItemTop;
}
function getLongestItemIndex(data) {
  var result = -1;
  var length2 = 0;
  data.forEach(function(item2, index2) {
    var _a;
    item2 = typeof item2 === "string" ? item2 : (_a = item2.props) === null || _a === void 0 ? void 0 : _a.children;
    if (typeof item2 === "string") {
      var _length = getStringLength(item2);
      if (_length > length2) {
        length2 = _length;
        result = index2;
      }
    }
  });
  return result;
}
function usePrevious(value) {
  var ref = useRef();
  useEffect(function() {
    ref.current = value;
  });
  return ref.current;
}
function getIndexByStartLoc(min, max, start2, index2) {
  var beforeCount = start2 - min;
  var afterCount = max - start2;
  var balanceCount = Math.min(beforeCount, afterCount) * 2;
  if (index2 <= balanceCount) {
    var stepIndex = Math.floor(index2 / 2);
    if (index2 % 2) {
      return start2 + stepIndex + 1;
    }
    return start2 - stepIndex;
  }
  if (beforeCount > afterCount) {
    return start2 - (index2 - afterCount);
  }
  return start2 + (index2 - beforeCount);
}
function findListDiffIndex(originList, targetList, getKey2) {
  var originLen = originList.length;
  var targetLen = targetList.length;
  var shortList;
  var longList;
  if (originLen === 0 && targetLen === 0) {
    return null;
  }
  if (originLen < targetLen) {
    shortList = originList;
    longList = targetList;
  } else {
    shortList = targetList;
    longList = originList;
  }
  var notExistKey = { __EMPTY_ITEM__: true };
  function getItemKey(item2, index2) {
    return item2 !== void 0 ? getKey2(item2, index2) : notExistKey;
  }
  var diffIndex = null;
  var multiple = Math.abs(originLen - targetLen) !== 1;
  for (var i2 = 0; i2 < longList.length; i2 += 1) {
    var shortKey = getItemKey(shortList[i2], i2);
    var longKey = getItemKey(longList[i2], i2);
    if (shortKey !== longKey) {
      diffIndex = i2;
      multiple = multiple || shortKey !== getItemKey(longList[i2 + 1], i2 + 1);
      break;
    }
  }
  return diffIndex === null ? null : { index: diffIndex, multiple };
}
var __assign$1q = globalThis && globalThis.__assign || function() {
  __assign$1q = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1q.apply(this, arguments);
};
var Filler = function(_a) {
  var height = _a.height, offset = _a.offset, children = _a.children, propsOuterStyle = _a.outerStyle;
  var outerStyle = {};
  var innerStyle = {
    display: "flex",
    flexDirection: "column"
  };
  if (offset !== void 0) {
    outerStyle = __assign$1q({ height, position: "relative", overflow: "hidden", zIndex: 0 }, propsOuterStyle);
    innerStyle = __assign$1q(__assign$1q({}, innerStyle), { transform: "translateY(" + offset + "px)", position: "absolute", left: 0, right: 0, top: 0 });
  }
  return React.createElement("div", { style: outerStyle }, React.createElement("div", { style: innerStyle }, children));
};
var Filler$1 = Filler;
var __assign$1p = globalThis && globalThis.__assign || function() {
  __assign$1p = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1p.apply(this, arguments);
};
var __rest$E = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$10 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var DEFAULT_VIRTUAL_ITEM_HEIGHT = 32;
var KEY_VIRTUAL_ITEM_HEIGHT = "__virtual_item_height_" + Math.random().toFixed(5).slice(2);
var useComputeVirtualItemHeight = function(refItemHeightMap) {
  var forceUpdate = useForceUpdate();
  var heightMap = refItemHeightMap.current;
  useEffect(function() {
    if (Object.keys(heightMap).length && !heightMap[KEY_VIRTUAL_ITEM_HEIGHT]) {
      heightMap[KEY_VIRTUAL_ITEM_HEIGHT] = Object.entries(heightMap).reduce(function(sum, _a, currentIndex, array) {
        var _b = __read$10(_a, 2), currentHeight = _b[1];
        var nextSum = sum + currentHeight;
        return currentIndex === array.length - 1 ? Math.round(nextSum / array.length) : nextSum;
      }, 0);
      forceUpdate();
    }
  }, [Object.keys(heightMap).length]);
};
var useCacheChildrenNodes = function(children) {
  var refCacheMap = useRef({});
  var refPrevChildren = useRef(children);
  useEffect(function() {
    refPrevChildren.current = children;
  }, [children]);
  if (children !== refPrevChildren.current) {
    refCacheMap.current = {};
  }
  return function(item2, index2, props) {
    if (!refCacheMap.current.hasOwnProperty(index2)) {
      refCacheMap.current[index2] = children(item2, index2, props);
    }
    return refCacheMap.current[index2];
  };
};
var VirtualList = React__default.forwardRef(function(props, ref) {
  var style = props.style, className = props.className, children = props.children, _a = props.data, data = _a === void 0 ? [] : _a, itemKey = props.itemKey, _b = props.threshold, threshold = _b === void 0 ? 100 : _b, _c = props.wrapper, WrapperTagName = _c === void 0 ? "div" : _c, _d = props.height, propHeight = _d === void 0 ? "100%" : _d, _e = props.isStaticItemHeight, isStaticItemHeight = _e === void 0 ? true : _e, propItemHeight = props.itemHeight, measureLongestItem = props.measureLongestItem, scrollOptions = props.scrollOptions, onScroll = props.onScroll, _f = props.needFiller, needFiller = _f === void 0 ? true : _f, outerStyle = props.outerStyle, restProps = __rest$E(props, ["style", "className", "children", "data", "itemKey", "threshold", "wrapper", "height", "isStaticItemHeight", "itemHeight", "measureLongestItem", "scrollOptions", "onScroll", "needFiller", "outerStyle"]);
  var styleListMaxHeight = style && style.maxHeight || propHeight;
  var refItemHeightMap = useRef({});
  var _g = __read$10(useState(200), 2), stateHeight = _g[0], setStateHeight = _g[1];
  var renderChild = useCacheChildrenNodes(children);
  useComputeVirtualItemHeight(refItemHeightMap);
  var itemCount = data.length;
  var itemHeight = propItemHeight || refItemHeightMap.current[KEY_VIRTUAL_ITEM_HEIGHT] || DEFAULT_VIRTUAL_ITEM_HEIGHT;
  var viewportHeight = isNumber$1(styleListMaxHeight) ? styleListMaxHeight : stateHeight;
  var itemCountVisible = Math.ceil(viewportHeight / itemHeight);
  var itemTotalHeight = itemHeight * itemCount;
  var isVirtual = threshold !== null && itemCount >= threshold && itemTotalHeight > viewportHeight;
  var refList = useRef(null);
  var refRafId = useRef(null);
  var refLockScroll = useRef(false);
  var refIsVirtual = useRef(isVirtual);
  var scrollListPadding = useMemo(function() {
    if (refList.current) {
      var getPadding = function(property) {
        return +window.getComputedStyle(refList.current)[property].replace(/\D/g, "");
      };
      return {
        top: getPadding("paddingTop"),
        bottom: getPadding("paddingBottom")
      };
    }
    return { top: 0, bottom: 0 };
  }, [refList.current]);
  var _h = __read$10(useStateWithPromise({
    status: "NONE",
    startIndex: 0,
    endIndex: 0,
    itemIndex: 0,
    itemOffsetPtg: 0,
    startItemTop: 0,
    scrollTop: 0
  }), 2), state = _h[0], setState = _h[1];
  var prevData = usePrevious(data) || [];
  var isFirstRender = useIsFirstRender();
  var getItemKey = function(item2, index2) {
    return typeof itemKey === "function" ? itemKey(item2, index2) : typeof itemKey === "string" ? item2[itemKey] : item2.key || index2;
  };
  var getItemKeyByIndex = function(index2, items) {
    if (items === void 0) {
      items = data;
    }
    if (index2 === items.length) {
      return GHOST_ITEM_KEY;
    }
    var item2 = items[index2];
    return item2 !== void 0 ? getItemKey(item2, index2) : null;
  };
  var getCachedItemHeight = function(key) {
    return refItemHeightMap.current[key] || itemHeight;
  };
  var internalScrollTo = function(relativeScroll) {
    var compareItemIndex = relativeScroll.itemIndex, compareItemRelativeTop = relativeScroll.relativeTop;
    var _a2 = refList.current, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
    var originScrollTop = state.scrollTop;
    var maxScrollTop = scrollHeight - clientHeight;
    var bestSimilarity = Number.MAX_VALUE;
    var bestScrollTop = null;
    var bestItemIndex = null;
    var bestItemOffsetPtg = null;
    var bestStartIndex = null;
    var bestEndIndex = null;
    var missSimilarity = 0;
    for (var i2 = 0; i2 < maxScrollTop; i2++) {
      var scrollTop = getIndexByStartLoc(0, maxScrollTop, originScrollTop, i2);
      var scrollPtg = getScrollPercentage({ scrollTop, scrollHeight, clientHeight });
      var _b2 = getRangeIndex(scrollPtg, itemCount, itemCountVisible), itemIndex = _b2.itemIndex, itemOffsetPtg = _b2.itemOffsetPtg, startIndex = _b2.startIndex, endIndex = _b2.endIndex;
      if (startIndex <= compareItemIndex && compareItemIndex <= endIndex) {
        var locatedItemRelativeTop = getItemRelativeTop({
          itemHeight: getCachedItemHeight(getItemKeyByIndex(itemIndex)),
          itemOffsetPtg,
          clientHeight,
          scrollPtg
        });
        var compareItemTop = getCompareItemRelativeTop({
          locatedItemRelativeTop,
          locatedItemIndex: itemIndex,
          compareItemIndex,
          startIndex,
          endIndex,
          itemHeight,
          getItemKey: getItemKeyByIndex,
          itemElementHeights: refItemHeightMap.current
        });
        var similarity = Math.abs(compareItemTop - compareItemRelativeTop);
        if (similarity < bestSimilarity) {
          bestSimilarity = similarity;
          bestScrollTop = scrollTop;
          bestItemIndex = itemIndex;
          bestItemOffsetPtg = itemOffsetPtg;
          bestStartIndex = startIndex;
          bestEndIndex = endIndex;
          missSimilarity = 0;
        } else {
          missSimilarity += 1;
        }
      }
      if (missSimilarity > 10) {
        break;
      }
    }
    if (bestScrollTop !== null) {
      refLockScroll.current = true;
      refList.current.scrollTop = bestScrollTop;
      setState(__assign$1p(__assign$1p({}, state), { status: "MEASURE_START", scrollTop: bestScrollTop, itemIndex: bestItemIndex, itemOffsetPtg: bestItemOffsetPtg, startIndex: bestStartIndex, endIndex: bestEndIndex }));
    }
    refRafId.current = raf(function() {
      refLockScroll.current = false;
    });
  };
  var rawListScrollHandler = function(event2) {
    var _a2 = refList.current, rawScrollTop = _a2.scrollTop, clientHeight = _a2.clientHeight, scrollHeight = _a2.scrollHeight;
    var scrollTop = getValidScrollTop(rawScrollTop, scrollHeight - clientHeight);
    var scrollPtg = getScrollPercentage({
      scrollTop,
      clientHeight,
      scrollHeight
    });
    var _b2 = getLocationItem(scrollPtg, itemCount), index2 = _b2.index, offsetPtg = _b2.offsetPtg;
    setState(__assign$1p(__assign$1p({}, state), { scrollTop, itemIndex: index2, itemOffsetPtg: offsetPtg }));
    event2 && onScroll && onScroll(event2);
  };
  var virtualListScrollHandler = function(event2, isInit) {
    if (isInit === void 0) {
      isInit = false;
    }
    var _a2 = refList.current, rawScrollTop = _a2.scrollTop, clientHeight = _a2.clientHeight, scrollHeight = _a2.scrollHeight;
    var scrollTop = getValidScrollTop(rawScrollTop, scrollHeight - clientHeight);
    if (!isInit && (scrollTop === state.scrollTop || refLockScroll.current)) {
      return;
    }
    var scrollPtg = getScrollPercentage({
      scrollTop,
      clientHeight,
      scrollHeight
    });
    var _b2 = getRangeIndex(scrollPtg, itemCount, itemCountVisible), itemIndex = _b2.itemIndex, itemOffsetPtg = _b2.itemOffsetPtg, startIndex = _b2.startIndex, endIndex = _b2.endIndex;
    setState(__assign$1p(__assign$1p({}, state), { scrollTop, itemIndex, itemOffsetPtg, startIndex, endIndex, status: "MEASURE_START" }));
    event2 && onScroll && onScroll(event2);
  };
  useEffect(function() {
    return function() {
      refRafId.current && caf(refRafId.current);
    };
  }, []);
  useEffect(function() {
    if (refList.current) {
      if (isFirstRender) {
        refList.current.scrollTop = 0;
      }
      virtualListScrollHandler(null, true);
    }
  }, [itemCountVisible]);
  useEffect(function() {
    var changedItemIndex = null;
    var switchTo = refIsVirtual.current !== isVirtual ? isVirtual ? "virtual" : "raw" : "";
    refIsVirtual.current = isVirtual;
    if (viewportHeight && prevData.length !== data.length) {
      var diff = findListDiffIndex(prevData, data, getItemKey);
      changedItemIndex = diff ? diff.index : null;
    }
    if (switchTo || isVirtual && changedItemIndex) {
      var clientHeight = refList.current.clientHeight;
      var locatedItemRelativeTop = getItemRelativeTop({
        itemHeight: getCachedItemHeight(getItemKeyByIndex(state.itemIndex, prevData)),
        itemOffsetPtg: state.itemOffsetPtg,
        scrollPtg: getScrollPercentage({
          scrollTop: state.scrollTop,
          scrollHeight: prevData.length * itemHeight,
          clientHeight
        }),
        clientHeight
      });
      if (switchTo === "raw") {
        var rawTop = locatedItemRelativeTop;
        for (var index2 = 0; index2 < state.itemIndex; index2++) {
          rawTop -= getCachedItemHeight(getItemKeyByIndex(index2));
        }
        refList.current.scrollTop = -rawTop;
        refLockScroll.current = true;
        refRafId.current = raf(function() {
          refLockScroll.current = false;
        });
      } else {
        internalScrollTo({
          itemIndex: state.itemIndex,
          relativeTop: locatedItemRelativeTop
        });
      }
    }
  }, [data, isVirtual]);
  useIsomorphicLayoutEffect$1(function() {
    if (state.status === "MEASURE_START") {
      var _a2 = refList.current, scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
      var scrollPtg = getScrollPercentage({
        scrollTop,
        scrollHeight,
        clientHeight
      });
      var startItemTop = getItemAbsoluteTop({
        scrollPtg,
        clientHeight,
        scrollTop: scrollTop - (scrollListPadding.top + scrollListPadding.bottom) * scrollPtg,
        itemHeight: getCachedItemHeight(getItemKeyByIndex(state.itemIndex)),
        itemOffsetPtg: state.itemOffsetPtg
      });
      for (var index2 = state.itemIndex - 1; index2 >= state.startIndex; index2--) {
        startItemTop -= getCachedItemHeight(getItemKeyByIndex(index2));
      }
      setState(__assign$1p(__assign$1p({}, state), { startItemTop, status: "MEASURE_DONE" }));
    }
  }, [state]);
  useImperativeHandle(ref, function() {
    return {
      dom: refList.current,
      scrollTo: function(arg) {
        refRafId.current && caf(refRafId.current);
        refRafId.current = raf(function() {
          var _a2;
          if (typeof arg === "number") {
            refList.current.scrollTop = arg;
            return;
          }
          var index2 = "index" in arg ? arg.index : "key" in arg ? data.findIndex(function(item3, index3) {
            return getItemKey(item3, index3) === arg.key;
          }) : 0;
          var item2 = data[index2];
          if (!item2) {
            return;
          }
          var align = typeof arg === "object" && ((_a2 = arg.options) === null || _a2 === void 0 ? void 0 : _a2.block) ? arg.options.block : (scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.block) || "nearest";
          var _b2 = refList.current, clientHeight = _b2.clientHeight, scrollTop = _b2.scrollTop;
          if (isVirtual && !isStaticItemHeight) {
            if (align === "nearest") {
              var itemIndex = state.itemIndex, itemOffsetPtg = state.itemOffsetPtg;
              if (Math.abs(itemIndex - index2) < itemCountVisible) {
                var itemTop = getItemRelativeTop({
                  itemHeight: getCachedItemHeight(getItemKeyByIndex(itemIndex)),
                  itemOffsetPtg,
                  clientHeight,
                  scrollPtg: getScrollPercentage(refList.current)
                });
                if (index2 < itemIndex) {
                  for (var i2 = index2; i2 < itemIndex; i2++) {
                    itemTop -= getCachedItemHeight(getItemKeyByIndex(i2));
                  }
                } else {
                  for (var i2 = itemIndex; i2 < index2; i2++) {
                    itemTop += getCachedItemHeight(getItemKeyByIndex(i2));
                  }
                }
                if (itemTop < 0 || itemTop > clientHeight) {
                  align = itemTop < 0 ? "start" : "end";
                } else {
                  return;
                }
              } else {
                align = index2 < itemIndex ? "start" : "end";
              }
            }
            setState(__assign$1p(__assign$1p({}, state), { startIndex: Math.max(0, index2 - itemCountVisible), endIndex: Math.min(itemCount - 1, index2 + itemCountVisible) })).then(function() {
              var itemHeight2 = getCachedItemHeight(getItemKey(item2, index2));
              internalScrollTo({
                itemIndex: index2,
                relativeTop: align === "start" ? 0 : (clientHeight - itemHeight2) / (align === "center" ? 2 : 1)
              });
            });
          } else {
            var indexItemHeight = getCachedItemHeight(getItemKeyByIndex(index2));
            var itemTop = 0;
            for (var i2 = 0; i2 < index2; i2++) {
              itemTop += getCachedItemHeight(getItemKeyByIndex(i2));
            }
            var itemBottom = itemTop + indexItemHeight;
            if (align === "nearest") {
              if (itemTop < scrollTop) {
                align = "start";
              } else if (itemBottom > scrollTop + clientHeight) {
                align = "end";
              }
            }
            var viewportHeight_1 = clientHeight - indexItemHeight;
            refList.current.scrollTop = itemTop - (align === "start" ? 0 : viewportHeight_1 / (align === "center" ? 2 : 1));
          }
        });
      }
    };
  }, [data, itemHeight, state]);
  var renderChildren = function(list2, startIndex) {
    return list2.map(function(item2, index2) {
      var originIndex = startIndex + index2;
      var node = renderChild(item2, originIndex, {
        style: {}
      });
      var key = getItemKey(item2, originIndex);
      return React__default.cloneElement(node, {
        key,
        ref: function(ele) {
          var heightMap = refItemHeightMap.current;
          if (ele && state.status === "MEASURE_START" && (!isStaticItemHeight || heightMap[key] === void 0)) {
            if (isStaticItemHeight) {
              if (!heightMap[KEY_VIRTUAL_ITEM_HEIGHT]) {
                heightMap[KEY_VIRTUAL_ITEM_HEIGHT] = getNodeHeight(ele);
              }
              heightMap[key] = heightMap[KEY_VIRTUAL_ITEM_HEIGHT];
            } else {
              heightMap[key] = getNodeHeight(ele);
            }
          }
        }
      });
    });
  };
  var refLongestItemIndex = useRef(null);
  useEffect(function() {
    refLongestItemIndex.current = null;
  }, [data]);
  var renderLongestItem = function() {
    if (measureLongestItem) {
      var index2 = refLongestItemIndex.current === null ? getLongestItemIndex(data) : refLongestItemIndex.current;
      var item2 = data[index2];
      refLongestItemIndex.current = index2;
      return item2 ? React__default.createElement("div", { style: { height: 1, overflow: "hidden", opacity: 0 } }, renderChild(item2, index2, { style: {} })) : null;
    }
    return null;
  };
  return React__default.createElement(ResizeObserver, { onResize: function() {
    if (refList.current && !isNumber$1(styleListMaxHeight)) {
      var clientHeight = refList.current.clientHeight;
      setStateHeight(clientHeight);
    }
  } }, React__default.createElement(WrapperTagName, __assign$1p({ ref: refList, style: __assign$1p(__assign$1p({ overflowY: "auto", overflowAnchor: "none" }, style), { maxHeight: styleListMaxHeight }), className, onScroll: isVirtual ? virtualListScrollHandler : rawListScrollHandler }, restProps), isVirtual ? React__default.createElement(React__default.Fragment, null, React__default.createElement(Filler$1, { height: itemTotalHeight, offset: state.status === "MEASURE_DONE" ? state.startItemTop : 0, outerStyle }, renderChildren(data.slice(state.startIndex, state.endIndex + 1), state.startIndex)), renderLongestItem()) : needFiller ? React__default.createElement(Filler$1, { height: viewportHeight }, renderChildren(data, 0)) : renderChildren(data, 0)));
});
VirtualList.displayName = "VirtualList";
var VirtualList$1 = VirtualList;
var isArray$b = Array.isArray;
var isArray_1 = isArray$b;
var isArray$a = isArray_1, isSymbol$2 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$1(value, object) {
  if (isArray$a(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$2(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$1;
var baseGetTag$4 = _baseGetTag, isObject$9 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$4(value) {
  if (!isObject$9(value)) {
    return false;
  }
  var tag = baseGetTag$4(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$4;
var root$6 = _root;
var coreJsData$1 = root$6["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$3 = isFunction_1, isMasked = _isMasked, isObject$8 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$e = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$d = objectProto$e.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$d).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value) {
  if (!isObject$8(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$3(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative;
var nativeCreate$4 = getNative$6(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$d = Object.prototype;
var hasOwnProperty$c = objectProto$d.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$c.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$c = Object.prototype;
var hasOwnProperty$b = objectProto$c.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$b.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$5(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$5;
var eq$4 = eq_1;
function assocIndexOf$4(array, key) {
  var length2 = array.length;
  while (length2--) {
    if (eq$4(array[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var getNative$5 = _getNative, root$5 = _root;
var Map$4 = getNative$5(root$5, "Map");
var _Map = Map$4;
var Hash = _Hash, ListCache$3 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$3)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var MapCache$2 = _MapCache;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache$2)();
  return memoized;
}
memoize$1.Cache = MapCache$2;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath$1;
function arrayMap$2(array, iteratee) {
  var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
  while (++index2 < length2) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var _arrayMap = arrayMap$2;
var Symbol$4 = _Symbol, arrayMap$1 = _arrayMap, isArray$9 = isArray_1, isSymbol$1 = isSymbol_1;
var INFINITY$1 = 1 / 0;
var symbolProto$2 = Symbol$4 ? Symbol$4.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$9(value)) {
    return arrayMap$1(value, baseToString$1) + "";
  }
  if (isSymbol$1(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$1(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$1;
var isArray$8 = isArray_1, isKey = _isKey, stringToPath = _stringToPath, toString = toString_1;
function castPath$5(value, object) {
  if (isArray$8(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}
var _castPath = castPath$5;
var isSymbol = isSymbol_1;
var INFINITY = 1 / 0;
function toKey$4(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _toKey = toKey$4;
var castPath$4 = _castPath, toKey$3 = _toKey;
function baseGet$2(object, path) {
  path = castPath$4(path, object);
  var index2 = 0, length2 = path.length;
  while (object != null && index2 < length2) {
    object = object[toKey$3(path[index2++])];
  }
  return index2 && index2 == length2 ? object : void 0;
}
var _baseGet = baseGet$2;
var baseGet$1 = _baseGet;
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet$1(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get;
function getHighlightText(_a) {
  var nodeList = _a.nodeList, pattern = _a.pattern, highlightClassName = _a.highlightClassName;
  if (!pattern) {
    return nodeList;
  }
  var transformNode = function(node) {
    if (node && node.props && typeof node.props.children === "string") {
      return cloneElement(node, void 0, React__default.createElement(HighlightText, { text: node.props.children, keyword: pattern, highlightClassName }));
    }
    return node;
  };
  return isArray$c(nodeList) ? nodeList.map(function(node) {
    return transformNode(node);
  }) : transformNode(nodeList);
}
function HighlightText(_a) {
  var text = _a.text, keyword = _a.keyword, highlightClassName = _a.highlightClassName;
  if (!keyword)
    return React__default.createElement(React__default.Fragment, null, text);
  var re = new RegExp("(" + lodash.exports.escapeRegExp(keyword) + ")", "i");
  var strArr = text.split(re);
  return React__default.createElement(React__default.Fragment, null, strArr.map(function(item2, index2) {
    return re.test(item2) ? React__default.createElement("span", { key: index2, className: highlightClassName }, item2) : React__default.createElement("span", { key: index2 }, item2);
  }));
}
var __assign$1o = globalThis && globalThis.__assign || function() {
  __assign$1o = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1o.apply(this, arguments);
};
function preventDefaultEvent(e) {
  e && e.preventDefault();
}
function isEmptyValue$2(value, isMultiple) {
  return isMultiple ? !isArray$c(value) || !value.length : value === void 0;
}
function getValidValue(value, isMultiple, labelInValue) {
  if (labelInValue) {
    if (isMultiple) {
      value = Array.isArray(value) ? value.map(function(item2) {
        return isObject$e(item2) && "label" in item2 ? item2.value : item2;
      }) : value;
    } else {
      value = isObject$e(value) && "label" in value ? value.value : value;
    }
  }
  return isEmptyValue$2(value, isMultiple) ? isMultiple ? Array.isArray(value) ? value : [] : void 0 : value;
}
function isSelectOption(child) {
  return get_1(child, "props.isSelectOption");
}
function isSelectOptGroup(child) {
  return get_1(child, "props.isSelectOptGroup");
}
function flatChildren(_a, _b, _c) {
  var children = _a.children, options2 = _a.options, filterOption = _a.filterOption;
  var _d = _b.inputValue, inputValue = _d === void 0 ? "" : _d, userCreatedOptions = _b.userCreatedOptions, userCreatingOption = _b.userCreatingOption, prefixCls2 = _b.prefixCls;
  var _e = _c === void 0 ? {} : _c, _f = _e.optionInfoMap, optionInfoMap = _f === void 0 ? new Map() : _f, _g = _e.optionValueList, optionValueList = _g === void 0 ? [] : _g, _h = _e.customNodeCount, customNodeCount = _h === void 0 ? 0 : _h;
  var hasOptGroup = false;
  var hasComplexLabelInOptions = false;
  var childrenList = [];
  var optionIndexListForArrowKey = [];
  var getChildValue = function(child) {
    var propValue = get_1(child, "props.value");
    return propValue === void 0 ? child.props.children.toString() : propValue;
  };
  var getChildKey = function(_a2, key, isGroupTitle) {
    var label = _a2.label, value = _a2.value;
    if (!label && !value && !key) {
      customNodeCount++;
      return "custom_node_" + customNodeCount;
    }
    return isGroupTitle ? key || "group_" + label : key || typeof value + "_" + value || label + "_" + optionInfoMap.size;
  };
  var handleOption = function(child, origin) {
    var optionValue = getChildValue(child);
    var isValidOption = true;
    if (filterOption === true) {
      isValidOption = optionValue !== void 0 && String(optionValue).toLowerCase().indexOf(inputValue.toLowerCase()) !== -1;
    } else if (typeof filterOption === "function") {
      isValidOption = !inputValue || filterOption(inputValue, child);
    }
    if (!optionInfoMap.get(optionValue)) {
      if (!("_key" in child.props)) {
        child = React__default.cloneElement(child, {
          _key: getChildKey(child.props, child.key)
        });
      }
      var index2 = optionInfoMap.size;
      var option = __assign$1o(__assign$1o({ child }, child.props), { value: optionValue, _index: index2, _origin: origin, _valid: isValidOption });
      optionInfoMap.set(optionValue, option);
      optionValueList.push(optionValue);
      if (isValidOption) {
        childrenList.push(child);
        if (!option.disabled) {
          optionIndexListForArrowKey.push(index2);
        }
      }
    }
    if (typeof child.props.children !== "string") {
      hasComplexLabelInOptions = true;
    }
  };
  var extendChildren = function(arr, origin) {
    if (origin && isArray$c(arr) && arr.length) {
      arr.forEach(function(option) {
        option = isString$1(option) || isNumber$1(option) ? {
          label: option,
          value: option
        } : option;
        var child = React__default.createElement(Option$3, { _key: getChildKey(option), value: option.value, disabled: option.disabled === true, extra: option.extra }, option.label);
        handleOption(child, origin);
      });
    }
  };
  if (userCreatingOption) {
    extendChildren([userCreatingOption], "userCreatingOption");
  }
  if (children) {
    React__default.Children.map(children, function(child) {
      if (isSelectOptGroup(child)) {
        var _a2 = child.props, children_1 = _a2.children, options_1 = _a2.options;
        var _b2 = flatChildren({ children: children_1, options: options_1, filterOption }, { inputValue, prefixCls: prefixCls2 }, { optionInfoMap, optionValueList, customNodeCount }), _childrenList = _b2.childrenList, _optionIndexListForArrowKey = _b2.optionIndexListForArrowKey, _hasComplexLabelInOptions = _b2.hasComplexLabelInOptions;
        if (_childrenList.length) {
          childrenList.push(React__default.cloneElement(child, {
            children: null,
            _key: getChildKey(child.props, child.key, true)
          }));
          childrenList = childrenList.concat(_childrenList);
          optionIndexListForArrowKey = optionIndexListForArrowKey.concat(_optionIndexListForArrowKey);
          hasOptGroup = true;
          hasComplexLabelInOptions = hasComplexLabelInOptions || _hasComplexLabelInOptions;
        }
      } else if (isSelectOption(child)) {
        handleOption(child, "children");
      } else if (isObject$e(child) && child.props) {
        childrenList.push(React__default.cloneElement(child, {
          _key: getChildKey(child.props, child.key)
        }));
      }
    });
  }
  extendChildren(options2, "options");
  extendChildren(userCreatedOptions, "userCreatedOptions");
  return {
    childrenList: getHighlightText({
      nodeList: childrenList,
      pattern: inputValue,
      highlightClassName: prefixCls2 + "-highlight"
    }),
    optionInfoMap,
    optionValueList,
    optionIndexListForArrowKey,
    hasOptGroup,
    hasComplexLabelInOptions
  };
}
var __assign$1n = globalThis && globalThis.__assign || function() {
  __assign$1n = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1n.apply(this, arguments);
};
var __read$$ = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __values$1 = globalThis && globalThis.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i2 >= o.length)
          o = void 0;
        return { value: o && o[i2++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __spreadArray$s = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var THRESHOLD_TOKEN_SEPARATOR_TRIGGER = 100;
var globalSelectIndex = 0;
var defaultProps$s = {
  trigger: "click",
  bordered: true,
  filterOption: true,
  unmountOnExit: true,
  defaultActiveFirstOption: true
};
function Select$1(baseProps, ref) {
  var _a = useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, renderEmpty2 = _a.renderEmpty, componentConfig2 = _a.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$s, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Select);
  var children = props.children, renderFormat = props.renderFormat, defaultActiveFirstOption = props.defaultActiveFirstOption, disabled = props.disabled, unmountOnExit = props.unmountOnExit, notFoundContent = props.notFoundContent, showSearch = props.showSearch, tokenSeparators = props.tokenSeparators, options2 = props.options, filterOption = props.filterOption, labelInValue = props.labelInValue, getPopupContainer = props.getPopupContainer, trigger = props.trigger, triggerElement = props.triggerElement, triggerProps = props.triggerProps, dropdownRender = props.dropdownRender, dropdownMenuStyle = props.dropdownMenuStyle, dropdownMenuClassName = props.dropdownMenuClassName, virtualListProps = props.virtualListProps, onChange = props.onChange, onDeselect = props.onDeselect, onClear = props.onClear, onSearch = props.onSearch, onFocus3 = props.onFocus, onBlur3 = props.onBlur, onPopupScroll = props.onPopupScroll, onVisibleChange = props.onVisibleChange, onInputValueChange = props.onInputValueChange, onPaste = props.onPaste;
  var mode = props.mode, allowCreate = props.allowCreate;
  if (mode === "tags") {
    mode = "multiple";
    allowCreate = true;
  }
  var prefixCls2 = getPrefixCls("select");
  var isMultipleMode = mode === "multiple";
  var _b = __read$$(useState(getValidValue(props.defaultValue, isMultipleMode, labelInValue)), 2), stateValue = _b[0], setValue = _b[1];
  var value = "value" in props ? getValidValue(props.value, isMultipleMode, labelInValue) : stateValue;
  var _c = __read$$(useMergeValue("", {
    value: "inputValue" in props ? props.inputValue || "" : void 0
  }), 3), inputValue = _c[0], setInputValue = _c[1], stateInputValue = _c[2];
  var _d = __read$$(useMergeValue(false, {
    defaultValue: props.defaultPopupVisible,
    value: "popupVisible" in props ? props.popupVisible : triggerProps && "popupVisible" in triggerProps ? triggerProps.popupVisible : void 0
  }), 2), popupVisible = _d[0], setPopupVisible = _d[1];
  var _e = __read$$(useState(null), 2), userCreatingOption = _e[0], setUserCreatingOption = _e[1];
  var _f = __read$$(useState([]), 2), userCreatedOptions = _f[0], setUserCreatedOptions = _f[1];
  var _g = __read$$(useState(isArray$c(value) ? value[0] : value), 2), valueActive = _g[0], setValueActive = _g[1];
  var _h = useMemo(function() {
    return flatChildren({ children, options: options2, filterOption }, {
      prefixCls: prefixCls2,
      inputValue,
      userCreatedOptions,
      userCreatingOption
    });
  }, [children, options2, filterOption, inputValue, userCreatingOption, userCreatedOptions]), childrenList = _h.childrenList, optionInfoMap = _h.optionInfoMap, optionValueList = _h.optionValueList, optionIndexListForArrowKey = _h.optionIndexListForArrowKey, hasOptGroup = _h.hasOptGroup, hasComplexLabelInOptions = _h.hasComplexLabelInOptions;
  var refWrapper = useRef(null);
  var refTrigger = useRef(null);
  var refSelectView = useRef(null);
  var refValueMap = useRef([]);
  var refKeyboardArrowDirection = useRef(null);
  var refOnInputChangeCallbackValue = useRef(inputValue);
  var refOnInputChangeCallbackReason = useRef(null);
  var refTSLastSeparateTriggered = useRef(0);
  var instancePopupID = useMemo(function() {
    var id = prefixCls2 + "-popup-" + globalSelectIndex;
    globalSelectIndex++;
    return id;
  }, []);
  var isNoOptionSelected = isEmptyValue$2(value, isMultipleMode);
  var valueActiveDefault = defaultActiveFirstOption ? optionValueList[optionIndexListForArrowKey[0]] : void 0;
  var scrollIntoView2 = function(optionValue) {
    var _a2;
    var activeOption = optionInfoMap.get(optionValue);
    if (refWrapper.current && ((_a2 = activeOption === null || activeOption === void 0 ? void 0 : activeOption.child) === null || _a2 === void 0 ? void 0 : _a2.props)) {
      refWrapper.current.scrollTo({ key: activeOption.child.props._key });
    }
  };
  var tryUpdateInputValue = function(value2, reason) {
    if (value2 !== refOnInputChangeCallbackValue.current) {
      setInputValue(value2);
      refOnInputChangeCallbackValue.current = value2;
      refOnInputChangeCallbackReason.current = reason;
      onInputValueChange && onInputValueChange(value2, reason);
    }
  };
  var tryUpdatePopupVisible = function(value2) {
    if (popupVisible !== value2) {
      setPopupVisible(value2);
      onVisibleChange && onVisibleChange(value2);
      triggerProps && triggerProps.onVisibleChange && triggerProps.onVisibleChange(value2);
    }
  };
  useEffect(function() {
    if (isMultipleMode) {
      if (!Array.isArray(value)) {
        setValue(value === void 0 ? [] : [value]);
      }
    } else if (Array.isArray(value)) {
      setValue(value.length === 0 ? void 0 : value[0]);
    }
  }, [isMultipleMode, value]);
  useEffect(function() {
    if (popupVisible) {
      var firstValue = isArray$c(value) ? value[0] : value;
      var nextValueActive_1 = !isNoOptionSelected && optionInfoMap.has(firstValue) ? firstValue : valueActiveDefault;
      setValueActive(nextValueActive_1);
      setTimeout(function() {
        return scrollIntoView2(nextValueActive_1);
      });
    } else {
      tryUpdateInputValue("", "optionListHide");
    }
  }, [popupVisible]);
  useEffect(function() {
    if (refKeyboardArrowDirection.current === "up" || refKeyboardArrowDirection.current === "down") {
      scrollIntoView2(valueActive);
      refKeyboardArrowDirection.current = "none";
    }
  }, [valueActive]);
  useEffect(function() {
    setValueActive(valueActiveDefault);
  }, [JSON.stringify(childrenList.map(function(child) {
    var _a2;
    return (_a2 = child === null || child === void 0 ? void 0 : child.props) === null || _a2 === void 0 ? void 0 : _a2.value;
  }))]);
  useEffect(function() {
    refValueMap.current = refValueMap.current.filter(function(x) {
      return isMultipleMode ? isArray$c(value) && value.indexOf(x.value) > -1 : x.value === value;
    });
  }, [value, isMultipleMode]);
  useEffect(function() {
    if (allowCreate && Array.isArray(value)) {
      var newUserCreatedOptions = value.filter(function(v) {
        var _a2;
        var option = optionInfoMap.get(v) || ((_a2 = refValueMap.current.find(function(item2) {
          return item2.value === v;
        })) === null || _a2 === void 0 ? void 0 : _a2.option);
        return !option || option._origin === "userCreatingOption";
      });
      var validUserCreatedOptions = userCreatedOptions.filter(function(tag) {
        return value.indexOf(tag) !== -1;
      });
      var _userCreatedOptions = validUserCreatedOptions.concat(newUserCreatedOptions);
      if (_userCreatedOptions.toString() !== userCreatedOptions.toString()) {
        setUserCreatedOptions(_userCreatedOptions);
      }
    }
  }, [value]);
  useEffect(function() {
    if (allowCreate) {
      setUserCreatingOption(optionInfoMap.has(inputValue) ? null : inputValue);
    }
  }, [inputValue]);
  useEffect(function() {
    var reason = refOnInputChangeCallbackReason.current;
    if (stateInputValue === inputValue && (reason === "manual" || reason === "optionListHide")) {
      onSearch && onSearch(inputValue, reason);
    }
  }, [inputValue]);
  var getOptionInfoByValue = function(value2) {
    var option = optionInfoMap.get(value2);
    if (option) {
      var index2 = refValueMap.current.findIndex(function(item3) {
        return item3.value === value2;
      });
      if (index2 > -1) {
        refValueMap.current.splice(index2, 1, { value: value2, option });
      } else {
        refValueMap.current.push({ value: value2, option });
      }
      return option;
    }
    var item2 = refValueMap.current.find(function(x) {
      return x.value === value2;
    });
    return item2 && item2.option;
  };
  var getValueActive = function(direction) {
    if (!optionIndexListForArrowKey.length) {
      return void 0;
    }
    if (valueActive === void 0 || !optionInfoMap.has(valueActive)) {
      return optionValueList[optionIndexListForArrowKey[0]];
    }
    var activeOption = optionInfoMap.get(valueActive);
    var activeIndex = activeOption._index;
    var _index = optionIndexListForArrowKey.indexOf(activeIndex);
    var _length = optionIndexListForArrowKey.length;
    return optionValueList[optionIndexListForArrowKey[((direction === "up" ? _index - 1 : _index + 1) + _length) % _length]];
  };
  var getValueAndOptionForCallback = function(stateValue2, isEmpty) {
    if (isEmpty === void 0) {
      isEmpty = isEmptyValue$2(stateValue2, isMultipleMode);
    }
    var value2 = stateValue2;
    var option = stateValue2 === void 0 ? void 0 : Array.isArray(stateValue2) ? stateValue2.map(getOptionInfoByValue) : getOptionInfoByValue(stateValue2);
    if (labelInValue && !isEmpty) {
      var getOptionLabel_1 = function(optionValue, optionInfo) {
        var e_1, _a2;
        if (optionInfo) {
          return optionInfo.children;
        }
        var propValue = "value" in props ? props.value : "defaultValue" in props ? props.defaultValue : null;
        if (Array.isArray(propValue)) {
          try {
            for (var propValue_1 = __values$1(propValue), propValue_1_1 = propValue_1.next(); !propValue_1_1.done; propValue_1_1 = propValue_1.next()) {
              var item2 = propValue_1_1.value;
              if (isObject$e(item2) && item2.value === optionValue) {
                return item2.label;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (propValue_1_1 && !propValue_1_1.done && (_a2 = propValue_1.return))
                _a2.call(propValue_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else if (isObject$e(propValue) && propValue.value === optionValue) {
          return propValue.label;
        }
      };
      if (Array.isArray(stateValue2)) {
        value2 = stateValue2.map(function(optionValue, index2) {
          return {
            value: optionValue,
            label: getOptionLabel_1(optionValue, option[index2])
          };
        });
      } else {
        value2 = { value: stateValue2, label: getOptionLabel_1(stateValue2, option) };
      }
    }
    return { option, value: value2 };
  };
  var tryUpdateSelectValue = function(value2) {
    setValue(value2);
    if (onChange) {
      var paramsForCallback = getValueAndOptionForCallback(value2);
      onChange(paramsForCallback.value, paramsForCallback.option);
    }
  };
  var checkOption = function(valueToAdd) {
    var option = optionInfoMap.get(valueToAdd);
    if (option) {
      var newValue = value.concat(valueToAdd);
      tryUpdateSelectValue(newValue);
    }
  };
  var uncheckOption = function(valueToRemove) {
    var newValue = value.filter(function(v) {
      return v !== valueToRemove;
    });
    tryUpdateSelectValue(newValue);
    if (onDeselect) {
      var paramsForCallback = getValueAndOptionForCallback(valueToRemove, false);
      onDeselect(paramsForCallback.value, paramsForCallback.option);
    }
  };
  var handleOptionClick = function(optionValue, disabled2) {
    if (disabled2) {
      return;
    }
    if (isMultipleMode) {
      value.indexOf(optionValue) === -1 ? checkOption(optionValue) : uncheckOption(optionValue);
      if (!isObject$e(showSearch) || !showSearch.retainInputValueWhileSelect) {
        tryUpdateInputValue("", "optionChecked");
      }
    } else {
      if (optionValue !== value) {
        tryUpdateSelectValue(optionValue);
      }
      setTimeout(function() {
        tryUpdatePopupVisible(false);
      });
    }
  };
  var hotkeyHandler = getHotkeyHandler(new Map([
    [Esc.code, function() {
      return tryUpdatePopupVisible(false);
    }],
    [
      Enter.code,
      function() {
        if (popupVisible) {
          var option = optionInfoMap.get(valueActive);
          option && handleOptionClick(valueActive, option.disabled);
        } else {
          tryUpdatePopupVisible(true);
        }
      }
    ],
    [
      Tab.code,
      function() {
        return tryUpdatePopupVisible(false);
      }
    ],
    [
      ArrowUp.code,
      function() {
        if (popupVisible) {
          refKeyboardArrowDirection.current = "up";
          setValueActive(getValueActive("up"));
          return false;
        }
      }
    ],
    [
      ArrowDown.code,
      function() {
        if (popupVisible) {
          refKeyboardArrowDirection.current = "down";
          setValueActive(getValueActive("down"));
          return false;
        }
      }
    ]
  ]));
  var renderPopup = function() {
    var _a2;
    var needMeasureLongestItem = (triggerProps === null || triggerProps === void 0 ? void 0 : triggerProps.autoAlignPopupWidth) === false;
    var needForbidVirtual = needMeasureLongestItem && hasComplexLabelInOptions;
    var mergedNotFoundContent = "notFoundContent" in props ? notFoundContent : renderEmpty2("Select");
    var eleOptionList = childrenList.length ? React__default.createElement(VirtualList$1, __assign$1n({ id: instancePopupID, role: "listbox", style: dropdownMenuStyle, className: cs$1(prefixCls2 + "-popup-inner", dropdownMenuClassName), ref: refWrapper, data: childrenList, height: null, isStaticItemHeight: !hasOptGroup, measureLongestItem: needMeasureLongestItem, itemKey: function(child) {
      return child.props._key;
    }, onMouseDown: preventDefaultEvent, onMouseMove: function() {
      refKeyboardArrowDirection.current = null;
    }, onScroll: function(e) {
      return onPopupScroll && onPopupScroll(e.target);
    } }, virtualListProps, { threshold: needForbidVirtual ? null : virtualListProps === null || virtualListProps === void 0 ? void 0 : virtualListProps.threshold }), function(child) {
      var _a3;
      if (isSelectOptGroup(child)) {
        return React__default.createElement(child.type, __assign$1n({}, child.props, { prefixCls: prefixCls2 }));
      }
      if (isSelectOption(child)) {
        var optionValue = (_a3 = child.props) === null || _a3 === void 0 ? void 0 : _a3.value;
        var optionProps = {
          prefixCls: prefixCls2,
          _valueActive: valueActive,
          _valueSelect: value,
          _isMultipleMode: isMultipleMode,
          _isUserCreatingOption: allowCreate && userCreatingOption === optionValue,
          _isUserCreatedOption: allowCreate && userCreatedOptions.indexOf(optionValue) > -1,
          _onClick: handleOptionClick,
          _onMouseEnter: function(value2) {
            refKeyboardArrowDirection.current === null && setValueActive(value2);
          },
          _onMouseLeave: function() {
            refKeyboardArrowDirection.current === null && setValueActive(void 0);
          }
        };
        return child && React__default.createElement(child.type, __assign$1n({}, child.props, optionProps));
      }
      return child;
    }) : null;
    var eleNoOptionPlaceholder = mergedNotFoundContent ? React__default.createElement("div", { style: dropdownMenuStyle, className: cs$1(prefixCls2 + "-popup-inner", dropdownMenuClassName) }, mergedNotFoundContent) : null;
    return React__default.createElement("div", { className: cs$1(prefixCls2 + "-popup", (_a2 = {}, _a2[prefixCls2 + "-popup-hidden"] = eleOptionList === null && eleNoOptionPlaceholder === null, _a2[prefixCls2 + "-popup-multiple"] = isMultipleMode, _a2)) }, typeof dropdownRender === "function" ? dropdownRender(eleOptionList || eleNoOptionPlaceholder) : eleOptionList || eleNoOptionPlaceholder);
  };
  var handleTokenSeparators = function(str) {
    var hasSeparator = false;
    if (isMultipleMode && isArray$c(tokenSeparators) && tokenSeparators.length) {
      var rawValues_1 = str.split(new RegExp("[" + tokenSeparators.join("") + "]"));
      if (rawValues_1.length > 1) {
        var splitValues = rawValues_1.filter(function(v, index2) {
          return v && rawValues_1.indexOf(v) === index2;
        });
        var newValue_1 = value.slice(0);
        var needUpdate_1 = false;
        splitValues.forEach(function(v) {
          if (newValue_1.indexOf(v) === -1 && (allowCreate || optionInfoMap.get(v))) {
            newValue_1.push(v);
            needUpdate_1 = true;
          }
        });
        if (needUpdate_1) {
          tryUpdateSelectValue(newValue_1);
        }
        hasSeparator = true;
      }
    }
    return hasSeparator;
  };
  var selectViewEventHandlers = {
    onFocus: onFocus3,
    onBlur: function(event2) {
      onBlur3 && onBlur3(event2);
      !popupVisible && tryUpdateInputValue("", "optionListHide");
    },
    onKeyDown: function(event2) {
      if (event2.target.tagName === "INPUT" && event2.target.value) {
        var isTab = event2.key === Tab.key;
        var isEnter = event2.key === Enter.key;
        if (isEnter || isTab) {
          var suffix = isEnter ? "\n" : isTab ? "	" : "";
          if (handleTokenSeparators(event2.target.value + suffix)) {
            refTSLastSeparateTriggered.current = Date.now();
            tryUpdateInputValue("", "tokenSeparator");
          }
        }
      }
      hotkeyHandler(event2);
    },
    onChangeInputValue: function(value2, _a2) {
      var inputType = _a2.nativeEvent.inputType;
      if (inputType === "insertFromPaste" && Date.now() - refTSLastSeparateTriggered.current < THRESHOLD_TOKEN_SEPARATOR_TRIGGER || handleTokenSeparators(value2)) {
        tryUpdateInputValue("", "tokenSeparator");
      } else {
        tryUpdateInputValue(value2, "manual");
      }
      if (!popupVisible && value2) {
        tryUpdatePopupVisible(true);
      }
    },
    onPaste: function(e) {
      if (handleTokenSeparators(e.clipboardData.getData("text"))) {
        refTSLastSeparateTriggered.current = Date.now();
      }
      onPaste && onPaste(e);
    },
    onRemoveCheckedItem: function(_, index2, event2) {
      event2.stopPropagation();
      uncheckOption(value[index2]);
    },
    onClear: function(event2) {
      event2.stopPropagation();
      if (isMultipleMode) {
        var newValue = value.filter(function(v) {
          var item2 = optionInfoMap.get(v);
          return item2 && item2.disabled;
        });
        tryUpdateSelectValue(newValue);
      } else {
        tryUpdateSelectValue(void 0);
      }
      tryUpdateInputValue("", "manual");
      onClear && onClear(popupVisible);
    }
  };
  useImperativeHandle(ref, function() {
    var _a2;
    return {
      dom: (_a2 = refSelectView.current) === null || _a2 === void 0 ? void 0 : _a2.dom,
      focus: function() {
        refSelectView.current && refSelectView.current.focus();
      },
      blur: function() {
        refSelectView.current && refSelectView.current.blur();
      },
      hotkeyHandler,
      activeOptionValue: valueActive,
      getOptionInfoByValue,
      getOptionInfoList: function() {
        return __spreadArray$s([], __read$$(optionInfoMap.values()), false).filter(function(info2) {
          return info2._valid;
        });
      }
    };
  }, [hotkeyHandler, optionInfoMap, valueActive]);
  return React__default.createElement(ResizeObserver, { onResize: function() {
    return refTrigger.current.updatePopupPosition();
  } }, React__default.createElement(Trigger$1, __assign$1n({ ref: function(ref2) {
    return refTrigger.current = ref2;
  }, popup: renderPopup, trigger, disabled, getPopupContainer, classNames: "slideDynamicOrigin", autoAlignPopupWidth: true, popupAlign: { bottom: 4 }, popupVisible, unmountOnExit, onVisibleChange: tryUpdatePopupVisible }, omit$1(triggerProps, ["popupVisible", "onVisibleChange"])), typeof triggerElement === "function" ? function() {
    return triggerElement(getValueAndOptionForCallback(value));
  }() : triggerElement || React__default.createElement(SelectView$1, __assign$1n({}, props, selectViewEventHandlers, {
    ref: refSelectView,
    value,
    inputValue,
    popupVisible,
    prefixCls: prefixCls2,
    ariaControls: instancePopupID,
    isEmptyValue: isNoOptionSelected,
    isMultiple: isMultipleMode,
    onSort: tryUpdateSelectValue,
    renderText: function(value2) {
      var option = getOptionInfoByValue(value2);
      var text = value2;
      if (isFunction$5(renderFormat)) {
        var paramsForCallback = getValueAndOptionForCallback(value2, false);
        text = renderFormat(paramsForCallback.option || null, paramsForCallback.value);
      } else {
        var foundLabelFromProps = false;
        if (labelInValue) {
          var propValue = props.value || props.defaultValue;
          if (Array.isArray(propValue)) {
            var targetLabeledValue = propValue.find(function(item2) {
              return isObject$e(item2) && item2.value === value2;
            });
            if (targetLabeledValue) {
              text = targetLabeledValue.label;
              foundLabelFromProps = true;
            }
          } else if (isObject$e(propValue)) {
            text = propValue.label;
            foundLabelFromProps = true;
          }
        }
        if (!foundLabelFromProps && option && "children" in option) {
          text = option.children;
        }
      }
      return {
        text,
        disabled: option && option.disabled
      };
    }
  }))));
}
var ForwardRefSelect = React__default.forwardRef(Select$1);
var SelectComponent = ForwardRefSelect;
SelectComponent.displayName = "Select";
SelectComponent.Option = Option$3;
SelectComponent.OptGroup = OptGroup$1;
var Select$2 = SelectComponent;
var __assign$1m = globalThis && globalThis.__assign || function() {
  __assign$1m = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1m.apply(this, arguments);
};
var __read$_ = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var IMPOSSIBLE_VALUE = "Autocomplete_" + Math.random();
var Option$1 = Select$2.Option;
var defaultProps$r = {
  defaultActiveFirstOption: true,
  triggerElement: React__default.createElement(Input$5, null)
};
function AutoComplete$1(baseProps, ref) {
  var _a = useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, componentConfig2 = _a.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$r, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.AutoComplete);
  var style = props.style, className = props.className, children = props.children, data = props.data, defaultValue = props.defaultValue, propValue = props.value, placeholder = props.placeholder, error2 = props.error, disabled = props.disabled, strict = props.strict, allowClear = props.allowClear, loading = props.loading, defaultActiveFirstOption = props.defaultActiveFirstOption, triggerElement = props.triggerElement, getPopupContainer = props.getPopupContainer, dropdownRender = props.dropdownRender, virtualListProps = props.virtualListProps, onFocus3 = props.onFocus, onBlur3 = props.onBlur, onChange = props.onChange, onSearch = props.onSearch, onSelect = props.onSelect, onPressEnter = props.onPressEnter, inputProps = props.inputProps;
  var _b = __read$_(useMergeValue("", {
    defaultValue,
    value: propValue
  }), 2), value = _b[0], setValue = _b[1];
  var _c = __read$_(useState(false), 2), isFocused = _c[0], setIsFocused = _c[1];
  var refInput = useRef(null);
  var refSelect = useRef(null);
  var prefixCls2 = getPrefixCls("autocomplete");
  var filterOption = "filterOption" in props ? props.filterOption : function(inputValue, option) {
    if (strict) {
      return option.props.value.indexOf(inputValue) > -1;
    }
    return option.props.value.toLowerCase().indexOf(inputValue.toLowerCase()) > -1;
  };
  var childNodes = React__default.Children.toArray(children);
  var selectChildren = null;
  if (childNodes.length && (isSelectOption(childNodes[0]) || isSelectOptGroup(childNodes[0]))) {
    selectChildren = children;
  } else if (data && data.length) {
    selectChildren = data.map(function(item2, index2) {
      if (isValidElement(item2)) {
        return item2;
      }
      if (typeof item2 === "string") {
        return React__default.createElement(Option$1, { key: index2, value: item2 }, item2);
      }
      if (typeof item2 === "object") {
        var _a2 = item2, value_1 = _a2.value, name_1 = _a2.name;
        return React__default.createElement(Option$1, { key: index2, value: value_1, extra: omit$1(item2, ["value", "name"]) }, name_1);
      }
      return null;
    });
  }
  useImperativeHandle(ref, function() {
    return refInput.current;
  });
  var usedTriggerElement = typeof triggerElement === "function" ? triggerElement({ value }) : triggerElement;
  var TriggerElement = React__default.cloneElement(usedTriggerElement, __assign$1m(__assign$1m({ ref: function(node) {
    refInput.current = node;
    var originRef = usedTriggerElement.ref;
    if (typeof originRef === "function") {
      originRef(node);
    }
  }, className: cs$1("" + prefixCls2, inputProps && inputProps.className, className), style, value, placeholder, error: error2, disabled, allowClear }, inputProps), {
    suffix: loading ? React__default.createElement(IconLoading$1, null) : (inputProps === null || inputProps === void 0 ? void 0 : inputProps.suffix) || React__default.createElement("i", null),
    onFocus: function(event2) {
      setIsFocused(true);
      onFocus3 && onFocus3(event2);
      inputProps && inputProps.onFocus && inputProps.onFocus(event2);
    },
    onBlur: function(event2) {
      setIsFocused(false);
      onBlur3 && onBlur3(event2);
      inputProps && inputProps.onBlur && inputProps.onBlur(event2);
    },
    onKeyDown: function(event2) {
      var keyCode = event2.keyCode || event2.which;
      refSelect.current && refSelect.current.hotkeyHandler(event2);
      if (keyCode === Enter.code && onPressEnter) {
        var activeOption = void 0;
        if (refSelect.current) {
          activeOption = refSelect.current.getOptionInfoByValue(refSelect.current.activeOptionValue);
        }
        onPressEnter(event2, activeOption);
      }
      if (keyCode === Esc.code) {
        refInput.current && refInput.current.blur && refInput.current.blur();
      }
      inputProps && inputProps.onKeyDown && inputProps.onKeyDown(event2);
    },
    onChange: function(value2, event2) {
      setValue(value2);
      onSearch && onSearch(value2);
      onChange && onChange(value2);
      inputProps && inputProps.onChange && inputProps.onChange(value2, event2);
    }
  }));
  var triggerProps = __assign$1m(__assign$1m({ popupVisible: !!(isFocused && ((data === null || data === void 0 ? void 0 : data.length) || React__default.Children.count(children))) }, props.triggerProps), {
    trigger: "focus",
    className: [prefixCls2 + "-popup"].concat(props.triggerProps && props.triggerProps.className)
  });
  var selectProps = {
    triggerElement: TriggerElement,
    value: IMPOSSIBLE_VALUE,
    inputValue: value,
    defaultActiveFirstOption,
    triggerProps,
    getPopupContainer,
    dropdownRender,
    filterOption,
    virtualListProps,
    notFoundContent: null,
    onChange: function(value2, option) {
      setValue(value2);
      onChange && onChange(value2, option);
      value2 && onSelect && onSelect(value2, option);
      refInput.current && refInput.current.blur && refInput.current.blur();
    }
  };
  return React__default.createElement(Select$2, __assign$1m({ ref: refSelect }, selectProps), selectChildren);
}
var ForwardRefAutoComplete = React__default.forwardRef(AutoComplete$1);
var AutoCompleteComponent = ForwardRefAutoComplete;
AutoCompleteComponent.displayName = "AutoComplete";
AutoCompleteComponent.Option = Select$2.Option;
AutoCompleteComponent.OptGroup = Select$2.OptGroup;
var ArcoAutoComplete = AutoCompleteComponent;
var __assign$1l = globalThis && globalThis.__assign || function() {
  __assign$1l = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1l.apply(this, arguments);
};
var __rest$D = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var defaultProps$q = {
  position: "top",
  trigger: "hover",
  escToClose: false,
  unmountOnExit: true,
  blurToHide: true,
  popupHoverStay: true
};
function Tooltip(baseProps, ref) {
  var _a = useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, componentConfig2 = _a.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$q, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Tooltip);
  var style = props.style, className = props.className, children = props.children, trigger = props.trigger, escToClose = props.escToClose, defaultPopupVisible = props.defaultPopupVisible, position = props.position, unmountOnExit = props.unmountOnExit, popupVisible = props.popupVisible, tooltipPrefixCls = props.prefixCls, blurToHide = props.blurToHide, popupHoverStay = props.popupHoverStay, disabled = props.disabled, onVisibleChange = props.onVisibleChange, triggerProps = props.triggerProps, childrenPrefix = props.childrenPrefix, getPopupContainer = props.getPopupContainer, content = props.content, mini = props.mini, color2 = props.color, rest = __rest$D(props, ["style", "className", "children", "trigger", "escToClose", "defaultPopupVisible", "position", "unmountOnExit", "popupVisible", "prefixCls", "blurToHide", "popupHoverStay", "disabled", "onVisibleChange", "triggerProps", "childrenPrefix", "getPopupContainer", "content", "mini", "color"]);
  var refTrigger = useRef();
  var updatePopupPosition = function(delay, callback) {
    if (delay === void 0) {
      delay = 0;
    }
    refTrigger.current && refTrigger.current.updatePopupPosition(delay, callback);
  };
  useImperativeHandle(ref, function() {
    return {
      updatePopupPosition
    };
  }, []);
  var prefixCls2 = tooltipPrefixCls || getPrefixCls("tooltip");
  var otherProps = __assign$1l(__assign$1l({}, pick(rest, EventsByTriggerNeed)), triggerProps);
  var renderedContent = isFunction$5(content) ? content() : content;
  var isEmpty = function(content2) {
    if (content2 === null || content2 === void 0 || content2 === false) {
      return true;
    }
    if (typeof content2 === "string" && content2.trim() === "") {
      return true;
    }
    return false;
  };
  if ("popupVisible" in props) {
    otherProps.popupVisible = popupVisible;
  } else if (isEmpty(renderedContent)) {
    otherProps.popupVisible = false;
  }
  if (otherProps.showArrow !== false || otherProps.arrowProps) {
    otherProps.arrowProps = otherProps.arrowProps || {};
    if (color2) {
      otherProps.arrowProps.style = __assign$1l({ backgroundColor: color2 }, otherProps.arrowProps.style);
    }
  }
  return React__default.createElement(Trigger$1, __assign$1l({ style: __assign$1l({ maxWidth: 350 }, style), className, ref: refTrigger, classNames: "zoomInFadeOut", duration: {
    enter: 300,
    exit: 100
  }, popup: function() {
    var _a2;
    return React__default.createElement("div", { style: { backgroundColor: color2 }, className: cs$1(prefixCls2 + "-content", prefixCls2 + "-content-" + position, (_a2 = {}, _a2[prefixCls2 + "-mini"] = mini, _a2)), role: "tooltip" }, React__default.createElement("div", { className: prefixCls2 + "-content-inner" }, renderedContent));
  }, position, disabled, trigger, escToClose, showArrow: true, popupAlign: {
    left: 12,
    right: 12,
    top: 12,
    bottom: 12
  }, mouseEnterDelay: 200, mouseLeaveDelay: 200, unmountOnExit, popupHoverStay, blurToHide, childrenPrefix: childrenPrefix || prefixCls2, getPopupContainer, onVisibleChange, defaultPopupVisible }, otherProps), children);
}
var TooltipComponent = forwardRef(Tooltip);
TooltipComponent.displayName = "Tooltip";
var Tooltip$1 = TooltipComponent;
var __assign$1k = globalThis && globalThis.__assign || function() {
  __assign$1k = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1k.apply(this, arguments);
};
var __rest$C = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var defaultProps$p = {
  position: "top",
  trigger: "hover",
  unmountOnExit: true
};
function Popover(baseProps, ref) {
  var _a = useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, componentConfig2 = _a.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$p, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Popover);
  var style = props.style, className = props.className, children = props.children, position = props.position, getPopupContainer = props.getPopupContainer, trigger = props.trigger, defaultPopupVisible = props.defaultPopupVisible, popupVisible = props.popupVisible, triggerProps = props.triggerProps, unmountOnExit = props.unmountOnExit, onVisibleChange = props.onVisibleChange, content = props.content, title2 = props.title, rest = __rest$C(props, ["style", "className", "children", "position", "getPopupContainer", "trigger", "defaultPopupVisible", "popupVisible", "triggerProps", "unmountOnExit", "onVisibleChange", "content", "title"]);
  var prefixCls2 = getPrefixCls("popover");
  return React__default.createElement(Tooltip$1, __assign$1k({}, rest, { ref, style: __assign$1k({ maxWidth: 350 }, style), className, prefixCls: prefixCls2, getPopupContainer, position, trigger, content: React__default.createElement("div", { className: prefixCls2 + "-inner" }, title2 ? React__default.createElement("div", { className: prefixCls2 + "-title" }, title2) : null, React__default.createElement("div", { className: prefixCls2 + "-inner-content" }, content)), popupHoverStay: true, unmountOnExit, triggerProps, defaultPopupVisible, onVisibleChange: onVisibleChange || (triggerProps ? triggerProps.onVisibleChange : void 0), childrenPrefix: prefixCls2 }, "popupVisible" in props ? { popupVisible } : {}), typeof children === "string" ? React__default.createElement("span", null, children) : children);
}
var PopoverComponent = forwardRef(Popover);
PopoverComponent.displayName = "Popover";
var Popover$1 = PopoverComponent;
function ownKeys$p(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$p(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$p(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$p(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconMoreComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$p(_objectSpread$p({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-more")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    fill: "currentColor",
    stroke: "none",
    d: "M38 25v-2h2v2h-2ZM23 25v-2h2v2h-2ZM8 25v-2h2v2H8Z"
  }), /* @__PURE__ */ React__default.createElement("path", {
    d: "M38 25v-2h2v2h-2ZM23 25v-2h2v2h-2ZM8 25v-2h2v2H8Z"
  }));
}
var IconMore = /* @__PURE__ */ React__default.forwardRef(IconMoreComponent);
IconMore.defaultProps = {
  isIcon: true
};
IconMore.displayName = "IconMore";
var IconMore$1 = IconMore;
var __assign$1j = globalThis && globalThis.__assign || function() {
  __assign$1j = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1j.apply(this, arguments);
};
var __read$Z = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var defaultProps$o = {
  position: "br",
  trigger: "hover",
  type: "default",
  icon: React__default.createElement(IconMore$1, null),
  unmountOnExit: true
};
function Button$1(baseProps, ref) {
  var _a;
  var componentConfig2 = useContext(ConfigContext).componentConfig;
  var props = useMergeProps(baseProps, defaultProps$o, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2["Dropdown.Button"]);
  var className = props.className, style = props.style, children = props.children, disabled = props.disabled, droplist = props.droplist, _b = props.position, position = _b === void 0 ? "br" : _b, _c = props.trigger, trigger = _c === void 0 ? "hover" : _c, _d = props.type, type = _d === void 0 ? "default" : _d, size = props.size, _e = props.icon, icon = _e === void 0 ? React__default.createElement(IconMore$1, null) : _e, _f = props.unmountOnExit, unmountOnExit = _f === void 0 ? true : _f, onClick = props.onClick, onVisibleChange = props.onVisibleChange, buttonProps = props.buttonProps, buttonsRender = props.buttonsRender;
  var leftButton = React__default.createElement(Button$4, __assign$1j({ disabled, type, size, onClick }, buttonProps), children);
  var rightButton = React__default.createElement(Button$4, { disabled, type, size, icon });
  if (buttonsRender) {
    _a = __read$Z(buttonsRender([leftButton, rightButton]), 2), leftButton = _a[0], rightButton = _a[1];
  }
  var disableTrigger = disabled || !rightButton || rightButton.props && rightButton.props.loading;
  return React__default.createElement(Button$4.Group, { className, style, ref }, leftButton, React__default.createElement(Dropdown$1, { droplist, position, trigger, unmountOnExit, onVisibleChange, triggerProps: {
    disabled: disableTrigger
  } }, rightButton));
}
var ButtonComponent = forwardRef(Button$1);
ButtonComponent.displayName = "DropdownButton";
var Button$2 = ButtonComponent;
var __assign$1i = globalThis && globalThis.__assign || function() {
  __assign$1i = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1i.apply(this, arguments);
};
var __rest$B = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$Y = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __values = globalThis && globalThis.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i2 >= o.length)
          o = void 0;
        return { value: o && o[i2++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __spreadArray$r = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var defaultProps$n = {
  position: "bl",
  trigger: "hover",
  unmountOnExit: true
};
function Dropdown(baseProps, _) {
  var _a;
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig2 = _b.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$n, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Button);
  var trigger = props.trigger, droplist = props.droplist, children = props.children, position = props.position, disabled = props.disabled, unmountOnExit = props.unmountOnExit, triggerProps = props.triggerProps, getPopupContainer = props.getPopupContainer, onVisibleChange = props.onVisibleChange, rest = __rest$B(props, ["trigger", "droplist", "children", "position", "disabled", "unmountOnExit", "triggerProps", "getPopupContainer", "onVisibleChange"]);
  var prefixCls2 = getPrefixCls("dropdown");
  var triggerRef = useRef(null);
  var _c = __read$Y(useMergeValue(false, {
    defaultValue: props.defaultPopupVisible,
    value: props.popupVisible
  }), 2), popupVisible = _c[0], setPopupVisible = _c[1];
  var getPopupContent = function() {
    return React__default.Children.only(droplist || React__default.createElement("span", null));
  };
  var changePopupVisible = function(visible) {
    setPopupVisible(visible);
    onVisibleChange && onVisibleChange(visible);
    triggerProps && triggerProps.onVisibleChange && triggerProps.onVisibleChange(visible);
  };
  var handleVisibleChange = function(visible) {
    if (visible !== popupVisible) {
      changePopupVisible(visible);
    }
  };
  var renderPopup = function() {
    var e_1, _a2, _b2;
    var _c2;
    var content = getPopupContent();
    if ((_c2 = content === null || content === void 0 ? void 0 : content.props) === null || _c2 === void 0 ? void 0 : _c2.isMenu) {
      var isEmpty = true;
      try {
        for (var _d = __values(React__default.Children.toArray(content.props.children)), _e = _d.next(); !_e.done; _e = _d.next()) {
          var child = _e.value;
          if (child !== null && child !== void 0) {
            isEmpty = false;
            break;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_e && !_e.done && (_a2 = _d.return))
            _a2.call(_d);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return React__default.cloneElement(content, {
        prefixCls: cs$1(prefixCls2 + "-menu", (_b2 = {}, _b2[prefixCls2 + "-menu-hidden"] = isEmpty, _b2)),
        inDropdown: true,
        selectable: false,
        onClickMenuItem: function() {
          var _a3;
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var returnValueOfOnClickMenuItem = null;
          var content2 = getPopupContent();
          if (content2.props.onClickMenuItem) {
            returnValueOfOnClickMenuItem = (_a3 = content2.props).onClickMenuItem.apply(_a3, __spreadArray$r([], __read$Y(args), false));
          }
          var child2 = triggerRef.current && triggerRef.current.getRootElement();
          child2 && child2.focus && child2.focus();
          if (returnValueOfOnClickMenuItem instanceof Promise) {
            returnValueOfOnClickMenuItem.finally(function() {
              return changePopupVisible(false);
            });
          } else if (returnValueOfOnClickMenuItem !== false) {
            changePopupVisible(false);
          }
        }
      });
    }
    return content;
  };
  return React__default.createElement(Trigger$1, __assign$1i({ ref: function(ref) {
    return triggerRef.current = ref;
  }, classNames: "slideDynamicOrigin", childrenPrefix: prefixCls2, trigger, popup: renderPopup, mouseEnterDelay: 400, mouseLeaveDelay: 400, disabled, unmountOnExit, position, popupVisible, popupAlign: {
    left: 4,
    right: 4,
    top: 4,
    bottom: 4
  }, getPopupContainer, alignPoint: trigger === "contextMenu" }, pick(rest, EventsByTriggerNeed), omit$1(triggerProps, ["onVisibleChange"]), { onVisibleChange: handleVisibleChange }), React__default.isValidElement(children) ? React__default.cloneElement(children, {
    disabled,
    className: cs$1((_a = {}, _a[prefixCls2 + "-popup-visible"] = popupVisible, _a), children.props.className)
  }) : children);
}
var ForwardRefDropdown = React__default.forwardRef(Dropdown);
var DropdownComponent = ForwardRefDropdown;
DropdownComponent.displayName = "Dropdown";
DropdownComponent.Button = Button$2;
var Dropdown$1 = DropdownComponent;
var MenuContext = createContext({});
var MenuContext$1 = MenuContext;
var __read$X = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$q = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function MenuIndent(props) {
  var prefixCls2 = props.prefixCls, levelIndent = props.levelIndent;
  var collapse = useContext(MenuContext$1).collapse;
  var level = props.level - 1;
  return !collapse && level > 0 ? React__default.createElement("span", null, __spreadArray$q([], __read$X(new Array(level)), false).map(function(_, index2) {
    return React__default.createElement("span", { key: index2, className: prefixCls2 + "-indent", style: { width: levelIndent } });
  })) : null;
}
var __assign$1h = globalThis && globalThis.__assign || function() {
  __assign$1h = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1h.apply(this, arguments);
};
var __read$W = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$p = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var PROPS_NEED_TO_BE_PASSED_IN_SUBMENU = ["popup", "triggerProps", "selectable"];
var flatMenuGroup = function(children) {
  var validMenuItems = [];
  React__default.Children.forEach(children, function(item2) {
    var _a;
    var menuType = (_a = item2 === null || item2 === void 0 ? void 0 : item2.type) === null || _a === void 0 ? void 0 : _a.menuType;
    if (menuType === "MenuItem" || menuType === "SubMenu") {
      validMenuItems.push(item2);
    } else if (menuType === "MenuGroup") {
      validMenuItems = validMenuItems.concat(flatMenuGroup(item2.props.children));
    }
  });
  return validMenuItems;
};
var generateInfoMap = function(children, keyPath, result) {
  if (keyPath === void 0) {
    keyPath = [];
  }
  if (result === void 0) {
    result = {};
  }
  var validChildrenList = flatMenuGroup(children);
  validChildrenList.forEach(function(item2, index2) {
    var _a;
    var _b, _c;
    var key = item2.key;
    var menuType = item2.type.menuType;
    var _keyPath = __spreadArray$p([key], __read$W(keyPath), false);
    var info2 = {
      keyPath: [],
      prev: ((_b = validChildrenList[index2 - 1]) === null || _b === void 0 ? void 0 : _b.key) || null,
      next: ((_c = validChildrenList[index2 + 1]) === null || _c === void 0 ? void 0 : _c.key) || null
    };
    if (index2 === 0 || index2 === validChildrenList.length - 1) {
      var parentKey = _keyPath[1];
      var propertyName = index2 === 0 ? "firstChild" : "lastChild";
      if (parentKey) {
        result[parentKey] = __assign$1h(__assign$1h({}, result[parentKey]), (_a = {}, _a[propertyName] = key, _a));
      }
    }
    switch (menuType) {
      case "SubMenu":
        info2.keyPath = _keyPath;
        generateInfoMap(item2.props.children, _keyPath, result);
        break;
      case "MenuItem":
        info2.keyPath = _keyPath;
        info2.disabled = item2.props.disabled;
        break;
    }
    result[key] = __assign$1h(__assign$1h({}, result[key]), info2);
  });
  return result;
};
var processChildren = function(children, props) {
  return React__default.Children.map(children, function(item2, index2) {
    if (!item2 || !item2.props) {
      return item2;
    }
    var isHTMLElement = typeof item2.type === "string";
    var isMenuSubComponent = item2.type && item2.type.menuType;
    if (!isMenuSubComponent && item2.props.children) {
      var _props = isHTMLElement ? {} : props;
      return React__default.cloneElement(item2, __assign$1h(__assign$1h({}, _props), { _key: item2.key, children: processChildren(item2.props.children, props) }));
    }
    return isHTMLElement ? item2 : React__default.cloneElement(item2, __assign$1h(__assign$1h(__assign$1h({}, props), item2.props), { _key: item2.key || "$menu-" + index2 }));
  });
};
function isChildrenSelected(children, keys2) {
  var find = false;
  function loop(_children) {
    if (!_children || find) {
      return;
    }
    React__default.Children.forEach(_children, function(c) {
      if (c && c.props && c.type && !find) {
        var menuType = c.type.menuType;
        var selectable = c.props.selectable;
        if (menuType === "MenuItem") {
          find = keys2.indexOf(c.key) !== -1;
        } else if (menuType === "SubMenu" && selectable) {
          find = keys2.indexOf(c.key) !== -1;
        }
        if (!find && c.props.children) {
          loop(c.props.children);
        }
      }
    });
  }
  loop(children);
  return find;
}
var __assign$1g = globalThis && globalThis.__assign || function() {
  __assign$1g = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1g.apply(this, arguments);
};
var __rest$A = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function Item$4(props, ref) {
  var _a;
  var _key = props._key, children = props.children, level = props.level, disabled = props.disabled, className = props.className, style = props.style, _b = props.wrapper, WrapperTagName = _b === void 0 ? "div" : _b, onClick = props.onClick, rest = __rest$A(props, ["_key", "children", "level", "disabled", "className", "style", "wrapper", "onClick"]);
  var _c = useContext(MenuContext$1), prefixCls2 = _c.prefixCls, mode = _c.mode, collapse = _c.collapse, inDropdown = _c.inDropdown, levelIndent = _c.levelIndent, selectedKeys = _c.selectedKeys, autoScrollIntoView = _c.autoScrollIntoView, scrollConfig = _c.scrollConfig, tooltipProps = _c.tooltipProps, onClickMenuItem = _c.onClickMenuItem;
  var refElement = useRef(null);
  var isFirstRender = useIsFirstRender();
  var needTextIndent = mode === "vertical" && level > 1;
  var needTooltip = collapse && !inDropdown && level === 1;
  var isSelected = selectedKeys && ~selectedKeys.indexOf(_key);
  useEffect(function() {
    var shouldScroll = isSelected && autoScrollIntoView;
    if (refElement.current && shouldScroll) {
      setTimeout(function() {
        scrollIntoView(refElement.current, __assign$1g({ behavior: "smooth", block: "start", scrollMode: "if-needed", boundary: document.body }, scrollConfig));
      }, isFirstRender ? 500 : 0);
    }
  }, [isSelected, autoScrollIntoView]);
  var menuItemClickHandler = function(event2) {
    if (!disabled) {
      onClickMenuItem(_key, event2);
      onClick && onClick(event2);
    }
  };
  var itemElement = React__default.createElement(WrapperTagName, __assign$1g({ tabIndex: disabled ? -1 : 0, role: "menuitem", ref: function(_ref2) {
    ref = _ref2;
    refElement.current = ref;
  }, style, className: cs$1(prefixCls2 + "-item", (_a = {}, _a[prefixCls2 + "-disabled"] = disabled, _a[prefixCls2 + "-selected"] = isSelected, _a[prefixCls2 + "-item-indented"] = needTextIndent && !collapse, _a), className), onClick: menuItemClickHandler, onKeyDown: function(event2) {
    var keyCode = event2.keyCode || event2.which;
    if (keyCode === Enter.code) {
      menuItemClickHandler(event2);
    }
  } }, omit$1(rest, ["key", "_key"].concat(PROPS_NEED_TO_BE_PASSED_IN_SUBMENU))), needTextIndent && !collapse ? React__default.createElement(React__default.Fragment, null, React__default.createElement(MenuIndent, { prefixCls: prefixCls2, levelIndent, level }), React__default.createElement("span", { className: prefixCls2 + "-item-inner", style: {
    display: "block"
  } }, children)) : children, isSelected && mode === "horizontal" ? React__default.createElement("div", { className: prefixCls2 + "-selected-label" }) : null);
  return needTooltip ? React__default.createElement(Tooltip$1, __assign$1g({ trigger: "hover", content: React__default.createElement("span", null, children), position: "right", triggerProps: __assign$1g({ className: prefixCls2 + "-item-tooltip" }, (tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.triggerProps) || {}) }, omit$1(tooltipProps, ["triggerProps"])), itemElement) : itemElement;
}
var ForwardRefItem$1 = forwardRef(Item$4);
var ItemComponent$2 = ForwardRefItem$1;
ItemComponent$2.displayName = "MenuItem";
ItemComponent$2.menuType = "MenuItem";
var Item$5 = ItemComponent$2;
function ItemGroup(props, ref) {
  var children = props.children, title2 = props.title, level = props.level, className = props.className, style = props.style;
  var _a = useContext(MenuContext$1), prefixCls2 = _a.prefixCls, levelIndent = _a.levelIndent;
  var childrenLevel = level === 1 ? level + 1 : level;
  var childrenList = processChildren(children, { level: childrenLevel });
  return React__default.createElement("div", { ref, className: cs$1(prefixCls2 + "-group", className), style }, React__default.createElement("div", { className: prefixCls2 + "-group-title" }, React__default.createElement(MenuIndent, { level, prefixCls: prefixCls2, levelIndent }), React__default.createElement("span", null, title2)), childrenList);
}
var ForwardRefItemGroup = forwardRef(ItemGroup);
var ItemGroupComponent = ForwardRefItemGroup;
ItemGroupComponent.displayName = "MenuItemGroup";
ItemGroupComponent.menuType = "MenuGroup";
var ItemGroup$1 = ItemGroupComponent;
var __assign$1f = globalThis && globalThis.__assign || function() {
  __assign$1f = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1f.apply(this, arguments);
};
var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$5 = globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
          return t2;
        if (y = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest$z = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$V = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var globalInlineSubMenuIndex = 0;
var CONTENT_HIDDEN_STYLE = { height: 0, visibility: "hidden" };
var SubMenuInline = function(props) {
  var _a;
  var _key = props._key, children = props.children, style = props.style, className = props.className, title2 = props.title, level = props.level, forwardedRef = props.forwardedRef, selectable = props.selectable, rest = __rest$z(props, ["_key", "children", "style", "className", "title", "level", "forwardedRef", "selectable"]);
  var _b = useContext(MenuContext$1), menuId = _b.id, prefixCls2 = _b.prefixCls, levelIndent = _b.levelIndent, _c = _b.openKeys, openKeys = _c === void 0 ? [] : _c, _d = _b.selectedKeys, selectedKeys = _d === void 0 ? [] : _d, icons = _b.icons, onClickSubMenu = _b.onClickSubMenu, onClickMenuItem = _b.onClickMenuItem;
  var baseClassName = prefixCls2 + "-inline";
  var isOpen = (openKeys === null || openKeys === void 0 ? void 0 : openKeys.indexOf(_key)) > -1;
  var isSelected = selectable && selectedKeys.indexOf(props._key) > -1 || isChildrenSelected(children, selectedKeys);
  var _e = __read$V(useStateWithPromise(isOpen ? { height: "auto" } : CONTENT_HIDDEN_STYLE), 2), contentStyle = _e[0], setContentStyle = _e[1];
  var subMenuClickHandler = function(event2) {
    onClickSubMenu(_key, level, "inline");
    selectable && onClickMenuItem(_key, event2);
  };
  var instanceId = useMemo(function() {
    var id = menuId + "-submenu-inline-" + globalInlineSubMenuIndex;
    globalInlineSubMenuIndex++;
    return id;
  }, []);
  var childrenList = processChildren(children, __assign$1f(__assign$1f({}, pick(rest, PROPS_NEED_TO_BE_PASSED_IN_SUBMENU)), { level: level + 1, selectable }));
  var header = React__default.createElement("div", { tabIndex: 0, "aria-expanded": isOpen, "aria-controls": instanceId, className: cs$1(baseClassName + "-header", (_a = {}, _a[prefixCls2 + "-selected"] = isSelected, _a)), onClick: subMenuClickHandler, onKeyDown: function(event2) {
    var keyCode = event2.keyCode || event2.which;
    if (keyCode === Enter.code) {
      subMenuClickHandler(event2);
    }
  } }, React__default.createElement(MenuIndent, { level, prefixCls: prefixCls2, levelIndent }), React__default.createElement("span", null, title2), React__default.createElement("span", { className: prefixCls2 + "-icon-suffix " + (isOpen ? "is-open" : "") }, icons && icons.horizontalArrowDown ? icons.horizontalArrowDown : React__default.createElement(IconDown$1, null)));
  var content = React__default.createElement("div", { id: instanceId, className: cs$1(baseClassName + "-content"), style: contentStyle }, childrenList);
  return React__default.createElement("div", { ref: forwardedRef, className: cs$1(baseClassName, className), style }, header, React__default.createElement(CSSTransition$1, { in: isOpen, timeout: 200, classNames: baseClassName, unmountOnExit: false, onEnter: function(element) {
    return __awaiter$5(void 0, void 0, void 0, function() {
      return __generator$5(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, setContentStyle(CONTENT_HIDDEN_STYLE)];
          case 1:
            _a2.sent();
            return [4, setContentStyle({ height: element.scrollHeight })];
          case 2:
            _a2.sent();
            return [2];
        }
      });
    });
  }, onEntered: function() {
    setContentStyle({ height: "auto" });
  }, onExit: function(element) {
    return __awaiter$5(void 0, void 0, void 0, function() {
      return __generator$5(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, setContentStyle({ height: element.scrollHeight })];
          case 1:
            _a2.sent();
            return [4, setContentStyle(CONTENT_HIDDEN_STYLE)];
          case 2:
            _a2.sent();
            return [2];
        }
      });
    });
  } }, content));
};
var SubMenuInline$1 = SubMenuInline;
function ownKeys$o(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$o(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$o(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$o(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconRightComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$o(_objectSpread$o({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-right")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "m16 39.513 15.556-15.557L16 8.4"
  }));
}
var IconRight = /* @__PURE__ */ React__default.forwardRef(IconRightComponent);
IconRight.defaultProps = {
  isIcon: true
};
IconRight.displayName = "IconRight";
var IconRight$1 = IconRight;
var __assign$1e = globalThis && globalThis.__assign || function() {
  __assign$1e = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1e.apply(this, arguments);
};
var __read$U = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var globalPopSubMenuIndex = 0;
var SubMenuPop = function(props) {
  var _a;
  var _key = props._key, children = props.children, style = props.style, className = props.className, title2 = props.title, level = props.level, selectable = props.selectable, forwardedRef = props.forwardedRef, propTriggerProps = props.triggerProps;
  var _b = useContext(MenuContext$1), menuId = _b.id, prefixCls2 = _b.prefixCls, mode = _b.mode, inDropdown = _b.inDropdown, levelIndent = _b.levelIndent, _c = _b.selectedKeys, selectedKeys = _c === void 0 ? [] : _c, icons = _b.icons, contextTriggerProps = _b.triggerProps, onClickSubMenu = _b.onClickSubMenu, onClickMenuItem = _b.onClickMenuItem;
  var triggerProps = __assign$1e(__assign$1e({}, contextTriggerProps), propTriggerProps);
  var _d = __read$U(useState(false), 2), popupVisible = _d[0], setPopupVisible = _d[1];
  var baseClassName = prefixCls2 + "-pop";
  var isSelected = selectable && selectedKeys.indexOf(props._key) > -1;
  var needPopOnBottom = mode === "horizontal" && !inDropdown;
  var instanceId = useMemo(function() {
    var id = menuId + "-submenu-pop-" + globalPopSubMenuIndex;
    globalPopSubMenuIndex++;
    return id;
  }, []);
  var renderSuffix = function() {
    var MergedIconRight = icons && icons.popArrowRight ? icons.popArrowRight : React__default.createElement(IconRight$1, null);
    var MergedIconDown = icons && icons.horizontalArrowDown ? icons.horizontalArrowDown : React__default.createElement(IconDown$1, null);
    return React__default.createElement("span", { className: prefixCls2 + "-icon-suffix" }, needPopOnBottom ? MergedIconDown : MergedIconRight);
  };
  var hasSelectedStatus = isChildrenSelected(children, selectedKeys) || isSelected;
  var subMenuClickHandler = function(event2) {
    onClickSubMenu(_key, level, "pop");
    selectable && onClickMenuItem(_key, event2);
  };
  return React__default.createElement(Dropdown$1, { trigger: "hover", onVisibleChange: function(visible) {
    return setPopupVisible(visible);
  }, droplist: React__default.createElement(Menu$1, { id: instanceId, selectedKeys, onClickMenuItem: function(key, event2) {
    onClickMenuItem(key, event2);
    setPopupVisible(false);
  } }, children), triggerProps: __assign$1e({ position: needPopOnBottom ? "bl" : "rt", popupVisible, showArrow: true, autoAlignPopupMinWidth: true, classNames: "fadeIn", duration: 100, mouseEnterDelay: 50, mouseLeaveDelay: 50, className: cs$1(baseClassName + "-trigger", triggerProps && triggerProps.className) }, omit$1(triggerProps, ["className"])) }, React__default.createElement("div", { tabIndex: 0, "aria-haspopup": true, "aria-expanded": popupVisible, "aria-controls": instanceId, ref: forwardedRef, style, className: cs$1(baseClassName, baseClassName + "-header", (_a = {}, _a[prefixCls2 + "-selected"] = hasSelectedStatus, _a), className), onClick: subMenuClickHandler, onKeyDown: function(event2) {
    var keyCode = event2.keyCode || event2.which;
    if (keyCode === Enter.code) {
      subMenuClickHandler(event2);
    }
  } }, React__default.createElement(MenuIndent, { prefixCls: prefixCls2, levelIndent, level }), title2, renderSuffix(), hasSelectedStatus && mode === "horizontal" ? React__default.createElement("div", { className: prefixCls2 + "-selected-label" }) : null));
};
var SubMenuPop$1 = SubMenuPop;
var __assign$1d = globalThis && globalThis.__assign || function() {
  __assign$1d = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1d.apply(this, arguments);
};
function SubMenu(props, ref) {
  var children = props.children, popup = props.popup, level = props.level;
  var _a = useContext(MenuContext$1), mode = _a.mode, collapse = _a.collapse, inDropdown = _a.inDropdown, collectInlineMenuKeys = _a.collectInlineMenuKeys;
  var forcePopup = !!(typeof popup === "function" ? popup(level) : popup);
  var mergedPopup = forcePopup || collapse || inDropdown || mode !== "vertical";
  var MergedMenu = mergedPopup ? SubMenuPop$1 : SubMenuInline$1;
  useEffect(function() {
    collectInlineMenuKeys(props._key);
    return function() {
      collectInlineMenuKeys(props._key, true);
    };
  }, []);
  return React__default.createElement(MergedMenu, __assign$1d({ forwardedRef: ref }, props), children);
}
var ForwardRefSubMenu = forwardRef(SubMenu);
var SubMenuComponent = ForwardRefSubMenu;
SubMenuComponent.displayName = "SubMenu";
SubMenuComponent.menuType = "SubMenu";
var SubMenu$1 = SubMenuComponent;
var transformNames = [
  "transform",
  "WebkitTransform",
  "msTransform",
  "MozTransform",
  "OTransform"
];
function setTransformStyle(value) {
  var style = {};
  transformNames.forEach(function(name2) {
    style[name2] = value;
  });
  return style;
}
function getStyle(element, prop) {
  if (!element || !prop)
    return null;
  var styleName = prop;
  if (styleName === "float") {
    styleName = "cssFloat";
  }
  try {
    if (document.defaultView) {
      var computed = document.defaultView.getComputedStyle(element, "");
      return element.style[styleName] || computed ? computed[styleName] : "";
    }
  } catch (e) {
    return element.style[styleName];
  }
}
var __assign$1c = globalThis && globalThis.__assign || function() {
  __assign$1c = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1c.apply(this, arguments);
};
var __read$T = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$o = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var OVERFLOW_THRESHOLD = 10;
function getNodeWidth(node) {
  return node && +node.getBoundingClientRect().width.toFixed(2);
}
function translatePxToNumber(str) {
  var result = Number(str.replace("px", ""));
  return isNaN(result) ? 0 : result;
}
var OverflowWrap = function(props) {
  var children = props.children;
  var prefixCls2 = useContext(MenuContext$1).prefixCls;
  var refUl = useRef(null);
  var refResizeObserver = useRef(null);
  var _a = __read$T(useState(null), 2), lastVisibleIndex = _a[0], setLastVisibleIndex = _a[1];
  var overflowSubMenuClass = prefixCls2 + "-overflow-sub-menu";
  var overflowMenuItemClass = prefixCls2 + "-overflow-hidden-menu-item";
  var overflowSubMenuMirrorClass = prefixCls2 + "-overflow-sub-menu-mirror";
  useEffect(function() {
    var ulElement = refUl.current;
    computeLastVisibleIndex();
    refResizeObserver.current = new index$1(function(entries) {
      entries.forEach(computeLastVisibleIndex);
    });
    refResizeObserver.current.observe(ulElement);
    return function() {
      if (refResizeObserver.current) {
        refResizeObserver.current.disconnect();
      }
    };
  }, [children]);
  function computeLastVisibleIndex() {
    if (!refUl.current) {
      return;
    }
    var ulElement = refUl.current;
    var maxWidth = getNodeWidth(ulElement) - OVERFLOW_THRESHOLD;
    var childNodeList = [].slice.call(ulElement.children);
    var menuItemIndex = 0;
    var currentItemRight = 0;
    var overflowSubMenuWidth = 0;
    for (var i2 = 0; i2 < childNodeList.length; i2++) {
      var node = childNodeList[i2];
      var classNames = node.className.split(" ");
      var isOverflowSubMenu = classNames.indexOf(overflowSubMenuClass) > -1;
      var isOverflowSubMenuMirror = classNames.indexOf(overflowSubMenuMirrorClass) > -1;
      if (isOverflowSubMenu) {
        continue;
      }
      var nodeWidth = getNodeWidth(node) + translatePxToNumber(getStyle(node, "marginLeft")) + translatePxToNumber(getStyle(node, "marginRight"));
      if (isOverflowSubMenuMirror) {
        overflowSubMenuWidth = nodeWidth;
        continue;
      }
      currentItemRight += nodeWidth;
      if (currentItemRight > maxWidth) {
        setLastVisibleIndex(menuItemIndex - (currentItemRight - nodeWidth + overflowSubMenuWidth <= maxWidth ? 1 : 2));
        return;
      }
      menuItemIndex++;
    }
    setLastVisibleIndex(null);
  }
  var renderOverflowSubMenu = function(children2, isMirror) {
    if (isMirror === void 0) {
      isMirror = false;
    }
    return React__default.createElement(SubMenu$1, __assign$1c({ title: React__default.createElement("span", null, "\xB7\xB7\xB7"), key: "arco-menu-overflow-sub-menu" + (isMirror ? "-mirror" : ""), className: isMirror ? overflowSubMenuMirrorClass : overflowSubMenuClass }, props, { children: children2 }));
  };
  var renderChildren = function() {
    var overflowSubMenu = null;
    var overflowSubMenuMirror = renderOverflowSubMenu(null, true);
    var originMenuItems = React__default.Children.map(children, function(child, index2) {
      var item2 = child;
      if (lastVisibleIndex !== null) {
        if (index2 > lastVisibleIndex) {
          item2 = React__default.cloneElement(child, {
            className: overflowMenuItemClass
          });
        }
        if (index2 === lastVisibleIndex + 1) {
          var overflowedItems = React__default.Children.toArray(children).slice(lastVisibleIndex + 1).map(function(child2) {
            return React__default.cloneElement(child2, { key: child2.props._key });
          });
          overflowSubMenu = renderOverflowSubMenu(overflowedItems);
        }
      }
      return item2;
    });
    return __spreadArray$o(__spreadArray$o([overflowSubMenuMirror], __read$T(originMenuItems), false), [overflowSubMenu], false);
  };
  return React__default.createElement("div", { className: prefixCls2 + "-overflow-wrap", ref: refUl }, renderChildren());
};
var OverflowWrap$1 = OverflowWrap;
function ownKeys$n(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$n(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$n(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$n(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconLeftComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$n(_objectSpread$n({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-left")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M32 8.4 16.444 23.956 32 39.513"
  }));
}
var IconLeft = /* @__PURE__ */ React__default.forwardRef(IconLeftComponent);
IconLeft.defaultProps = {
  isIcon: true
};
IconLeft.displayName = "IconLeft";
var IconLeft$1 = IconLeft;
function ownKeys$m(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$m(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$m(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$m(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconDragDotVerticalComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$m(_objectSpread$m({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-drag-dot-vertical")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    fill: "currentColor",
    stroke: "none",
    d: "M17 8h2v2h-2V8ZM17 23h2v2h-2v-2ZM17 38h2v2h-2v-2ZM29 8h2v2h-2V8ZM29 23h2v2h-2v-2ZM29 38h2v2h-2v-2Z"
  }), /* @__PURE__ */ React__default.createElement("path", {
    d: "M17 8h2v2h-2V8ZM17 23h2v2h-2v-2ZM17 38h2v2h-2v-2ZM29 8h2v2h-2V8ZM29 23h2v2h-2v-2ZM29 38h2v2h-2v-2Z"
  }));
}
var IconDragDotVertical = /* @__PURE__ */ React__default.forwardRef(IconDragDotVerticalComponent);
IconDragDotVertical.defaultProps = {
  isIcon: true
};
IconDragDotVertical.displayName = "IconDragDotVertical";
var IconDragDotVertical$1 = IconDragDotVertical;
function ownKeys$l(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$l(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$l(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$l(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconDragDotComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$l(_objectSpread$l({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-drag-dot")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    fill: "currentColor",
    stroke: "none",
    d: "M40 17v2h-2v-2h2ZM25 17v2h-2v-2h2ZM10 17v2H8v-2h2ZM40 29v2h-2v-2h2ZM25 29v2h-2v-2h2ZM10 29v2H8v-2h2Z"
  }), /* @__PURE__ */ React__default.createElement("path", {
    d: "M40 17v2h-2v-2h2ZM25 17v2h-2v-2h2ZM10 17v2H8v-2h2ZM40 29v2h-2v-2h2ZM25 29v2h-2v-2h2ZM10 29v2H8v-2h2Z"
  }));
}
var IconDragDot = /* @__PURE__ */ React__default.forwardRef(IconDragDotComponent);
IconDragDot.defaultProps = {
  isIcon: true
};
IconDragDot.displayName = "IconDragDot";
var IconDragDot$1 = IconDragDot;
function ownKeys$k(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$k(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$k(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$k(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconCaretRightComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$k(_objectSpread$k({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-caret-right")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    fill: "currentColor",
    stroke: "none",
    d: "M34.829 23.063c.6.48.6 1.394 0 1.874L17.949 38.44c-.785.629-1.949.07-1.949-.937V10.497c0-1.007 1.164-1.566 1.95-.937l16.879 13.503Z"
  }));
}
var IconCaretRight = /* @__PURE__ */ React__default.forwardRef(IconCaretRightComponent);
IconCaretRight.defaultProps = {
  isIcon: true
};
IconCaretRight.displayName = "IconCaretRight";
var IconCaretRight$1 = IconCaretRight;
function ownKeys$j(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$j(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$j(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$j(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconCaretLeftComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$j(_objectSpread$j({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-caret-left")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    fill: "currentColor",
    stroke: "none",
    d: "M13.171 24.937a1.2 1.2 0 0 1 0-1.874L30.051 9.56c.785-.629 1.949-.07 1.949.937v27.006c0 1.006-1.164 1.566-1.95.937L13.171 24.937Z"
  }));
}
var IconCaretLeft = /* @__PURE__ */ React__default.forwardRef(IconCaretLeftComponent);
IconCaretLeft.defaultProps = {
  isIcon: true
};
IconCaretLeft.displayName = "IconCaretLeft";
var IconCaretLeft$1 = IconCaretLeft;
function ownKeys$i(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$i(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$i(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$i(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconCaretDownComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$i(_objectSpread$i({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-caret-down")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    fill: "currentColor",
    stroke: "none",
    d: "M24.938 34.829a1.2 1.2 0 0 1-1.875 0L9.56 17.949c-.628-.785-.069-1.949.937-1.949h27.007c1.006 0 1.565 1.164.937 1.95L24.937 34.829Z"
  }));
}
var IconCaretDown = /* @__PURE__ */ React__default.forwardRef(IconCaretDownComponent);
IconCaretDown.defaultProps = {
  isIcon: true
};
IconCaretDown.displayName = "IconCaretDown";
var IconCaretDown$1 = IconCaretDown;
function ownKeys$h(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$h(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$h(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$h(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconCaretUpComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$h(_objectSpread$h({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-caret-up")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    fill: "currentColor",
    stroke: "none",
    d: "M23.063 13.171a1.2 1.2 0 0 1 1.875 0l13.503 16.88c.628.785.069 1.949-.937 1.949H10.497c-1.006 0-1.565-1.164-.937-1.95l13.503-16.879Z"
  }));
}
var IconCaretUp = /* @__PURE__ */ React__default.forwardRef(IconCaretUpComponent);
IconCaretUp.defaultProps = {
  isIcon: true
};
IconCaretUp.displayName = "IconCaretUp";
var IconCaretUp$1 = IconCaretUp;
var __assign$1b = globalThis && globalThis.__assign || function() {
  __assign$1b = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1b.apply(this, arguments);
};
function ResizeTrigger(props) {
  var _a;
  var className = props.className, direction = props.direction, icon = props.icon, onMouseDown = props.onMouseDown, onResize = props.onResize, children = props.children, _b = props.collapsible, collapsible = _b === void 0 ? {} : _b, _c = props.resizable, resizable = _c === void 0 ? true : _c, renderChildren = props.renderChildren;
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var prefixCls2 = getPrefixCls("resizebox-trigger");
  var isHorizontal = direction === "horizontal";
  var classNames = cs$1(prefixCls2, prefixCls2 + "-" + (isHorizontal ? "horizontal" : "vertical"), (_a = {}, _a[prefixCls2 + "-not-resizable"] = !resizable, _a), className);
  var prevCollapsedConfig = isObject$e(collapsible.prev) ? __assign$1b(__assign$1b({}, collapsible.prev), { icon: collapsible.prev.icon || (isHorizontal ? React__default.createElement(IconCaretUp$1, null) : React__default.createElement(IconCaretLeft$1, null)) }) : {};
  var nextCollapsedConfig = isObject$e(collapsible.next) ? __assign$1b(__assign$1b({}, collapsible.next), { icon: collapsible.next.icon || (isHorizontal ? React__default.createElement(IconCaretDown$1, null) : React__default.createElement(IconCaretRight$1, null)) }) : {};
  var renderPrevCollapsedTrigger = function() {
    if (prevCollapsedConfig.icon && !prevCollapsedConfig.collapsed || nextCollapsedConfig.collapsed) {
      return React__default.createElement("span", { className: cs$1(prefixCls2 + "-icon", cs$1(prefixCls2 + "-prev")), onClick: prevCollapsedConfig.onClick }, prevCollapsedConfig.icon);
    }
    return React__default.createElement("span", { className: cs$1(prefixCls2 + "-icon-empty") });
  };
  var renderNextCollapsedTrigger = function() {
    if (nextCollapsedConfig.icon && !nextCollapsedConfig.collapsed || prevCollapsedConfig.collapsed) {
      return React__default.createElement("span", { className: cs$1(prefixCls2 + "-icon", cs$1(prefixCls2 + "-next")), onClick: nextCollapsedConfig.onClick }, nextCollapsedConfig.icon);
    }
    return React__default.createElement("span", { className: cs$1(prefixCls2 + "-icon-empty") });
  };
  var renderResizeTrigger = function() {
    if (resizable) {
      return React__default.createElement("span", { className: prefixCls2 + "-icon" }, icon || (isHorizontal ? React__default.createElement(IconDragDot$1, null) : React__default.createElement(IconDragDotVertical$1, null)));
    }
    return React__default.createElement("span", { className: cs$1(prefixCls2 + "-icon-empty") });
  };
  var prev = renderPrevCollapsedTrigger();
  var trigger = renderResizeTrigger();
  var next = renderNextCollapsedTrigger();
  var renderIcon = function() {
    return React__default.createElement("div", { className: prefixCls2 + "-icon-wrapper" }, prev, trigger, next);
  };
  if (!resizable) {
    return React__default.createElement("div", { className: classNames }, isFunction$5(renderChildren) ? renderChildren(prev, trigger, next) : children || renderIcon());
  }
  return React__default.createElement(ResizeObserver, { onResize }, React__default.createElement("div", { className: classNames, onMouseDown }, isFunction$5(renderChildren) ? renderChildren(prev, trigger, next) : children || renderIcon()));
}
var __read$S = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var DIRECTION_HORIZONTAL$1 = "horizontal";
var DIRECTION_VERTICAL$2 = "vertical";
function Split(props, ref) {
  var style = props.style, className = props.className, _a = props.component, component = _a === void 0 ? "div" : _a, _b = props.direction, direction = _b === void 0 ? "horizontal" : _b, icon = props.icon, _c = props.size, size = _c === void 0 ? 0.5 : _c, min = props.min, max = props.max, panes = props.panes, disabled = props.disabled, trigger = props.trigger;
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var prefixCls2 = getPrefixCls("resizebox-split");
  var isHorizontal = direction.includes(DIRECTION_HORIZONTAL$1);
  var isReverse = direction.includes("reverse");
  var isTriggerHorizontal = !isHorizontal;
  var classNames = cs$1(prefixCls2, prefixCls2 + "-" + (isHorizontal ? DIRECTION_HORIZONTAL$1 : DIRECTION_VERTICAL$2), className);
  var _d = __read$S(panes, 2), firstPane = _d[0], secondPane = _d[1];
  var isPxSize = typeof size === "string";
  var _e = __read$S(useState(parseFloat(size)), 2), offset = _e[0], setOffset = _e[1];
  var _f = __read$S(useState(0), 2), triggerSize = _f[0], setTriggerSize = _f[1];
  var recordRef = useRef({
    startX: 0,
    startY: 0,
    startWidth: 0,
    startHeight: 0,
    startOffset: 0,
    moving: false
  });
  var wrapperRef = useRef();
  var paneContainers = useRef([]);
  useImperativeHandle(ref, function() {
    return wrapperRef.current;
  }, []);
  function px2percent(numerator, denominator) {
    return parseFloat(numerator) / parseFloat(denominator);
  }
  function getOffset2(startSize, startOffset, startPosition, currentPosition) {
    var minOffset = min ? parseFloat(min) : 0;
    var maxOffset = max ? parseFloat(max) : isPxSize ? startSize : 1;
    var ratio = isReverse ? -1 : 1;
    var moveOffset = isPxSize ? startOffset + (currentPosition - startPosition) * ratio : px2percent(startSize * startOffset + (currentPosition - startPosition) * ratio, startSize);
    moveOffset = Math.max(moveOffset, minOffset);
    moveOffset = Math.min(moveOffset, maxOffset);
    return moveOffset;
  }
  function onTriggerMouseDown(e) {
    var _a2, _b2;
    props.onMovingStart && props.onMovingStart();
    recordRef.current.moving = true;
    recordRef.current.startX = e.pageX;
    recordRef.current.startY = e.pageY;
    recordRef.current.startWidth = (_a2 = wrapperRef.current) === null || _a2 === void 0 ? void 0 : _a2.offsetWidth;
    recordRef.current.startHeight = (_b2 = wrapperRef.current) === null || _b2 === void 0 ? void 0 : _b2.offsetHeight;
    recordRef.current.startOffset = offset;
    on(window, "mousemove", moving);
    on(window, "touchmove", moving);
    on(window, "mouseup", moveEnd);
    on(window, "touchend", moveEnd);
    on(window, "contextmenu", moveEnd);
    document.body.style.cursor = isTriggerHorizontal ? "row-resize" : "col-resize";
  }
  function moving(e) {
    if (recordRef.current.moving) {
      var newOffset = isHorizontal ? getOffset2(recordRef.current.startWidth, recordRef.current.startOffset, recordRef.current.startX, e.pageX) : getOffset2(recordRef.current.startHeight, recordRef.current.startOffset, recordRef.current.startY, e.pageY);
      setOffset(newOffset);
      props.onMoving && props.onMoving(e, isPxSize ? newOffset + "px" : newOffset);
    }
  }
  function moveEnd() {
    recordRef.current.moving = false;
    off(window, "mousemove", moving);
    off(window, "touchmove", moving);
    off(window, "mouseup", moveEnd);
    off(window, "touchend", moveEnd);
    off(window, "contextmenu", moveEnd);
    document.body.style.cursor = "default";
    props.onMovingEnd && props.onMovingEnd();
  }
  function onTriggerResize(e) {
    var contentRect = e[0].contentRect;
    var newTriggerSize = contentRect[isTriggerHorizontal ? "height" : "width"];
    setTriggerSize(newTriggerSize);
  }
  function getFirstPaneSize() {
    var unit = isPxSize ? "px" : "%";
    if (!offset)
      return "0" + unit;
    var baseVal = isPxSize ? offset : offset * 100;
    return "calc(" + baseVal + unit + " - " + triggerSize / 2 + "px)";
  }
  useEffect(function() {
    props.onPaneResize && props.onPaneResize(paneContainers.current);
  }, [offset, triggerSize]);
  useIsomorphicLayoutEffect$1(function() {
    var newOffset = parseFloat(size);
    if (offset !== newOffset) {
      setOffset(newOffset);
    }
  }, [size]);
  var Tag2 = component;
  var firstPaneNode = React__default.createElement("div", { className: cs$1(prefixCls2 + "-pane", "first-pane"), style: { flexBasis: getFirstPaneSize() }, ref: function(el) {
    paneContainers.current[0] = el;
  } }, firstPane);
  var secondPaneNode = React__default.createElement("div", { className: cs$1(prefixCls2 + "-pane", "second-pane"), ref: function(el) {
    paneContainers.current[1] = el;
  } }, secondPane);
  return React__default.createElement(Tag2, { style, className: classNames, ref: wrapperRef }, isReverse ? secondPaneNode : firstPaneNode, !disabled && React__default.createElement(ResizeTrigger, { className: prefixCls2 + "-trigger", direction: isTriggerHorizontal ? DIRECTION_HORIZONTAL$1 : DIRECTION_VERTICAL$2, icon, onMouseDown: onTriggerMouseDown, onResize: onTriggerResize }, trigger), isReverse ? firstPaneNode : secondPaneNode);
}
var SplitComponent = forwardRef(Split);
SplitComponent.displayName = "ResizeBoxSplit";
var Split$1 = SplitComponent;
var __read$R = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$n = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DIRECTION_HORIZONTAL = "horizontal";
var DIRECTION_VERTICAL$1 = "vertical";
function SplitGroup(props, ref) {
  var _a;
  var panes = props.panes, style = props.style, className = props.className, _b = props.component, component = _b === void 0 ? "div" : _b, _c = props.direction, direction = _c === void 0 ? "horizontal" : _c, icon = props.icon;
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var defaultOffset = 1 / panes.length;
  var wrapperRef = useRef();
  var recordRef = useRef(new Array(panes.length).fill({
    moving: false,
    startOffset: 0,
    startPosition: 0
  }));
  var paneContainers = useRef([]);
  var movingIndex = useRef(0);
  var prevOffsets = useRef([]);
  var _d = __read$R(useState(new Array(panes.length).fill(defaultOffset)), 2), offsets = _d[0], setOffsets = _d[1];
  var _e = __read$R(useState(false), 2), isMoving = _e[0], setIsMoving = _e[1];
  var _f = __read$R(useState(new Array(panes.length).fill(0)), 2), triggerSize = _f[0], setTriggerSize = _f[1];
  var _g = __read$R(useState(new Array(Math.max(panes.length - 1, 0)).fill({ prev: false, next: false })), 2), collapsedStatus = _g[0], setCollapsedStatus = _g[1];
  var prefixCls2 = getPrefixCls("resizebox-split-group");
  var isHorizontal = direction === DIRECTION_HORIZONTAL;
  var isTriggerHorizontal = !isHorizontal;
  var classNames = cs$1(prefixCls2, prefixCls2 + "-" + (isHorizontal ? DIRECTION_HORIZONTAL : DIRECTION_VERTICAL$1), (_a = {}, _a[prefixCls2 + "-moving"] = isMoving, _a), className);
  var Tag2 = component;
  var getInitialOffsets = function() {
    var newOffsets = [];
    panes.forEach(function(pane) {
      var size = pane.size;
      if (!isUndefined(size)) {
        newOffsets.push(formatSize(size));
      } else {
        newOffsets.push(void 0);
      }
    });
    var noSizeArr = newOffsets.filter(function(size) {
      return !size;
    });
    var remainPercent = 1 - newOffsets.reduce(function(a, b) {
      var formatA = a || 0;
      var formatB = b || 0;
      return formatA + formatB;
    }, 0);
    var averagePercent = remainPercent / noSizeArr.length;
    newOffsets = newOffsets.map(function(size) {
      if (!isUndefined(size)) {
        return size;
      }
      return averagePercent;
    });
    return newOffsets;
  };
  var getPaneSize = function(index2) {
    var prevTriggerSize = triggerSize[index2 - 1] || 0;
    var currentTriggerSize = triggerSize[index2];
    var baseVal = offsets[index2] * 100;
    var unit = "%";
    return "calc(" + baseVal + unit + " - " + (prevTriggerSize + currentTriggerSize) / 2 + "px)";
  };
  function formatSize(size) {
    var totalPX = isHorizontal ? wrapperRef.current.offsetWidth : wrapperRef.current.offsetHeight;
    if (!size || isNumber$1(size) && size < 0) {
      return 0;
    }
    var percent = isString$1(size) ? parseFloat(size) / totalPX : size;
    return Math.min(percent, 1);
  }
  var getMinAndMax = function(index2) {
    var next = Math.min(index2 + 1, panes.length - 1);
    var totalOffset = offsets[index2] + offsets[next];
    var currentMin = formatSize(panes[index2].min) || 0;
    var currentMax = formatSize(panes[index2].max) || totalOffset;
    var nextMin = formatSize(panes[next].min) || 0;
    var nextMax = formatSize(panes[next].max) || totalOffset;
    currentMax = Math.min(totalOffset - nextMin, currentMax);
    nextMax = Math.min(totalOffset - currentMin, nextMax);
    return {
      currentMin,
      currentMax,
      nextMin,
      nextMax
    };
  };
  var getNewOffsets = function(startOffset, startPosition, currentPosition) {
    var current = movingIndex.current;
    var next = current + 1;
    var newOffsets = __spreadArray$n([], __read$R(offsets), false);
    var currentPercent = offsets[current];
    var nextPercent = offsets[next];
    var totalPercent = currentPercent + nextPercent;
    var _a2 = getMinAndMax(current), minOffset = _a2.currentMin, maxOffset = _a2.currentMax;
    var moveOffset = startOffset + formatSize(currentPosition - startPosition + "px");
    moveOffset = Math.max(minOffset, moveOffset);
    moveOffset = Math.min(maxOffset, moveOffset);
    newOffsets[current] = moveOffset;
    newOffsets[next] = totalPercent - moveOffset;
    return newOffsets;
  };
  function onTriggerResize(e, index2) {
    var contentRect = e[0].contentRect;
    var currentSize = contentRect[isTriggerHorizontal ? "height" : "width"];
    var newTriggerSize = __spreadArray$n([], __read$R(triggerSize), false);
    newTriggerSize[index2] = currentSize;
    setTriggerSize(newTriggerSize);
  }
  var getCollapsedConfig = function(index2) {
    var collapsible = panes[index2].collapsible;
    if (!isObject$e(collapsible)) {
      collapsible = !collapsible ? {} : { prev: true, next: true };
    }
    var prev = collapsible.prev, next = collapsible.next;
    if (!prev && !next) {
      return {};
    }
    if (!collapsedStatus[index2]) {
      return {};
    }
    var hasPrev = !!prev || !prev && collapsedStatus[index2].next;
    var hasNext = !!next || !next && collapsedStatus[index2].prev;
    return { hasPrev, hasNext };
  };
  function onTriggerMouseDown(e, index2) {
    props.onMovingStart && props.onMovingStart(index2);
    movingIndex.current = index2;
    var currentRecord = recordRef.current[index2];
    currentRecord.moving = true;
    currentRecord.startOffset = offsets[index2];
    currentRecord.startPosition = isHorizontal ? e.pageX : e.pageY;
    setIsMoving(true);
    on(window, "mousemove", moving);
    on(window, "touchmove", moving);
    on(window, "mouseup", moveEnd);
    on(window, "touchend", moveEnd);
    on(window, "contextmenu", moveEnd);
    document.body.style.cursor = isTriggerHorizontal ? "row-resize" : "col-resize";
  }
  function moving(e) {
    var index2 = movingIndex.current;
    var currentRecord = recordRef.current[index2];
    var totalPX = isHorizontal ? wrapperRef.current.offsetWidth : wrapperRef.current.offsetHeight;
    if (currentRecord.moving) {
      var newOffsets = getNewOffsets(currentRecord.startOffset, currentRecord.startPosition, isHorizontal ? e.pageX : e.pageY);
      setOffsets(newOffsets);
      prevOffsets.current = newOffsets;
      props.onMoving && props.onMoving(e, newOffsets.map(function(value) {
        return value * totalPX + "px";
      }), index2);
    }
  }
  function moveEnd() {
    var index2 = movingIndex.current;
    recordRef.current[index2].moving = false;
    setIsMoving(false);
    off(window, "mousemove", moving);
    off(window, "touchmove", moving);
    off(window, "mouseup", moveEnd);
    off(window, "touchend", moveEnd);
    off(window, "contextmenu", moveEnd);
    document.body.style.cursor = "default";
    props.onMovingEnd && props.onMovingEnd(index2);
  }
  function handleCollapsed(e, index2, status, callback) {
    var next = index2 + 1;
    var newOffset = __spreadArray$n([], __read$R(offsets), false);
    var currentOffset = offsets[index2];
    var nextOffset = offsets[next];
    var totalOffset = currentOffset + nextOffset;
    var totalPX = isHorizontal ? wrapperRef.current.offsetWidth : wrapperRef.current.offsetHeight;
    var _a2 = getMinAndMax(index2), currentMin = _a2.currentMin, nextMin = _a2.nextMin;
    var newCurrentOffset = prevOffsets.current[index2];
    var newNextOffset = prevOffsets.current[next];
    var collapsed = collapsedStatus[index2][status];
    if (status === "prev") {
      if (nextOffset !== nextMin || newNextOffset === nextMin) {
        newCurrentOffset = currentMin;
        newNextOffset = totalOffset - currentMin;
        collapsed = true;
      }
    } else if (currentOffset !== currentMin || newCurrentOffset === currentMin) {
      newCurrentOffset = totalOffset - nextMin;
      newNextOffset = nextMin;
      collapsed = true;
    }
    newOffset[index2] = newCurrentOffset;
    newOffset[next] = newNextOffset;
    props.onMoving && props.onMoving(e, newOffset.map(function(value) {
      return value * totalPX + "px";
    }), index2);
    props.onMovingEnd && props.onMovingEnd(index2);
    setOffsets(newOffset);
    if (isFunction$5(callback)) {
      callback(e, index2, status, collapsed);
    }
  }
  useEffect(function() {
    var offsets2 = getInitialOffsets();
    setOffsets(offsets2);
    prevOffsets.current = offsets2;
  }, [JSON.stringify(panes.map(function(item2) {
    return item2.size;
  }))]);
  useImperativeHandle(ref, function() {
    return wrapperRef.current;
  }, []);
  useEffect(function() {
    var newCollapsedStatus = [];
    offsets.forEach(function(offset, index2) {
      var currentCollapsedStatus = { prev: false, next: false };
      var next = index2 + 1;
      var _a2 = getMinAndMax(index2), currentMin = _a2.currentMin, nextMin = _a2.nextMin;
      if (offset === currentMin) {
        currentCollapsedStatus.prev = true;
      } else if (offsets[next] === nextMin) {
        currentCollapsedStatus.next = true;
      }
      newCollapsedStatus.push(currentCollapsedStatus);
    });
    setCollapsedStatus(newCollapsedStatus);
  }, [offsets]);
  return React__default.createElement(Tag2, { style, className: classNames, ref: wrapperRef }, panes.map(function(pane, index2) {
    var content = pane.content, disabled = pane.disabled, trigger = pane.trigger, _a2 = pane.resizable, resizable = _a2 === void 0 ? true : _a2, _b2 = pane.collapsible, collapsible = _b2 === void 0 ? {} : _b2;
    var _c2 = getCollapsedConfig(index2), hasPrev = _c2.hasPrev, hasNext = _c2.hasNext;
    var prevConfig = isObject$e(collapsible) && isObject$e(collapsible.prev) ? collapsible.prev : {};
    var nextConfig = isObject$e(collapsible) && isObject$e(collapsible.next) ? collapsible.next : {};
    return React__default.createElement(React__default.Fragment, { key: index2 }, React__default.createElement("div", { className: prefixCls2 + "-pane", style: { flexBasis: getPaneSize(index2) }, ref: function(el) {
      return paneContainers.current[index2] = el;
    } }, content), !disabled && index2 !== panes.length - 1 && React__default.createElement(ResizeTrigger, { className: prefixCls2 + "-trigger", direction: isTriggerHorizontal ? DIRECTION_HORIZONTAL : DIRECTION_VERTICAL$1, icon, onResize: function(e) {
      return onTriggerResize(e, index2);
    }, onMouseDown: function(e) {
      return onTriggerMouseDown(e, index2);
    }, collapsible: {
      prev: hasPrev ? {
        onClick: function(e) {
          return handleCollapsed(e, index2, "prev", prevConfig.onClick);
        },
        icon: prevConfig.icon,
        collapsed: collapsedStatus[index2].prev
      } : void 0,
      next: hasNext ? {
        onClick: function(e) {
          return handleCollapsed(e, index2, "next", nextConfig.onClick);
        },
        icon: nextConfig.icon,
        collapsed: collapsedStatus[index2].next
      } : void 0
    }, resizable, renderChildren: trigger }));
  }));
}
var SplitGroupComponent = forwardRef(SplitGroup);
SplitGroupComponent.displayName = "ResizeBoxSplitGroup";
var SplitGroup$1 = SplitGroupComponent;
var __assign$1a = globalThis && globalThis.__assign || function() {
  __assign$1a = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1a.apply(this, arguments);
};
var __read$Q = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var DIRECTION_LEFT = "left";
var DIRECTION_RIGHT = "right";
var DIRECTION_TOP = "top";
var DIRECTION_BOTTOM = "bottom";
var allDirections = [
  DIRECTION_LEFT,
  DIRECTION_RIGHT,
  DIRECTION_TOP,
  DIRECTION_BOTTOM
];
var defaultProps$m = {
  component: "div",
  directions: ["right"],
  resizeIcons: {},
  resizeTriggers: {}
};
function ResizeBox(baseProps, ref) {
  var _a = useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, componentConfig2 = _a.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$m, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.ResizeBox);
  var style = props.style, className = props.className, component = props.component, directions = props.directions, resizeIcons = props.resizeIcons, children = props.children, resizeTriggers = props.resizeTriggers, propWidth = props.width, propHeight = props.height;
  var prefixCls2 = getPrefixCls("resizebox");
  var classNames = cs$1(prefixCls2, className);
  var _b = __read$Q(useState({}), 2), paddingStyles = _b[0], setPaddingStyles = _b[1];
  var _c = __read$Q(useMergeValue(void 0, { value: propWidth }), 2), width = _c[0], setWidth = _c[1];
  var _d = __read$Q(useMergeValue(void 0, { value: propHeight }), 2), height = _d[0], setHeight = _d[1];
  var recordRef = useRef({
    startX: 0,
    startY: 0,
    startWidth: 0,
    startHeight: 0,
    direction: DIRECTION_RIGHT,
    moving: false,
    padding: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    }
  });
  var wrapperRef = useRef();
  useImperativeHandle(ref, function() {
    return wrapperRef.current;
  }, []);
  function getIsHorizontal(direction) {
    return [DIRECTION_TOP, DIRECTION_BOTTOM].indexOf(direction) > -1;
  }
  function getRealSize(clientSize, padding) {
    if (clientSize === 0)
      return 0;
    var res = clientSize - padding;
    return res <= 0 ? 0 : res;
  }
  function onTriggerMouseDown(direction, e) {
    var _a2, _b2;
    props.onMovingStart && props.onMovingStart();
    recordRef.current.moving = true;
    recordRef.current.startX = e.pageX;
    recordRef.current.startY = e.pageY;
    recordRef.current.direction = direction;
    var _c2 = recordRef.current.padding, top = _c2.top, left = _c2.left, right = _c2.right, bottom = _c2.bottom;
    recordRef.current.startWidth = getRealSize((_a2 = wrapperRef.current) === null || _a2 === void 0 ? void 0 : _a2.clientWidth, left + right);
    recordRef.current.startHeight = getRealSize((_b2 = wrapperRef.current) === null || _b2 === void 0 ? void 0 : _b2.clientHeight, top + bottom);
    on(window, "mousemove", moving);
    on(window, "touchmove", moving);
    on(window, "mouseup", moveEnd);
    on(window, "touchend", moveEnd);
    on(window, "contextmenu", moveEnd);
    document.body.style.cursor = getIsHorizontal(direction) ? "row-resize" : "col-resize";
  }
  function moving(e) {
    if (!recordRef.current.moving)
      return false;
    var _a2 = recordRef.current, startX = _a2.startX, startY = _a2.startY, startWidth = _a2.startWidth, startHeight = _a2.startHeight;
    var newWidth = startWidth;
    var newHeight = startHeight;
    var offsetX = e.pageX - startX;
    var offsetY = e.pageY - startY;
    switch (recordRef.current.direction) {
      case DIRECTION_LEFT:
        newWidth = startWidth - offsetX;
        setWidth(newWidth);
        break;
      case DIRECTION_RIGHT:
        newWidth = startWidth + offsetX;
        setWidth(newWidth);
        break;
      case DIRECTION_TOP:
        newHeight = startHeight - offsetY;
        setHeight(newHeight);
        break;
      case DIRECTION_BOTTOM:
        newHeight = startHeight + offsetY;
        setHeight(newHeight);
        break;
    }
    props.onMoving && props.onMoving(e, {
      width: newWidth,
      height: newHeight
    });
  }
  function moveEnd() {
    recordRef.current.moving = false;
    offEvents();
    document.body.style.cursor = "default";
    props.onMovingEnd && props.onMovingEnd();
  }
  function offEvents() {
    off(window, "mousemove", moving);
    off(window, "touchmove", moving);
    off(window, "mouseup", moveEnd);
    off(window, "touchend", moveEnd);
    off(window, "contextmenu", moveEnd);
  }
  function onTriggerResize(direction, e) {
    var isHorizontal = getIsHorizontal(direction);
    var contentRect = e[0].contentRect;
    var styleDirection = "" + direction.slice(0, 1).toUpperCase() + direction.slice(1);
    var size = contentRect[isHorizontal ? "height" : "width"];
    recordRef.current.padding[direction] = size;
    setPaddingStyles(function(pre) {
      var _a2;
      return __assign$1a(__assign$1a({}, pre), (_a2 = {}, _a2["padding" + styleDirection] = size, _a2));
    });
  }
  var wrapperStyles = __assign$1a(__assign$1a(__assign$1a(__assign$1a({}, paddingStyles), style || {}), isNumber$1(width) ? { width } : {}), isNumber$1(height) ? { height } : {});
  var Tag2 = component;
  return React__default.createElement(Tag2, { style: wrapperStyles, className: classNames, ref: wrapperRef }, children, directions.map(function(direction) {
    if (allDirections.indexOf(direction) !== -1) {
      return React__default.createElement(ResizeTrigger, { key: direction, className: prefixCls2 + "-direction-" + direction, direction: getIsHorizontal(direction) ? "horizontal" : "vertical", icon: resizeIcons[direction], onMouseDown: function(e) {
        onTriggerMouseDown(direction, e);
      }, onResize: function(e) {
        onTriggerResize(direction, e);
      } }, resizeTriggers[direction]);
    }
  }));
}
var ForwardRefResizeBox = forwardRef(ResizeBox);
var ResizeBoxComponent = ForwardRefResizeBox;
ResizeBoxComponent.Split = Split$1;
ResizeBoxComponent.SplitGroup = SplitGroup$1;
ResizeBoxComponent.displayName = "ResizeBox";
var ResizeBox$1 = ResizeBoxComponent;
var __assign$19 = globalThis && globalThis.__assign || function() {
  __assign$19 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$19.apply(this, arguments);
};
var responsiveArray = ["xxl", "xl", "lg", "md", "sm", "xs"];
var responsiveMap = {
  xs: "(max-width: 575px)",
  sm: "(min-width: 576px)",
  md: "(min-width: 768px)",
  lg: "(min-width: 992px)",
  xl: "(min-width: 1200px)",
  xxl: "(min-width: 1600px)"
};
var subscribers = [];
var subUid = -1;
var screens = {};
var responsiveObserve = {
  matchHandlers: {},
  dispatch: function(pointMap, breakpointChecked) {
    screens = pointMap;
    if (subscribers.length < 1) {
      return false;
    }
    subscribers.forEach(function(item2) {
      item2.func(screens, breakpointChecked);
    });
    return true;
  },
  subscribe: function(func) {
    if (subscribers.length === 0) {
      this.register();
    }
    var token = (++subUid).toString();
    subscribers.push({
      token,
      func
    });
    func(screens, null);
    return token;
  },
  unsubscribe: function(token) {
    subscribers = subscribers.filter(function(item2) {
      return item2.token !== token;
    });
    if (subscribers.length === 0) {
      this.unregister();
    }
  },
  unregister: function() {
    var _this = this;
    Object.keys(responsiveMap).forEach(function(screen) {
      var matchMediaQuery = responsiveMap[screen];
      var handler = _this.matchHandlers[matchMediaQuery];
      if (handler && handler.mql && handler.listener) {
        handler.mql.removeListener(handler.listener);
      }
    });
  },
  register: function() {
    var _this = this;
    Object.keys(responsiveMap).forEach(function(screen) {
      var matchMediaQuery = responsiveMap[screen];
      var listener = function(_a) {
        var _b;
        var matches = _a.matches;
        _this.dispatch(__assign$19(__assign$19({}, screens), (_b = {}, _b[screen] = matches, _b)), screen);
      };
      var mql = window.matchMedia(matchMediaQuery);
      mql.addListener(listener);
      _this.matchHandlers[matchMediaQuery] = {
        mql,
        listener
      };
      listener(mql);
    });
  }
};
var ResponsiveObserve = responsiveObserve;
var __assign$18 = globalThis && globalThis.__assign || function() {
  __assign$18 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$18.apply(this, arguments);
};
var __read$P = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var SiderContext = createContext({
  siderCollapsed: false,
  collapsedWidth: 64
});
var generateId = function() {
  var i2 = 0;
  return function(prefix) {
    if (prefix === void 0) {
      prefix = "";
    }
    i2 += 1;
    return "" + prefix + i2;
  };
}();
function Sider(props, ref) {
  var _a;
  var _b;
  var children = props.children, className = props.className, style = props.style, _c = props.theme, theme = _c === void 0 ? "light" : _c, trigger = props.trigger, reverseArrow = props.reverseArrow, _d = props.collapsedWidth, collapsedWidth = _d === void 0 ? 48 : _d, _e = props.width, width = _e === void 0 ? 200 : _e, collapsible = props.collapsible, resizeDirections = props.resizeDirections, onSiderMount = props.onSiderMount, onSiderUnmount = props.onSiderUnmount, breakpoint = props.breakpoint, onBreakpoint = props.onBreakpoint, onCollapse = props.onCollapse, _f = props.resizeBoxProps, resizeBoxProps = _f === void 0 ? {} : _f;
  var uniqueId = generateId("arco-sider-");
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var prefixCls2 = getPrefixCls("layout-sider");
  var _g = __read$P(useMergeValue(false, {
    value: props.collapsed
  }), 2), collapsed = _g[0], setCollapsed = _g[1];
  var propsWidth = isNumber$1(width) ? width + "px" : String(width);
  var _h = __read$P(useState(propsWidth), 2), siderWidth = _h[0], setSiderWidth = _h[1];
  var refResponsiveHandlerToken = useRef(null);
  var refStateForResponsiveHandler = useRef(null);
  refStateForResponsiveHandler.current = {
    breakpoint,
    collapsed,
    onCollapse,
    onBreakpoint
  };
  useEffect(function() {
    onSiderMount && onSiderMount(uniqueId);
    if (collapsible && breakpoint in responsiveMap) {
      refResponsiveHandlerToken.current = ResponsiveObserve.subscribe(function(screens2, breakpointChecked) {
        var _a2 = refStateForResponsiveHandler.current, breakpoint2 = _a2.breakpoint, collapsed2 = _a2.collapsed, onCollapse2 = _a2.onCollapse, onBreakpoint2 = _a2.onBreakpoint;
        if (!breakpointChecked || breakpointChecked === breakpoint2) {
          var nextCollapsed = !screens2[breakpoint2];
          if (nextCollapsed !== collapsed2) {
            setCollapsed(nextCollapsed);
            onCollapse2 && onCollapse2(nextCollapsed, "responsive");
          }
          onBreakpoint2 && onBreakpoint2(nextCollapsed);
        }
      });
    }
    return function() {
      onSiderUnmount && onSiderUnmount(uniqueId);
      if (refResponsiveHandlerToken.current) {
        ResponsiveObserve.unsubscribe(refResponsiveHandlerToken.current);
      }
    };
  }, []);
  useEffect(function() {
    var _collapsedWidth = isNumber$1(collapsedWidth) ? collapsedWidth + "px" : String(collapsedWidth);
    setSiderWidth(collapsed ? _collapsedWidth : propsWidth);
  }, [collapsed, propsWidth, collapsedWidth]);
  var resizable = resizeDirections && isArray$c(resizeDirections) || ((_b = resizeBoxProps.directions) === null || _b === void 0 ? void 0 : _b.length);
  var TagName = resizable ? ResizeBox$1 : "aside";
  var renderTrigger = function() {
    var _a2;
    var triggerIcon = trigger || (collapsed ? reverseArrow ? React__default.createElement(IconLeft$1, null) : React__default.createElement(IconRight$1, null) : reverseArrow ? React__default.createElement(IconRight$1, null) : React__default.createElement(IconLeft$1, null));
    return collapsible && trigger !== null ? React__default.createElement("div", { style: { width: siderWidth }, className: cs$1(prefixCls2 + "-trigger", (_a2 = {}, _a2[prefixCls2 + "-trigger-light"] = theme === "light", _a2)), onClick: function() {
      setCollapsed(!collapsed);
      onCollapse && onCollapse(!collapsed, "clickTrigger");
    } }, triggerIcon) : null;
  };
  var resizeProps = useMemo(function() {
    if (resizable) {
      return __assign$18(__assign$18({ component: "aside", onMoving: function(_, _a2) {
        var currentWidth = _a2.width;
        setSiderWidth(currentWidth);
      } }, resizeBoxProps), { width: siderWidth, directions: resizeDirections });
    }
    return {};
  }, [resizable, resizeDirections, siderWidth, resizeBoxProps]);
  return React__default.createElement(SiderContext.Provider, { value: {
    siderCollapsed: collapsed,
    collapsedWidth
  } }, React__default.createElement(TagName, __assign$18({ ref, style: __assign$18({ width: siderWidth }, style), className: cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-light"] = theme === "light", _a[prefixCls2 + "-has-trigger"] = trigger !== null && collapsible, _a[prefixCls2 + "-collapsed"] = collapsed, _a), className) }, resizeProps), React__default.createElement("div", { className: prefixCls2 + "-children" }, children), renderTrigger()));
}
var SiderComponent = forwardRef(Sider);
SiderComponent.defaultProps = {
  sign: "sider"
};
SiderComponent.displayName = "LayoutSider";
var Sider$1 = SiderComponent;
var __assign$17 = globalThis && globalThis.__assign || function() {
  __assign$17 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$17.apply(this, arguments);
};
var __rest$y = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function Header$1(props, ref) {
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var className = props.className, children = props.children, rest = __rest$y(props, ["className", "children"]);
  var prefixCls2 = getPrefixCls("layout-header");
  var classNames = cs$1(prefixCls2, className);
  return React__default.createElement("header", __assign$17({ ref }, rest, { className: classNames }), children);
}
var HeaderComponent = forwardRef(Header$1);
HeaderComponent.displayName = "LayoutHeader";
var Header$2 = HeaderComponent;
var __assign$16 = globalThis && globalThis.__assign || function() {
  __assign$16 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$16.apply(this, arguments);
};
var __rest$x = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function Footer$1(props, ref) {
  var className = props.className, children = props.children, rest = __rest$x(props, ["className", "children"]);
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var prefixCls2 = getPrefixCls("layout-footer");
  var classNames = cs$1(prefixCls2, className);
  return React__default.createElement("footer", __assign$16({ ref }, rest, { className: classNames }), children);
}
var FooterComponent = forwardRef(Footer$1);
FooterComponent.displayName = "LayoutFooter";
var Footer$2 = FooterComponent;
var __assign$15 = globalThis && globalThis.__assign || function() {
  __assign$15 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$15.apply(this, arguments);
};
var __rest$w = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function Content(props, ref) {
  var className = props.className, children = props.children, rest = __rest$w(props, ["className", "children"]);
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var prefixCls2 = getPrefixCls("layout-content");
  var classNames = cs$1(prefixCls2, className);
  return React__default.createElement("main", __assign$15({ ref }, rest, { className: classNames }), children);
}
var contentComponent = forwardRef(Content);
contentComponent.displayName = "LayoutContent";
var Content$1 = contentComponent;
var __assign$14 = globalThis && globalThis.__assign || function() {
  __assign$14 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$14.apply(this, arguments);
};
var __rest$v = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$O = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$m = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function Layout(baseProps, ref) {
  var _a;
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig2 = _b.componentConfig;
  var props = useMergeProps(baseProps, {}, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Layout);
  var className = props.className, hasSider = props.hasSider, children = props.children, rest = __rest$v(props, ["className", "hasSider", "children"]);
  var _c = __read$O(useState([]), 2), siders = _c[0], setSiders = _c[1];
  var prefixCls2 = getPrefixCls("layout");
  var classNames = cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-has-sider"] = typeof hasSider === "boolean" ? hasSider : siders.length > 0, _a), className);
  return React__default.createElement("section", __assign$14({ ref }, rest, { className: classNames }), React__default.Children.map(children, function(child) {
    if (child && child.props && child.props.sign === "sider") {
      return React__default.cloneElement(child, {
        onSiderMount: function(id) {
          return setSiders(__spreadArray$m(__spreadArray$m([], __read$O(siders), false), [id], false));
        },
        onSiderUnmount: function(id) {
          return setSiders(siders.filter(function(currentId) {
            return currentId !== id;
          }));
        }
      });
    }
    return child;
  }));
}
var ForwardRefLayout = forwardRef(Layout);
var LayoutComponent = ForwardRefLayout;
LayoutComponent.displayName = "Layout";
LayoutComponent.Sider = Sider$1;
LayoutComponent.Header = Header$2;
LayoutComponent.Footer = Footer$2;
LayoutComponent.Content = Content$1;
var Layout$1 = LayoutComponent;
function ownKeys$g(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$g(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$g(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$g(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconMenuFoldComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$g(_objectSpread$g({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-menu-fold")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M42 11H6M42 24H22M42 37H6M13.66 26.912l-4.82-3.118 4.82-3.118v6.236Z"
  }));
}
var IconMenuFold = /* @__PURE__ */ React__default.forwardRef(IconMenuFoldComponent);
IconMenuFold.defaultProps = {
  isIcon: true
};
IconMenuFold.displayName = "IconMenuFold";
var IconMenuFold$1 = IconMenuFold;
function ownKeys$f(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$f(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$f(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$f(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconMenuUnfoldComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$f(_objectSpread$f({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-menu-unfold")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M6 11h36M22 24h20M6 37h36M8 20.882 12.819 24 8 27.118v-6.236Z"
  }));
}
var IconMenuUnfold = /* @__PURE__ */ React__default.forwardRef(IconMenuUnfoldComponent);
IconMenuUnfold.defaultProps = {
  isIcon: true
};
IconMenuUnfold.displayName = "IconMenuUnfold";
var IconMenuUnfold$1 = IconMenuUnfold;
var __assign$13 = globalThis && globalThis.__assign || function() {
  __assign$13 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$13.apply(this, arguments);
};
var __rest$u = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$N = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$l = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var globalMenuIndex = 0;
var DEFAULT_THEME = "light";
var defaultProps$l = {
  mode: "vertical",
  selectable: true,
  ellipsis: true
};
function Menu(baseProps, ref) {
  var _a;
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig2 = _b.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$l, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Menu);
  var style = props.style, children = props.children, className = props.className, menuPrefixCls = props.prefixCls, mode = props.mode, propTheme = props.theme, icons = props.icons, levelIndent = props.levelIndent, propCollapse = props.collapse, inDropdown = props.inDropdown, selectable = props.selectable, triggerProps = props.triggerProps, tooltipProps = props.tooltipProps, ellipsis = props.ellipsis, accordion = props.accordion, autoOpen = props.autoOpen, autoScrollIntoView = props.autoScrollIntoView, scrollConfig = props.scrollConfig, hasCollapseButton = props.hasCollapseButton, defaultOpenKeys = props.defaultOpenKeys, defaultSelectedKeys = props.defaultSelectedKeys, propOpenKeys = props.openKeys, propSelectedKeys = props.selectedKeys, onClickSubMenu = props.onClickSubMenu, onClickMenuItem = props.onClickMenuItem, onCollapseChange = props.onCollapseChange, rest = __rest$u(props, ["style", "children", "className", "prefixCls", "mode", "theme", "icons", "levelIndent", "collapse", "inDropdown", "selectable", "triggerProps", "tooltipProps", "ellipsis", "accordion", "autoOpen", "autoScrollIntoView", "scrollConfig", "hasCollapseButton", "defaultOpenKeys", "defaultSelectedKeys", "openKeys", "selectedKeys", "onClickSubMenu", "onClickMenuItem", "onCollapseChange"]);
  var _c = __read$N(useMergeValue([], {
    defaultValue: defaultOpenKeys,
    value: propOpenKeys
  }), 2), openKeys = _c[0], setOpenKeys = _c[1];
  var _d = __read$N(useMergeValue([], {
    defaultValue: defaultSelectedKeys,
    value: propSelectedKeys
  }), 2), selectedKeys = _d[0], setSelectedKeys = _d[1];
  var _e = __read$N(useMergeValue(false, {
    value: propCollapse
  }), 2), collapse = _e[0], setCollapse = _e[1];
  var menuContext = useContext(MenuContext$1);
  var siderCollapsed = useContext(SiderContext).siderCollapsed;
  var prefixCls2 = menuPrefixCls || getPrefixCls("menu");
  var mergedCollapse = siderCollapsed || collapse || inDropdown || mode === "popButton";
  var theme = propTheme || menuContext.theme || DEFAULT_THEME;
  var refSubMenuKeys = useRef([]);
  var refPrevSubMenuKeys = useRef([]);
  var forceUpdate = useForceUpdate();
  var menuInfoMap = useMemo(function() {
    return generateInfoMap(children);
  }, [children]);
  var instanceId = useMemo(function() {
    if (rest.id) {
      return rest.id;
    }
    var id = prefixCls2 + "-" + globalMenuIndex;
    globalMenuIndex++;
    return id;
  }, [rest.id]);
  useEffect(function() {
    var validOpenKeys = openKeys.filter(function(key) {
      return refSubMenuKeys.current.indexOf(key) !== -1;
    });
    if (autoOpen) {
      var keysAdded = refSubMenuKeys.current.filter(function(key) {
        return refPrevSubMenuKeys.current.indexOf(key) === -1;
      });
      validOpenKeys = openKeys.concat(keysAdded);
    }
    setOpenKeys(accordion ? validOpenKeys.slice(0, 1) : validOpenKeys);
    refPrevSubMenuKeys.current = refSubMenuKeys.current.slice();
  }, [refSubMenuKeys.current.toString()]);
  var mergedHasCollapseButton = mode !== "horizontal" && mode !== "popButton" && !inDropdown && hasCollapseButton;
  var renderChildren = function() {
    var childrenList = processChildren(children, { level: 1 });
    var collapseIcon = collapse ? icons && icons.collapseActive || React__default.createElement(IconMenuUnfold$1, null) : icons && icons.collapseDefault || React__default.createElement(IconMenuFold$1, null);
    return React__default.createElement(React__default.Fragment, null, React__default.createElement("div", { className: prefixCls2 + "-inner" }, mode === "horizontal" && ellipsis !== false ? React__default.createElement(OverflowWrap$1, null, childrenList) : childrenList), mergedHasCollapseButton && React__default.createElement("div", { tabIndex: 0, role: "button", "aria-controls": instanceId, "aria-expanded": !collapse, className: prefixCls2 + "-collapse-button", onClick: function() {
      var newCollapse = !collapse;
      setCollapse(newCollapse);
      onCollapseChange && onCollapseChange(newCollapse);
    } }, collapseIcon));
  };
  var usedStyle = __assign$13({}, style);
  if (mergedCollapse && !inDropdown) {
    delete usedStyle.width;
  }
  return React__default.createElement("div", __assign$13({ id: mergedHasCollapseButton ? instanceId : void 0, role: "menu" }, omit$1(rest, ["isMenu"]), { ref, style: usedStyle, className: cs$1(prefixCls2, prefixCls2 + "-" + theme, prefixCls2 + "-" + (mode === "horizontal" ? "horizontal" : "vertical"), (_a = {}, _a[prefixCls2 + "-collapse"] = mergedCollapse, _a[prefixCls2 + "-pop"] = mode === "pop" || mergedCollapse, _a[prefixCls2 + "-pop-button"] = mode === "popButton", _a), className) }), React__default.createElement(MenuContext$1.Provider, { value: {
    mode,
    theme,
    collapse: mergedCollapse,
    levelIndent,
    inDropdown,
    selectedKeys,
    openKeys,
    icons,
    triggerProps,
    tooltipProps,
    autoScrollIntoView,
    scrollConfig,
    id: instanceId,
    prefixCls: prefixCls2,
    collectInlineMenuKeys: function(key, unmount) {
      if (unmount) {
        refSubMenuKeys.current = refSubMenuKeys.current.filter(function(x) {
          return x !== key;
        });
      } else {
        refSubMenuKeys.current.push(key);
      }
      forceUpdate();
    },
    onClickMenuItem: function(key, event2) {
      var _a2;
      selectable && setSelectedKeys([key]);
      onClickMenuItem && onClickMenuItem(key, event2, (_a2 = menuInfoMap[key]) === null || _a2 === void 0 ? void 0 : _a2.keyPath);
    },
    onClickSubMenu: function(key, level, type) {
      var _a2;
      var newOpenKeys = __spreadArray$l([], __read$N(openKeys), false);
      if (type === "inline") {
        if ((openKeys === null || openKeys === void 0 ? void 0 : openKeys.indexOf(key)) > -1) {
          if (accordion && level === 1) {
            newOpenKeys = [];
          } else {
            newOpenKeys = openKeys.filter(function(item2) {
              return item2 !== key;
            });
          }
        } else if (accordion && level === 1) {
          newOpenKeys = [key];
        } else {
          newOpenKeys = openKeys.concat([key]);
        }
      }
      setOpenKeys(newOpenKeys);
      onClickSubMenu && onClickSubMenu(key, newOpenKeys, (_a2 = menuInfoMap[key]) === null || _a2 === void 0 ? void 0 : _a2.keyPath);
    }
  } }, renderChildren()));
}
var ForwardRefMenu = forwardRef(Menu);
var MenuComponent = ForwardRefMenu;
MenuComponent.displayName = "Menu";
MenuComponent.Item = Item$5;
MenuComponent.SubMenu = SubMenu$1;
MenuComponent.ItemGroup = ItemGroup$1;
MenuComponent.defaultProps = {
  isMenu: true
};
var Menu$1 = MenuComponent;
var ListCache$2 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$2();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$1 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$1(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$3(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$3.prototype.clear = stackClear;
Stack$3.prototype["delete"] = stackDelete;
Stack$3.prototype.get = stackGet;
Stack$3.prototype.has = stackHas;
Stack$3.prototype.set = stackSet;
var _Stack = Stack$3;
var getNative$4 = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative$4(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var _defineProperty = defineProperty$2;
var defineProperty$1 = _defineProperty;
function baseAssignValue$3(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$3;
var baseAssignValue$2 = _baseAssignValue, eq$3 = eq_1;
function assignMergeValue$2(object, key, value) {
  if (value !== void 0 && !eq$3(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}
var _assignMergeValue = assignMergeValue$2;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
    while (length2--) {
      var key = props[fromRight ? length2 : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
var _cloneBuffer = { exports: {} };
(function(module, exports) {
  var root2 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var root$4 = _root;
var Uint8Array$3 = root$4.Uint8Array;
var _Uint8Array = Uint8Array$3;
var Uint8Array$2 = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneTypedArray$2(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$2;
function copyArray$2(source, array) {
  var index2 = -1, length2 = source.length;
  array || (array = Array(length2));
  while (++index2 < length2) {
    array[index2] = source[index2];
  }
  return array;
}
var _copyArray = copyArray$2;
var isObject$7 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$7(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$1;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var getPrototype$3 = overArg$1(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$3;
var objectProto$b = Object.prototype;
function isPrototype$3(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$b;
  return value === proto;
}
var _isPrototype = isPrototype$3;
var baseCreate = _baseCreate, getPrototype$2 = _getPrototype, isPrototype$2 = _isPrototype;
function initCloneObject$2(object) {
  return typeof object.constructor == "function" && !isPrototype$2(object) ? baseCreate(getPrototype$2(object)) : {};
}
var _initCloneObject = initCloneObject$2;
var baseGetTag$3 = _baseGetTag, isObjectLike$7 = isObjectLike_1;
var argsTag$3 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$7(value) && baseGetTag$3(value) == argsTag$3;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$6 = isObjectLike_1;
var objectProto$a = Object.prototype;
var hasOwnProperty$a = objectProto$a.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable;
var isArguments$4 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$6(value) && hasOwnProperty$a.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$4;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$3;
var isFunction$2 = isFunction_1, isLength$2 = isLength_1;
function isArrayLike$4(value) {
  return value != null && isLength$2(value.length) && !isFunction$2(value);
}
var isArrayLike_1 = isArrayLike$4;
var isArrayLike$3 = isArrayLike_1, isObjectLike$5 = isObjectLike_1;
function isArrayLikeObject$1(value) {
  return isObjectLike$5(value) && isArrayLike$3(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
var isBuffer$4 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$4, isBuffer$4.exports);
var baseGetTag$2 = _baseGetTag, getPrototype$1 = _getPrototype, isObjectLike$4 = isObjectLike_1;
var objectTag$4 = "[object Object]";
var funcProto = Function.prototype, objectProto$9 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$2(value) {
  if (!isObjectLike$4(value) || baseGetTag$2(value) != objectTag$4) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$9.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$2;
var baseGetTag$1 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$3 = isObjectLike_1;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$3(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$3(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$3;
var _nodeUtil = { exports: {} };
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary$2 = _baseUnary, nodeUtil$2 = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$3 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$3;
function safeGet$2(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var _safeGet = safeGet$2;
var baseAssignValue$1 = _baseAssignValue, eq$2 = eq_1;
var objectProto$8 = Object.prototype;
var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
function assignValue$3(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$8.call(object, key) && eq$2(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$1(object, key, value);
  }
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue, baseAssignValue = _baseAssignValue;
function copyObject$6(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length2 = props.length;
  while (++index2 < length2) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue$2(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$6;
function baseTimes$1(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$4(value, length2) {
  var type = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
  return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
var _isIndex = isIndex$4;
var baseTimes = _baseTimes, isArguments$3 = isArguments_1, isArray$7 = isArray_1, isBuffer$3 = isBuffer$4.exports, isIndex$3 = _isIndex, isTypedArray$2 = isTypedArray_1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$7(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$3(value), isType = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex$3(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$6 = isObject_1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn;
var objectProto$6 = Object.prototype;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$6(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$1(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$6.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike$2 = isArrayLike_1;
function keysIn$5(object) {
  return isArrayLike$2(object) ? arrayLikeKeys$1(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$5;
var copyObject$5 = _copyObject, keysIn$4 = keysIn_1;
function toPlainObject$1(value) {
  return copyObject$5(value, keysIn$4(value));
}
var toPlainObject_1 = toPlainObject$1;
var assignMergeValue$1 = _assignMergeValue, cloneBuffer$1 = _cloneBuffer.exports, cloneTypedArray$1 = _cloneTypedArray, copyArray$1 = _copyArray, initCloneObject$1 = _initCloneObject, isArguments$2 = isArguments_1, isArray$6 = isArray_1, isArrayLikeObject = isArrayLikeObject_1, isBuffer$2 = isBuffer$4.exports, isFunction$1 = isFunction_1, isObject$5 = isObject_1, isPlainObject$1 = isPlainObject_1, isTypedArray$1 = isTypedArray_1, safeGet$1 = _safeGet, toPlainObject = toPlainObject_1;
function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key), srcValue = safeGet$1(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$1(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$6(srcValue), isBuff = !isArr && isBuffer$2(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$6(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray$1(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer$1(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray$1(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject$1(srcValue) || isArguments$2(srcValue)) {
      newValue = objValue;
      if (isArguments$2(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$5(objValue) || isFunction$1(objValue)) {
        newValue = initCloneObject$1(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$1(object, key, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;
var Stack$2 = _Stack, assignMergeValue = _assignMergeValue, baseFor = _baseFor, baseMergeDeep = _baseMergeDeep, isObject$4 = isObject_1, keysIn$3 = keysIn_1, safeGet = _safeGet;
function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack$2());
    if (isObject$4(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn$3);
}
var _baseMerge = baseMerge$1;
function identity$2(value) {
  return value;
}
var identity_1 = identity$2;
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax = Math.max;
function overRest$2(func, start2, transform) {
  start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length2 = nativeMax(args.length - start2, 0), array = Array(length2);
    while (++index2 < length2) {
      array[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform(array);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$2;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
var constant = constant_1, defineProperty = _defineProperty, identity$1 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString, shortOut = _shortOut;
var setToString$2 = shortOut(baseSetToString);
var _setToString = setToString$2;
var identity = identity_1, overRest$1 = _overRest, setToString$1 = _setToString;
function baseRest$1(func, start2) {
  return setToString$1(overRest$1(func, start2, identity), func + "");
}
var _baseRest = baseRest$1;
var eq$1 = eq_1, isArrayLike$1 = isArrayLike_1, isIndex$2 = _isIndex, isObject$3 = isObject_1;
function isIterateeCall$1(value, index2, object) {
  if (!isObject$3(object)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike$1(object) && isIndex$2(index2, object.length) : type == "string" && index2 in object) {
    return eq$1(object[index2], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$1;
var baseRest = _baseRest, isIterateeCall = _isIterateeCall;
function createAssigner$1(assigner) {
  return baseRest(function(object, sources) {
    var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length2 < 3 ? void 0 : customizer;
      length2 = 1;
    }
    object = Object(object);
    while (++index2 < length2) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner$1;
var baseMerge = _baseMerge, createAssigner = _createAssigner;
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
var merge_1 = merge;
var customParseFormat$1 = { exports: {} };
(function(module, exports) {
  !function(t2, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, e = /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i2 = /\d*[^\s\d-_:/()]+/, o = {}, s = function(t3) {
      return (t3 = +t3) + (t3 > 68 ? 1900 : 2e3);
    };
    var a = function(t3) {
      return function(e2) {
        this[t3] = +e2;
      };
    }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(t3) {
      (this.zone || (this.zone = {})).offset = function(t4) {
        if (!t4)
          return 0;
        if (t4 === "Z")
          return 0;
        var e2 = t4.match(/([+-]|\d\d)/g), n2 = 60 * e2[1] + (+e2[2] || 0);
        return n2 === 0 ? 0 : e2[0] === "+" ? -n2 : n2;
      }(t3);
    }], u = function(t3) {
      var e2 = o[t3];
      return e2 && (e2.indexOf ? e2 : e2.s.concat(e2.f));
    }, h = function(t3, e2) {
      var n2, r2 = o.meridiem;
      if (r2) {
        for (var i3 = 1; i3 <= 24; i3 += 1)
          if (t3.indexOf(r2(i3, 0, e2)) > -1) {
            n2 = i3 > 12;
            break;
          }
      } else
        n2 = t3 === (e2 ? "pm" : "PM");
      return n2;
    }, d = { A: [i2, function(t3) {
      this.afternoon = h(t3, false);
    }], a: [i2, function(t3) {
      this.afternoon = h(t3, true);
    }], S: [/\d/, function(t3) {
      this.milliseconds = 100 * +t3;
    }], SS: [n, function(t3) {
      this.milliseconds = 10 * +t3;
    }], SSS: [/\d{3}/, function(t3) {
      this.milliseconds = +t3;
    }], s: [r, a("seconds")], ss: [r, a("seconds")], m: [r, a("minutes")], mm: [r, a("minutes")], H: [r, a("hours")], h: [r, a("hours")], HH: [r, a("hours")], hh: [r, a("hours")], D: [r, a("day")], DD: [n, a("day")], Do: [i2, function(t3) {
      var e2 = o.ordinal, n2 = t3.match(/\d+/);
      if (this.day = n2[0], e2)
        for (var r2 = 1; r2 <= 31; r2 += 1)
          e2(r2).replace(/\[|\]/g, "") === t3 && (this.day = r2);
    }], M: [r, a("month")], MM: [n, a("month")], MMM: [i2, function(t3) {
      var e2 = u("months"), n2 = (u("monthsShort") || e2.map(function(t4) {
        return t4.substr(0, 3);
      })).indexOf(t3) + 1;
      if (n2 < 1)
        throw new Error();
      this.month = n2 % 12 || n2;
    }], MMMM: [i2, function(t3) {
      var e2 = u("months").indexOf(t3) + 1;
      if (e2 < 1)
        throw new Error();
      this.month = e2 % 12 || e2;
    }], Y: [/[+-]?\d+/, a("year")], YY: [n, function(t3) {
      this.year = s(t3);
    }], YYYY: [/\d{4}/, a("year")], Z: f, ZZ: f };
    function c(n2) {
      var r2, i3;
      r2 = n2, i3 = o && o.formats;
      for (var s2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(e2, n3, r3) {
        var o2 = r3 && r3.toUpperCase();
        return n3 || i3[r3] || t2[r3] || i3[o2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(t3, e3, n4) {
          return e3 || n4.slice(1);
        });
      })).match(e), a2 = s2.length, f2 = 0; f2 < a2; f2 += 1) {
        var u2 = s2[f2], h2 = d[u2], c2 = h2 && h2[0], l = h2 && h2[1];
        s2[f2] = l ? { regex: c2, parser: l } : u2.replace(/^\[|\]$/g, "");
      }
      return function(t3) {
        for (var e2 = {}, n3 = 0, r3 = 0; n3 < a2; n3 += 1) {
          var i4 = s2[n3];
          if (typeof i4 == "string")
            r3 += i4.length;
          else {
            var o2 = i4.regex, f3 = i4.parser, u3 = t3.substr(r3), h3 = o2.exec(u3)[0];
            f3.call(e2, h3), t3 = t3.replace(h3, "");
          }
        }
        return function(t4) {
          var e3 = t4.afternoon;
          if (e3 !== void 0) {
            var n4 = t4.hours;
            e3 ? n4 < 12 && (t4.hours += 12) : n4 === 12 && (t4.hours = 0), delete t4.afternoon;
          }
        }(e2), e2;
      };
    }
    return function(t3, e2, n2) {
      n2.p.customParseFormat = true, t3 && t3.parseTwoDigitYear && (s = t3.parseTwoDigitYear);
      var r2 = e2.prototype, i3 = r2.parse;
      r2.parse = function(t4) {
        var e3 = t4.date, r3 = t4.utc, s2 = t4.args;
        this.$u = r3;
        var a2 = s2[1];
        if (typeof a2 == "string") {
          var f2 = s2[2] === true, u2 = s2[3] === true, h2 = f2 || u2, d2 = s2[2];
          u2 && (d2 = s2[2]), o = this.$locale(), !f2 && d2 && (o = n2.Ls[d2]), this.$d = function(t5, e4, n3) {
            try {
              if (["x", "X"].indexOf(e4) > -1)
                return new Date((e4 === "X" ? 1e3 : 1) * t5);
              var r4 = c(e4)(t5), i4 = r4.year, o2 = r4.month, s3 = r4.day, a3 = r4.hours, f3 = r4.minutes, u3 = r4.seconds, h3 = r4.milliseconds, d3 = r4.zone, l2 = new Date(), m2 = s3 || (i4 || o2 ? 1 : l2.getDate()), M2 = i4 || l2.getFullYear(), Y = 0;
              i4 && !o2 || (Y = o2 > 0 ? o2 - 1 : l2.getMonth());
              var p = a3 || 0, v = f3 || 0, D = u3 || 0, g = h3 || 0;
              return d3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g + 60 * d3.offset * 1e3)) : n3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g)) : new Date(M2, Y, m2, p, v, D, g);
            } catch (t6) {
              return new Date("");
            }
          }(e3, a2, r3), this.init(), d2 && d2 !== true && (this.$L = this.locale(d2).$L), h2 && e3 != this.format(a2) && (this.$d = new Date("")), o = {};
        } else if (a2 instanceof Array)
          for (var l = a2.length, m = 1; m <= l; m += 1) {
            s2[1] = a2[m - 1];
            var M = n2.apply(this, s2);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            m === l && (this.$d = new Date(""));
          }
        else
          i3.call(this, t4);
      };
    };
  });
})(customParseFormat$1);
var customParseFormat = customParseFormat$1.exports;
var isBetween$1 = { exports: {} };
(function(module, exports) {
  !function(e, i2) {
    module.exports = i2();
  }(commonjsGlobal, function() {
    return function(e, i2, t2) {
      i2.prototype.isBetween = function(e2, i3, s, f) {
        var n = t2(e2), o = t2(i3), r = (f = f || "()")[0] === "(", u = f[1] === ")";
        return (r ? this.isAfter(n, s) : !this.isBefore(n, s)) && (u ? this.isBefore(o, s) : !this.isAfter(o, s)) || (r ? this.isBefore(n, s) : !this.isAfter(n, s)) && (u ? this.isAfter(o, s) : !this.isBefore(o, s));
      };
    };
  });
})(isBetween$1);
var isBetween = isBetween$1.exports;
var weekOfYear$1 = { exports: {} };
(function(module, exports) {
  !function(e, t2) {
    module.exports = t2();
  }(commonjsGlobal, function() {
    var e = "week", t2 = "year";
    return function(i2, n, r) {
      var f = n.prototype;
      f.week = function(i3) {
        if (i3 === void 0 && (i3 = null), i3 !== null)
          return this.add(7 * (i3 - this.week()), "day");
        var n2 = this.$locale().yearStart || 1;
        if (this.month() === 11 && this.date() > 25) {
          var f2 = r(this).startOf(t2).add(1, t2).date(n2), s = r(this).endOf(e);
          if (f2.isBefore(s))
            return 1;
        }
        var a = r(this).startOf(t2).date(n2).startOf(e).subtract(1, "millisecond"), o = this.diff(a, e, true);
        return o < 0 ? r(this).startOf("week").week() : Math.ceil(o);
      }, f.weeks = function(e2) {
        return e2 === void 0 && (e2 = null), this.week(e2);
      };
    };
  });
})(weekOfYear$1);
var weekOfYear = weekOfYear$1.exports;
var advancedFormat = { exports: {} };
(function(module, exports) {
  !function(e, t2) {
    module.exports = t2();
  }(commonjsGlobal, function() {
    return function(e, t2, r) {
      var n = t2.prototype, s = n.format;
      r.en.ordinal = function(e2) {
        var t3 = ["th", "st", "nd", "rd"], r2 = e2 % 100;
        return "[" + e2 + (t3[(r2 - 20) % 10] || t3[r2] || t3[0]) + "]";
      }, n.format = function(e2) {
        var t3 = this, r2 = this.$locale();
        if (!this.isValid())
          return s.bind(this)(e2);
        var n2 = this.$utils(), a = (e2 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e3) {
          switch (e3) {
            case "Q":
              return Math.ceil((t3.$M + 1) / 3);
            case "Do":
              return r2.ordinal(t3.$D);
            case "gggg":
              return t3.weekYear();
            case "GGGG":
              return t3.isoWeekYear();
            case "wo":
              return r2.ordinal(t3.week(), "W");
            case "w":
            case "ww":
              return n2.s(t3.week(), e3 === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return n2.s(t3.isoWeek(), e3 === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return n2.s(String(t3.$H === 0 ? 24 : t3.$H), e3 === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(t3.$d.getTime() / 1e3);
            case "x":
              return t3.$d.getTime();
            case "z":
              return "[" + t3.offsetName() + "]";
            case "zzz":
              return "[" + t3.offsetName("long") + "]";
            default:
              return e3;
          }
        });
        return s.bind(this)(a);
      };
    };
  });
})(advancedFormat);
var AdvancedFormat = advancedFormat.exports;
var weekYear$1 = { exports: {} };
(function(module, exports) {
  !function(e, t2) {
    module.exports = t2();
  }(commonjsGlobal, function() {
    return function(e, t2) {
      t2.prototype.weekYear = function() {
        var e2 = this.month(), t3 = this.week(), n = this.year();
        return t3 === 1 && e2 === 11 ? n + 1 : e2 === 0 && t3 >= 52 ? n - 1 : n;
      };
    };
  });
})(weekYear$1);
var weekYear = weekYear$1.exports;
var quarterOfYear = { exports: {} };
(function(module, exports) {
  !function(t2, n) {
    module.exports = n();
  }(commonjsGlobal, function() {
    var t2 = "month", n = "quarter";
    return function(e, i2) {
      var r = i2.prototype;
      r.quarter = function(t3) {
        return this.$utils().u(t3) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t3 - 1));
      };
      var s = r.add;
      r.add = function(e2, i3) {
        return e2 = Number(e2), this.$utils().p(i3) === n ? this.add(3 * e2, t2) : s.bind(this)(e2, i3);
      };
      var u = r.startOf;
      r.startOf = function(e2, i3) {
        var r2 = this.$utils(), s2 = !!r2.u(i3) || i3;
        if (r2.p(e2) === n) {
          var o = this.quarter() - 1;
          return s2 ? this.month(3 * o).startOf(t2).startOf("day") : this.month(3 * o + 2).endOf(t2).endOf("day");
        }
        return u.bind(this)(e2, i3);
      };
    };
  });
})(quarterOfYear);
var QuarterOfYear = quarterOfYear.exports;
var __assign$12 = globalThis && globalThis.__assign || function() {
  __assign$12 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$12.apply(this, arguments);
};
var __read$M = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$k = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var isMoment = dayjs$1()._isAMomentObject;
if (isMoment) {
  dayjs$1.extend = function() {
  };
}
var overwriteIsDayjs = function(_, Dayjs, dayjs2) {
  dayjs2 = function(date, c) {
    if (isDayjs(date)) {
      return date.clone();
    }
    var cfg = typeof c === "object" ? c : {};
    cfg.date = date;
    cfg.args = arguments;
    return new Dayjs(cfg);
  };
  var proto = Dayjs.prototype;
  var old$Utils = proto.$utils;
  proto.$utils = function() {
    var newUtils = old$Utils();
    newUtils.i = isDayjs;
    return newUtils;
  };
  dayjs2.isDayjs = isDayjs;
};
dayjs$1.extend(overwriteIsDayjs);
dayjs$1.extend(customParseFormat);
dayjs$1.extend(isBetween);
dayjs$1.extend(weekOfYear);
dayjs$1.extend(AdvancedFormat);
dayjs$1.extend(weekYear);
dayjs$1.extend(QuarterOfYear);
var dayjs = dayjs$1;
var methods = {
  add: function(time, value, unit) {
    return isMoment ? time.clone().add(value, unit) : time.add(value, unit);
  },
  subtract: function(time, value, unit) {
    return isMoment ? time.clone().subtract(value, unit) : time.subtract(value, unit);
  },
  startOf: function(time, unit) {
    return isMoment ? time.clone().startOf(unit) : time.startOf(unit);
  },
  endOf: function(time, unit) {
    return isMoment ? time.clone().endOf(unit) : time.endOf(unit);
  },
  set: function(time, unit, value) {
    return isMoment ? time.clone().set(unit, value) : time.set(unit, value);
  },
  isSameWeek: function(date1, date2, weekStart, localeName) {
    return isMoment ? date1.locale(localeName, { week: { dow: weekStart } }).isSame(date2, "week") : date1.locale(__assign$12(__assign$12({}, dayjs.Ls[localeName]), { weekStart })).isSame(date2, "week");
  }
};
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
var dtfCache = {};
var getDateTimeFormat = function(timezone, timeZoneName) {
  var key = timezone + "|" + (timeZoneName || "short");
  var dtf = dtfCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: timezone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
    dtfCache[key] = dtf;
  }
  return dtf;
};
var makeFormatParts = function(timestamp, timezone) {
  var date = new Date(timestamp);
  var dtf = getDateTimeFormat(timezone);
  return dtf.formatToParts(date);
};
var tzOffset = function(timestamp, timezone) {
  var formatResult = makeFormatParts(timestamp, timezone);
  var filled = [];
  for (var i2 = 0; i2 < formatResult.length; i2 += 1) {
    var _a = formatResult[i2], type = _a.type, value = _a.value;
    var pos = typeToPos[type];
    if (pos >= 0) {
      filled[pos] = parseInt(value, 10);
    }
  }
  var hour = filled[3];
  var fixedHour = hour === 24 ? 0 : hour;
  var utcTs = Date.UTC(filled[0], filled[1] - 1, filled[2], fixedHour, filled[4], filled[5], 0);
  var asTS = +timestamp;
  var over = asTS % 1e3;
  asTS -= over;
  return (utcTs - asTS) / (60 * 1e3);
};
var fixOffset = function(localTS, o0, tz) {
  var utcGuess = localTS - o0 * 60 * 1e3;
  var o2 = tzOffset(utcGuess, tz);
  if (o0 === o2) {
    return [utcGuess, o0];
  }
  utcGuess -= (o2 - o0) * 60 * 1e3;
  var o3 = tzOffset(utcGuess, tz);
  if (o2 === o3) {
    return [utcGuess, o2];
  }
  return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
};
function timezoneToOffset(inputTs, timezone) {
  return fixOffset(inputTs, tzOffset(new Date().getTime(), timezone), timezone)[1];
}
function getNow(utcOffset, timezone) {
  return isUndefined(utcOffset) && !timezone ? dayjs() : toTimezone(dayjs(), utcOffset, timezone);
}
function toTimezone(time, utcOffset, timezone, local) {
  if (!time || isUndefined(utcOffset) && !timezone) {
    return time;
  }
  var localOffset = -time.toDate().getTimezoneOffset();
  var uOffset = isUndefined(utcOffset) ? !timezone ? localOffset : timezoneToOffset(time.valueOf(), timezone) : utcOffset;
  var timezoneOffset = Math.abs(uOffset) <= 16 ? uOffset * 60 : uOffset;
  var diffOffset = local ? localOffset - timezoneOffset : timezoneOffset - localOffset;
  return dayjs(dayjs(time).valueOf() + diffOffset * 60 * 1e3);
}
function toLocal(time, utcOffset, timezone) {
  return toTimezone(time, utcOffset, timezone, true);
}
function getTimeFormat(format) {
  var units = ["H", "h", "m", "s", "A", "a"];
  var timeFormat = "";
  units.some(function(unit) {
    if (format.indexOf(unit) !== -1) {
      timeFormat = "" + unit + format.split(" " + unit)[1];
      return true;
    }
    return false;
  });
  return timeFormat || "HH:mm:ss";
}
function getDayjsValue(time, format, utcOffset, timezone) {
  if (!time) {
    return void 0;
  }
  var formatValue2 = function(value) {
    if (isDayjs(value)) {
      return dayjs(value.valueOf());
    }
    if (typeof value === "string") {
      var dv = dayjs(value, format);
      return dv.isValid() ? dv : dayjs(value, "YYYY-MM-DD");
    }
    return dayjs(value);
  };
  var getRealTime = function(t2) {
    return utcOffset !== void 0 || timezone ? toTimezone(formatValue2(t2), utcOffset, timezone) : formatValue2(t2);
  };
  if (isArray$c(time)) {
    return time.map(function(t2) {
      return t2 ? getRealTime(t2) : void 0;
    });
  }
  return getRealTime(time);
}
function getValueWithTime(date, time) {
  var y = date.year();
  var m = date.month();
  var d = date.date();
  if (time) {
    var returnTime = time;
    returnTime = methods.set(returnTime, "year", y);
    returnTime = methods.set(returnTime, "month", m);
    returnTime = methods.set(returnTime, "date", d);
    return returnTime;
  }
  return date;
}
function getSortedDayjsArray(values2) {
  if (!values2 || !values2[0] || !values2[1]) {
    return values2;
  }
  var newValues = __spreadArray$k([], __read$M(values2), false);
  newValues.sort(function(a, b) {
    return a.valueOf() - b.valueOf();
  });
  return newValues;
}
function isDayjsChange(prevValue, currentValue) {
  if (currentValue === void 0 && prevValue === void 0) {
    return false;
  }
  return currentValue && !prevValue || !currentValue && prevValue || dayjs(currentValue).valueOf() !== dayjs(prevValue).valueOf();
}
function isDayjsArrayChange(prevValue, currentValue) {
  if (currentValue === void 0 && prevValue === void 0) {
    return false;
  }
  return currentValue && !prevValue || !currentValue && prevValue || isArray$c(currentValue) && isArray$c(prevValue) && dayjs(currentValue[0]).valueOf() !== dayjs(prevValue[0]).valueOf() || dayjs(currentValue[1]).valueOf() !== dayjs(prevValue[1]).valueOf();
}
function isValidTimeString(str, format) {
  return typeof str === "string" && dayjs(str, format).format(format) === str;
}
function padStart(string, length2, char) {
  if (char === void 0) {
    char = " ";
  }
  var s = String(string);
  if (!length2) {
    return s;
  }
  var newString = s.length < length2 ? "" + char + s : s;
  return newString.length < length2 ? padStart(newString, length2, char) : newString;
}
var __read$L = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var RadioGroupContext = createContext({
  type: "radio"
});
var defaultProps$k = {
  type: "radio",
  mode: "outline",
  direction: "horizontal"
};
function Group$1(baseProps) {
  var _a;
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, ctxSize = _b.size, componentConfig2 = _b.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$k, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2["Radio.Group"]);
  var style = props.style, className = props.className, name2 = props.name, children = props.children, direction = props.direction, type = props.type, mode = props.mode, options2 = props.options, disabled = props.disabled;
  var _c = __read$L(useMergeValue(void 0, {
    defaultValue: props.defaultValue,
    value: props.value
  }), 2), value = _c[0], setValue = _c[1];
  var size = props.size || ctxSize;
  var prefixCls2 = getPrefixCls("radio");
  var classNames = cs$1(prefixCls2 + "-group", (_a = {}, _a[prefixCls2 + "-group-type-button"] = type !== "radio", _a[prefixCls2 + "-size-" + size] = !!size, _a[prefixCls2 + "-mode-" + mode] = !!mode, _a[prefixCls2 + "-group-disabled"] = disabled, _a[prefixCls2 + "-group-direction-vertical"] = direction === "vertical", _a), className);
  var onChangeValue = function(v, event2) {
    var onChange = props.onChange;
    if (v !== value) {
      if (!("value" in props)) {
        setValue(v);
      }
      onChange && onChange(v, event2);
    }
  };
  var contextProp = {
    onChangeValue,
    type,
    value,
    disabled,
    group: true,
    name: name2
  };
  return React__default.createElement(RadioGroupContext.Provider, { value: contextProp }, React__default.createElement("div", { className: classNames, style }, options2 && isArray$c(options2) ? options2.map(function(option, index2) {
    if (isObject$e(option)) {
      return React__default.createElement(Radio, { key: option.value, disabled: disabled || option.disabled, value: option.value }, option.label);
    }
    return React__default.createElement(Radio, { key: index2, value: option, disabled }, option);
  }) : children));
}
Group$1.displayName = "RadioGroup";
var __assign$11 = globalThis && globalThis.__assign || function() {
  __assign$11 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$11.apply(this, arguments);
};
var __rest$t = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$K = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function Radio(baseProps) {
  var _a;
  var inputRef = useRef(null);
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig2 = _b.componentConfig;
  var props = useMergeProps(baseProps, {}, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Radio);
  var context = useContext(RadioGroupContext);
  var prefixCls2 = getPrefixCls("radio");
  var mergeProps2 = __assign$11({}, props);
  if (context.group) {
    mergeProps2.checked = context.value === props.value;
    mergeProps2.disabled = !!(context.disabled || props.disabled);
  }
  var disabled = mergeProps2.disabled, children = mergeProps2.children, value = mergeProps2.value, style = mergeProps2.style, className = mergeProps2.className, rest = __rest$t(mergeProps2, ["disabled", "children", "value", "style", "className"]);
  var _c = __read$K(useMergeValue(false, {
    value: mergeProps2.checked,
    defaultValue: mergeProps2.defaultChecked
  }), 2), checked = _c[0], setChecked = _c[1];
  var classNames = cs$1("" + prefixCls2 + (context.type === "button" ? "-button" : ""), (_a = {}, _a[prefixCls2 + "-checked"] = checked, _a[prefixCls2 + "-disabled"] = disabled, _a), className);
  var onChange = function(event2) {
    var onChange2 = mergeProps2.onChange, value2 = mergeProps2.value;
    if (disabled) {
      return;
    }
    if (context.group) {
      context.onChangeValue && context.onChangeValue(value2, event2);
    } else if (!("checked" in props) && !checked) {
      setChecked(true);
    }
    !checked && onChange2 && onChange2(true, event2);
  };
  var onLabelClick = React__default.useCallback(function(e) {
    if (isFunction$5(props.children)) {
      e.preventDefault();
      inputRef.current && inputRef.current.click();
    }
    rest.onClick && rest.onClick(e);
  }, [props.children, rest.onClick]);
  return React__default.createElement("label", __assign$11({}, omit$1(rest, ["checked", "onChange"]), { onClick: onLabelClick, style, className: classNames }), React__default.createElement("input", __assign$11({ ref: inputRef, disabled, value: value || "", type: "radio" }, context.name ? { name: context.name } : {}, { checked, onChange: function(event2) {
    event2.persist();
    onChange(event2);
  }, onClick: function(e) {
    e.stopPropagation();
  } })), isFunction$5(children) ? children({ checked }) : context.type === "radio" ? React__default.createElement(React__default.Fragment, null, React__default.createElement(IconHover, { prefix: prefixCls2, className: prefixCls2 + "-mask-wrapper", disabled: checked || disabled }, React__default.createElement("div", { className: prefixCls2 + "-mask" })), children && React__default.createElement("span", { className: prefixCls2 + "-text" }, children)) : context.type === "button" && React__default.createElement("span", { className: prefixCls2 + "-button-inner" }, children));
}
Radio.__BYTE_RADIO = true;
Radio.displayName = "Radio";
Radio.Group = Group$1;
Radio.GroupContext = RadioGroupContext;
function ownKeys$e(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$e(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$e(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$e(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconDoubleLeftComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$e(_objectSpread$e({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-double-left")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M36.857 9.9 22.715 24.042l14.142 14.142M25.544 9.9 11.402 24.042l14.142 14.142"
  }));
}
var IconDoubleLeft = /* @__PURE__ */ React__default.forwardRef(IconDoubleLeftComponent);
IconDoubleLeft.defaultProps = {
  isIcon: true
};
IconDoubleLeft.displayName = "IconDoubleLeft";
var IconDoubleLeft$1 = IconDoubleLeft;
function ownKeys$d(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$d(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$d(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$d(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconDoubleRightComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$d(_objectSpread$d({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-double-right")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "m11.143 38.1 14.142-14.142L11.143 9.816M22.456 38.1l14.142-14.142L22.456 9.816"
  }));
}
var IconDoubleRight = /* @__PURE__ */ React__default.forwardRef(IconDoubleRightComponent);
IconDoubleRight.defaultProps = {
  isIcon: true
};
IconDoubleRight.displayName = "IconDoubleRight";
var IconDoubleRight$1 = IconDoubleRight;
var __assign$10 = globalThis && globalThis.__assign || function() {
  __assign$10 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$10.apply(this, arguments);
};
var __rest$s = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function Meta$2(props, ref) {
  var _a;
  var className = props.className, title2 = props.title, avatar = props.avatar, description = props.description, actionList = props.actionList, others = __rest$s(props, ["className", "title", "avatar", "description", "actionList"]);
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var prefixCls2 = getPrefixCls("card-meta");
  var classNames = cs$1(prefixCls2, className);
  return React__default.createElement("div", __assign$10({}, others, { ref, className: classNames }), title2 || description ? React__default.createElement("div", { className: prefixCls2 + "-content" }, title2 && React__default.createElement("div", { className: prefixCls2 + "-title" }, title2), description && React__default.createElement("div", { className: prefixCls2 + "-description" }, description)) : null, avatar || actionList ? React__default.createElement("div", { className: cs$1(prefixCls2 + "-footer ", (_a = {}, _a[prefixCls2 + "-footer-only-actions"] = !avatar, _a)) }, avatar ? React__default.createElement("div", { className: prefixCls2 + "-avatar" }, avatar) : null, actionList) : null);
}
var MetaComponent$1 = React__default.forwardRef(Meta$2);
MetaComponent$1.displayName = "CardMeta";
var Meta$3 = MetaComponent$1;
function Grid$1(props, ref) {
  var _a;
  var children = props.children, style = props.style, className = props.className, hoverable = props.hoverable;
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var prefixCls2 = getPrefixCls("card-grid");
  return React__default.createElement("div", { ref, style, className: cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-hoverable"] = hoverable, _a), className) }, children);
}
var CardComponent$1 = React__default.forwardRef(Grid$1);
CardComponent$1.displayName = "CardGrid";
var Grid$2 = CardComponent$1;
var __read$J = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$j = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function DotLoading(props) {
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var prefixCls2 = getPrefixCls("spin") + "-dot";
  var dotStyle = {
    width: props.size,
    height: props.size
  };
  var sizeNumber = props.size ? parseInt(String(props.size)) : 0;
  return React__default.createElement("div", { className: prefixCls2 + "-list", style: {
    height: props.size,
    width: isNumber$1(sizeNumber) && sizeNumber > 0 ? sizeNumber * 7 : ""
  } }, __spreadArray$j([], __read$J(new Array(5)), false).map(function(_, index2) {
    return React__default.createElement("div", { key: index2, className: prefixCls2, style: dotStyle });
  }));
}
var __read$I = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function Spin(baseProps, ref) {
  var _a;
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig2 = _b.componentConfig;
  var props = useMergeProps(baseProps, {}, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Spin);
  var style = props.style, className = props.className, children = props.children, propLoading = props.loading, size = props.size, icon = props.icon, element = props.element, tip = props.tip, dot = props.dot, delay = props.delay, _c = props.block, block2 = _c === void 0 ? false : _c;
  var _d = __read$I(useState(delay ? false : propLoading), 2), loading = _d[0], setLoading = _d[1];
  var debouncedSetLoading = useCallback(debounce_1(setLoading, delay), [delay]);
  var _usedLoading = delay ? loading : propLoading;
  var prefixCls2 = getPrefixCls("spin");
  useEffect(function() {
    delay && debouncedSetLoading(propLoading);
    return function() {
      debouncedSetLoading && debouncedSetLoading.cancel();
    };
  }, [propLoading]);
  var loadingIcon = React__default.createElement("span", { className: prefixCls2 + "-icon" }, icon ? React__default.cloneElement(icon, {
    className: cs$1(prefixCls2.replace("-spin", "-icon") + "-loading"),
    style: {
      fontSize: size
    }
  }) : element || (dot ? React__default.createElement(DotLoading, { size }) : React__default.createElement(IconLoading$1, { style: { fontSize: size } })));
  return React__default.createElement("div", { ref, className: cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-block"] = block2, _a[prefixCls2 + "-loading"] = _usedLoading, _a[prefixCls2 + "-with-tip"] = tip && !children, _a), className), style }, children ? React__default.createElement(React__default.Fragment, null, React__default.createElement("div", { className: prefixCls2 + "-children" }, children), _usedLoading && React__default.createElement("div", { className: prefixCls2 + "-loading-layer", style: { fontSize: size } }, React__default.createElement("span", { className: prefixCls2 + "-loading-layer-inner" }, loadingIcon, tip ? React__default.createElement("div", { className: prefixCls2 + "-tip" }, tip) : null))) : React__default.createElement(React__default.Fragment, null, loadingIcon, tip ? React__default.createElement("div", { className: prefixCls2 + "-tip" }, tip) : null));
}
var SpinComponent = React__default.forwardRef(Spin);
SpinComponent.displayName = "Spin";
var Spin$1 = SpinComponent;
var __assign$$ = globalThis && globalThis.__assign || function() {
  __assign$$ = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$$.apply(this, arguments);
};
var __rest$r = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var defaultProps$j = {
  size: "default",
  bordered: true
};
function Card(baseProps, ref) {
  var _a, _b;
  var _c = useContext(ConfigContext), getPrefixCls = _c.getPrefixCls, loadingElement = _c.loadingElement, componentConfig2 = _c.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$j, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Card);
  var className = props.className, children = props.children, bordered = props.bordered, loading = props.loading, hoverable = props.hoverable, size = props.size, title2 = props.title, extra = props.extra, cover = props.cover, actions = props.actions, headerStyle = props.headerStyle, bodyStyle = props.bodyStyle, rest = __rest$r(props, ["className", "children", "bordered", "loading", "hoverable", "size", "title", "extra", "cover", "actions", "headerStyle", "bodyStyle"]);
  var prefixCls2 = getPrefixCls("card");
  var actionList = actions && actions.length ? React__default.createElement("div", { className: prefixCls2 + "-actions" }, React__default.createElement("div", { className: prefixCls2 + "-actions-right" }, actions.map(function(action, index2) {
    return React__default.createElement("span", { key: "action-" + index2, className: prefixCls2 + "-actions-item" }, action);
  }))) : null;
  var isContainGrid = false;
  var isContainMeta = false;
  var handledChildren = React__default.Children.map(children, function(element) {
    if (element && element.type) {
      if (element.type === Grid$2) {
        isContainGrid = true;
      } else if (element.type === Meta$3) {
        isContainMeta = true;
        return React__default.cloneElement(element, { actionList });
      }
    }
    return element;
  });
  return React__default.createElement("div", __assign$$({}, rest, { ref, className: cs$1(prefixCls2, prefixCls2 + "-size-" + size, (_a = {}, _a[prefixCls2 + "-loading"] = loading, _a[prefixCls2 + "-bordered"] = bordered, _a[prefixCls2 + "-hoverable"] = hoverable, _a[prefixCls2 + "-contain-grid"] = isContainGrid, _a), className) }), title2 || extra ? React__default.createElement("div", { className: cs$1(prefixCls2 + "-header", (_b = {}, _b[prefixCls2 + "-header-no-title"] = !title2, _b)), style: headerStyle }, title2 && React__default.createElement("div", { className: prefixCls2 + "-header-title" }, title2), extra && React__default.createElement("div", { className: prefixCls2 + "-header-extra" }, extra)) : null, cover ? React__default.createElement("div", { className: prefixCls2 + "-cover" }, cover) : null, React__default.createElement("div", { className: prefixCls2 + "-body", style: bodyStyle }, loading ? loadingElement || React__default.createElement(Spin$1, null) : handledChildren, isContainMeta ? null : actionList));
}
var ForwardRefCard = React__default.forwardRef(Card);
var CardComponent = ForwardRefCard;
CardComponent.Meta = Meta$3;
CardComponent.Grid = Grid$2;
CardComponent.displayName = "Card";
var Card$1 = CardComponent;
function ownKeys$c(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$c(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$c(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$c(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconUpComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$c(_objectSpread$c({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-up")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M39.6 30.557 24.043 15 8.487 30.557"
  }));
}
var IconUp = /* @__PURE__ */ React__default.forwardRef(IconUpComponent);
IconUp.defaultProps = {
  isIcon: true
};
IconUp.displayName = "IconUp";
var IconUp$1 = IconUp;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$1(values2) {
  var index2 = -1, length2 = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache();
  while (++index2 < length2) {
    this.add(values2[index2]);
  }
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
SetCache$1.prototype.has = setCacheHas;
var _SetCache = SetCache$1;
function arraySome$1(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
function cacheHas$1(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$1;
var SetCache = _SetCache, arraySome = _arraySome, cacheHas = _cacheHas;
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
function mapToArray$1(map) {
  var index2 = -1, result = Array(map.size);
  map.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$1(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray = setToArray$1;
var Symbol$3 = _Symbol, Uint8Array$1 = _Uint8Array, eq = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]";
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$3:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag$2:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag$2:
    case dateTag$2:
    case numberTag$2:
      return eq(+object, +other);
    case errorTag$1:
      return object.name == other.name && object.message == other.message;
    case regexpTag$2:
    case stringTag$2:
      return object == other + "";
    case mapTag$4:
      var convert2 = mapToArray;
    case setTag$4:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert2 || (convert2 = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;
      stack.set(object, other);
      var result = equalArrays$1(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag$2:
      if (symbolValueOf$1) {
        return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$3(array, values2) {
  var index2 = -1, length2 = values2.length, offset = array.length;
  while (++index2 < length2) {
    array[offset + index2] = values2[index2];
  }
  return array;
}
var _arrayPush = arrayPush$3;
var arrayPush$2 = _arrayPush, isArray$5 = isArray_1;
function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$5(object) ? result : arrayPush$2(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$2;
function arrayFilter$1(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length2) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter, stubArray$1 = stubArray_1;
var objectProto$5 = Object.prototype;
var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var _getSymbols = getSymbols$3;
var overArg = _overArg;
var nativeKeys$1 = overArg(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$4 = Object.prototype;
var hasOwnProperty$5 = objectProto$4.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$5.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike = isArrayLike_1;
function keys$3(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
var keys_1 = keys$3;
var baseGetAllKeys$1 = _baseGetAllKeys, getSymbols$2 = _getSymbols, keys$2 = keys_1;
function getAllKeys$2(object) {
  return baseGetAllKeys$1(object, keys$2, getSymbols$2);
}
var _getAllKeys = getAllKeys$2;
var getAllKeys$1 = _getAllKeys;
var COMPARE_PARTIAL_FLAG$1 = 1;
var objectProto$3 = Object.prototype;
var hasOwnProperty$4 = objectProto$3.hasOwnProperty;
function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys$1(object), objLength = objProps.length, othProps = getAllKeys$1(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$4.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$3 = _getNative, root$3 = _root;
var DataView$1 = getNative$3(root$3, "DataView");
var _DataView = DataView$1;
var getNative$2 = _getNative, root$2 = _root;
var Promise$2 = getNative$2(root$2, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative, root$1 = _root;
var Set$2 = getNative$1(root$1, "Set");
var _Set = Set$2;
var getNative = _getNative, root = _root;
var WeakMap$2 = getNative(root, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag = _baseGetTag, toSource = _toSource;
var mapTag$3 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag$4 = baseGetTag;
if (DataView && getTag$4(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag$4(new Map$1()) != mapTag$3 || Promise$1 && getTag$4(Promise$1.resolve()) != promiseTag || Set$1 && getTag$4(new Set$1()) != setTag$3 || WeakMap$1 && getTag$4(new WeakMap$1()) != weakMapTag$1) {
  getTag$4 = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$4;
var Stack$1 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag$3 = _getTag, isArray$4 = isArray_1, isBuffer$1 = isBuffer$4.exports, isTypedArray = isTypedArray_1;
var COMPARE_PARTIAL_FLAG = 1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", objectTag$1 = "[object Object]";
var objectProto$2 = Object.prototype;
var hasOwnProperty$3 = objectProto$2.hasOwnProperty;
function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$4(object), othIsArr = isArray$4(other), objTag = objIsArr ? arrayTag$1 : getTag$3(object), othTag = othIsArr ? arrayTag$1 : getTag$3(other);
  objTag = objTag == argsTag$1 ? objectTag$1 : objTag;
  othTag = othTag == argsTag$1 ? objectTag$1 : othTag;
  var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty$3.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$3.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$1());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$2 = isObjectLike_1;
function baseIsEqual$1(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$2(value) && !isObjectLike$2(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$1, stack);
}
var _baseIsEqual = baseIsEqual$1;
var baseIsEqual = _baseIsEqual;
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  var result = customizer ? customizer(value, other) : void 0;
  return result === void 0 ? baseIsEqual(value, other, void 0, customizer) : !!result;
}
var isEqualWith_1 = isEqualWith;
var __read$H = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$i = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function useUpdate(fn, deps) {
  if (deps === void 0) {
    deps = [];
  }
  var isDidMount = useRef(false);
  useEffect(function() {
    if (isDidMount.current) {
      fn();
    } else {
      isDidMount.current = true;
    }
  }, __spreadArray$i([], __read$H(deps), false));
}
var __assign$_ = globalThis && globalThis.__assign || function() {
  __assign$_ = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$_.apply(this, arguments);
};
var __rest$q = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function Item$3(props, ref) {
  var _a, _b, _c, _d, _e;
  var _f;
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var ctx = useContext(CollapseContext);
  var children = props.children, name2 = props.name, header = props.header, className = props.className, style = props.style, contentStyle = props.contentStyle, extra = props.extra, disabled = props.disabled, destroyOnHide = props.destroyOnHide, expandIcon = props.expandIcon, _g = props.showExpandIcon, showExpandIcon = _g === void 0 ? true : _g, rest = __rest$q(props, ["children", "name", "header", "className", "style", "contentStyle", "extra", "disabled", "destroyOnHide", "expandIcon", "showExpandIcon"]);
  var prefixCls2 = getPrefixCls("collapse-item");
  var isExpanded = ((_f = ctx.activeKeys) === null || _f === void 0 ? void 0 : _f.indexOf(name2)) > -1;
  var icon = showExpandIcon ? "expandIcon" in props ? expandIcon : ctx.expandIcon : null;
  return React__default.createElement("div", __assign$_({ ref }, rest, { className: cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-active"] = isExpanded, _a[prefixCls2 + "-no-icon"] = !icon, _a[prefixCls2 + "-disabled"] = disabled, _a), className), style }), React__default.createElement("div", { role: "button", "aria-disabled": disabled, "aria-expanded": isExpanded, tabIndex: 0, className: cs$1(prefixCls2 + "-header", prefixCls2 + "-header-" + ctx.expandIconPosition, (_b = {}, _b[prefixCls2 + "-header-disabled"] = disabled, _b)), onClick: function(e) {
    !disabled && ctx.onToggle(name2, e);
  } }, icon && React__default.createElement(IconHover, { prefix: prefixCls2, disabled, className: cs$1((_c = {}, _c[prefixCls2 + "-icon-hover-right"] = ctx.expandIconPosition === "right", _c[prefixCls2 + "-header-icon-right"] = ctx.expandIconPosition === "right", _c)) }, React__default.createElement("span", { className: cs$1(prefixCls2 + "-header-icon", (_d = {}, _d[prefixCls2 + "-header-icon-down"] = isExpanded, _d)) }, icon)), React__default.createElement("div", { className: prefixCls2 + "-header-title" }, header), extra && React__default.createElement("div", { className: prefixCls2 + "-header-extra", onClick: function(e) {
    e.stopPropagation();
  } }, extra)), React__default.createElement(Transition$1, { in: isExpanded, addEndListener: function(node, done) {
    node.addEventListener("transitionend", done, false);
  }, mountOnEnter: "destroyOnHide" in props ? destroyOnHide : ctx.destroyOnHide || ctx.lazyload, unmountOnExit: "destroyOnHide" in props ? destroyOnHide : ctx.destroyOnHide, onEnter: function(e) {
    e.style.height = 0;
    e.style.display = "block";
  }, onEntering: function(e) {
    e.style.height = e.scrollHeight + "px";
  }, onEntered: function(e) {
    e.style.height = "auto";
  }, onExit: function(e) {
    e.style.display = "block";
    e.style.height = e.offsetHeight + "px";
    e.offsetHeight;
  }, onExiting: function(e) {
    e.style.height = 0;
  }, onExited: function(e) {
    e.style.display = "none";
    e.style.height = "auto";
  } }, React__default.createElement("div", { role: "region", className: cs$1(prefixCls2 + "-content", (_e = {}, _e[prefixCls2 + "-content-expanded"] = isExpanded, _e)) }, React__default.createElement("div", { style: contentStyle, className: prefixCls2 + "-content-box" }, children))));
}
var ItemRef = React__default.forwardRef(Item$3);
ItemRef.displayName = "CollapseItem";
var CollapseItem = ItemRef;
var __assign$Z = globalThis && globalThis.__assign || function() {
  __assign$Z = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$Z.apply(this, arguments);
};
var __rest$p = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$G = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$h = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var getActiveKeys = function(keys2, accordion) {
  var res = [].concat(keys2);
  if (accordion) {
    return res.slice(0, 1);
  }
  return res;
};
var defaultProps$i = {
  bordered: true,
  lazyload: true,
  expandIconPosition: "left"
};
var CollapseContext = createContext({
  expandIconPosition: "left",
  expandIcon: React__default.createElement(IconCaretRight$1, null),
  activeKeys: [],
  onToggle: function() {
  }
});
function Collapse(baseProps, ref) {
  var _a = useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, componentConfig2 = _a.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$i, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Collapse);
  var _b = __read$G(useMergeValue([], {
    defaultValue: "defaultActiveKey" in props ? getActiveKeys(props.defaultActiveKey, props.accordion) : void 0,
    value: "activeKey" in props ? getActiveKeys(props.activeKey, props.accordion) : void 0
  }), 2), activeKeys = _b[0], setActiveKeys = _b[1];
  var children = props.children, className = props.className, style = props.style, bordered = props.bordered, lazyload = props.lazyload, expandIcon = props.expandIcon, expandIconPosition = props.expandIconPosition, destroyOnHide = props.destroyOnHide, accordion = props.accordion, onChange = props.onChange, rest = __rest$p(props, ["children", "className", "style", "bordered", "lazyload", "expandIcon", "expandIconPosition", "destroyOnHide", "accordion", "onChange"]);
  var prefixCls2 = getPrefixCls("collapse");
  var onItemClick = function(key, e) {
    var newActiveKeys = __spreadArray$h([], __read$G(activeKeys), false);
    var index2 = activeKeys.indexOf(key);
    if (index2 > -1) {
      newActiveKeys.splice(index2, 1);
    } else if (accordion) {
      newActiveKeys = [key];
    } else {
      newActiveKeys.push(key);
    }
    if (!("activeKey" in props)) {
      setActiveKeys(newActiveKeys);
    }
    isFunction$5(onChange) && onChange(key, newActiveKeys, e);
  };
  return React__default.createElement(CollapseContext.Provider, { value: {
    activeKeys,
    onToggle: onItemClick,
    lazyload,
    expandIcon: "expandIcon" in props ? expandIcon : expandIconPosition === "right" ? React__default.createElement(IconCaretLeft$1, null) : React__default.createElement(IconCaretRight$1, null),
    destroyOnHide,
    expandIconPosition
  } }, React__default.createElement("div", __assign$Z({ ref }, omit$1(rest, ["activeKey", "defaultActiveKey"]), { className: cs$1(prefixCls2, prefixCls2 + "-" + (bordered ? "border" : "borderless"), className), style }), children));
}
var ForwardRefCollapse = React__default.forwardRef(Collapse);
var CollapseComponent = ForwardRefCollapse;
CollapseComponent.displayName = "Collapse";
CollapseComponent.Item = CollapseItem;
var Collapse$1 = CollapseComponent;
var __assign$Y = globalThis && globalThis.__assign || function() {
  __assign$Y = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$Y.apply(this, arguments);
};
var __rest$o = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function DateInput$1(_a, ref) {
  var _b, _c;
  var style = _a.style, className = _a.className, propPrefixCls = _a.prefixCls, allowClear = _a.allowClear, error2 = _a.error, disabled = _a.disabled, placeholder = _a.placeholder, format = _a.format, propSize = _a.size, onClear = _a.onClear, editable = _a.editable, value = _a.value, inputValue = _a.inputValue, onPressEnter = _a.onPressEnter, suffixIcon = _a.suffixIcon, onChange = _a.onChange, popupVisible = _a.popupVisible, isPlaceholder = _a.isPlaceholder, rest = __rest$o(_a, ["style", "className", "prefixCls", "allowClear", "error", "disabled", "placeholder", "format", "size", "onClear", "editable", "value", "inputValue", "onPressEnter", "suffixIcon", "onChange", "popupVisible", "isPlaceholder"]);
  var _d = useContext(ConfigContext), getPrefixCls = _d.getPrefixCls, ctxSize = _d.size, locale = _d.locale;
  var input = useRef(null);
  var size = propSize || ctxSize;
  useImperativeHandle(ref, function() {
    return {
      focus: function() {
        input.current && input.current.focus && input.current.focus();
      },
      blur: function() {
        input.current && input.current.blur && input.current.blur();
      }
    };
  });
  function onKeyDown(e) {
    var keyCode = e.keyCode || e.which;
    if (keyCode === Enter.code) {
      onPressEnter && onPressEnter();
    }
  }
  var showValue = "";
  if (inputValue !== void 0) {
    showValue = inputValue;
  } else if (value && !isArray$c(value)) {
    showValue = typeof format === "function" ? format(value) : value.locale(locale.dayjsLocale).format(format);
  }
  var readOnlyProps = editable ? {} : { readOnly: true };
  var prefixCls2 = propPrefixCls || getPrefixCls("picker");
  var classNames = cs$1(prefixCls2, prefixCls2 + "-size-" + size, (_b = {}, _b[prefixCls2 + "-focused"] = !!popupVisible, _b[prefixCls2 + "-disabled"] = disabled, _b[prefixCls2 + "-error"] = error2, _b), className);
  return React__default.createElement("div", __assign$Y({ style, className: classNames }, omit$1(rest, ["onChange", "onPressEnter"])), React__default.createElement("div", { className: cs$1(prefixCls2 + "-input", (_c = {}, _c[prefixCls2 + "-input-placeholder"] = isPlaceholder, _c)) }, React__default.createElement("input", __assign$Y({ ref: input, disabled, placeholder, className: prefixCls2 + "-start-time", value: showValue, onKeyDown, onChange }, readOnlyProps))), React__default.createElement("div", { className: prefixCls2 + "-suffix" }, allowClear && showValue && React__default.createElement(IconHover, { prefix: prefixCls2, onClick: onClear, className: prefixCls2 + "-clear-icon" }, React__default.createElement(IconClose$1, null)), React__default.createElement("span", { className: prefixCls2 + "-suffix-icon" }, suffixIcon)));
}
var Input$3 = forwardRef(DateInput$1);
function ownKeys$b(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$b(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$b(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$b(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconCalendarComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$b(_objectSpread$b({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-calendar")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M7 22h34M14 5v8m20-8v8M8 41h32a1 1 0 0 0 1-1V10a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1Z"
  }));
}
var IconCalendar = /* @__PURE__ */ React__default.forwardRef(IconCalendarComponent);
IconCalendar.defaultProps = {
  isIcon: true
};
IconCalendar.displayName = "IconCalendar";
var IconCalendar$1 = IconCalendar;
function ownKeys$a(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$a(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$a(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$a(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconCalendarClockComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$a(_objectSpread$a({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-calendar-clock")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M7 22h34V10a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h18M34 5v8M14 5v8"
  }), /* @__PURE__ */ React__default.createElement("path", {
    fill: "currentColor",
    fillRule: "evenodd",
    stroke: "none",
    d: "M36 44a9 9 0 1 0 0-18 9 9 0 0 0 0 18Zm1.5-9.75V29h-3v8.25H42v-3h-4.5Z",
    clipRule: "evenodd"
  }));
}
var IconCalendarClock = /* @__PURE__ */ React__default.forwardRef(IconCalendarClockComponent);
IconCalendarClock.defaultProps = {
  isIcon: true
};
IconCalendarClock.displayName = "IconCalendarClock";
var IconCalendarClock$1 = IconCalendarClock;
function Shortcuts(props, ref) {
  var prefixCls2 = props.prefixCls, _a = props.shortcuts, shortcuts = _a === void 0 ? [] : _a, onSelectNow = props.onSelectNow, nowText = props.nowText, showNowBtn = props.showNowBtn, showTime = props.showTime, onMouseEnterShortcut = props.onMouseEnterShortcut, onMouseLeaveShortcut = props.onMouseLeaveShortcut;
  function onMouseEnter(shortcut) {
    onMouseEnterShortcut && onMouseEnterShortcut(shortcut);
  }
  function onMouseLeave(shortcut) {
    onMouseLeaveShortcut && onMouseLeaveShortcut(shortcut);
  }
  function onClick(shortcut, e) {
    var onSelectShortcut = props.onSelectShortcut;
    onSelectShortcut && onSelectShortcut(shortcut, e);
  }
  var hasShortcuts = isArray$c(shortcuts) && shortcuts.length > 0;
  var shouldShowNowBtn = showNowBtn && showTime && !hasShortcuts;
  return React__default.createElement("div", { ref, className: prefixCls2 + "-shortcuts" }, shouldShowNowBtn && React__default.createElement(Button$4, { size: "mini", onClick: onSelectNow }, nowText), hasShortcuts && shortcuts.map(function(shortcut, index2) {
    return React__default.createElement(Button$4, { key: index2, size: "mini", onMouseEnter: function() {
      return onMouseEnter(shortcut);
    }, onMouseLeave: function() {
      return onMouseLeave(shortcut);
    }, onClick: function(e) {
      return onClick(shortcut, e);
    } }, shortcut.text);
  }));
}
var Shortcuts$1 = forwardRef(Shortcuts);
function ownKeys$9(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$9(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$9(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$9(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconLinkComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$9(_objectSpread$9({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-link")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "m14.1 25.414-4.95 4.95a6 6 0 0 0 8.486 8.485l8.485-8.485a6 6 0 0 0 0-8.485m7.779.707 4.95-4.95a6 6 0 1 0-8.486-8.485l-8.485 8.485a6 6 0 0 0 0 8.485"
  }));
}
var IconLink = /* @__PURE__ */ React__default.forwardRef(IconLinkComponent);
IconLink.defaultProps = {
  isIcon: true
};
IconLink.displayName = "IconLink";
var IconLink$1 = IconLink;
var __assign$X = globalThis && globalThis.__assign || function() {
  __assign$X = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$X.apply(this, arguments);
};
var __rest$n = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var defaultProps$h = {
  hoverable: true
};
function Link$2(baseProps, ref) {
  var _a;
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig2 = _b.componentConfig, rtl = _b.rtl;
  var props = useMergeProps(baseProps, defaultProps$h, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Link);
  var className = props.className, style = props.style, children = props.children, icon = props.icon, status = props.status, disabled = props.disabled, hoverable = props.hoverable, rest = __rest$n(props, ["className", "style", "children", "icon", "status", "disabled", "hoverable"]);
  var prefixCls2 = getPrefixCls("link");
  var TagWrapper = "href" in props ? "a" : "span";
  return React__default.createElement(TagWrapper, __assign$X({ className: cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-disabled"] = disabled, _a[prefixCls2 + "-is-" + status] = status, _a[prefixCls2 + "-with-icon"] = icon, _a[prefixCls2 + "-hoverless"] = !hoverable, _a[prefixCls2 + "-rtl"] = rtl, _a), className), ref }, rest, { style, onClick: function(e) {
    if (disabled) {
      e.preventDefault();
      e.stopPropagation();
    } else {
      props.onClick && props.onClick(e);
    }
  } }), icon ? React__default.createElement("span", { className: prefixCls2 + "-icon" }, icon === true ? React__default.createElement(IconLink$1, null) : icon) : null, children);
}
var LinkRef = forwardRef(Link$2);
LinkRef.displayName = "Link";
var Link$3 = LinkRef;
function Footer(props) {
  var showTime = props.showTime, prefixCls2 = props.prefixCls, DATEPICKER_LOCALE = props.DATEPICKER_LOCALE, disabled = props.disabled, onClickConfirmBtn = props.onClickConfirmBtn, onClickSelectTimeBtn = props.onClickSelectTimeBtn, isTimePanel = props.isTimePanel, onSelectNow = props.onSelectNow, showNowBtn = props.showNowBtn, shortcuts = props.shortcuts, onMouseEnterShortcut = props.onMouseEnterShortcut, onMouseLeaveShortcut = props.onMouseLeaveShortcut, onSelectShortcut = props.onSelectShortcut, extra = props.extra, mode = props.mode, shortcutsPlacementLeft = props.shortcutsPlacementLeft;
  var hasShortcuts = isArray$c(shortcuts) && shortcuts.length > 0;
  var shouldShowNowBtn = showNowBtn && showTime && !hasShortcuts;
  var shouldShouldShortcuts = shouldShowNowBtn || hasShortcuts && !shortcutsPlacementLeft;
  return React__default.createElement("div", { className: prefixCls2 + "-footer" }, extra && React__default.createElement("div", { className: prefixCls2 + "-footer-extra-wrapper" }, extra), !showTime && showNowBtn && mode === "date" && React__default.createElement("div", { className: prefixCls2 + "-footer-now-wrapper" }, React__default.createElement(Link$3, { onClick: onSelectNow }, DATEPICKER_LOCALE.today)), shouldShouldShortcuts || showTime ? React__default.createElement("div", { className: prefixCls2 + "-footer-btn-wrapper" }, !shortcutsPlacementLeft ? React__default.createElement(Shortcuts$1, { shortcuts, prefixCls: prefixCls2, onSelectNow, nowText: DATEPICKER_LOCALE.now, showNowBtn, onMouseEnterShortcut, onMouseLeaveShortcut, onSelectShortcut, showTime }) : React__default.createElement("div", null), showTime && React__default.createElement(React__default.Fragment, null, React__default.createElement(Button$4, { type: "text", size: "mini", onClick: onClickSelectTimeBtn, className: isTimePanel ? prefixCls2 + "-btn-select-date" : prefixCls2 + "-btn-select-time" }, isTimePanel ? DATEPICKER_LOCALE.selectDate : DATEPICKER_LOCALE.selectTime), React__default.createElement(Button$4, { className: prefixCls2 + "-btn-confirm", type: "primary", size: "mini", disabled, onClick: onClickConfirmBtn }, DATEPICKER_LOCALE.ok))) : null);
}
var PickerContext$1 = createContext({});
function getAvailableDayjsLength(value) {
  if (!value) {
    return 0;
  }
  if (isArray$c(value)) {
    if (isDayjs(value[0]) && isDayjs(value[1])) {
      return 2;
    }
    if (!isDayjs(value[0]) && !isDayjs(value[1])) {
      return 0;
    }
    return 1;
  }
  return 0;
}
function isDisabledDate(date, disabledDate, mode, originMode) {
  if (typeof disabledDate !== "function") {
    return false;
  }
  if (!originMode || originMode === mode) {
    return disabledDate(date);
  }
  return disabledDate(date.startOf(mode)) && disabledDate(date.endOf(mode));
}
function getDefaultWeekStart(dayjsLocale) {
  var _a, _b;
  return ((_b = (_a = dayjs$1.Ls) === null || _a === void 0 ? void 0 : _a[dayjsLocale]) === null || _b === void 0 ? void 0 : _b.weekStart) || 0;
}
var __assign$W = globalThis && globalThis.__assign || function() {
  __assign$W = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$W.apply(this, arguments);
};
var __read$F = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function getFormat$1(props) {
  var format = props.format, picker = props.picker, showTime = props.showTime;
  var valueFormat;
  switch (picker.props.pickerType) {
    case "date":
      valueFormat = showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
      break;
    case "month":
      valueFormat = "YYYY-MM";
      break;
    case "year":
      valueFormat = "YYYY";
      break;
    case "week":
      valueFormat = "gggg-wo";
      break;
    case "quarter":
      valueFormat = "YYYY-[Q]Q";
      break;
    default:
      valueFormat = "YYYY-MM-DD";
  }
  if (format) {
    valueFormat = format;
  }
  return valueFormat;
}
var defaultProps$g = {
  allowClear: true,
  unmountOnExit: true,
  position: "bl",
  editable: true,
  showNowBtn: true
};
var Picker$1 = function(baseProps) {
  var _a = useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, locale = _a.locale, ctxSize = _a.size, componentConfig2 = _a.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$g, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.DatePicker);
  var allowClear = props.allowClear, className = props.className, style = props.style, placeholder = props.placeholder, getPopupContainer = props.getPopupContainer, disabled = props.disabled, position = props.position, error2 = props.error, unmountOnExit = props.unmountOnExit, editable = props.editable, triggerProps = props.triggerProps, picker = props.picker, shortcuts = props.shortcuts, onSelect = props.onSelect, onVisibleChange = props.onVisibleChange, propsValue = props.value, onChange = props.onChange, icons = props.icons, disabledDate = props.disabledDate, showTime = props.showTime, showNowBtn = props.showNowBtn, onSelectShortcut = props.onSelectShortcut, extra = props.extra, shortcutsPlacementLeft = props.shortcutsPlacementLeft, onOk = props.onOk, defaultPickerValue = props.defaultPickerValue, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, triggerElement = props.triggerElement, utcOffset = props.utcOffset, timezone = props.timezone, panelRender = props.panelRender;
  var prefixCls2 = getPrefixCls("picker");
  var DATEPICKER_LOCALE = locale.DatePicker;
  var weekStart = isUndefined(props.dayStartOfWeek) ? getDefaultWeekStart(locale.dayjsLocale) : props.dayStartOfWeek;
  var mode = picker.props.pickerType;
  var refInput = useRef(null);
  var refPanel = useRef(null);
  var refShortcuts = useRef(null);
  var realFormat = getFormat$1(props);
  var format = realFormat;
  if (typeof format === "function") {
    format = showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
  }
  function getDefaultValue() {
    var value2;
    if (props.value) {
      value2 = getDayjsValue(props.value, format, utcOffset, timezone);
    } else {
      value2 = getDayjsValue(props.defaultValue, format, utcOffset, timezone);
    }
    return value2;
  }
  var _b = __read$F(useState(getDefaultValue()), 2), value = _b[0], setValue = _b[1];
  var _c = __read$F(useState(props.popupVisible), 2), popupVisible = _c[0], setPopupVisible = _c[1];
  var _d = __read$F(useState(false), 2), isTimePanel = _d[0], setIsTimePanel = _d[1];
  var _e = __read$F(useState(), 2), hoverPlaceholderValue = _e[0], setHoverPlaceholderValue = _e[1];
  var mergedPopupVisible = "popupVisible" in props ? props.popupVisible : popupVisible;
  var mergedValue = "value" in props ? getDayjsValue(propsValue, format, utcOffset, timezone) : value;
  var defaultPageShowDate = mergedValue || getDayjsValue(defaultPickerValue, format) || getNow();
  var _f = __read$F(useState(), 2), inputValue = _f[0], setInputValue = _f[1];
  var _g = __read$F(useState(), 2), valueShow = _g[0], setValueShow = _g[1];
  var _h = __read$F(useState(), 2), shortcutValue = _h[0], setShortcutValue = _h[1];
  var _j = __read$F(useState(defaultPageShowDate), 2), pageShowDate = _j[0], setPageShowDate = _j[1];
  var mergedPageShowDate = getDayjsValue(pickerValue, format) || pageShowDate;
  var panelValue = shortcutValue || valueShow || mergedValue;
  var _k = __read$F(useState(mode), 2), panelMode = _k[0], setPanelMode = _k[1];
  var defaultTimeValue = isObject$e(showTime) && getDayjsValue(showTime.defaultValue, showTime.format || "HH:mm:ss", utcOffset, timezone) || getNow(utcOffset, timezone);
  var timeValue = panelValue || defaultTimeValue;
  function focusInput() {
    refInput.current && refInput.current.blur && refInput.current.focus();
  }
  function blurInput() {
    refInput.current && refInput.current.blur && refInput.current.blur();
  }
  var previousUtcOffset = usePrevious(utcOffset);
  var previousTimezone = usePrevious(timezone);
  useUpdate(function() {
    if (value && (previousUtcOffset !== utcOffset || timezone !== previousTimezone)) {
      var localValue = toLocal(value, previousUtcOffset, previousTimezone);
      setValue(toTimezone(localValue, utcOffset, timezone));
    }
  }, [utcOffset, previousUtcOffset, timezone, previousTimezone]);
  useEffect(function() {
    setInputValue(void 0);
    setHoverPlaceholderValue(void 0);
    if (mergedPopupVisible) {
      setPageShowDate(defaultPageShowDate);
      if (shortcutsPlacementLeft) {
        refShortcuts.current.style.maxHeight = refPanel.current.clientHeight + "px";
      }
    } else {
      setValueShow(void 0);
      setShortcutValue(void 0);
      setTimeout(function() {
        setIsTimePanel(false);
        setPanelMode(mode);
        blurInput();
      }, 100);
    }
  }, [mergedPopupVisible]);
  function visibleChange(visible) {
    if (visible) {
      setOpen(visible, function() {
        focusInput();
      });
    } else {
      setOpen(false);
    }
  }
  function handlePickerValueChange(v) {
    onPickerValueChange && onPickerValueChange(v.format(format), v);
  }
  function setOpen(visible, callback) {
    setPopupVisible(visible);
    onVisibleChange && onVisibleChange(visible);
    callback && callback();
  }
  function onClear(e) {
    e.stopPropagation();
    setValue(void 0);
    setValueShow(void 0);
    onHandleChange(void 0);
    props.onClear && props.onClear();
  }
  function onClickConfirmBtn() {
    onConfirmValue();
    onOk && onOk(panelValue && panelValue.format(format), panelValue);
  }
  function onConfirmValue() {
    setValue(panelValue);
    onHandleChange(panelValue);
    setOpen(false);
  }
  function onHandleSelect(_, date, now2) {
    setInputValue(void 0);
    setHoverPlaceholderValue(void 0);
    if (showTime) {
      var newTime = now2 ? date : getValueWithTime(date, timeValue);
      setValueShow(newTime);
      setPageShowDate(newTime);
      var localTime = toLocal(newTime, utcOffset, timezone);
      onSelect && onSelect(localTime.format(format), localTime);
    } else {
      var localTime = toLocal(date, utcOffset, timezone);
      onSelect && onSelect(localTime ? localTime.format(format) : void 0, localTime);
      setValue(date);
      onHandleChange(date);
      setOpen(false);
    }
  }
  function onHandleChange(newValue) {
    if (isDayjsChange(newValue, mergedValue)) {
      var localValue = toLocal(newValue, utcOffset, timezone);
      onChange && onChange(localValue ? localValue.format(format) : void 0, localValue);
    }
  }
  function onTimePickerSelect(_, time) {
    var _valueShow = panelValue || getNow(utcOffset, timezone);
    var newValueShow = getValueWithTime(_valueShow, time);
    setValueShow(newValueShow);
    var localNewValueShow = toLocal(newValueShow, utcOffset, timezone);
    onSelect && onSelect(localNewValueShow.format(format), localNewValueShow);
  }
  function isValid(time) {
    return typeof time === "string" && dayjs(time, format).format(format) === time && (typeof disabledDate === "function" ? !disabledDate(dayjs(time, format)) : true);
  }
  function onChangeInput(e) {
    var niv = e.target.value;
    setInputValue(niv);
    if (!mergedPopupVisible) {
      setOpen(true);
    }
    if (isValid(niv)) {
      var newValue = getDayjsValue(niv, format, utcOffset, timezone);
      setValueShow(newValue);
      setPageShowDate(newValue);
      setInputValue(void 0);
    }
  }
  function onPressEnter() {
    if (panelValue) {
      onConfirmValue();
      blurInput();
    } else if (mergedPopupVisible) {
      setOpen(false);
    }
  }
  function changePageShowDate(type, unit, num) {
    if (num === void 0) {
      num = 1;
    }
    var newPageShowDate;
    if (type === "prev") {
      newPageShowDate = methods.subtract(mergedPageShowDate, num, unit);
    }
    if (type === "next") {
      newPageShowDate = methods.add(mergedPageShowDate, num, unit);
    }
    handlePickerValueChange(newPageShowDate);
    setPageShowDate(newPageShowDate);
  }
  function getHeaderOperations(pickMode) {
    if (pickMode === void 0) {
      pickMode = mode;
    }
    if (pickMode === "date" || pickMode === "week") {
      return {
        onPrev: function() {
          return changePageShowDate("prev", "month");
        },
        onNext: function() {
          return changePageShowDate("next", "month");
        },
        onSuperPrev: function() {
          return changePageShowDate("prev", "year");
        },
        onSuperNext: function() {
          return changePageShowDate("next", "year");
        }
      };
    }
    if (pickMode === "month" || pickMode === "quarter") {
      return {
        onSuperPrev: function() {
          return changePageShowDate("prev", "year");
        },
        onSuperNext: function() {
          return changePageShowDate("next", "year");
        }
      };
    }
    if (pickMode === "year") {
      return {
        onSuperPrev: function() {
          return changePageShowDate("prev", "year", 10);
        },
        onSuperNext: function() {
          return changePageShowDate("next", "year", 10);
        }
      };
    }
  }
  function onSelectNow() {
    var now2 = getNow(utcOffset, timezone);
    handlePickerValueChange(now2);
    onHandleSelect(now2.format(format), now2, true);
  }
  function onMouseEnterCell(value2, disabled2) {
    if (!disabled2) {
      var placeHolderValue = showTime ? getValueWithTime(value2, timeValue) : value2;
      setHoverPlaceholderValue(typeof realFormat === "function" ? realFormat(value2) : placeHolderValue.locale(locale.dayjsLocale).format(format));
    }
  }
  function onMouseLeaveCell() {
    setHoverPlaceholderValue(void 0);
  }
  function onMouseEnterShortcut(shortcut) {
    if (typeof shortcut.value === "function" && isDayjs(shortcut.value())) {
      var sv = getDayjsValue(shortcut.value(), format, utcOffset, timezone);
      setPageShowDate(sv);
      handlePickerValueChange(sv);
      setShortcutValue(sv);
    }
  }
  function onMouseLeaveShortcut() {
    var newValue = valueShow || mergedValue || getNow(utcOffset, timezone);
    setShortcutValue(void 0);
    setPageShowDate(newValue);
    handlePickerValueChange(newValue);
  }
  function onHandleSelectShortcut(shortcut) {
    onSelectShortcut && onSelectShortcut(shortcut);
    if (typeof shortcut.value === "function" && isDayjs(shortcut.value())) {
      var time = getDayjsValue(shortcut.value(), format, utcOffset, timezone);
      setValue(time);
      onHandleChange(time);
      setOpen(false);
    }
  }
  function onClickSelectTimeBtn() {
    setIsTimePanel(!isTimePanel);
  }
  function renderPopup(panelOnly) {
    var _a2;
    var classNames = cs$1(prefixCls2 + "-container", (_a2 = {}, _a2[prefixCls2 + "-panel-only"] = panelOnly, _a2[prefixCls2 + "-container-shortcuts-placement-left"] = isArray$c(shortcuts) && shortcutsPlacementLeft, _a2), panelOnly ? className : "");
    var shortcutsProps = {
      prefixCls: prefixCls2,
      showTime,
      shortcuts,
      onSelectNow,
      showNowBtn,
      onMouseEnterShortcut,
      onMouseLeaveShortcut,
      onSelectShortcut: onHandleSelectShortcut
    };
    var shouldShowFooter = showTime && panelMode === "date" || extra || isArray$c(shortcuts) && shortcuts.length && !shortcutsPlacementLeft || !showTime && panelMode === "date" && showNowBtn;
    var content = React__default.createElement(React__default.Fragment, null, React__default.cloneElement(picker, __assign$W(__assign$W(__assign$W({}, omit$1(props, ["style"])), getHeaderOperations()), { getHeaderOperations, onSelect: onHandleSelect, onTimePickerSelect, onSelectNow, popupVisible: mergedPopupVisible, format, value: panelValue, pageShowDate: mergedPageShowDate, localeName: locale.dayjsLocale, setPageShowDate: function(v) {
      setPageShowDate(v);
      handlePickerValueChange(v);
    }, timeValue, isTimePanel, panelMode, setPanelMode, onMouseEnterCell, onMouseLeaveCell })), shouldShowFooter && React__default.createElement(Footer, __assign$W({}, shortcutsProps, { DATEPICKER_LOCALE, disabled: !panelValue, onClickConfirmBtn, extra, mode: panelMode, shortcutsPlacementLeft, onClickSelectTimeBtn, isTimePanel })));
    var contentWithShortcuts = shortcutsPlacementLeft ? React__default.createElement(React__default.Fragment, null, React__default.createElement(Shortcuts$1, __assign$W({ ref: refShortcuts }, shortcutsProps)), React__default.createElement("div", { ref: refPanel, className: prefixCls2 + "-panel-wrapper" }, content)) : content;
    var panelNode = typeof panelRender === "function" ? panelRender(contentWithShortcuts) : contentWithShortcuts;
    return React__default.createElement("div", { className: classNames, onClick: function() {
      refInput.current && refInput.current.focus && refInput.current.focus();
    }, style: panelOnly ? style : {} }, panelNode);
  }
  var size = props.size || ctxSize;
  var suffixIcon = icons && icons.inputSuffix === null ? null : icons && icons.inputSuffix || (showTime ? React__default.createElement(IconCalendarClock$1, null) : React__default.createElement(IconCalendar$1, null));
  var baseInputProps = {
    style,
    className,
    popupVisible: mergedPopupVisible,
    format: realFormat,
    disabled,
    error: error2,
    size,
    onPressEnter,
    onClear,
    suffixIcon,
    editable: editable && typeof realFormat !== "function",
    allowClear
  };
  return React__default.createElement(PickerContext$1.Provider, { value: { utcOffset, timezone, weekStart } }, triggerElement === null ? renderPopup(true) : React__default.createElement(Trigger$1, __assign$W({ popup: renderPopup, trigger: "click", clickToClose: false, position, disabled, popupAlign: { bottom: 4 }, getPopupContainer, onVisibleChange: visibleChange, popupVisible: mergedPopupVisible, classNames: "slideDynamicOrigin", unmountOnExit }, triggerProps), triggerElement || React__default.createElement(Input$3, __assign$W({}, baseInputProps, { ref: refInput, placeholder: placeholder || DATEPICKER_LOCALE.placeholder[mode], popupVisible: mergedPopupVisible, value: valueShow || mergedValue, inputValue: hoverPlaceholderValue || inputValue, prefixCls: prefixCls2, onChange: onChangeInput, isPlaceholder: !!hoverPlaceholderValue }))));
};
var Picker$2 = Picker$1;
var __assign$V = globalThis && globalThis.__assign || function() {
  __assign$V = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$V.apply(this, arguments);
};
var __rest$m = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function DateInput(_a, ref) {
  var _b;
  var allowClear = _a.allowClear, error2 = _a.error, style = _a.style, className = _a.className, disabled = _a.disabled, _c = _a.placeholder, placeholder = _c === void 0 ? [] : _c, _d = _a.value, value = _d === void 0 ? [] : _d, popupVisible = _a.popupVisible, format = _a.format, propSize = _a.size, onClear = _a.onClear, editable = _a.editable, inputValue = _a.inputValue, onPressEnter = _a.onPressEnter, onPressTab = _a.onPressTab, onChange = _a.onChange, separator = _a.separator, suffixIcon = _a.suffixIcon, changeFocusedInputIndex = _a.changeFocusedInputIndex, focusedInputIndex = _a.focusedInputIndex, isPlaceholder = _a.isPlaceholder, rest = __rest$m(_a, ["allowClear", "error", "style", "className", "disabled", "placeholder", "value", "popupVisible", "format", "size", "onClear", "editable", "inputValue", "onPressEnter", "onPressTab", "onChange", "separator", "suffixIcon", "changeFocusedInputIndex", "focusedInputIndex", "isPlaceholder"]);
  var _e = useContext(ConfigContext), getPrefixCls = _e.getPrefixCls, ctxSize = _e.size, locale = _e.locale;
  var input0 = useRef(null);
  var input1 = useRef(null);
  var disabled1 = isArray$c(disabled) ? disabled[0] : disabled;
  var disabled2 = isArray$c(disabled) ? disabled[1] : disabled;
  useImperativeHandle(ref, function() {
    return {
      focus: function(index2) {
        var focusedIndex = typeof index2 === "number" ? index2 : focusedInputIndex;
        var focusElement = focusedIndex === 0 ? input0 : input1;
        if (focusedInputIndex === 0 && !disabled1 || focusedInputIndex === 1 && !disabled2) {
          focusElement.current && focusElement.current.focus && focusElement.current.focus();
        }
      },
      blur: function() {
        if (focusedInputIndex === 0) {
          input0.current && input0.current.blur && input0.current.blur();
        }
        if (focusedInputIndex === 1) {
          input1.current && input1.current.blur && input1.current.blur();
        }
      }
    };
  });
  function changeFocusedInput(index2) {
    if (focusedInputIndex !== index2) {
      changeFocusedInputIndex(index2);
    }
  }
  function onKeyDown(e) {
    var keyCode = e.keyCode || e.which;
    if (keyCode === Enter.code) {
      onPressEnter && onPressEnter();
    }
    if (keyCode === Tab.code) {
      onPressTab && onPressTab(e);
    }
  }
  function onChangeInput(e) {
    e.stopPropagation();
    onChange && onChange(e);
  }
  var prefixCls2 = getPrefixCls("picker");
  var size = propSize || ctxSize;
  var inputClassNames = cs$1(prefixCls2, prefixCls2 + "-range", prefixCls2 + "-size-" + size, (_b = {}, _b[prefixCls2 + "-focused"] = !!popupVisible, _b[prefixCls2 + "-disabled"] = disabled1 && disabled2, _b[prefixCls2 + "-error"] = error2, _b), className);
  var getInputValue = function(index2) {
    var valueText = value[index2] ? value[index2].locale(locale.dayjsLocale).format(format) : "";
    if (inputValue) {
      return index2 === focusedInputIndex ? inputValue : valueText;
    }
    return valueText;
  };
  var readOnlyProps = editable ? {} : { readOnly: true };
  function getFocusInputClassName(index2) {
    var _a2;
    return cs$1(prefixCls2 + "-input", (_a2 = {}, _a2[prefixCls2 + "-input-active"] = focusedInputIndex === index2, _a2[prefixCls2 + "-input-placeholder"] = isPlaceholder && focusedInputIndex === index2, _a2));
  }
  return React__default.createElement("div", __assign$V({ style, className: inputClassNames }, omit$1(rest, ["onChange", "onPressEnter"])), React__default.createElement("div", { className: getFocusInputClassName(0) }, React__default.createElement("input", __assign$V({ ref: input0, disabled: disabled1, placeholder: placeholder[0], value: getInputValue(0), onChange: onChangeInput, onKeyDown, onClick: function() {
    return changeFocusedInput(0);
  } }, readOnlyProps))), React__default.createElement("span", { className: prefixCls2 + "-separator" }, separator || "-"), React__default.createElement("div", { className: getFocusInputClassName(1) }, React__default.createElement("input", __assign$V({ ref: input1, disabled: disabled2, placeholder: placeholder[1], value: getInputValue(1), onChange: onChangeInput, onKeyDown, onClick: function() {
    return changeFocusedInput(1);
  } }, readOnlyProps))), React__default.createElement("div", { className: prefixCls2 + "-suffix" }, allowClear && value.length === 2 && React__default.createElement(IconHover, { prefix: prefixCls2, onClick: onClear, className: prefixCls2 + "-clear-icon" }, React__default.createElement(IconClose$1, null)), React__default.createElement("span", { className: prefixCls2 + "-suffix-icon" }, suffixIcon)));
}
var InputRange = forwardRef(DateInput);
function getColumnsFromFormat(format) {
  var units = ["H", "h", "m", "s", "a", "A"];
  var list2 = [];
  var use12Hours = false;
  units.forEach(function(unit) {
    if (format.indexOf(unit) !== -1) {
      list2.push(unit);
      if (unit === "a" || unit === "A") {
        use12Hours = true;
      }
    }
  });
  return {
    list: list2,
    use12Hours
  };
}
var scrollIds = new Map();
function scrollTo(element, to, duration2) {
  if (scrollIds.get(element)) {
    cancelAnimationFrame(scrollIds.get(element));
  }
  if (duration2 <= 0) {
    element.scrollTop = to;
  }
  scrollIds.set(element, requestAnimationFrame(function() {
    var tween = new Tween({
      from: { scrollTop: element.scrollTop },
      to: { scrollTop: to },
      duration: duration2,
      onUpdate: function(keys2) {
        element.scrollTop = keys2.scrollTop;
      },
      easing: "quartInOut"
    });
    tween.start();
  }));
}
function TimeColumn(props) {
  var prefixCls2 = props.prefixCls, list2 = props.list, value = props.value, onHandleSelect = props.onHandleSelect, unit = props.unit, popupVisible = props.popupVisible, scrollSticky = props.scrollSticky;
  var lis = useRef(new Map());
  var wrapper2 = useRef();
  var ul = useRef();
  var listItemHeight = useRef(0);
  var prevPopupVisible = usePrevious(popupVisible);
  var prevScrollTop = useRef(wrapper2.current && wrapper2.current.scrollTop);
  useEffect(function() {
    var li = lis.current.get(value);
    if (li && popupVisible && prevPopupVisible) {
      scrollTo(wrapper2.current, li.offsetTop, 150);
      prevScrollTop.current = li.offsetTop;
    }
  }, [value]);
  useEffect(function() {
    if (popupVisible && popupVisible !== prevPopupVisible) {
      var li = lis.current.get(value);
      if (li) {
        scrollTo(wrapper2.current, li.offsetTop, 0);
        prevScrollTop.current = li.offsetTop;
      }
    }
  }, [popupVisible, prevPopupVisible]);
  useEffect(function() {
    if (list2.length <= 1) {
      return;
    }
    listItemHeight.current = (ul.current.clientHeight - wrapper2.current.clientHeight) / (list2.length - 1);
  }, [list2.length]);
  var onScrollList = useCallback(debounce_1(function() {
    var mathFunc = wrapper2.current.scrollTop - prevScrollTop.current > 0 ? Math.ceil : Math.floor;
    var index2 = mathFunc(wrapper2.current.scrollTop / listItemHeight.current);
    if (index2 !== value && list2[index2] && !list2[index2].disabled) {
      onHandleSelect(list2[index2].value, unit);
    }
  }, 100), [onHandleSelect]);
  return React__default.createElement("div", { className: cs$1(prefixCls2 + "-list"), ref: wrapper2, onWheel: scrollSticky && onScrollList }, React__default.createElement("ul", { ref: ul }, list2.map(function(item2) {
    var _a;
    return React__default.createElement("li", { key: item2.value, className: cs$1(prefixCls2 + "-cell", (_a = {}, _a[prefixCls2 + "-cell-disabled"] = item2.disabled, _a[prefixCls2 + "-cell-selected"] = item2.selected, _a)), onClick: function() {
      return !item2.disabled && onHandleSelect(item2.value, unit);
    }, ref: function(element) {
      lis.current.set(item2.value, element);
    } }, React__default.createElement("div", { className: prefixCls2 + "-cell-inner" }, item2.label));
  })));
}
var PickerContext = createContext({});
var __assign$U = globalThis && globalThis.__assign || function() {
  __assign$U = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$U.apply(this, arguments);
};
var AMPM = ["am", "pm"];
function isUse12Hours(props) {
  return props.use12Hours || getColumnsFromFormat(props.format).use12Hours;
}
function TimePicker(props) {
  var _a = props.format, format = _a === void 0 ? "HH:mm:ss" : _a, onSelect = props.onSelect, popupVisible = props.popupVisible, _b = props.step, step = _b === void 0 ? {} : _b, disabledHours = props.disabledHours, disabledMinutes = props.disabledMinutes, disabledSeconds = props.disabledSeconds, hideDisabledOptions = props.hideDisabledOptions, onConfirmValue = props.onConfirmValue, isRangePicker = props.isRangePicker, confirmBtnDisabled = props.confirmBtnDisabled, propsValueShow = props.valueShow, setValueShow = props.setValueShow, extra = props.extra, disableConfirm = props.disableConfirm, hideFooter = props.hideFooter, _c = props.showNowBtn, showNowBtn = _c === void 0 ? true : _c, scrollSticky = props.scrollSticky;
  var _d = useContext(ConfigContext), getPrefixCls = _d.getPrefixCls, locale = _d.locale;
  var prefixCls2 = getPrefixCls("timepicker");
  var _e = useContext(PickerContext), utcOffset = _e.utcOffset, timezone = _e.timezone;
  var valueShow = getDayjsValue(propsValueShow, format);
  var ampm = valueShow && valueShow.hour() >= 12 ? "pm" : "am";
  var use12Hours = isUse12Hours(props);
  var getShowList = useCallback(function(type) {
    var stepHour = step.hour || 1;
    var stepMinute = step.minute || 1;
    var stepSecond = step.second || 1;
    var list3 = [];
    if (type === "hour") {
      for (var i2 = 0; i2 < (use12Hours ? 12 : 24); i2 += stepHour) {
        list3.push(i2);
      }
      if (use12Hours) {
        list3[0] = 12;
      }
    }
    if (type === "minute") {
      for (var i2 = 0; i2 < 60; i2 += stepMinute) {
        list3.push(i2);
      }
    }
    if (type === "second") {
      for (var i2 = 0; i2 < 60; i2 += stepSecond) {
        list3.push(i2);
      }
    }
    return list3;
  }, [step.hour, step.minute, step.second, use12Hours]);
  var HOURS = getShowList("hour");
  var MINUTES = getShowList("minute");
  var SECONDS = getShowList("second");
  var selectedHour = valueShow && valueShow.hour();
  selectedHour = use12Hours ? selectedHour > 12 ? selectedHour - 12 : selectedHour : selectedHour;
  if (use12Hours && selectedHour === 0 && ampm === "am") {
    selectedHour += 12;
  }
  var selectedMinute = valueShow && valueShow.minute();
  var selectedSecond = valueShow && valueShow.second();
  var getDefaultStr = useCallback(function(type) {
    switch (type) {
      case "hour":
        return typeof disabledHours === "function" ? padStart(HOURS.find(function(h) {
          return disabledHours().indexOf(h) === -1;
        }) || 0, 2, "0") : padStart(HOURS[0], 2, "0");
      case "minute":
        return typeof disabledMinutes === "function" ? padStart(MINUTES.find(function(m) {
          return disabledMinutes(selectedHour).indexOf(m) === -1;
        }) || 0, 2, "0") : padStart(MINUTES[0], 2, "0");
      case "second":
        return typeof disabledSeconds === "function" ? padStart(SECONDS.find(function(s) {
          return disabledSeconds(selectedHour, selectedMinute).indexOf(s) === -1;
        }) || 0, 2, "0") : padStart(SECONDS[0], 2, "0");
      default:
        return "00";
    }
  }, [
    HOURS,
    MINUTES,
    SECONDS,
    disabledHours,
    disabledMinutes,
    disabledSeconds,
    selectedHour,
    selectedMinute
  ]);
  function onHandleSelect(selectedValue, unit) {
    var isUpperCase = getColumnsFromFormat(format).list.indexOf("A") !== -1;
    var _valueShow = valueShow || dayjs(getDefaultStr("hour") + ":" + getDefaultStr("minute") + ":" + getDefaultStr("second"), "HH:mm:ss");
    var hour = _valueShow.hour();
    var minute = _valueShow.minute();
    var second = _valueShow.second();
    var selectedAmpm = isUpperCase ? ampm.toUpperCase() : ampm;
    var valueFormat = "HH:mm:ss";
    var newValue;
    if (use12Hours) {
      if (isUpperCase) {
        valueFormat = valueFormat + " A";
      } else {
        valueFormat = valueFormat + " a";
      }
    }
    if (use12Hours) {
      hour = hour > 12 ? hour - 12 : hour;
    }
    if (unit === "hour") {
      newValue = dayjs(selectedValue + ":" + minute + ":" + second + " " + selectedAmpm, valueFormat, "en");
    }
    if (unit === "minute") {
      newValue = dayjs(hour + ":" + selectedValue + ":" + second + " " + selectedAmpm, valueFormat, "en");
    }
    if (unit === "second") {
      newValue = dayjs(hour + ":" + minute + ":" + selectedValue + " " + selectedAmpm, valueFormat, "en");
    }
    if (unit === "ampm") {
      newValue = dayjs(hour + ":" + minute + ":" + second + " " + (isUpperCase ? selectedValue.toUpperCase() : selectedValue), valueFormat, "en");
    }
    newValue = dayjs(newValue, valueFormat).locale(dayjs.locale());
    onSelect && onSelect(toLocal(newValue, utcOffset, timezone).format(format), toLocal(newValue, utcOffset, timezone));
    if (!isRangePicker) {
      setValueShow && setValueShow(newValue);
      if (disableConfirm) {
        onConfirmValue(newValue);
      }
    }
  }
  function onConfirmTime() {
    if (valueShow) {
      onConfirmValue(valueShow);
    }
  }
  function onSelectNow() {
    var now2 = getNow();
    var zoneNow = getNow(utcOffset, timezone);
    onSelect && onSelect(now2.format(format), now2);
    if (disableConfirm) {
      onConfirmValue(zoneNow);
    } else {
      setValueShow && setValueShow(zoneNow);
    }
  }
  var baseTimeColumnProps = {
    prefixCls: prefixCls2,
    onHandleSelect,
    popupVisible,
    scrollSticky
  };
  function renderHours() {
    var hours = hideDisabledOptions && typeof disabledHours === "function" ? HOURS.filter(function(h) {
      return disabledHours().indexOf(h) === -1;
    }) : HOURS;
    var list3 = hours.map(function(h) {
      return {
        label: padStart("" + h, 2, "0"),
        value: h,
        selected: selectedHour !== void 0 && selectedHour === h,
        disabled: typeof disabledHours === "function" && disabledHours().indexOf(h) !== -1
      };
    });
    return React__default.createElement(TimeColumn, __assign$U({}, baseTimeColumnProps, { list: list3, value: selectedHour, unit: "hour" }));
  }
  function renderMinutes() {
    var minutes = hideDisabledOptions && typeof disabledMinutes === "function" ? MINUTES.filter(function(h) {
      return disabledMinutes(selectedHour).indexOf(h) === -1;
    }) : MINUTES;
    var list3 = minutes.map(function(m) {
      return {
        label: padStart("" + m, 2, "0"),
        value: m,
        selected: selectedHour !== void 0 && selectedMinute === m,
        disabled: typeof disabledMinutes === "function" && disabledMinutes(selectedHour).indexOf(m) !== -1
      };
    });
    return React__default.createElement(TimeColumn, __assign$U({}, baseTimeColumnProps, { list: list3, value: selectedMinute, unit: "minute" }));
  }
  function renderSeconds() {
    var seconds = hideDisabledOptions && typeof disabledSeconds === "function" ? SECONDS.filter(function(h) {
      return disabledSeconds(selectedHour, selectedMinute).indexOf(h) === -1;
    }) : SECONDS;
    var list3 = seconds.map(function(s) {
      return {
        label: padStart("" + s, 2, "0"),
        value: s,
        selected: selectedHour !== void 0 && selectedSecond === s,
        disabled: typeof disabledSeconds === "function" && disabledSeconds(selectedHour, selectedMinute).indexOf(s) !== -1
      };
    });
    return React__default.createElement(TimeColumn, __assign$U({}, baseTimeColumnProps, { list: list3, value: selectedSecond, unit: "second" }));
  }
  function renderAmPm() {
    var isUpperCase = getColumnsFromFormat(format).list.indexOf("A") !== -1;
    var list3 = AMPM.map(function(a) {
      return {
        label: isUpperCase ? a.toUpperCase() : a,
        value: a,
        selected: ampm === a
      };
    });
    return React__default.createElement(TimeColumn, __assign$U({}, baseTimeColumnProps, { list: list3, value: ampm, unit: "ampm" }));
  }
  var list2 = getColumnsFromFormat(format).list;
  var classNames = cs$1(prefixCls2);
  var _hideFooter = hideFooter || disableConfirm && isRangePicker || !isRangePicker && disableConfirm && !showNowBtn;
  return React__default.createElement(React__default.Fragment, null, React__default.createElement("div", { className: classNames }, (list2.indexOf("H") !== -1 || list2.indexOf("h") !== -1) && renderHours(), list2.indexOf("m") !== -1 && renderMinutes(), list2.indexOf("s") !== -1 && renderSeconds(), use12Hours && renderAmPm()), extra && React__default.createElement("div", { className: prefixCls2 + "-footer-extra-wrapper" }, extra), !_hideFooter && React__default.createElement("div", { className: prefixCls2 + "-footer-btn-wrapper" }, !isRangePicker && showNowBtn ? React__default.createElement(Button$4, { size: "mini", onClick: onSelectNow }, locale.TimePicker.now) : React__default.createElement("div", null), !disableConfirm && React__default.createElement(Button$4, { type: "primary", size: "mini", onClick: onConfirmTime, disabled: confirmBtnDisabled || !valueShow }, locale.TimePicker.ok)));
}
function Header(props) {
  var prefixCls2 = props.prefixCls, title2 = props.title, onPrev = props.onPrev, onNext = props.onNext, onSuperPrev = props.onSuperPrev, onSuperNext = props.onSuperNext, mode = props.mode, value = props.value, onChangePanel = props.onChangePanel, _a = props.icons, icons = _a === void 0 ? {} : _a;
  var showPrev = typeof onPrev === "function";
  var showSuperPrev = typeof onSuperPrev === "function";
  var showNext = typeof onNext === "function";
  var showSuperNext = typeof onSuperNext === "function";
  var getIconClassName = function(isShow) {
    var _a2;
    return cs$1(prefixCls2 + "-header-icon", (_a2 = {}, _a2[prefixCls2 + "-header-icon-hidden"] = !isShow, _a2));
  };
  function renderHeaderLabel() {
    if (title2) {
      return title2;
    }
    if (mode === "date" || mode === "week") {
      return React__default.createElement(React__default.Fragment, null, React__default.createElement("span", { className: prefixCls2 + "-header-label", onClick: function() {
        return onChangePanel("year");
      } }, value.format("YYYY")), "-", React__default.createElement("span", { className: prefixCls2 + "-header-label", onClick: function() {
        return onChangePanel("month");
      } }, value.format("MM")));
    }
    if (mode === "month" || mode === "quarter") {
      return React__default.createElement("span", { className: prefixCls2 + "-header-label", onClick: function() {
        return onChangePanel("year");
      } }, value.format("YYYY"));
    }
  }
  var prevDoubleNull = icons.prevDouble === null;
  var prevNull = icons.prev === null;
  var nextNull = icons.next === null;
  var nextDoubleNull = icons.nextDouble === null;
  return React__default.createElement("div", { className: prefixCls2 + "-header" }, !prevDoubleNull && React__default.createElement("div", { className: getIconClassName(showSuperPrev), onClick: onSuperPrev }, showSuperPrev && (prevDoubleNull ? null : icons.prevDouble || React__default.createElement(IconDoubleLeft$1, null))), !prevNull && React__default.createElement("div", { className: getIconClassName(showPrev), onClick: onPrev }, showPrev && (prevNull ? null : icons.prev || React__default.createElement(IconLeft$1, null))), React__default.createElement("div", { className: prefixCls2 + "-header-value" }, renderHeaderLabel()), !nextNull && React__default.createElement("div", { className: getIconClassName(showNext), onClick: onNext }, showNext && (nextNull ? null : icons.next || React__default.createElement(IconRight$1, null))), !nextDoubleNull && React__default.createElement("div", { className: getIconClassName(showSuperNext), onClick: onSuperNext }, showSuperNext && (nextDoubleNull ? null : icons.nextDouble || React__default.createElement(IconDoubleRight$1, null))));
}
function WeekList(props) {
  var prefixCls2 = props.prefixCls, weekStart = props.weekStart, isWeek = props.isWeek, CALENDAR_LOCALE = props.CALENDAR_LOCALE;
  var weekList = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
  weekList = weekList.slice(weekStart).concat(weekList.slice(0, weekStart));
  if (isWeek) {
    weekList.unshift("");
  }
  var weekLocale = CALENDAR_LOCALE.week.short;
  return React__default.createElement("div", { className: prefixCls2 + "-week-list" }, weekList.map(function(w) {
    return React__default.createElement("div", { className: prefixCls2 + "-week-list-item", key: w }, w && weekLocale[w]);
  }));
}
function getDateValue(date, index2) {
  if (!date) {
    return void 0;
  }
  if (isArray$c(date)) {
    return date[index2];
  }
}
function useClassName(props) {
  var prefixCls2 = props.prefixCls, value = props.value, rangeValues = props.rangeValues, valueShowHover = props.valueShowHover, isSameTime = props.isSameTime, mode = props.mode, hideNotInViewDates = props.hideNotInViewDates;
  var selectedLength = getAvailableDayjsLength(rangeValues);
  var hoverLength = getAvailableDayjsLength(valueShowHover);
  var sortedRangeValues = selectedLength !== 2 && hoverLength === 2 ? getSortedDayjsArray(valueShowHover) : rangeValues;
  var sortedHoverRangeValues = selectedLength === 2 ? getSortedDayjsArray(valueShowHover) : [];
  function isInRange(current, startDate, endDate) {
    if (startDate && endDate) {
      return isSameTime(current, startDate) || isSameTime(current, endDate) || current.isBetween(startDate, endDate, null);
    }
  }
  return function getCellClassName(cellDateObj, disabled, utcOffset, timezone) {
    var _a;
    var rangeStart = getDateValue(sortedRangeValues, 0);
    var rangeEnd = getDateValue(sortedRangeValues, 1);
    var hoverRangeStart = getDateValue(sortedHoverRangeValues, 0);
    var hoverRangeEnd = getDateValue(sortedHoverRangeValues, 1);
    var isInView = !cellDateObj.isPrev && !cellDateObj.isNext;
    var selected = value && isSameTime(cellDateObj.time, value);
    var isToday = isSameTime(cellDateObj.time, getNow(utcOffset, timezone));
    var checkIsInView = mode !== "week" ? isInView : true;
    if (mode === "week") {
      isToday = getNow(utcOffset, timezone).isSame(cellDateObj.time, "date");
    }
    if (mode === "quarter") {
      isToday = getNow(utcOffset, timezone).isSame(cellDateObj.time, "quarter");
    }
    function getIsRangeStartOrEnd(v) {
      return checkIsInView && !disabled && v && isSameTime(cellDateObj.time, v);
    }
    var isRangeStart = getIsRangeStartOrEnd(rangeStart);
    var isRangeEnd = getIsRangeStartOrEnd(rangeEnd);
    var isRangeStartSelected = getIsRangeStartOrEnd(getDateValue(rangeValues, 0));
    var isRangeEndSelected = getIsRangeStartOrEnd(getDateValue(rangeValues, 1));
    var isHoverRangeStart = getIsRangeStartOrEnd(hoverRangeStart);
    var isHoverRangeEnd = getIsRangeStartOrEnd(hoverRangeEnd);
    var isRangeEdgeInHoverRange = false;
    if (isRangeStart) {
      isRangeEdgeInHoverRange = hoverRangeStart && rangeStart && hoverRangeStart.isBefore(rangeStart) && isInRange(rangeStart, hoverRangeStart, hoverRangeEnd);
    } else if (isRangeEnd) {
      isRangeEdgeInHoverRange = hoverRangeEnd && rangeEnd && hoverRangeEnd.isAfter(rangeEnd) && isInRange(rangeEnd, hoverRangeStart, hoverRangeEnd);
    }
    var isHoverRangeEdgeInRange = false;
    if (isHoverRangeStart) {
      isHoverRangeEdgeInRange = hoverRangeStart && rangeStart && rangeStart.isBefore(hoverRangeStart) && isInRange(hoverRangeStart, rangeStart, rangeEnd);
    } else if (isHoverRangeEnd) {
      isHoverRangeEdgeInRange = hoverRangeEnd && rangeEnd && rangeEnd.isAfter(hoverRangeEnd) && isInRange(hoverRangeEnd, rangeStart, rangeEnd);
    }
    return cs$1(prefixCls2 + "-cell", (_a = {}, _a[prefixCls2 + "-cell-disabled"] = disabled, _a[prefixCls2 + "-cell-hidden"] = hideNotInViewDates && !isInView, _a[prefixCls2 + "-cell-in-view"] = isInView, _a[prefixCls2 + "-cell-today"] = isToday && isInView, _a[prefixCls2 + "-cell-selected"] = selected || isRangeStartSelected || isRangeEndSelected, _a[prefixCls2 + "-cell-range-start"] = isRangeStart, _a[prefixCls2 + "-cell-range-end"] = isRangeEnd, _a[prefixCls2 + "-cell-in-range"] = checkIsInView && !disabled && isInRange(cellDateObj.time, rangeStart, rangeEnd), _a[prefixCls2 + "-cell-hover-range-start"] = isHoverRangeStart, _a[prefixCls2 + "-cell-hover-range-end"] = isHoverRangeEnd, _a[prefixCls2 + "-cell-hover-in-range"] = checkIsInView && !disabled && isInRange(cellDateObj.time, hoverRangeStart, hoverRangeEnd), _a[prefixCls2 + "-cell-range-edge-in-hover-range"] = isRangeEdgeInHoverRange, _a[prefixCls2 + "-cell-hover-range-edge-in-range"] = isHoverRangeEdgeInRange, _a));
  };
}
var __assign$T = globalThis && globalThis.__assign || function() {
  __assign$T = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$T.apply(this, arguments);
};
function Body(props) {
  var prefixCls2 = props.prefixCls, isWeek = props.isWeek, disabledDate = props.disabledDate, onSelectDate = props.onSelectDate, dateRender = props.dateRender, onMouseEnterCell = props.onMouseEnterCell, onMouseLeaveCell = props.onMouseLeaveCell, CALENDAR_LOCALE = props.CALENDAR_LOCALE, rows = props.rows, showWeekList = props.showWeekList, isSameTime = props.isSameTime, format = props.format, mode = props.mode, originMode = props.originMode;
  var _a = useContext(PickerContext$1), utcOffset = _a.utcOffset, timezone = _a.timezone, weekStart = _a.weekStart;
  var getCellClassName = useClassName(__assign$T(__assign$T({}, props), { isSameTime }));
  function renderRow(row) {
    return row.map(function(col, index2) {
      if (col.time) {
        var disabled_1 = isDisabledDate(col.time, disabledDate, mode, originMode);
        var onClickHandler = function() {
          return !disabled_1 && onSelectDate(col.time.format(format), col.time);
        };
        return React__default.createElement("div", { key: index2, className: getCellClassName(col, disabled_1, utcOffset, timezone), onMouseEnter: function() {
          return onMouseEnterCell && onMouseEnterCell(col.time, disabled_1);
        }, onMouseLeave: function() {
          return onMouseLeaveCell && onMouseLeaveCell(col.time, disabled_1);
        }, onClick: onClickHandler }, dateRender ? React__default.cloneElement(dateRender(col.time)) : React__default.createElement("div", { className: prefixCls2 + "-date" }, React__default.createElement("div", { className: prefixCls2 + "-date-value" }, col.name)));
      }
      if ("weekOfYear" in col) {
        return React__default.createElement("div", { key: index2, className: cs$1(prefixCls2 + "-cell", prefixCls2 + "-cell-week") }, React__default.createElement("div", { className: prefixCls2 + "-date" }, React__default.createElement("div", { className: prefixCls2 + "-date-value" }, col.weekOfYear)));
      }
    });
  }
  return React__default.createElement(React__default.Fragment, null, showWeekList && React__default.createElement(WeekList, { prefixCls: prefixCls2, weekStart, isWeek, CALENDAR_LOCALE }), React__default.createElement("div", { className: prefixCls2 + "-body" }, rows.map(function(row, index2) {
    var _a2;
    return React__default.createElement("div", { key: index2, className: cs$1(prefixCls2 + "-row", (_a2 = {}, _a2[prefixCls2 + "-row-week"] = isWeek, _a2)) }, renderRow(row));
  })));
}
var __assign$S = globalThis && globalThis.__assign || function() {
  __assign$S = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$S.apply(this, arguments);
};
var __rest$l = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function YearPicker$1(props) {
  var pageShowDate = props.pageShowDate, style = props.style, onMouseEnterCell = props.onMouseEnterCell, onMouseLeaveCell = props.onMouseLeaveCell, dateRender = props.dateRender, disabledDate = props.disabledDate, value = props.value, locale = props.locale, isRangePicker = props.isRangePicker, onSelect = props.onSelect, rangeValues = props.rangeValues, onSuperPrev = props.onSuperPrev, onSuperNext = props.onSuperNext, format = props.format, icons = props.icons, originMode = props.originMode, rest = __rest$l(props, ["pageShowDate", "style", "onMouseEnterCell", "onMouseLeaveCell", "dateRender", "disabledDate", "value", "locale", "isRangePicker", "onSelect", "rangeValues", "onSuperPrev", "onSuperNext", "format", "icons", "originMode"]);
  var _a = useContext(ConfigContext), globalLocale = _a.locale, getPrefixCls = _a.getPrefixCls;
  var DATEPICKER_LOCALE = merge_1(globalLocale.DatePicker, locale);
  var CALENDAR_LOCALE = DATEPICKER_LOCALE.Calendar;
  var _b = useContext(PickerContext$1), utcOffset = _b.utcOffset, timezone = _b.timezone;
  var prefixCls2 = getPrefixCls("panel-year");
  var classNames = cs$1(prefixCls2);
  var bodyProps = isRangePicker ? { rangeValues } : { value };
  var showYear = pageShowDate ? pageShowDate.year() : getNow(utcOffset, timezone).year();
  var startYear = Math.floor(showYear / 10) * 10 - 1;
  var groupRow = newArray(3).map(function(_) {
    return "";
  });
  var rows = newArray(4).map(function(_) {
    return groupRow;
  }).map(function(arr, i2) {
    return arr.map(function(_, j) {
      return {
        name: startYear + i2 * 3 + j,
        time: dayjs("" + (startYear + i2 * 3 + j), "YYYY").endOf("year"),
        isPrev: i2 === 0 && j === 0,
        isNext: i2 === 3 && j === 2
      };
    });
  });
  function renderCalendar() {
    return React__default.createElement(Body, __assign$S({}, rest, bodyProps, { prefixCls: getPrefixCls("picker"), rows, onSelectDate: onSelect, isSameTime: function(current, target2) {
      return current.isSame(target2, "year");
    }, onMouseEnterCell, onMouseLeaveCell, dateRender, disabledDate, CALENDAR_LOCALE, mode: "year", originMode, format }));
  }
  var headerOperations = { onSuperPrev, onSuperNext };
  return React__default.createElement("div", { className: classNames, style }, React__default.createElement(Header, __assign$S({ prefixCls: getPrefixCls("picker"), icons, title: rows[0][1].name + " - " + rows[3][2].name }, headerOperations)), renderCalendar());
}
YearPicker$1.defaultProps = {
  pickerType: "year"
};
var __assign$R = globalThis && globalThis.__assign || function() {
  __assign$R = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$R.apply(this, arguments);
};
var __rest$k = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function MonthPicker$1(props) {
  var pageShowDate = props.pageShowDate, style = props.style, onMouseEnterCell = props.onMouseEnterCell, onMouseLeaveCell = props.onMouseLeaveCell, dateRender = props.dateRender, disabledDate = props.disabledDate, value = props.value, locale = props.locale, isRangePicker = props.isRangePicker, onSelect = props.onSelect, rangeValues = props.rangeValues, onSuperPrev = props.onSuperPrev, onSuperNext = props.onSuperNext, format = props.format, getHeaderOperations = props.getHeaderOperations, setPageShowDate = props.setPageShowDate, icons = props.icons, panelMode = props.panelMode, originMode = props.originMode, setPanelMode = props.setPanelMode, rest = __rest$k(props, ["pageShowDate", "style", "onMouseEnterCell", "onMouseLeaveCell", "dateRender", "disabledDate", "value", "locale", "isRangePicker", "onSelect", "rangeValues", "onSuperPrev", "onSuperNext", "format", "getHeaderOperations", "setPageShowDate", "icons", "panelMode", "originMode", "setPanelMode"]);
  var _a = useContext(ConfigContext), globalLocale = _a.locale, getPrefixCls = _a.getPrefixCls;
  var DATEPICKER_LOCALE = merge_1(globalLocale.DatePicker, locale);
  var CALENDAR_LOCALE = DATEPICKER_LOCALE.Calendar;
  var prefixCls2 = getPrefixCls("panel-month");
  var classNames = cs$1(prefixCls2);
  var bodyProps = isRangePicker ? { rangeValues } : { value };
  var showYear = pageShowDate.year();
  var rows = useMemo(function() {
    var MONTHS = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ].map(function(month, index2) {
      return {
        name: CALENDAR_LOCALE.month.short[month],
        time: dayjs(showYear + "-" + padStart(index2 + 1, 2, "0"), "YYYY-MM").endOf("month")
      };
    });
    var monthGroup = Array(4);
    for (var i2 = 0; i2 < 4; i2++) {
      monthGroup[i2] = MONTHS.slice(i2 * 3, 3 * (i2 + 1));
    }
    return monthGroup;
  }, [showYear, CALENDAR_LOCALE]);
  function renderCalendar() {
    return React__default.createElement(Body, __assign$R({}, rest, bodyProps, { prefixCls: getPrefixCls("picker"), rows, onSelectDate: onSelect, isSameTime: function(current, target2) {
      return current.isSame(target2, "month");
    }, onMouseEnterCell, onMouseLeaveCell, dateRender, disabledDate, CALENDAR_LOCALE, mode: "month", originMode, format }));
  }
  var headerOperations = { onSuperPrev, onSuperNext };
  function onChangePanel(mode) {
    setPanelMode(mode);
  }
  if (panelMode === "year") {
    return React__default.createElement(YearPicker$1, __assign$R({}, getHeaderOperations(panelMode), { pageShowDate, onSelect: function(_, date) {
      setPanelMode("month");
      setPageShowDate(date);
    }, disabledDate }));
  }
  return React__default.createElement("div", { className: classNames, style }, React__default.createElement(Header, __assign$R({}, headerOperations, { icons, prefixCls: getPrefixCls("picker"), value: pageShowDate, mode: panelMode, onChangePanel })), renderCalendar());
}
MonthPicker$1.defaultProps = {
  pickerType: "month"
};
var __assign$Q = globalThis && globalThis.__assign || function() {
  __assign$Q = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$Q.apply(this, arguments);
};
var __rest$j = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$E = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$g = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var allDaysInOnePage = 6 * 7;
var getReturn = function(time) {
  return {
    year: time.year(),
    month: time.month() + 1,
    day: time.day(),
    name: time.date(),
    time
  };
};
var getTimeObj = function(time) {
  return __assign$Q(__assign$Q({}, getReturn(methods.startOf(time, "month"))), { days: time.daysInMonth() });
};
function getAllDaysByTime(props, time) {
  var dayStartOfWeek = props.dayStartOfWeek, isWeek = props.isWeek;
  var current = getTimeObj(time);
  var flatRows = newArray(allDaysInOnePage).map(function() {
    return {};
  });
  var startIndex = current.day - dayStartOfWeek < 0 ? 7 + (current.day - dayStartOfWeek) : current.day - dayStartOfWeek;
  flatRows[startIndex] = __assign$Q({}, current);
  for (var i2 = 0; i2 < startIndex; i2++) {
    flatRows[startIndex - i2 - 1] = __assign$Q(__assign$Q({}, getReturn(methods.subtract(current.time, i2 + 1, "day"))), { isPrev: true });
  }
  for (var i2 = 0; i2 < allDaysInOnePage - startIndex - 1; i2++) {
    flatRows[startIndex + i2 + 1] = __assign$Q(__assign$Q({}, getReturn(methods.add(current.time, i2 + 1, "day"))), { isNext: i2 >= current.days - 1 });
  }
  var rows = newArray(6).map(function() {
    return [];
  });
  for (var i2 = 0; i2 < 6; i2++) {
    rows[i2] = flatRows.slice(i2 * 7, 7 * (i2 + 1));
    if (isWeek) {
      var weekTime = rows[i2][0].time;
      var weekRows = __spreadArray$g([], __read$E(rows[i2]), false);
      rows[i2].unshift({
        weekRows,
        weekOfYear: weekTime.week()
      });
    }
  }
  return rows;
}
function DatePicker$2(props) {
  var isWeek = props.isWeek, popupVisible = props.popupVisible, format = props.format, pageShowDate = props.pageShowDate, showTime = props.showTime, style = props.style, timepickerProps = props.timepickerProps, onMouseEnterCell = props.onMouseEnterCell, onMouseLeaveCell = props.onMouseLeaveCell, dateRender = props.dateRender, disabledDate = props.disabledDate, disabledTime = props.disabledTime, value = props.value, rangeValues = props.rangeValues, locale = props.locale, isRangePicker = props.isRangePicker, onSelect = props.onSelect, onTimePickerSelect = props.onTimePickerSelect, onPrev = props.onPrev, onNext = props.onNext, onSuperPrev = props.onSuperPrev, onSuperNext = props.onSuperNext, isSameTime = props.isSameTime, index2 = props.index, getHeaderOperations = props.getHeaderOperations, setPageShowDate = props.setPageShowDate, timeValue = props.timeValue, hideNotInViewDates = props.hideNotInViewDates, icons = props.icons, isTimePanel = props.isTimePanel, panelMode = props.panelMode, setPanelMode = props.setPanelMode, rest = __rest$j(props, ["isWeek", "popupVisible", "format", "pageShowDate", "showTime", "style", "timepickerProps", "onMouseEnterCell", "onMouseLeaveCell", "dateRender", "disabledDate", "disabledTime", "value", "rangeValues", "locale", "isRangePicker", "onSelect", "onTimePickerSelect", "onPrev", "onNext", "onSuperPrev", "onSuperNext", "isSameTime", "index", "getHeaderOperations", "setPageShowDate", "timeValue", "hideNotInViewDates", "icons", "isTimePanel", "panelMode", "setPanelMode"]);
  var _a = useContext(ConfigContext), globalLocale = _a.locale, getPrefixCls = _a.getPrefixCls;
  var _b = useContext(PickerContext$1), utcOffset = _b.utcOffset, timezone = _b.timezone, weekStart = _b.weekStart;
  var DATEPICKER_LOCALE = merge_1(globalLocale.DatePicker, locale);
  var prefixCls2 = getPrefixCls(isWeek ? "panel-week" : "panel-date");
  var classNames = cs$1(prefixCls2);
  var bodyProps = isRangePicker ? { rangeValues } : { value };
  var timeFormat = isObject$e(showTime) && showTime.format || getTimeFormat(format);
  var rows = useMemo(function() {
    return getAllDaysByTime(__assign$Q(__assign$Q({}, props), { dayStartOfWeek: weekStart }), pageShowDate);
  }, [pageShowDate.toString(), weekStart]);
  var disabledTimeProps;
  if (isRangePicker) {
    disabledTimeProps = typeof disabledTime === "function" ? disabledTime(rangeValues[index2], index2 === 0 ? "start" : "end") : {};
  } else {
    disabledTimeProps = typeof disabledTime === "function" ? disabledTime(getDayjsValue(value, format)) : {};
  }
  function renderCalendar() {
    return React__default.createElement(Body, __assign$Q({}, rest, bodyProps, { showWeekList: true, isWeek, prefixCls: getPrefixCls("picker"), rows, isSameTime: isSameTime || function(current, target2) {
      return current.isSame(target2, "day");
    }, onSelectDate: onSelect, onMouseEnterCell, onMouseLeaveCell, dateRender, disabledDate, CALENDAR_LOCALE: DATEPICKER_LOCALE.Calendar, mode: isWeek ? "week" : "date", format, hideNotInViewDates }));
  }
  function renderTimePicker() {
    var showTimeProps = isObject$e(showTime) ? showTime : {};
    return React__default.createElement("div", { className: prefixCls2 + "-timepicker" }, React__default.createElement("header", { className: prefixCls2 + "-timepicker-title" }, DATEPICKER_LOCALE.selectTime), React__default.createElement(TimePicker, __assign$Q({}, timepickerProps, showTimeProps, disabledTimeProps, { hideFooter: true, format: timeFormat, valueShow: timeValue.format(timeFormat), onSelect: onTimePickerSelect, popupVisible, utcOffset, timezone })));
  }
  var headerOperations = { onPrev, onSuperPrev, onNext, onSuperNext };
  function onChangePanel(mode) {
    setPanelMode(mode);
  }
  if (panelMode === "year") {
    return React__default.createElement(YearPicker$1, __assign$Q({}, getHeaderOperations(panelMode), { pageShowDate, onSelect: function(_, date) {
      setPanelMode("month");
      setPageShowDate(date);
    }, disabledDate, originMode: "date" }));
  }
  if (panelMode === "month") {
    return React__default.createElement(MonthPicker$1, __assign$Q({}, getHeaderOperations(panelMode), { setPageShowDate, pageShowDate, panelMode, getHeaderOperations, onSelect: function(_, date) {
      setPanelMode("date");
      setPageShowDate(date);
    }, disabledDate, originMode: "date" }));
  }
  return React__default.createElement("div", { className: classNames, style }, showTime && isTimePanel ? renderTimePicker() : React__default.createElement("div", { className: prefixCls2 + "-inner" }, React__default.createElement(Header, __assign$Q({}, headerOperations, { icons, prefixCls: getPrefixCls("picker"), value: pageShowDate, mode: panelMode, onChangePanel })), renderCalendar()));
}
DatePicker$2.defaultProps = {
  pickerType: "date"
};
var __assign$P = globalThis && globalThis.__assign || function() {
  __assign$P = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$P.apply(this, arguments);
};
var __rest$i = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function WeekPicker$1(props) {
  var value = props.value, isRangePicker = props.isRangePicker, rangeValues = props.rangeValues, onPrev = props.onPrev, onNext = props.onNext, onSuperPrev = props.onSuperPrev, onSuperNext = props.onSuperNext, localeName = props.localeName, rest = __rest$i(props, ["value", "isRangePicker", "rangeValues", "onPrev", "onNext", "onSuperPrev", "onSuperNext", "localeName"]);
  var weekStart = useContext(PickerContext$1).weekStart;
  var bodyProps = isRangePicker ? { rangeValues } : { value };
  var headerOperations = { onPrev, onNext, onSuperPrev, onSuperNext };
  function isSameTime(current, target2) {
    return methods.isSameWeek(current, target2, weekStart, localeName);
  }
  return React__default.createElement(DatePicker$2, __assign$P({}, rest, bodyProps, headerOperations, { isWeek: true, isSameTime, isRangePicker }));
}
WeekPicker$1.defaultProps = {
  pickerType: "week"
};
var __assign$O = globalThis && globalThis.__assign || function() {
  __assign$O = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$O.apply(this, arguments);
};
var __rest$h = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function QuarterPicker$1(props) {
  var pageShowDate = props.pageShowDate, style = props.style, onMouseEnterCell = props.onMouseEnterCell, onMouseLeaveCell = props.onMouseLeaveCell, dateRender = props.dateRender, disabledDate = props.disabledDate, value = props.value, locale = props.locale, isRangePicker = props.isRangePicker, onSelect = props.onSelect, rangeValues = props.rangeValues, onSuperPrev = props.onSuperPrev, onSuperNext = props.onSuperNext, format = props.format, getHeaderOperations = props.getHeaderOperations, setPageShowDate = props.setPageShowDate, icons = props.icons, panelMode = props.panelMode, setPanelMode = props.setPanelMode, rest = __rest$h(props, ["pageShowDate", "style", "onMouseEnterCell", "onMouseLeaveCell", "dateRender", "disabledDate", "value", "locale", "isRangePicker", "onSelect", "rangeValues", "onSuperPrev", "onSuperNext", "format", "getHeaderOperations", "setPageShowDate", "icons", "panelMode", "setPanelMode"]);
  var _a = useContext(ConfigContext), globalLocale = _a.locale, getPrefixCls = _a.getPrefixCls;
  var DATEPICKER_LOCALE = merge_1(globalLocale.DatePicker, locale);
  var CALENDAR_LOCALE = DATEPICKER_LOCALE.Calendar;
  var prefixCls2 = getPrefixCls("panel-quarter");
  var classNames = cs$1(prefixCls2);
  var bodyProps = isRangePicker ? { rangeValues } : { value };
  var showYear = pageShowDate.year();
  var rows = [
    [1, 2, 3, 4].map(function(q) {
      return {
        name: "Q" + q,
        time: dayjs(showYear + "-" + padStart((q - 1) * 3 + 1, 2, "0") + "-01")
      };
    })
  ];
  function renderCalendar() {
    return React__default.createElement(Body, __assign$O({}, rest, bodyProps, { prefixCls: getPrefixCls("picker"), rows, onSelectDate: onSelect, isSameTime: function(current, target2) {
      return current.isSame(target2, "month");
    }, onMouseEnterCell, onMouseLeaveCell, dateRender, disabledDate, CALENDAR_LOCALE, mode: "quarter", format }));
  }
  var headerOperations = { onSuperPrev, onSuperNext };
  function onChangePanel(mode) {
    setPanelMode(mode);
  }
  if (panelMode === "year") {
    return React__default.createElement(YearPicker$1, __assign$O({}, getHeaderOperations(panelMode), { pageShowDate, onSelect: function(_, date) {
      setPanelMode("quarter");
      setPageShowDate(date);
    }, disabledDate, originMode: "quarter" }));
  }
  return React__default.createElement("div", { className: classNames, style }, React__default.createElement(Header, __assign$O({}, headerOperations, { icons, prefixCls: getPrefixCls("picker"), value: pageShowDate, mode: panelMode, onChangePanel })), React__default.createElement("div", { className: prefixCls2 + "-wrapper" }, renderCalendar()));
}
QuarterPicker$1.defaultProps = {
  pickerType: "quarter"
};
var __assign$N = globalThis && globalThis.__assign || function() {
  __assign$N = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$N.apply(this, arguments);
};
function range(start2, end) {
  var result = [];
  for (var i2 = start2; i2 < end; i2++) {
    result.push(i2);
  }
  return result;
}
function RangePicker$1(props) {
  var _a = props.mode, mode = _a === void 0 ? "date" : _a, showTime = props.showTime, disabledDate = props.disabledDate, disabledTime = props.disabledTime, format = props.format, dateRender = props.dateRender, propsValue = props.value, timeValues = props.timeValues, icons = props.icons, locale = props.locale, pageShowDates = props.pageShowDates, onMouseEnterCell = props.onMouseEnterCell, onMouseLeaveCell = props.onMouseLeaveCell, onSelectTime = props.onTimePickerSelect, onSelectPanel = props.onSelectPanel, onPrev = props.onPrev, onSuperPrev = props.onSuperPrev, onNext = props.onNext, onSuperNext = props.onSuperNext, localeName = props.localeName, popupVisible = props.popupVisible, timepickerProps = props.timepickerProps, getHeaderOperations = props.getHeaderOperations, setRangePageShowDates = props.setRangePageShowDates, disabledTimePickerIndex = props.disabledTimePickerIndex, hideNotInViewDates = props.hideNotInViewDates, isTimePanel = props.isTimePanel, valueShowHover = props.valueShowHover, panelModes = props.panelModes, setPanelModes = props.setPanelModes;
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var prefixCls2 = getPrefixCls("picker-range");
  var _b = useContext(PickerContext$1), utcOffset = _b.utcOffset, timezone = _b.timezone;
  var startShowDate = pageShowDates[0] || getNow(utcOffset, timezone);
  var endShowDate = pageShowDates[1] || getNow(utcOffset, timezone);
  var value = getDayjsValue(propsValue, format);
  var basePickerProps = {
    isRangePicker: true,
    rangeValues: value,
    onMouseEnterCell,
    onMouseLeaveCell,
    format,
    locale,
    disabledDate,
    onSelect: onSelectPanel,
    dateRender,
    getHeaderOperations,
    icons,
    valueShowHover
  };
  var startPickerProps = {
    pageShowDate: startShowDate,
    panelMode: panelModes[0],
    setPanelMode: function(m) {
      return setPanelModes([m, panelModes[1]]);
    }
  };
  var endPickerProps = {
    pageShowDate: endShowDate,
    panelMode: panelModes[1],
    setPanelMode: function(m) {
      return setPanelModes([panelModes[0], m]);
    }
  };
  function renderDate() {
    var startOperations = {
      onPrev,
      onSuperPrev
    };
    var endOperations = {
      onNext,
      onSuperNext
    };
    var pickerProps = __assign$N(__assign$N({}, basePickerProps), { localeName, popupVisible, timepickerProps, getHeaderOperations, hideNotInViewDates, isTimePanel });
    if (mode === "week") {
      return React__default.createElement(React__default.Fragment, null, React__default.createElement(WeekPicker$1, __assign$N({ setPageShowDate: function(d) {
        return setRangePageShowDates([d, d], "week", 0);
      } }, startOperations, pickerProps, startPickerProps)), React__default.createElement(WeekPicker$1, __assign$N({ setPageShowDate: function(d) {
        return setRangePageShowDates([d, d], "week", 1);
      } }, endOperations, pickerProps, endPickerProps)));
    }
    var showTimeProps = {
      disabledTime,
      showTime
    };
    var disabledTimePickerProps = {};
    if (typeof disabledTimePickerIndex === "number") {
      disabledTimePickerProps.disabledTime = function() {
        return {
          disabledHours: function() {
            return range(0, 24);
          },
          disabledMinutes: function() {
            return range(0, 60);
          },
          disabledSeconds: function() {
            return range(0, 60);
          }
        };
      };
      if (isObject$e(showTime)) {
        var st = __assign$N(__assign$N({}, showTime), { defaultValue: void 0 });
        disabledTimePickerProps.showTime = __assign$N(__assign$N({}, st), { hideDisabledOptions: false });
      }
    }
    return React__default.createElement(React__default.Fragment, null, React__default.createElement(DatePicker$2, __assign$N({}, startOperations, pickerProps, showTimeProps, disabledTimePickerIndex === 0 ? disabledTimePickerProps : {}, { onTimePickerSelect: function(timeString, time) {
      onSelectTime(0, timeString, time);
    }, index: 0, setPageShowDate: function(d) {
      return setRangePageShowDates([d, d], "date", 0);
    }, timeValue: timeValues[0] }, startPickerProps)), React__default.createElement(DatePicker$2, __assign$N({}, endOperations, pickerProps, showTimeProps, disabledTimePickerIndex === 1 ? disabledTimePickerProps : {}, { onTimePickerSelect: function(timeString, time) {
      onSelectTime(1, timeString, time);
    }, index: 1, setPageShowDate: function(d) {
      return setRangePageShowDates([d, d], "date", 1);
    }, timeValue: timeValues[1] }, endPickerProps)));
  }
  function renderMonth() {
    var startOperations = {
      onSuperPrev
    };
    var endOperations = {
      onSuperNext
    };
    var pickerProps = basePickerProps;
    return React__default.createElement(React__default.Fragment, null, React__default.createElement(MonthPicker$1, __assign$N({ setPageShowDate: function(d) {
      return setRangePageShowDates([d, d], "month", 0);
    } }, startOperations, pickerProps, startPickerProps)), React__default.createElement(MonthPicker$1, __assign$N({ setPageShowDate: function(d) {
      return setRangePageShowDates([d, d], "month", 1);
    } }, endOperations, pickerProps, endPickerProps)));
  }
  function renderYear() {
    var startOperations = {
      onSuperPrev
    };
    var endOperations = {
      onSuperNext
    };
    var pickerProps = basePickerProps;
    return React__default.createElement(React__default.Fragment, null, React__default.createElement(YearPicker$1, __assign$N({}, startOperations, pickerProps, { pageShowDate: startShowDate })), React__default.createElement(YearPicker$1, __assign$N({}, endOperations, pickerProps, { pageShowDate: endShowDate })));
  }
  function renderQuarter() {
    var startOperations = {
      onSuperPrev
    };
    var endOperations = {
      onSuperNext
    };
    var pickerProps = basePickerProps;
    return React__default.createElement(React__default.Fragment, null, React__default.createElement(QuarterPicker$1, __assign$N({ setPageShowDate: function(d) {
      return setRangePageShowDates([d, d], "quarter", 0);
    } }, startOperations, pickerProps, startPickerProps)), React__default.createElement(QuarterPicker$1, __assign$N({ setPageShowDate: function(d) {
      return setRangePageShowDates([d, d], "quarter", 1);
    } }, endOperations, pickerProps, endPickerProps)));
  }
  return React__default.createElement("div", { className: prefixCls2 }, React__default.createElement("div", { className: prefixCls2 + "-wrapper" }, (mode === "date" || mode === "week") && renderDate(), mode === "month" && renderMonth(), mode === "year" && renderYear(), mode === "quarter" && renderQuarter()));
}
RangePicker$1.defaultProps = {
  pickerType: "range"
};
var __assign$M = globalThis && globalThis.__assign || function() {
  __assign$M = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$M.apply(this, arguments);
};
var __read$D = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$f = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function getFormat(props) {
  var format = props.format, showTime = props.showTime, mode = props.mode;
  var valueFormat;
  switch (mode) {
    case "date":
      valueFormat = showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
      break;
    case "month":
      valueFormat = "YYYY-MM";
      break;
    case "year":
      valueFormat = "YYYY";
      break;
    case "week":
      valueFormat = "YYYY-wo";
      break;
    case "quarter":
      valueFormat = "YYYY-[Q]Q";
      break;
    default:
      valueFormat = "YYYY-MM-DD";
  }
  if (format) {
    valueFormat = format;
  }
  return valueFormat;
}
var defaultProps$f = {
  allowClear: true,
  unmountOnExit: true,
  position: "bl",
  editable: true,
  mode: "date"
};
var Picker = function(baseProps) {
  var _a, _b;
  var _c = useContext(ConfigContext), getPrefixCls = _c.getPrefixCls, locale = _c.locale, ctxSize = _c.size, componentConfig2 = _c.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$f, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.DatePicker);
  var allowClear = props.allowClear, className = props.className, style = props.style, placeholder = props.placeholder, getPopupContainer = props.getPopupContainer, disabled = props.disabled, position = props.position, error2 = props.error, unmountOnExit = props.unmountOnExit, editable = props.editable, triggerProps = props.triggerProps, shortcuts = props.shortcuts, onSelect = props.onSelect, onVisibleChange = props.onVisibleChange, propsValue = props.value, onChange = props.onChange, icons = props.icons, disabledDate = props.disabledDate, disabledTime = props.disabledTime, mode = props.mode, showTime = props.showTime, onSelectShortcut = props.onSelectShortcut, extra = props.extra, shortcutsPlacementLeft = props.shortcutsPlacementLeft, onOk = props.onOk, defaultPickerValue = props.defaultPickerValue, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, triggerElement = props.triggerElement, clearRangeOnReselect = props.clearRangeOnReselect, separator = props.separator, utcOffset = props.utcOffset, timezone = props.timezone;
  var prefixCls2 = getPrefixCls("picker-range");
  var weekStart = isUndefined(props.dayStartOfWeek) ? getDefaultWeekStart(locale.dayjsLocale) : props.dayStartOfWeek;
  var refInput = useRef(null);
  var refPanel = useRef(null);
  var refShortcuts = useRef(null);
  var shortcutEnterTimer = useRef(null);
  var shortcutLeaveTimer = useRef(null);
  var format = getFormat(props);
  function getAvailableInputIndex() {
    if (isArray$c(disabled)) {
      if (disabled[0] && !disabled[1]) {
        return 1;
      }
      if (disabled[1] && !disabled[0]) {
        return 0;
      }
    }
  }
  var availableInputIndex = getAvailableInputIndex();
  var isHalfAvailable = typeof availableInputIndex === "number";
  var disabledTimePickerIndex = isHalfAvailable ? 1 ^ availableInputIndex : void 0;
  var _d = __read$D(useState(isHalfAvailable ? availableInputIndex : 0), 2), focusedInputIndex = _d[0], setFocusedInputIndex = _d[1];
  var nextFocusedInputIndex = 1 ^ focusedInputIndex;
  var _e = __read$D(useState(), 2), inputValue = _e[0], setInputValue = _e[1];
  var _f = __read$D(useState(), 2), hoverPlaceholderValue = _f[0], setHoverPlaceholderValue = _f[1];
  var _g = __read$D(useState(getDefaultValue()), 2), value = _g[0], setValue = _g[1];
  var _h = __read$D(useState(), 2), valueShow = _h[0], setValueShow = _h[1];
  var _j = __read$D(useState(), 2), valueShowHover = _j[0], setValueShowHover = _j[1];
  var _k = __read$D(useState(), 2), shortcutsValue = _k[0], setShortcutsValue = _k[1];
  var _l = __read$D(useState(props.popupVisible), 2), popupVisible = _l[0], setPopupVisible = _l[1];
  var _m = __read$D(useState([mode, mode]), 2), panelModes = _m[0], setPanelModes = _m[1];
  var _o = __read$D(useState(false), 2), isTimePanel = _o[0], setIsTimePanel = _o[1];
  var mergedPopupVisible = "popupVisible" in props ? props.popupVisible : popupVisible;
  var propsValueDayjs = getDayjsValue(propsValue, format, utcOffset, timezone);
  var mergedValue = "value" in props ? propsValueDayjs : value;
  var panelValue = shortcutsValue || valueShow || mergedValue || [];
  var selectedLength = getAvailableDayjsLength(valueShow || mergedValue);
  var firstRange = useRef(true);
  var now2 = getNow();
  var zoneNow = toTimezone(now2, utcOffset, timezone);
  function getTimeValues() {
    var timeValues2 = [];
    var defaultTimeValue = isObject$e(showTime) && showTime.defaultValue ? getDayjsValue(showTime.defaultValue, showTime.format || "HH:mm:ss", utcOffset, timezone) : [];
    timeValues2[0] = panelValue[0] || defaultTimeValue[0] || zoneNow;
    timeValues2[1] = panelValue[1] || defaultTimeValue[1] || zoneNow;
    return timeValues2;
  }
  var timeValues = getTimeValues();
  var initialDisabledDate = isHalfAvailable ? function(current) {
    return availableInputIndex === 0 ? current.isAfter(panelValue[1], mode) : current.isBefore(panelValue[0], mode);
  } : void 0;
  var selectedDisabledDate = useRef(initialDisabledDate);
  var customTriggerElement = triggerElement !== void 0;
  var resetRange = customTriggerElement || clearRangeOnReselect;
  function getDefaultValue() {
    var value2;
    if (props.value) {
      value2 = getDayjsValue(props.value, format, utcOffset, timezone);
    } else {
      value2 = getDayjsValue(props.defaultValue, format, utcOffset, timezone);
    }
    if (isHalfAvailable && (!value2 || value2 && !value2[nextFocusedInputIndex])) {
      var nv = [];
      nv[nextFocusedInputIndex] = getNow(utcOffset, timezone);
      return nv;
    }
    return value2;
  }
  var defaultPageShowDates = mergedValue || getDayjsValue(defaultPickerValue, format) || [now2, now2];
  var _p = __read$D(useState(getShowDatesFromFocused(defaultPageShowDates)), 2), pageShowDates = _p[0], setPageShowDates = _p[1];
  var mergedPageShowDate = getShowDatesFromFocused(getDayjsValue(pickerValue, format, utcOffset, timezone)) || pageShowDates;
  var previousUtcOffset = usePrevious(utcOffset);
  var previousTimezone = usePrevious(timezone);
  useUpdate(function() {
    if (isArray$c(value) && (previousUtcOffset !== utcOffset || timezone !== previousTimezone)) {
      var localValue = value.map(function(v) {
        return toLocal(v, previousUtcOffset, previousTimezone);
      });
      var zoneValue = localValue.map(function(v) {
        return toTimezone(v, utcOffset, timezone);
      });
      setValue(zoneValue);
    }
  }, [utcOffset, previousUtcOffset, timezone, previousTimezone]);
  useEffect(function() {
    setPanelModes([mode, mode]);
  }, [mode]);
  useEffect(function() {
    setHoverPlaceholderValue(void 0);
    setInputValue(void 0);
    if (mergedPopupVisible) {
      setIsTimePanel(false);
      setPanelModes([mode, mode]);
      setPageShowDates(getShowDatesFromFocused(defaultPageShowDates));
      setValueShow(mergedValue);
      if (shortcutsPlacementLeft) {
        refShortcuts.current.style.maxHeight = refPanel.current.clientHeight + "px";
      }
    } else {
      setValueShow(void 0);
      setValueShowHover(void 0);
      setShortcutsValue(void 0);
      resetSelectedDisabledDate();
      blurInput();
    }
    firstRange.current = mergedPopupVisible;
  }, [mergedPopupVisible]);
  var startStr = (_a = propsValueDayjs === null || propsValueDayjs === void 0 ? void 0 : propsValueDayjs[0]) === null || _a === void 0 ? void 0 : _a.format(format);
  var endStr = (_b = propsValueDayjs === null || propsValueDayjs === void 0 ? void 0 : propsValueDayjs[1]) === null || _b === void 0 ? void 0 : _b.format(format);
  useEffect(function() {
    setValueShow(void 0);
    setValueShowHover(void 0);
  }, [startStr, endStr]);
  function setFixedPageShowDates(innerValue) {
    var newPageShowDates = getShowDatesFromFocused(innerValue);
    setPageShowDates(newPageShowDates);
    handlePickerValueChange(newPageShowDates);
  }
  function handlePickerValueChange(v) {
    if (!isSamePanel([v[0], pageShowDates[0]], mode)) {
      onPickerValueChange && onPickerValueChange(isArray$c(v) ? v.map(function(v2) {
        return v2 && v2.format(format);
      }) : void 0, v);
    }
  }
  function getShowDatesFromFocused(dates, index2) {
    if (index2 === void 0) {
      index2 = focusedInputIndex;
    }
    var prev = index2 === 0 || isSamePanel(dates, mode);
    if (isArray$c(dates) && dates.length < 2) {
      return getPageShowDatesByValue(dates[0] || getNow(utcOffset, timezone), mode, "prev");
    }
    if (isArray$c(dates) && dates.length === 2) {
      if (dates[index2]) {
        return getPageShowDatesByValue(dates[index2], mode, prev ? "prev" : "next");
      }
      return getPageShowDatesByValue(dates[index2 === 0 ? 1 : 0] || getNow(utcOffset, timezone), mode, prev && !dates[index2 === 0 ? 1 : 0] ? "prev" : "next");
    }
  }
  function setNestPageShowDates(dates, pickerMode, index2) {
    if (isArray$c(dates) && dates[index2]) {
      setPageShowDates(getPageShowDatesByValue(dates[index2], pickerMode, index2 === 0 ? "prev" : "next"));
      handlePickerValueChange(dates);
    }
  }
  function isSamePanel(innerValue, pickerMode) {
    if (innerValue && innerValue.length === 2 && isValidDayjsArray(innerValue)) {
      return (pickerMode === "date" || pickerMode === "week") && innerValue[0].isSame(innerValue[1], "month") || (pickerMode === "month" || pickerMode === "quarter") && innerValue[0].isSame(innerValue[1], "year") || pickerMode === "year" && Math.floor(innerValue[0].year() / 10) === Math.floor(innerValue[1].year() / 10);
    }
  }
  function getPageShowDatesByValue(value2, pickerMode, type) {
    if (value2 === void 0) {
      value2 = getNow(utcOffset, timezone);
    }
    if (pickerMode === void 0) {
      pickerMode = mode;
    }
    if (type === void 0) {
      type = "prev";
    }
    var prev = type === "prev";
    switch (pickerMode) {
      case "date":
      case "week":
        return prev ? [value2, methods.add(value2, 1, "month")] : [methods.subtract(value2, 1, "month"), value2];
      case "month":
      case "quarter":
        return prev ? [value2, methods.add(value2, 1, "year")] : [methods.subtract(value2, 1, "year"), value2];
      case "year":
        return prev ? [value2, methods.add(value2, 10, "year")] : [methods.subtract(value2, 10, "year"), value2];
      default:
        return [];
    }
  }
  function focusInput(index2) {
    refInput.current && refInput.current.focus && refInput.current.focus(isHalfAvailable ? availableInputIndex : index2);
  }
  function blurInput() {
    refInput.current && refInput.current.blur && refInput.current.blur();
  }
  function visibleChange(visible) {
    if (visible) {
      setTimeout(function() {
        return focusInput();
      });
      setOpen(visible);
    } else {
      setOpen(false);
    }
  }
  function setOpen(visible) {
    onVisibleChange && onVisibleChange(visible);
    setPopupVisible(visible);
  }
  function onClear(e) {
    e.stopPropagation();
    var newValueShow = __spreadArray$f([], __read$D(panelValue), false);
    if (isHalfAvailable) {
      newValueShow[availableInputIndex] = void 0;
    } else {
      newValueShow = void 0;
    }
    setValue(newValueShow);
    setValueShow(newValueShow);
    onHandleChange(newValueShow);
    props.onClear && props.onClear();
  }
  function changeFocusedInputIndex(index2, silent) {
    setInputValue(void 0);
    setFocusedInputIndex(index2);
    if (panelValue && panelValue.length && !silent) {
      var newPageShowDates = getShowDatesFromFocused(panelValue, index2);
      setPageShowDates(newPageShowDates);
      handlePickerValueChange(newPageShowDates);
    }
  }
  function isDisabledDate2(date) {
    var selectedDisabled = typeof selectedDisabledDate.current === "function" ? selectedDisabledDate.current(date) : false;
    var originDisabledDate = typeof disabledDate === "function" ? disabledDate(date) : false;
    return originDisabledDate || selectedDisabled;
  }
  function isValid(time) {
    return isValidTimeString(time, format) && !isDisabledDate2(getDayjsValue(time, format));
  }
  function resetSelectedDisabledDate() {
    selectedDisabledDate.current = initialDisabledDate;
  }
  function onChangeInput(e) {
    var newValueShow = __spreadArray$f([], __read$D(panelValue || []), false);
    var niv = e.target.value;
    setInputValue(niv);
    if (!mergedPopupVisible) {
      setOpen(true);
    }
    if (isValid(niv)) {
      newValueShow[focusedInputIndex] = getDayjsValue(niv, format);
      setValueShow(newValueShow);
      setFixedPageShowDates(newValueShow);
      setInputValue(void 0);
    }
  }
  function onHandleChange(newValue) {
    if (isDayjsArrayChange(mergedValue, newValue)) {
      var localValue = isArray$c(newValue) ? newValue.map(function(v) {
        return toLocal(v, utcOffset, timezone);
      }) : void 0;
      onChange && onChange(isArray$c(localValue) ? localValue.map(function(v) {
        return v && v.format(format);
      }) : void 0, localValue);
    }
  }
  function onPressEnter() {
    if (isArray$c(valueShow) && valueShow.length) {
      if (inputValue && !isValid(inputValue)) {
        setInputValue(void 0);
      } else if (selectedLength !== 2) {
        switchFocusedInput();
      } else if (selectedLength === 2) {
        onConfirmValue(valueShow);
      }
    } else if (mergedPopupVisible) {
      setOpen(false);
    }
  }
  function onPressTab(e) {
    e.preventDefault();
  }
  function onConfirmValue(date, keepOpen) {
    var confirmValue = date || panelValue;
    if (!confirmValue || !confirmValue[0] || !confirmValue[1]) {
      return;
    }
    var sortedValues = getSortedDayjsArray(confirmValue);
    setValue(sortedValues);
    onHandleChange(sortedValues);
    resetSelectedDisabledDate();
    if (triggerElement !== null && !keepOpen) {
      setOpen(false);
    }
  }
  function onClickConfirmBtn() {
    onConfirmValue();
    onOk && onOk(panelValue.map(function(v) {
      return v && v.format(format);
    }), panelValue);
  }
  function outOfRange(date) {
    if (selectedLength !== 2) {
      return false;
    }
    var v = valueShow || mergedValue;
    if (focusedInputIndex === 0 && date.valueOf() > v[1].valueOf()) {
      return true;
    }
    if (focusedInputIndex === 1 && date.valueOf() < v[0].valueOf()) {
      return true;
    }
    return false;
  }
  function onSelectPanel(_, date) {
    var isOutOfRange = outOfRange(date) && firstRange.current;
    var newValueShow = resetRange && selectedLength === 2 && !isHalfAvailable ? [] : __spreadArray$f([], __read$D(panelValue), false);
    var focusedIndex = customTriggerElement ? selectedLength === 0 || selectedLength === 2 ? 0 : 1 : focusedInputIndex;
    var newDate = showTime ? getValueWithTime(date, timeValues[focusedIndex]) : date;
    if (isOutOfRange) {
      newValueShow[focusedIndex] = newDate;
      newValueShow[1 ^ focusedIndex] = void 0;
    } else {
      newValueShow[focusedIndex] = newDate;
    }
    var sortedValueShow = getSortedDayjsArray(newValueShow);
    onSelectValueShow(sortedValueShow);
    setInputValue(void 0);
    setHoverPlaceholderValue(void 0);
    var newSelectedLength = getAvailableDayjsLength(newValueShow);
    if (resetRange) {
      if (selectedLength === 0 || selectedLength === 2 && !isHalfAvailable) {
        customTriggerElement ? setFocusedInputIndex(1) : switchFocusedInput(true);
      } else if (!showTime) {
        onConfirmValue(newValueShow);
      }
    } else if (newSelectedLength <= 1) {
      switchFocusedInput(true);
    } else if (selectedLength === 2 && firstRange.current && !isHalfAvailable) {
      firstRange.current = false;
      switchFocusedInput(true);
      if (!showTime && !isOutOfRange) {
        onConfirmValue(newValueShow, true);
      }
    } else {
      firstRange.current = false;
      if (!showTime && !isOutOfRange) {
        onConfirmValue(newValueShow);
      }
    }
  }
  function onTimePickerSelect(index2, _, time) {
    var newValueShow = isArray$c(panelValue) ? __spreadArray$f([], __read$D(panelValue), false) : [];
    var newTimeValue = getValueWithTime(newValueShow[index2] || getNow(utcOffset, timezone), time);
    newValueShow[index2] = newTimeValue;
    onSelectValueShow(newValueShow);
  }
  function onSelectValueShow(newValueShow) {
    setValueShow(newValueShow);
    setValueShowHover(void 0);
    var sortedValues = getSortedDayjsArray(newValueShow);
    var zoneValues = sortedValues.map(function(v) {
      return toLocal(v, utcOffset, timezone);
    });
    onSelect && onSelect(zoneValues.map(function(v) {
      return v && v.format(format);
    }), zoneValues, { type: focusedInputIndex === 1 ? "end" : "start" });
  }
  function switchFocusedInput(silent) {
    changeFocusedInputIndex(nextFocusedInputIndex, silent);
    setTimeout(function() {
      return focusInput(nextFocusedInputIndex);
    });
  }
  function onMouseEnterCell(date, disabled2) {
    var newValueShowHover = __spreadArray$f([], __read$D(panelValue || []), false);
    var needShowHover = resetRange ? selectedLength === 1 : selectedLength !== 0;
    if (!disabled2 && needShowHover && !outOfRange(date)) {
      newValueShowHover[focusedInputIndex] = getValueWithTime(date, timeValues[focusedInputIndex]);
      setValueShowHover(newValueShowHover);
      setInputValue(void 0);
    }
    if (!disabled2) {
      var placeHolderValue = showTime ? getValueWithTime(date, timeValues[focusedInputIndex]) : date;
      setHoverPlaceholderValue(placeHolderValue.locale(locale.dayjsLocale).format(format));
    }
  }
  function onMouseLeaveCell() {
    setValueShowHover(void 0);
    setHoverPlaceholderValue(void 0);
  }
  function isValidDayjsArray(sv) {
    return sv && isArray$c(sv) && sv.length === 2 && isDayjs(sv[0]) && isDayjs(sv[1]);
  }
  function isValidShortcut(shortcut) {
    var sv = typeof shortcut.value === "function" && shortcut.value();
    return isValidDayjsArray(sv);
  }
  function clearShortcutsTimer() {
    clearTimeout(shortcutEnterTimer.current);
    clearTimeout(shortcutLeaveTimer.current);
    shortcutEnterTimer.current = null;
    shortcutLeaveTimer.current = null;
  }
  function onMouseEnterShortcut(shortcut) {
    clearShortcutsTimer();
    shortcutEnterTimer.current = setTimeout(function() {
      if (isValidShortcut(shortcut)) {
        var nv = getDayjsValue(shortcut.value(), format, utcOffset, timezone);
        setShortcutsValue(nv);
        setFixedPageShowDates(nv);
      }
    }, 50);
  }
  function onMouseLeaveShortcut() {
    clearShortcutsTimer();
    shortcutLeaveTimer.current = setTimeout(function() {
      setShortcutsValue(void 0);
      setFixedPageShowDates(valueShow || mergedValue || [getNow(utcOffset, timezone), getNow(utcOffset, timezone)]);
    }, 50);
  }
  function onHandleSelectShortcut(shortcut) {
    onSelectShortcut && onSelectShortcut(shortcut);
    if (isValidShortcut(shortcut)) {
      var time = getDayjsValue(shortcut.value(), format, utcOffset, timezone);
      onConfirmValue(time);
    }
  }
  function changePageShowDates(type, unit, num) {
    if (num === void 0) {
      num = 1;
    }
    var index2 = type === "prev" ? 0 : 1;
    var newPageShowDates = __spreadArray$f([], __read$D(mergedPageShowDate), false);
    if (type === "prev") {
      newPageShowDates[index2] = methods.subtract(mergedPageShowDate[index2], num, unit);
    }
    if (type === "next") {
      newPageShowDates[index2] = methods.add(mergedPageShowDate[index2], num, unit);
    }
    newPageShowDates = getPageShowDatesByValue(newPageShowDates[index2], mode, type);
    setFixedPageShowDates(newPageShowDates);
  }
  function getHeaderOperations(pickerMode) {
    if (pickerMode === void 0) {
      pickerMode = mode;
    }
    if (pickerMode === "date" || pickerMode === "week") {
      return {
        onPrev: function() {
          return changePageShowDates("prev", "month");
        },
        onNext: function() {
          return changePageShowDates("next", "month");
        },
        onSuperPrev: function() {
          return changePageShowDates("prev", "year");
        },
        onSuperNext: function() {
          return changePageShowDates("next", "year");
        }
      };
    }
    if (pickerMode === "month" || pickerMode === "quarter") {
      return {
        onSuperPrev: function() {
          return changePageShowDates("prev", "year");
        },
        onSuperNext: function() {
          return changePageShowDates("next", "year");
        }
      };
    }
    if (pickerMode === "year") {
      return {
        onSuperPrev: function() {
          return changePageShowDates("prev", "year", 10);
        },
        onSuperNext: function() {
          return changePageShowDates("next", "year", 10);
        }
      };
    }
  }
  function onClickSelectTimeBtn() {
    setIsTimePanel(!isTimePanel);
  }
  function renderPopup(panelOnly) {
    var _a2;
    var classNames = cs$1(prefixCls2 + "-container", (_a2 = {}, _a2[prefixCls2 + "-panel-only"] = panelOnly, _a2[prefixCls2 + "-container-shortcuts-placement-left"] = isArray$c(shortcuts) && shortcutsPlacementLeft, _a2), panelOnly ? className : "");
    var shortcutsProps = {
      prefixCls: getPrefixCls("picker"),
      showTime,
      shortcuts,
      onMouseEnterShortcut,
      onMouseLeaveShortcut,
      onSelectShortcut: onHandleSelectShortcut
    };
    var shouldShowFooter = showTime && panelModes[0] === "date" && panelModes[1] === "date" || extra || isArray$c(shortcuts) && shortcuts.length && !shortcutsPlacementLeft;
    var content = React__default.createElement(React__default.Fragment, null, React__default.createElement(RangePicker$1, __assign$M({}, props, getHeaderOperations(), { getHeaderOperations, setRangePageShowDates: setNestPageShowDates, pageShowDates: mergedPageShowDate, value: panelValue, format, onSelectPanel, onMouseEnterCell, onMouseLeaveCell, disabledDate: function(current) {
      return isDisabledDate2(current);
    }, disabledTime, mode, localeName: locale.dayjsLocale, showTime, timeValues: shortcutsValue || timeValues, onTimePickerSelect, popupVisible: mergedPopupVisible, disabledTimePickerIndex, isTimePanel, valueShowHover, panelModes, setPanelModes })), shouldShowFooter && React__default.createElement(Footer, __assign$M({}, shortcutsProps, { DATEPICKER_LOCALE: locale.DatePicker, disabled: !(isArray$c(panelValue) && panelValue[0] && panelValue[1]), onClickConfirmBtn, extra, shortcutsPlacementLeft, onClickSelectTimeBtn, isTimePanel })));
    return React__default.createElement("div", { className: classNames, onClick: function() {
      return focusInput();
    }, style: panelOnly ? style : {} }, shortcutsPlacementLeft ? React__default.createElement(React__default.Fragment, null, React__default.createElement(Shortcuts$1, __assign$M({ ref: refShortcuts }, shortcutsProps)), React__default.createElement("div", { ref: refPanel, className: prefixCls2 + "-panel-wrapper" }, content)) : content);
  }
  var size = props.size || ctxSize;
  var placeholders = isArray$c(placeholder) ? placeholder : locale.DatePicker.placeholders[mode];
  var suffixIcon = icons && icons.inputSuffix === null ? null : icons && icons.inputSuffix || (showTime ? React__default.createElement(IconCalendarClock$1, null) : React__default.createElement(IconCalendar$1, null));
  var baseInputProps = {
    style,
    className,
    popupVisible: mergedPopupVisible,
    format,
    disabled,
    error: error2,
    size,
    onPressEnter,
    onPressTab,
    onClear,
    suffixIcon,
    editable,
    allowClear
  };
  var triggerDisabled = isArray$c(disabled) ? disabled[0] && disabled[1] : disabled;
  return React__default.createElement(PickerContext$1.Provider, { value: { utcOffset, timezone, weekStart } }, triggerElement === null ? renderPopup(true) : React__default.createElement(Trigger$1, __assign$M({ popup: renderPopup, trigger: "click", clickToClose: false, position, disabled: triggerDisabled, popupAlign: { bottom: 4 }, getPopupContainer, onVisibleChange: visibleChange, popupVisible: mergedPopupVisible, classNames: "slideDynamicOrigin", unmountOnExit }, triggerProps), triggerElement || React__default.createElement(InputRange, __assign$M({}, baseInputProps, { ref: refInput, placeholder: placeholders, value: valueShow || mergedValue, onChange: onChangeInput, inputValue: hoverPlaceholderValue || inputValue, changeFocusedInputIndex, focusedInputIndex, isPlaceholder: !!hoverPlaceholderValue, separator }))));
};
Picker.displayName = "RangePicker";
var PickerRange = Picker;
var __extends$5 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$L = globalThis && globalThis.__assign || function() {
  __assign$L = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$L.apply(this, arguments);
};
function wrapper(picker, displayName) {
  var _a;
  return _a = function(_super) {
    __extends$5(PickerWrapper, _super);
    function PickerWrapper() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PickerWrapper.prototype.render = function() {
      return React__default.createElement(Picker$2, __assign$L({}, this.props, { picker }));
    };
    return PickerWrapper;
  }(React__default.Component), _a.displayName = displayName, _a;
}
var DatePicker = wrapper(React__default.createElement(DatePicker$2, null), "DatePicker");
var MonthPicker = wrapper(React__default.createElement(MonthPicker$1, null), "MonthPicker");
var YearPicker = wrapper(React__default.createElement(YearPicker$1, null), "YearPicker");
var WeekPicker = wrapper(React__default.createElement(WeekPicker$1, null), "WeekPicker");
var QuarterPicker = wrapper(React__default.createElement(QuarterPicker$1, null), "QuarterPicker");
var RangePicker = PickerRange;
Object.assign(DatePicker, { MonthPicker, YearPicker, WeekPicker, QuarterPicker, RangePicker });
var DatePicker$1 = DatePicker;
var FOCUS_GROUP = "data-focus-lock";
var FOCUS_DISABLED = "data-focus-lock-disabled";
var FOCUS_ALLOW = "data-no-focus-lock";
var FOCUS_AUTO = "data-autofocus-inside";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = useState(function() {
    return {
      value: initialValue,
      callback,
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last2 = ref.value;
          if (last2 !== value) {
            ref.value = value;
            ref.callback(value, last2);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
function useMergeRefs(refs, defaultValue) {
  return useCallbackRef(defaultValue, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
}
var hiddenGuard = {
  width: "1px",
  height: "0px",
  padding: 0,
  overflow: "hidden",
  position: "fixed",
  top: "1px",
  left: "1px"
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$K = function() {
  __assign$K = Object.assign || function __assign2(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$K.apply(this, arguments);
};
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item2 = middleware(data, assigned);
      buffer.push(item2);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item2;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  return innerCreateMedium(defaults, middleware);
}
function createSidecarMedium(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign$K({ async: true, ssr: false }, options2);
  return medium;
}
var mediumFocus = createMedium({}, function(_ref2) {
  var target2 = _ref2.target, currentTarget = _ref2.currentTarget;
  return {
    target: target2,
    currentTarget
  };
});
var mediumBlur = createMedium();
var mediumEffect = createMedium();
var mediumSidecar = createSidecarMedium({
  async: true
});
var emptyArray = [];
var FocusLock$1 = /* @__PURE__ */ React.forwardRef(function FocusLockUI2(props, parentRef) {
  var _extends2;
  var _React$useState = React.useState(), realObserved = _React$useState[0], setObserved = _React$useState[1];
  var observed = React.useRef();
  var isActive = React.useRef(false);
  var originalFocusedElement = React.useRef(null);
  var children = props.children, disabled = props.disabled, noFocusGuards = props.noFocusGuards, persistentFocus = props.persistentFocus, crossFrame = props.crossFrame, autoFocus = props.autoFocus;
  props.allowTextSelection;
  var group = props.group, className = props.className, whiteList = props.whiteList, _props$shards = props.shards, shards = _props$shards === void 0 ? emptyArray : _props$shards, _props$as = props.as, Container = _props$as === void 0 ? "div" : _props$as, _props$lockProps = props.lockProps, containerProps = _props$lockProps === void 0 ? {} : _props$lockProps, SideCar = props.sideCar, shouldReturnFocus = props.returnFocus, onActivationCallback = props.onActivation, onDeactivationCallback = props.onDeactivation;
  var _React$useState2 = React.useState({}), id = _React$useState2[0];
  var onActivation = React.useCallback(function() {
    originalFocusedElement.current = originalFocusedElement.current || document && document.activeElement;
    if (observed.current && onActivationCallback) {
      onActivationCallback(observed.current);
    }
    isActive.current = true;
  }, [onActivationCallback]);
  var onDeactivation = React.useCallback(function() {
    isActive.current = false;
    if (onDeactivationCallback) {
      onDeactivationCallback(observed.current);
    }
  }, [onDeactivationCallback]);
  useEffect(function() {
    if (!disabled) {
      originalFocusedElement.current = null;
    }
  }, []);
  var returnFocus = React.useCallback(function(allowDefer) {
    var returnFocusTo = originalFocusedElement.current;
    if (returnFocusTo && returnFocusTo.focus) {
      var howToReturnFocus = typeof shouldReturnFocus === "function" ? shouldReturnFocus(returnFocusTo) : shouldReturnFocus;
      if (Boolean(howToReturnFocus)) {
        var focusOptions = typeof howToReturnFocus === "object" ? howToReturnFocus : void 0;
        originalFocusedElement.current = null;
        if (allowDefer) {
          Promise.resolve().then(function() {
            return returnFocusTo.focus(focusOptions);
          });
        } else {
          returnFocusTo.focus(focusOptions);
        }
      }
    }
  }, [shouldReturnFocus]);
  var onFocus3 = React.useCallback(function(event2) {
    if (isActive.current) {
      mediumFocus.useMedium(event2);
    }
  }, []);
  var onBlur3 = mediumBlur.useMedium;
  var setObserveNode = React.useCallback(function(newObserved) {
    if (observed.current !== newObserved) {
      observed.current = newObserved;
      setObserved(newObserved);
    }
  }, []);
  var lockProps = _extends((_extends2 = {}, _extends2[FOCUS_DISABLED] = disabled && "disabled", _extends2[FOCUS_GROUP] = group, _extends2), containerProps);
  var hasLeadingGuards = noFocusGuards !== true;
  var hasTailingGuards = hasLeadingGuards && noFocusGuards !== "tail";
  var mergedRef = useMergeRefs([parentRef, setObserveNode]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, hasLeadingGuards && [
    /* @__PURE__ */ React.createElement("div", {
      key: "guard-first",
      "data-focus-guard": true,
      tabIndex: disabled ? -1 : 0,
      style: hiddenGuard
    }),
    /* @__PURE__ */ React.createElement("div", {
      key: "guard-nearest",
      "data-focus-guard": true,
      tabIndex: disabled ? -1 : 1,
      style: hiddenGuard
    })
  ], !disabled && /* @__PURE__ */ React.createElement(SideCar, {
    id,
    sideCar: mediumSidecar,
    observed: realObserved,
    disabled,
    persistentFocus,
    crossFrame,
    autoFocus,
    whiteList,
    shards,
    onActivation,
    onDeactivation,
    returnFocus
  }), /* @__PURE__ */ React.createElement(Container, _extends({
    ref: mergedRef
  }, lockProps, {
    className,
    onBlur: onBlur3,
    onFocus: onFocus3
  }), children), hasTailingGuards && /* @__PURE__ */ React.createElement("div", {
    "data-focus-guard": true,
    tabIndex: disabled ? -1 : 0,
    style: hiddenGuard
  }));
});
FocusLock$1.propTypes = {};
FocusLock$1.defaultProps = {
  children: void 0,
  disabled: false,
  returnFocus: false,
  noFocusGuards: false,
  autoFocus: true,
  persistentFocus: false,
  crossFrame: true,
  allowTextSelection: void 0,
  group: void 0,
  className: void 0,
  whiteList: void 0,
  shards: void 0,
  as: "div",
  lockProps: {},
  onActivation: void 0,
  onDeactivation: void 0
};
var FocusLockUI = FocusLock$1;
function withSideEffect(reducePropsToState2, handleStateChangeOnClient2) {
  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || "Component";
  }
  return function wrap2(WrappedComponent) {
    var mountedInstances = [];
    var state;
    function emitChange() {
      state = reducePropsToState2(mountedInstances.map(function(instance) {
        return instance.props;
      }));
      handleStateChangeOnClient2(state);
    }
    var SideEffect = /* @__PURE__ */ function(_PureComponent) {
      _inheritsLoose(SideEffect2, _PureComponent);
      function SideEffect2() {
        return _PureComponent.apply(this, arguments) || this;
      }
      SideEffect2.peek = function peek() {
        return state;
      };
      var _proto = SideEffect2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        mountedInstances.push(this);
        emitChange();
      };
      _proto.componentDidUpdate = function componentDidUpdate() {
        emitChange();
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        var index2 = mountedInstances.indexOf(this);
        mountedInstances.splice(index2, 1);
        emitChange();
      };
      _proto.render = function render() {
        return /* @__PURE__ */ React__default.createElement(WrappedComponent, this.props);
      };
      return SideEffect2;
    }(PureComponent);
    _defineProperty$1(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");
    return SideEffect;
  };
}
var toArray = function(a) {
  var ret = Array(a.length);
  for (var i2 = 0; i2 < a.length; ++i2) {
    ret[i2] = a[i2];
  }
  return ret;
};
var asArray = function(a) {
  return Array.isArray(a) ? a : [a];
};
var filterNested = function(nodes) {
  var contained = new Set();
  var l = nodes.length;
  for (var i2 = 0; i2 < l; i2 += 1) {
    for (var j = i2 + 1; j < l; j += 1) {
      var position = nodes[i2].compareDocumentPosition(nodes[j]);
      if ((position & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0) {
        contained.add(j);
      }
      if ((position & Node.DOCUMENT_POSITION_CONTAINS) > 0) {
        contained.add(i2);
      }
    }
  }
  return nodes.filter(function(_, index2) {
    return !contained.has(index2);
  });
};
var getTopParent = function(node) {
  return node.parentNode ? getTopParent(node.parentNode) : node;
};
var getAllAffectedNodes = function(node) {
  var nodes = asArray(node);
  return nodes.filter(Boolean).reduce(function(acc, currentNode) {
    var group = currentNode.getAttribute(FOCUS_GROUP);
    acc.push.apply(acc, group ? filterNested(toArray(getTopParent(currentNode).querySelectorAll("[" + FOCUS_GROUP + '="' + group + '"]:not([' + FOCUS_DISABLED + '="disabled"])'))) : [currentNode]);
    return acc;
  }, []);
};
var isElementHidden = function(node) {
  if (node.nodeType !== Node.ELEMENT_NODE) {
    return false;
  }
  var computedStyle = window.getComputedStyle(node, null);
  if (!computedStyle || !computedStyle.getPropertyValue) {
    return false;
  }
  return computedStyle.getPropertyValue("display") === "none" || computedStyle.getPropertyValue("visibility") === "hidden";
};
var isVisibleUncached = function(node, checkParent) {
  return !node || node === document || node && node.nodeType === Node.DOCUMENT_NODE || !isElementHidden(node) && checkParent(node.parentNode && node.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? node.parentNode.host : node.parentNode);
};
var isVisibleCached = function(visibilityCache, node) {
  var cached = visibilityCache.get(node);
  if (cached !== void 0) {
    return cached;
  }
  var result = isVisibleUncached(node, isVisibleCached.bind(void 0, visibilityCache));
  visibilityCache.set(node, result);
  return result;
};
var notHiddenInput = function(node) {
  return !((node.tagName === "INPUT" || node.tagName === "BUTTON") && (node.type === "hidden" || node.disabled));
};
var isGuard = function(node) {
  return Boolean(node && node.dataset && node.dataset.focusGuard);
};
var isNotAGuard = function(node) {
  return !isGuard(node);
};
var isDefined = function(x) {
  return Boolean(x);
};
var tabSort = function(a, b) {
  var tabDiff = a.tabIndex - b.tabIndex;
  var indexDiff = a.index - b.index;
  if (tabDiff) {
    if (!a.tabIndex) {
      return 1;
    }
    if (!b.tabIndex) {
      return -1;
    }
  }
  return tabDiff || indexDiff;
};
var orderByTabIndex = function(nodes, filterNegative, keepGuards) {
  return toArray(nodes).map(function(node, index2) {
    return {
      node,
      index: index2,
      tabIndex: keepGuards && node.tabIndex === -1 ? (node.dataset || {}).focusGuard ? 0 : -1 : node.tabIndex
    };
  }).filter(function(data) {
    return !filterNegative || data.tabIndex >= 0;
  }).sort(tabSort);
};
var tabbables = [
  "button:enabled",
  "select:enabled",
  "textarea:enabled",
  "input:enabled",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[tabindex]",
  "[contenteditable]",
  "[autofocus]"
];
var queryTabbables = tabbables.join(",");
var queryGuardTabbables = queryTabbables + ", [data-focus-guard]";
var getFocusables = function(parents, withGuards) {
  return parents.reduce(function(acc, parent2) {
    return acc.concat(toArray(parent2.querySelectorAll(withGuards ? queryGuardTabbables : queryTabbables)), parent2.parentNode ? toArray(parent2.parentNode.querySelectorAll(queryTabbables)).filter(function(node) {
      return node === parent2;
    }) : []);
  }, []);
};
var getParentAutofocusables = function(parent2) {
  var parentFocus = parent2.querySelectorAll("[" + FOCUS_AUTO + "]");
  return toArray(parentFocus).map(function(node) {
    return getFocusables([node]);
  }).reduce(function(acc, nodes) {
    return acc.concat(nodes);
  }, []);
};
var filterFocusable = function(nodes, visibilityCache) {
  return toArray(nodes).filter(function(node) {
    return isVisibleCached(visibilityCache, node);
  }).filter(function(node) {
    return notHiddenInput(node);
  });
};
var getTabbableNodes = function(topNodes, visibilityCache, withGuards) {
  return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards), visibilityCache), true, withGuards);
};
var getAllTabbableNodes = function(topNodes, visibilityCache) {
  return orderByTabIndex(filterFocusable(getFocusables(topNodes), visibilityCache), false);
};
var parentAutofocusables = function(topNode, visibilityCache) {
  return filterFocusable(getParentAutofocusables(topNode), visibilityCache);
};
var getParents = function(node, parents) {
  if (parents === void 0) {
    parents = [];
  }
  parents.push(node);
  if (node.parentNode) {
    getParents(node.parentNode, parents);
  }
  return parents;
};
var getCommonParent = function(nodeA, nodeB) {
  var parentsA = getParents(nodeA);
  var parentsB = getParents(nodeB);
  for (var i2 = 0; i2 < parentsA.length; i2 += 1) {
    var currentParent = parentsA[i2];
    if (parentsB.indexOf(currentParent) >= 0) {
      return currentParent;
    }
  }
  return false;
};
var getTopCommonParent = function(baseActiveElement, leftEntry, rightEntries) {
  var activeElements = asArray(baseActiveElement);
  var leftEntries = asArray(leftEntry);
  var activeElement = activeElements[0];
  var topCommon = false;
  leftEntries.filter(Boolean).forEach(function(entry) {
    topCommon = getCommonParent(topCommon || entry, entry) || topCommon;
    rightEntries.filter(Boolean).forEach(function(subEntry) {
      var common = getCommonParent(activeElement, subEntry);
      if (common) {
        if (!topCommon || common.contains(topCommon)) {
          topCommon = common;
        } else {
          topCommon = getCommonParent(common, topCommon);
        }
      }
    });
  });
  return topCommon;
};
var allParentAutofocusables = function(entries, visibilityCache) {
  return entries.reduce(function(acc, node) {
    return acc.concat(parentAutofocusables(node, visibilityCache));
  }, []);
};
var getFocusabledIn = function(topNode) {
  var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
  var commonParent = getTopCommonParent(topNode, topNode, entries);
  var visibilityCache = new Map();
  var outerNodes = getTabbableNodes([commonParent], visibilityCache, true);
  var innerElements = getTabbableNodes(entries, visibilityCache).filter(function(_a) {
    var node = _a.node;
    return isNotAGuard(node);
  }).map(function(_a) {
    var node = _a.node;
    return node;
  });
  return outerNodes.map(function(_a) {
    var node = _a.node, index2 = _a.index;
    return {
      node,
      index: index2,
      lockItem: innerElements.indexOf(node) >= 0,
      guard: isGuard(node)
    };
  });
};
var focusInFrame = function(frame) {
  return frame === document.activeElement;
};
var focusInsideIframe = function(topNode) {
  return Boolean(toArray(topNode.querySelectorAll("iframe")).some(function(node) {
    return focusInFrame(node);
  }));
};
var focusInside = function(topNode) {
  var activeElement = document && document.activeElement;
  if (!activeElement || activeElement.dataset && activeElement.dataset.focusGuard) {
    return false;
  }
  return getAllAffectedNodes(topNode).reduce(function(result, node) {
    return result || node.contains(activeElement) || focusInsideIframe(node);
  }, false);
};
var focusIsHidden = function() {
  return document && toArray(document.querySelectorAll("[" + FOCUS_ALLOW + "]")).some(function(node) {
    return node.contains(document.activeElement);
  });
};
var isRadio = function(node) {
  return node.tagName === "INPUT" && node.type === "radio";
};
var findSelectedRadio = function(node, nodes) {
  return nodes.filter(isRadio).filter(function(el) {
    return el.name === node.name;
  }).filter(function(el) {
    return el.checked;
  })[0] || node;
};
var correctNode = function(node, nodes) {
  if (isRadio(node) && node.name) {
    return findSelectedRadio(node, nodes);
  }
  return node;
};
var correctNodes = function(nodes) {
  var resultSet = new Set();
  nodes.forEach(function(node) {
    return resultSet.add(correctNode(node, nodes));
  });
  return nodes.filter(function(node) {
    return resultSet.has(node);
  });
};
var pickFirstFocus = function(nodes) {
  if (nodes[0] && nodes.length > 1) {
    return correctNode(nodes[0], nodes);
  }
  return nodes[0];
};
var pickFocusable = function(nodes, index2) {
  if (nodes.length > 1) {
    return nodes.indexOf(correctNode(nodes[index2], nodes));
  }
  return index2;
};
var NEW_FOCUS = "NEW_FOCUS";
var newFocus = function(innerNodes, outerNodes, activeElement, lastNode) {
  var cnt = innerNodes.length;
  var firstFocus = innerNodes[0];
  var lastFocus = innerNodes[cnt - 1];
  var isOnGuard = isGuard(activeElement);
  if (innerNodes.indexOf(activeElement) >= 0) {
    return void 0;
  }
  var activeIndex = outerNodes.indexOf(activeElement);
  var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;
  var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;
  var indexDiff = activeIndex - lastIndex;
  var firstNodeIndex = outerNodes.indexOf(firstFocus);
  var lastNodeIndex = outerNodes.indexOf(lastFocus);
  var correctedNodes = correctNodes(outerNodes);
  var correctedIndexDiff = correctedNodes.indexOf(activeElement) - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex);
  var returnFirstNode = pickFocusable(innerNodes, 0);
  var returnLastNode = pickFocusable(innerNodes, cnt - 1);
  if (activeIndex === -1 || lastNodeInside === -1) {
    return NEW_FOCUS;
  }
  if (!indexDiff && lastNodeInside >= 0) {
    return lastNodeInside;
  }
  if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnLastNode;
  }
  if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnFirstNode;
  }
  if (indexDiff && Math.abs(correctedIndexDiff) > 1) {
    return lastNodeInside;
  }
  if (activeIndex <= firstNodeIndex) {
    return returnLastNode;
  }
  if (activeIndex > lastNodeIndex) {
    return returnFirstNode;
  }
  if (indexDiff) {
    if (Math.abs(indexDiff) > 1) {
      return lastNodeInside;
    }
    return (cnt + lastNodeInside + indexDiff) % cnt;
  }
  return void 0;
};
var findAutoFocused = function(autoFocusables) {
  return function(node) {
    return node.autofocus || node.dataset && !!node.dataset.autofocus || autoFocusables.indexOf(node) >= 0;
  };
};
var reorderNodes = function(srcNodes, dstNodes) {
  var remap = new Map();
  dstNodes.forEach(function(entity) {
    return remap.set(entity.node, entity);
  });
  return srcNodes.map(function(node) {
    return remap.get(node);
  }).filter(isDefined);
};
var getFocusMerge = function(topNode, lastNode) {
  var activeElement = document && document.activeElement;
  var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
  var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries);
  var visibilityCache = new Map();
  var anyFocusable = getAllTabbableNodes(entries, visibilityCache);
  var innerElements = getTabbableNodes(entries, visibilityCache).filter(function(_a) {
    var node = _a.node;
    return isNotAGuard(node);
  });
  if (!innerElements[0]) {
    innerElements = anyFocusable;
    if (!innerElements[0]) {
      return void 0;
    }
  }
  var outerNodes = getAllTabbableNodes([commonParent], visibilityCache).map(function(_a) {
    var node = _a.node;
    return node;
  });
  var orderedInnerElements = reorderNodes(outerNodes, innerElements);
  var innerNodes = orderedInnerElements.map(function(_a) {
    var node = _a.node;
    return node;
  });
  var newId = newFocus(innerNodes, outerNodes, activeElement, lastNode);
  if (newId === NEW_FOCUS) {
    var autoFocusable = anyFocusable.map(function(_a) {
      var node = _a.node;
      return node;
    }).filter(findAutoFocused(allParentAutofocusables(entries, visibilityCache)));
    return {
      node: autoFocusable && autoFocusable.length ? pickFirstFocus(autoFocusable) : pickFirstFocus(innerNodes)
    };
  }
  if (newId === void 0) {
    return newId;
  }
  return orderedInnerElements[newId];
};
var focusOn = function(target2) {
  target2.focus();
  if ("contentWindow" in target2 && target2.contentWindow) {
    target2.contentWindow.focus();
  }
};
var guardCount = 0;
var lockDisabled = false;
var setFocus = function(topNode, lastNode) {
  var focusable = getFocusMerge(topNode, lastNode);
  if (lockDisabled) {
    return;
  }
  if (focusable) {
    if (guardCount > 2) {
      console.error("FocusLock: focus-fighting detected. Only one focus management system could be active. See https://github.com/theKashey/focus-lock/#focus-fighting");
      lockDisabled = true;
      setTimeout(function() {
        lockDisabled = false;
      }, 1);
      return;
    }
    guardCount++;
    focusOn(focusable.node);
    guardCount--;
  }
};
var moveFocusInside = setFocus;
function deferAction(action) {
  var _window = window, setImmediate = _window.setImmediate;
  if (typeof setImmediate !== "undefined") {
    setImmediate(action);
  } else {
    setTimeout(action, 1);
  }
}
var focusOnBody = function focusOnBody2() {
  return document && document.activeElement === document.body;
};
var isFreeFocus = function isFreeFocus2() {
  return focusOnBody() || focusIsHidden();
};
var lastActiveTrap = null;
var lastActiveFocus = null;
var lastPortaledElement = null;
var focusWasOutsideWindow = false;
var defaultWhitelist = function defaultWhitelist2() {
  return true;
};
var focusWhitelisted = function focusWhitelisted2(activeElement) {
  return (lastActiveTrap.whiteList || defaultWhitelist)(activeElement);
};
var recordPortal = function recordPortal2(observerNode, portaledElement) {
  lastPortaledElement = {
    observerNode,
    portaledElement
  };
};
var focusIsPortaledPair = function focusIsPortaledPair2(element) {
  return lastPortaledElement && lastPortaledElement.portaledElement === element;
};
function autoGuard(startIndex, end, step, allNodes) {
  var lastGuard = null;
  var i2 = startIndex;
  do {
    var item2 = allNodes[i2];
    if (item2.guard) {
      if (item2.node.dataset.focusAutoGuard) {
        lastGuard = item2;
      }
    } else if (item2.lockItem) {
      if (i2 !== startIndex) {
        return;
      }
      lastGuard = null;
    } else {
      break;
    }
  } while ((i2 += step) !== end);
  if (lastGuard) {
    lastGuard.node.tabIndex = 0;
  }
}
var extractRef = function extractRef2(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var focusWasOutside = function focusWasOutside2(crossFrameOption) {
  if (crossFrameOption) {
    return Boolean(focusWasOutsideWindow);
  }
  return focusWasOutsideWindow === "meanwhile";
};
var activateTrap = function activateTrap2() {
  var result = false;
  if (lastActiveTrap) {
    var _lastActiveTrap = lastActiveTrap, observed = _lastActiveTrap.observed, persistentFocus = _lastActiveTrap.persistentFocus, autoFocus = _lastActiveTrap.autoFocus, shards = _lastActiveTrap.shards, crossFrame = _lastActiveTrap.crossFrame;
    var workingNode = observed || lastPortaledElement && lastPortaledElement.portaledElement;
    var activeElement = document && document.activeElement;
    if (workingNode) {
      var workingArea = [workingNode].concat(shards.map(extractRef).filter(Boolean));
      if (!activeElement || focusWhitelisted(activeElement)) {
        if (persistentFocus || focusWasOutside(crossFrame) || !isFreeFocus() || !lastActiveFocus && autoFocus) {
          if (workingNode && !(focusInside(workingArea) || focusIsPortaledPair(activeElement))) {
            if (document && !lastActiveFocus && activeElement && !autoFocus) {
              if (activeElement.blur) {
                activeElement.blur();
              }
              document.body.focus();
            } else {
              result = moveFocusInside(workingArea, lastActiveFocus);
              lastPortaledElement = {};
            }
          }
          focusWasOutsideWindow = false;
          lastActiveFocus = document && document.activeElement;
        }
      }
      if (document) {
        var newActiveElement = document && document.activeElement;
        var allNodes = getFocusabledIn(workingArea);
        var focusedIndex = allNodes.map(function(_ref2) {
          var node = _ref2.node;
          return node;
        }).indexOf(newActiveElement);
        if (focusedIndex > -1) {
          allNodes.filter(function(_ref2) {
            var guard = _ref2.guard, node = _ref2.node;
            return guard && node.dataset.focusAutoGuard;
          }).forEach(function(_ref3) {
            var node = _ref3.node;
            return node.removeAttribute("tabIndex");
          });
          autoGuard(focusedIndex, allNodes.length, 1, allNodes);
          autoGuard(focusedIndex, -1, -1, allNodes);
        }
      }
    }
  }
  return result;
};
var onTrap = function onTrap2(event2) {
  if (activateTrap() && event2) {
    event2.stopPropagation();
    event2.preventDefault();
  }
};
var onBlur = function onBlur2() {
  return deferAction(activateTrap);
};
var onFocus = function onFocus2(event2) {
  var source = event2.target;
  var currentNode = event2.currentTarget;
  if (!currentNode.contains(source)) {
    recordPortal(currentNode, source);
  }
};
var FocusWatcher = function FocusWatcher2() {
  return null;
};
var onWindowBlur = function onWindowBlur2() {
  focusWasOutsideWindow = "just";
  setTimeout(function() {
    focusWasOutsideWindow = "meanwhile";
  }, 0);
};
var attachHandler = function attachHandler2() {
  document.addEventListener("focusin", onTrap);
  document.addEventListener("focusout", onBlur);
  window.addEventListener("blur", onWindowBlur);
};
var detachHandler = function detachHandler2() {
  document.removeEventListener("focusin", onTrap);
  document.removeEventListener("focusout", onBlur);
  window.removeEventListener("blur", onWindowBlur);
};
function reducePropsToState(propsList) {
  return propsList.filter(function(_ref5) {
    var disabled = _ref5.disabled;
    return !disabled;
  });
}
function handleStateChangeOnClient(traps) {
  var trap = traps.slice(-1)[0];
  if (trap && !lastActiveTrap) {
    attachHandler();
  }
  var lastTrap = lastActiveTrap;
  var sameTrap = lastTrap && trap && trap.id === lastTrap.id;
  lastActiveTrap = trap;
  if (lastTrap && !sameTrap) {
    lastTrap.onDeactivation();
    if (!traps.filter(function(_ref6) {
      var id = _ref6.id;
      return id === lastTrap.id;
    }).length) {
      lastTrap.returnFocus(!trap);
    }
  }
  if (trap) {
    lastActiveFocus = null;
    if (!sameTrap || lastTrap.observed !== trap.observed) {
      trap.onActivation();
    }
    activateTrap();
    deferAction(activateTrap);
  } else {
    detachHandler();
    lastActiveFocus = null;
  }
}
mediumFocus.assignSyncMedium(onFocus);
mediumBlur.assignMedium(onBlur);
mediumEffect.assignMedium(function(cb) {
  return cb({
    moveFocusInside,
    focusInside
  });
});
var FocusTrap = withSideEffect(reducePropsToState, handleStateChangeOnClient)(FocusWatcher);
var FocusLockCombination = /* @__PURE__ */ React.forwardRef(function FocusLockUICombination(props, ref) {
  return /* @__PURE__ */ React.createElement(FocusLockUI, _extends({
    sideCar: FocusTrap,
    ref
  }, props));
});
var _ref = FocusLockUI.propTypes || {};
_ref.sideCar;
_objectWithoutPropertiesLoose(_ref, ["sideCar"]);
FocusLockCombination.propTypes = {};
var FocusLock = FocusLockCombination;
var __extends$4 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Portal$1 = function(_super) {
  __extends$4(Portal2, _super);
  function Portal2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.container = null;
    return _this;
  }
  Portal2.prototype.componentDidMount = function() {
    var _this = this;
    this.createContainer();
    this.timer = setTimeout(function() {
      if (!_this.container) {
        _this.createContainer();
      }
    });
  };
  Portal2.prototype.componentWillUnmount = function() {
    clearTimeout(this.timer);
  };
  Portal2.prototype.createContainer = function() {
    var getContainer = this.props.getContainer;
    this.container = getContainer && getContainer();
    this.forceUpdate();
  };
  Portal2.prototype.render = function() {
    var children = this.props.children;
    if (this.container) {
      return ReactDOM.createPortal(children, this.container);
    }
    return null;
  };
  return Portal2;
}(Component);
var Portal$2 = Portal$1;
var __extends$3 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$J = globalThis && globalThis.__assign || function() {
  __assign$J = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$J.apply(this, arguments);
};
var PortalWrapper = function(_super) {
  __extends$3(PortalWrapper2, _super);
  function PortalWrapper2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PortalWrapper2.prototype.componentWillUnmount = function() {
    this.instance = null;
  };
  PortalWrapper2.prototype.render = function() {
    var _this = this;
    var _a = this.props, forceRender = _a.forceRender, visible = _a.visible;
    return forceRender || visible || this.instance ? React__default.createElement(Portal$2, __assign$J({ ref: function(ref) {
      return _this.instance = ref;
    } }, this.props)) : null;
  };
  PortalWrapper2.displayName = "Portal";
  PortalWrapper2.defaultProps = {
    getContainer: function() {
      return document.body;
    }
  };
  return PortalWrapper2;
}(Component);
var Portal = PortalWrapper;
function useOverflowHidden(getContainer, _a) {
  var hidden = _a.hidden;
  var needResetContainerStyle = useRef(false);
  var originContainerStyle = useRef({});
  var getScrollBarWidth = function(element) {
    return element.tagName === "BODY" ? window.innerWidth - (document.body.clientWidth || document.documentElement.clientWidth) : element.offsetWidth - element.clientWidth;
  };
  var setContainerStyle = function() {
    var container2 = getContainer();
    if (container2 && container2.style.overflow !== "hidden") {
      var originStyle = container2.style;
      needResetContainerStyle.current = true;
      var containerScrollBarWidth = getScrollBarWidth(container2);
      if (containerScrollBarWidth) {
        originContainerStyle.current.width = originStyle.width;
        container2.style.width = "calc(" + (container2.style.width || "100%") + " - " + containerScrollBarWidth + "px)";
      }
      originContainerStyle.current.overflow = originStyle.overflow;
      container2.style.overflow = "hidden";
    }
  };
  var resetContainerStyle = function() {
    if (needResetContainerStyle.current && getContainer()) {
      var container_1 = getContainer();
      var originStyle_1 = originContainerStyle.current;
      Object.keys(originStyle_1).forEach(function(i2) {
        return container_1.style[i2] = originStyle_1[i2];
      });
    }
    needResetContainerStyle.current = false;
    originContainerStyle.current = {};
  };
  useEffect(function() {
    hidden ? setContainerStyle() : resetContainerStyle();
    return function() {
      resetContainerStyle();
    };
  }, [getContainer, hidden]);
  return [resetContainerStyle, setContainerStyle];
}
var __assign$I = globalThis && globalThis.__assign || function() {
  __assign$I = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$I.apply(this, arguments);
};
var __read$C = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var defaultProps$e = {
  placement: "right",
  width: 250,
  height: 250,
  escToExit: true,
  mask: true,
  closable: true,
  maskClosable: true,
  mountOnEnter: true,
  getPopupContainer: function() {
    return document.body;
  }
};
function Drawer(baseProps, ref) {
  var _a, _b, _c;
  var context = useContext(ConfigContext);
  var locale = context.locale, getPrefixCls = context.getPrefixCls, componentConfig2 = context.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$e, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Drawer);
  var style = props.style, className = props.className, children = props.children, wrapClassName = props.wrapClassName, maskStyle = props.maskStyle, headerStyle = props.headerStyle, bodyStyle = props.bodyStyle, title2 = props.title, footer = props.footer, okText = props.okText, cancelText = props.cancelText, width = props.width, height = props.height, placement = props.placement, mask2 = props.mask, visible = props.visible, closable = props.closable, maskClosable = props.maskClosable, confirmLoading = props.confirmLoading, mountOnEnter = props.mountOnEnter, unmountOnExit = props.unmountOnExit, afterOpen = props.afterOpen, afterClose = props.afterClose, getPopupContainer = props.getPopupContainer, escToExit = props.escToExit, propGetChildrenPopupContainer = props.getChildrenPopupContainer, focusLock = props.focusLock, autoFocus = props.autoFocus, okButtonProps = props.okButtonProps, cancelButtonProps = props.cancelButtonProps;
  var drawerWrapperRef = useRef(null);
  var contentWrapperRef = useRef(null);
  var _d = __read$C(useState(false), 2), shouldReComputeFixed = _d[0], setShouldReComputeFixed = _d[1];
  var _e = __read$C(useState(), 2), popupZIndex = _e[0], setPopupZIndex = _e[1];
  var prefixCls2 = getPrefixCls("drawer");
  var inExit = useRef(false);
  var _f = __read$C(useState(false), 2), isOpened = _f[0], setIsOpened = _f[1];
  var getContainer = useCallback(function() {
    var container2 = getPopupContainer && getPopupContainer();
    return findDOMNode(container2) || document.body;
  }, [getPopupContainer]);
  var isFixed = useMemo(function() {
    return !isServerRendering && getContainer() === document.body;
  }, [shouldReComputeFixed, getContainer]);
  useOverflowHidden(getContainer, { hidden: visible && mask2 });
  useImperativeHandle(ref, function() {
    return drawerWrapperRef.current;
  });
  useEffect(function() {
    if (visible && props.getPopupContainer) {
      setShouldReComputeFixed(true);
    }
  }, []);
  useEffect(function() {
    var _a2;
    if (visible && popupZIndex === void 0) {
      if (drawerWrapperRef.current) {
        var zIndex = +((_a2 = window.getComputedStyle(drawerWrapperRef.current, null)) === null || _a2 === void 0 ? void 0 : _a2.zIndex);
        if (!isNaN(zIndex)) {
          setPopupZIndex(zIndex + 1);
        }
      }
    }
  }, [visible, popupZIndex]);
  useEffect(function() {
    var onKeyDown = function(e) {
      if (escToExit && e && e.key === Esc.key && props.onCancel) {
        props.onCancel(e);
      }
    };
    if (visible) {
      on(document, "keydown", onKeyDown);
    }
    return function() {
      off(document, "keydown", onKeyDown);
    };
  }, [visible, escToExit]);
  var element = React__default.createElement("div", { className: prefixCls2 + "-scroll" }, title2 !== null && React__default.createElement("div", { className: prefixCls2 + "-header", style: headerStyle }, React__default.createElement("div", { className: prefixCls2 + "-header-title" }, title2)), closable && React__default.createElement(IconHover, { onClick: props.onCancel, className: prefixCls2 + "-close-icon" }, React__default.createElement(IconClose$1, null)), React__default.createElement("div", { ref: contentWrapperRef, style: bodyStyle, className: cs$1(prefixCls2 + "-content", (_a = {}, _a[prefixCls2 + "-content-nofooter"] = footer === null, _a[prefixCls2 + "-content-noheader"] = title2 === null, _a)) }, React__default.createElement(ConfigProvider, __assign$I({}, context, { zIndex: popupZIndex || 1050, getPopupContainer: function(node) {
    return typeof propGetChildrenPopupContainer === "function" ? propGetChildrenPopupContainer(node) : contentWrapperRef.current;
  } }), children)), footer !== null && (footer ? React__default.createElement("div", { className: prefixCls2 + "-footer" }, footer) : React__default.createElement("div", { className: prefixCls2 + "-footer" }, React__default.createElement(Button$4, __assign$I({ onClick: props.onCancel }, cancelButtonProps), cancelText || locale.Drawer.cancelText), React__default.createElement(Button$4, __assign$I({ type: "primary", loading: confirmLoading, onClick: props.onOk }, okButtonProps), okText || locale.Drawer.okText))));
  var globalFocusLockConfig = context.focusLock.drawer;
  var globalFocusLock = !!globalFocusLockConfig;
  var globalAutoFocus = isObject$e(globalFocusLockConfig) && globalFocusLockConfig.autoFocus;
  var innerFocusLock = focusLock !== void 0 ? focusLock : globalFocusLock;
  var innerAutoFocus = autoFocus !== void 0 ? autoFocus : globalAutoFocus;
  var dom = innerFocusLock ? React__default.createElement(FocusLock, { as: "span", disabled: !isOpened, autoFocus: innerAutoFocus }, element) : element;
  return React__default.createElement(Portal, { forceRender: !mountOnEnter, visible, getContainer: getPopupContainer }, React__default.createElement("div", { ref: drawerWrapperRef, className: cs$1(prefixCls2 + "-wrapper", (_b = {}, _b[prefixCls2 + "-no-mask"] = !mask2, _b[prefixCls2 + "-wrapper-hide"] = !visible, _b), wrapClassName), style: isFixed ? { position: "fixed" } : { zIndex: "inherit", position: "absolute" } }, mask2 ? React__default.createElement(CSSTransition$1, { in: visible, appear: true, timeout: 300, classNames: "fadeInStandard", mountOnEnter, unmountOnExit }, React__default.createElement("div", { className: prefixCls2 + "-mask", style: maskStyle, onClick: function(e) {
    if (!inExit.current && maskClosable) {
      props.onCancel && props.onCancel(e);
    }
  } })) : null, React__default.createElement(CSSTransition$1, { in: visible, appear: true, timeout: 300, classNames: {
    top: "slideTop",
    bottom: "slideBottom",
    left: "slideLeft",
    right: "slideRight"
  }[placement], mountOnEnter, unmountOnExit, onEnter: function(e) {
    e.parentNode.style.display = "block";
    inExit.current = false;
  }, onEntered: function() {
    setIsOpened(true);
    afterOpen && afterOpen();
  }, onExit: function() {
    setIsOpened(false);
    inExit.current = true;
  }, onExited: function(e) {
    inExit.current = false;
    e.parentNode.style.display = "";
    afterClose && afterClose();
  } }, React__default.createElement("div", { className: cs$1(prefixCls2, className), style: Object.assign(placement === "left" || placement === "right" ? { width } : { height }, (_c = {}, _c[placement] = 0, _c), style) }, React__default.createElement("div", { className: prefixCls2 + "-inner" }, React__default.createElement(ConfigProvider, __assign$I({}, context, { zIndex: popupZIndex || 1050 }), dom))))));
}
var DrawerComponent = React__default.forwardRef(Drawer);
DrawerComponent.displayName = "Drawer";
var Drawer$1 = DrawerComponent;
var assignValue$1 = _assignValue, castPath$3 = _castPath, isIndex$1 = _isIndex, isObject$2 = isObject_1, toKey$2 = _toKey;
function baseSet$2(object, path, value, customizer) {
  if (!isObject$2(object)) {
    return object;
  }
  path = castPath$3(path, object);
  var index2 = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
  while (nested != null && ++index2 < length2) {
    var key = toKey$2(path[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$2(objValue) ? objValue : isIndex$1(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue$1(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var _baseSet = baseSet$2;
var baseSet$1 = _baseSet;
function setWith(object, path, value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseSet$1(object, path, value, customizer);
}
var setWith_1 = setWith;
var objectProto$1 = Object.prototype;
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
function baseHas$1(object, key) {
  return object != null && hasOwnProperty$2.call(object, key);
}
var _baseHas = baseHas$1;
var castPath$2 = _castPath, isArguments$1 = isArguments_1, isArray$3 = isArray_1, isIndex = _isIndex, isLength = isLength_1, toKey$1 = _toKey;
function hasPath$1(object, path, hasFunc) {
  path = castPath$2(path, object);
  var index2 = -1, length2 = path.length, result = false;
  while (++index2 < length2) {
    var key = toKey$1(path[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length2) {
    return result;
  }
  length2 = object == null ? 0 : object.length;
  return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray$3(object) || isArguments$1(object));
}
var _hasPath = hasPath$1;
var baseHas = _baseHas, hasPath = _hasPath;
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}
var has_1 = has;
function arrayEach$1(array, iteratee) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$1;
var copyObject$4 = _copyObject, keys$1 = keys_1;
function baseAssign$1(object, source) {
  return object && copyObject$4(source, keys$1(source), object);
}
var _baseAssign = baseAssign$1;
var copyObject$3 = _copyObject, keysIn$2 = keysIn_1;
function baseAssignIn$1(object, source) {
  return object && copyObject$3(source, keysIn$2(source), object);
}
var _baseAssignIn = baseAssignIn$1;
var copyObject$2 = _copyObject, getSymbols$1 = _getSymbols;
function copySymbols$1(source, object) {
  return copyObject$2(source, getSymbols$1(source), object);
}
var _copySymbols = copySymbols$1;
var arrayPush$1 = _arrayPush, getPrototype = _getPrototype, getSymbols = _getSymbols, stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush$1(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject$1 = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
  return copyObject$1(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$1 = keysIn_1;
function getAllKeysIn$2(object) {
  return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$2;
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function initCloneArray$1(array) {
  var length2 = array.length, result = new array.constructor(length2);
  if (length2 && typeof array[0] == "string" && hasOwnProperty$1.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$2 = _Symbol;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray;
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);
    case dataViewTag$1:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);
    case regexpTag$1:
      return cloneRegExp(object);
    case setTag$2:
      return new Ctor();
    case symbolTag$1:
      return cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag$1;
var getTag$2 = _getTag, isObjectLike$1 = isObjectLike_1;
var mapTag$1 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$1(value) && getTag$2(value) == mapTag$1;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtil.exports;
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$1 = _getTag, isObjectLike = isObjectLike_1;
var setTag$1 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$1;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports;
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack = _Stack, arrayEach = _arrayEach, assignValue = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBuffer.exports, copyArray = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys = _getAllKeys, getAllKeysIn$1 = _getAllKeysIn, getTag = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray$2 = isArray_1, isBuffer = isBuffer$4.exports, isMap = isMap_1, isObject$1 = isObject_1, isSet = isSet_1, keys = keys_1, keysIn = keysIn_1;
var CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$2(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$1(value)) {
    return value;
  }
  var isArr = isArray$2(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$2(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn$1 : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue(result, key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$2;
function last$1(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? array[length2 - 1] : void 0;
}
var last_1 = last$1;
function baseSlice$1(array, start2, end) {
  var index2 = -1, length2 = array.length;
  if (start2 < 0) {
    start2 = -start2 > length2 ? 0 : length2 + start2;
  }
  end = end > length2 ? length2 : end;
  if (end < 0) {
    end += length2;
  }
  length2 = start2 > end ? 0 : end - start2 >>> 0;
  start2 >>>= 0;
  var result = Array(length2);
  while (++index2 < length2) {
    result[index2] = array[index2 + start2];
  }
  return result;
}
var _baseSlice = baseSlice$1;
var baseGet = _baseGet, baseSlice = _baseSlice;
function parent$1(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}
var _parent = parent$1;
var castPath$1 = _castPath, last = last_1, parent = _parent, toKey = _toKey;
function baseUnset$1(object, path) {
  path = castPath$1(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}
var _baseUnset = baseUnset$1;
var isPlainObject = isPlainObject_1;
function customOmitClone$1(value) {
  return isPlainObject(value) ? void 0 : value;
}
var _customOmitClone = customOmitClone$1;
var Symbol$1 = _Symbol, isArguments = isArguments_1, isArray$1 = isArray_1;
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$1(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush = _arrayPush, isFlattenable = _isFlattenable;
function baseFlatten$1(array, depth, predicate, isStrict, result) {
  var index2 = -1, length2 = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length2) {
    var value = array[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$1(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$1;
var baseFlatten = _baseFlatten;
function flatten$1(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? baseFlatten(array, 1) : [];
}
var flatten_1 = flatten$1;
var flatten = flatten_1, overRest = _overRest, setToString = _setToString;
function flatRest$1(func) {
  return setToString(overRest(func, void 0, flatten), func + "");
}
var _flatRest = flatRest$1;
var arrayMap = _arrayMap, baseClone$1 = _baseClone, baseUnset = _baseUnset, castPath = _castPath, copyObject = _copyObject, customOmitClone = _customOmitClone, flatRest = _flatRest, getAllKeysIn = _getAllKeysIn;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone$1(result, CLONE_DEEP_FLAG$1 | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG$1, customOmitClone);
  }
  var length2 = paths.length;
  while (length2--) {
    baseUnset(result, paths[length2]);
  }
  return result;
});
var omit_1 = omit;
var baseClone = _baseClone;
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeepWith(value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
}
var cloneDeepWith_1 = cloneDeepWith;
var baseSet = _baseSet;
function set$1(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}
var set_1 = set$1;
var opt = Object.prototype.toString;
function isArray(obj) {
  return opt.call(obj) === "[object Array]";
}
function isObject(obj) {
  return opt.call(obj) === "[object Object]";
}
function isString(obj) {
  return opt.call(obj) === "[object String]";
}
function isNumber(obj) {
  return opt.call(obj) === "[object Number]" && obj === obj;
}
function isBoolean(obj) {
  return opt.call(obj) === "[object Boolean]";
}
function isFunction(obj) {
  return opt.call(obj) === "[object Function]";
}
function isEmptyObject(obj) {
  return isObject(obj) && Object.keys(obj).length === 0;
}
function isEmptyValue$1(obj) {
  return obj === void 0 || obj === null || obj === "";
}
function isEmptyArray(obj) {
  return isArray(obj) && !obj.length;
}
var isEqual = function(obj, other) {
  if (typeof obj !== "object" || typeof other !== "object") {
    return obj === other;
  }
  if (isFunction(obj) && isFunction(other)) {
    return obj === other || obj.toString() === other.toString();
  }
  if (Object.keys(obj).length !== Object.keys(other).length) {
    return false;
  }
  for (var key in obj) {
    var result = isEqual(obj[key], other[key]);
    if (!result) {
      return false;
    }
  }
  return true;
};
var mergeTemplate = function(defaultValidateMessages, validateMessages2) {
  var result = {};
  Object.keys(defaultValidateMessages).forEach(function(key) {
    var defaultValue = defaultValidateMessages[key];
    var propsValue = validateMessages2 && validateMessages2[key];
    result[key] = isObject(defaultValue) ? Object.assign(Object.assign({}, defaultValue), propsValue) : propsValue || defaultValue;
  });
  return result;
};
var getTemplate = function(validateMessages2, keyPath) {
  var keys2 = keyPath.split(".");
  var result = validateMessages2;
  for (var i2 = 0; i2 < keys2.length; i2++) {
    result = result && result[keys2[i2]];
    if (result === void 0) {
      return result;
    }
  }
  return result;
};
var defaultTypeTemplate = "`#{value}` is not a #{type} type";
var validateMessages = {
  required: "#{field} is required",
  type: {
    ip: defaultTypeTemplate,
    email: defaultTypeTemplate,
    url: defaultTypeTemplate,
    string: defaultTypeTemplate,
    number: defaultTypeTemplate,
    array: defaultTypeTemplate,
    object: defaultTypeTemplate,
    boolean: defaultTypeTemplate
  },
  number: {
    min: "`#{value}` is not greater than `#{min}`",
    max: "`#{value}` is not less than `#{max}`",
    equal: "`#{value}` is not equal to `#{equal}`",
    range: "`#{value}` is not in range `#{min} ~ #{max}`",
    positive: "`#{value}` is not a positive number",
    negative: "`#{value}` is not a negative number"
  },
  array: {
    length: "The `#{value}` length is not equal to #{length}",
    minLength: "The `#{value}` length is not greater than #{minLength}",
    maxLength: "The `#{value}` length is not less than #{maxLength}",
    includes: "#{value} is not includes #{includes}",
    deepEqual: "#{value} is not deep equal with #{deepEqual}",
    empty: "`#{value}` is not an empty array"
  },
  string: {
    maxLength: "The `#{value}` length is not greater than #{maxLength}",
    minLength: "The `#{value}` length is not less than #{minLength}",
    length: "The `#{value}` length is not equal to #{length}",
    match: "`#{value}` is not match pattern #{pattern}",
    uppercase: "Expect `#{value}` to be uppercased",
    lowercase: "Expect `#{value}` to be lowercased"
  },
  object: {
    deepEqual: "`#{value}` is not deep equal with #{deepEqual}",
    hasKeys: "`#{value}` is not has keys #{keys}",
    empty: "`#{value}` is not an empty object"
  },
  boolean: {
    true: "Expect true but got `#{value}`",
    false: "Expect false but got `#{value}`"
  }
};
var Base$1 = function Base2(obj, options2) {
  var this$1$1 = this;
  this.getValidateMsg = function(keyPath, info2) {
    if (info2 === void 0)
      info2 = {};
    var data = Object.assign(Object.assign({}, info2), { value: this$1$1.obj, field: this$1$1.field, type: this$1$1.type });
    var template = getTemplate(this$1$1.validateMessages, keyPath);
    if (isFunction(template)) {
      return template(data);
    }
    if (isString(template)) {
      return template.replace(/\#\{.+?\}/g, function(variable) {
        var key = variable.slice(2, -1);
        if (key in data) {
          if (isObject(data[key]) || isArray(data[key])) {
            return JSON.stringify(data[key]);
          }
          return String(data[key]);
        }
        return variable;
      });
    }
    return template;
  };
  if (isObject(options2) && isString(obj) && options2.trim) {
    this.obj = obj.trim();
  } else if (isObject(options2) && options2.ignoreEmptyString && obj === "") {
    this.obj = void 0;
  } else {
    this.obj = obj;
  }
  this.message = options2.message;
  this.type = options2.type;
  this.error = null;
  this.field = options2.field || options2.type;
  this.validateMessages = mergeTemplate(validateMessages, options2.validateMessages);
};
var prototypeAccessors = { not: { configurable: true }, isRequired: { configurable: true }, end: { configurable: true } };
prototypeAccessors.not.get = function() {
  this._not = !this._not;
  return this;
};
prototypeAccessors.isRequired.get = function() {
  if (isEmptyValue$1(this.obj) || isEmptyArray(this.obj)) {
    this.error = {
      value: this.obj,
      type: this.type,
      requiredError: true,
      message: this.message || "" + (this._not ? "[NOT MODE]:" : "") + this.getValidateMsg("required")
    };
  }
  return this;
};
prototypeAccessors.end.get = function() {
  return this.error;
};
Base$1.prototype.addError = function addError(message) {
  if (!this.error && message) {
    this.error = {
      value: this.obj,
      type: this.type,
      message: this.message || (isObject(message) ? message : "" + (this._not ? "[NOT MODE]:" : "") + message)
    };
  }
};
Base$1.prototype.validate = function validate(expression, errorMessage) {
  var _expression = this._not ? expression : !expression;
  if (_expression) {
    this.addError(errorMessage);
  }
  return this;
};
Base$1.prototype.collect = function collect(callback) {
  callback && callback(this.error);
};
Object.defineProperties(Base$1.prototype, prototypeAccessors);
var StringValidator = /* @__PURE__ */ function(Base3) {
  function StringValidator2(obj, options2) {
    Base3.call(this, obj, Object.assign(Object.assign({}, options2), { type: "string" }));
    this.validate(options2 && options2.strict ? isString(this.obj) : true, this.getValidateMsg("type.string"));
  }
  if (Base3)
    StringValidator2.__proto__ = Base3;
  StringValidator2.prototype = Object.create(Base3 && Base3.prototype);
  StringValidator2.prototype.constructor = StringValidator2;
  var prototypeAccessors2 = { uppercase: { configurable: true }, lowercase: { configurable: true } };
  StringValidator2.prototype.maxLength = function maxLength(length2) {
    return this.obj ? this.validate(this.obj.length <= length2, this.getValidateMsg("string.maxLength", { maxLength: length2 })) : this;
  };
  StringValidator2.prototype.minLength = function minLength(length2) {
    return this.obj ? this.validate(this.obj.length >= length2, this.getValidateMsg("string.minLength", { minLength: length2 })) : this;
  };
  StringValidator2.prototype.length = function length2(length$1) {
    return this.obj ? this.validate(this.obj.length === length$1, this.getValidateMsg("string.length", { length: length$1 })) : this;
  };
  StringValidator2.prototype.match = function match(pattern) {
    var isRegex = pattern instanceof RegExp;
    if (isRegex) {
      pattern.lastIndex = 0;
    }
    return this.validate(this.obj === void 0 || isRegex && pattern.test(this.obj), this.getValidateMsg("string.match", { pattern }));
  };
  prototypeAccessors2.uppercase.get = function() {
    return this.obj ? this.validate(this.obj.toUpperCase() === this.obj, this.getValidateMsg("string.uppercase")) : this;
  };
  prototypeAccessors2.lowercase.get = function() {
    return this.obj ? this.validate(this.obj.toLowerCase() === this.obj, this.getValidateMsg("string.lowercase")) : this;
  };
  Object.defineProperties(StringValidator2.prototype, prototypeAccessors2);
  return StringValidator2;
}(Base$1);
var NumberValidator = /* @__PURE__ */ function(Base3) {
  function NumberValidator2(obj, options2) {
    Base3.call(this, obj, Object.assign(Object.assign({}, options2), { type: "number" }));
    this.validate(options2 && options2.strict ? isNumber(this.obj) : true, this.getValidateMsg("type.number"));
  }
  if (Base3)
    NumberValidator2.__proto__ = Base3;
  NumberValidator2.prototype = Object.create(Base3 && Base3.prototype);
  NumberValidator2.prototype.constructor = NumberValidator2;
  var prototypeAccessors2 = { positive: { configurable: true }, negative: { configurable: true } };
  NumberValidator2.prototype.min = function min(num) {
    return !isEmptyValue$1(this.obj) ? this.validate(this.obj >= num, this.getValidateMsg("number.min", { min: num })) : this;
  };
  NumberValidator2.prototype.max = function max(num) {
    return !isEmptyValue$1(this.obj) ? this.validate(this.obj <= num, this.getValidateMsg("number.max", { max: num })) : this;
  };
  NumberValidator2.prototype.equal = function equal(num) {
    return !isEmptyValue$1(this.obj) ? this.validate(this.obj === num, this.getValidateMsg("number.equal", { equal: num })) : this;
  };
  NumberValidator2.prototype.range = function range2(min, max) {
    return !isEmptyValue$1(this.obj) ? this.validate(this.obj >= min && this.obj <= max, this.getValidateMsg("number.range", { min, max })) : this;
  };
  prototypeAccessors2.positive.get = function() {
    return !isEmptyValue$1(this.obj) ? this.validate(this.obj > 0, this.getValidateMsg("number.positive")) : this;
  };
  prototypeAccessors2.negative.get = function() {
    return !isEmptyValue$1(this.obj) ? this.validate(this.obj < 0, this.getValidateMsg("number.negative")) : this;
  };
  Object.defineProperties(NumberValidator2.prototype, prototypeAccessors2);
  return NumberValidator2;
}(Base$1);
var ArrayValidator = /* @__PURE__ */ function(Base3) {
  function ArrayValidator2(obj, options2) {
    Base3.call(this, obj, Object.assign(Object.assign({}, options2), { type: "array" }));
    this.validate(options2 && options2.strict ? isArray(this.obj) : true, this.getValidateMsg("type.array", { value: this.obj, type: this.type }));
  }
  if (Base3)
    ArrayValidator2.__proto__ = Base3;
  ArrayValidator2.prototype = Object.create(Base3 && Base3.prototype);
  ArrayValidator2.prototype.constructor = ArrayValidator2;
  var prototypeAccessors2 = { empty: { configurable: true } };
  ArrayValidator2.prototype.length = function length2(num) {
    return this.obj ? this.validate(this.obj.length === num, this.getValidateMsg("array.length", { value: this.obj, length: num })) : this;
  };
  ArrayValidator2.prototype.minLength = function minLength(num) {
    return this.obj ? this.validate(this.obj.length >= num, this.getValidateMsg("array.minLength", { value: this.obj, minLength: num })) : this;
  };
  ArrayValidator2.prototype.maxLength = function maxLength(num) {
    return this.obj ? this.validate(this.obj.length <= num, this.getValidateMsg("array.maxLength", { value: this.obj, maxLength: num })) : this;
  };
  ArrayValidator2.prototype.includes = function includes(arrays) {
    var this$1$1 = this;
    return this.obj ? this.validate(arrays.every(function(el) {
      return this$1$1.obj.indexOf(el) !== -1;
    }), this.getValidateMsg("array.includes", {
      value: this.obj,
      includes: arrays
    })) : this;
  };
  ArrayValidator2.prototype.deepEqual = function deepEqual(other) {
    return this.obj ? this.validate(isEqual(this.obj, other), this.getValidateMsg("array.deepEqual", { value: this.obj, deepEqual: other })) : this;
  };
  prototypeAccessors2.empty.get = function() {
    return this.validate(isEmptyArray(this.obj), this.getValidateMsg("array.empty", { value: this.obj }));
  };
  Object.defineProperties(ArrayValidator2.prototype, prototypeAccessors2);
  return ArrayValidator2;
}(Base$1);
var ObjectValidator = /* @__PURE__ */ function(Base3) {
  function ObjectValidator2(obj, options2) {
    Base3.call(this, obj, Object.assign(Object.assign({}, options2), { type: "object" }));
    this.validate(options2 && options2.strict ? isObject(this.obj) : true, this.getValidateMsg("type.object"));
  }
  if (Base3)
    ObjectValidator2.__proto__ = Base3;
  ObjectValidator2.prototype = Object.create(Base3 && Base3.prototype);
  ObjectValidator2.prototype.constructor = ObjectValidator2;
  var prototypeAccessors2 = { empty: { configurable: true } };
  ObjectValidator2.prototype.deepEqual = function deepEqual(other) {
    return this.obj ? this.validate(isEqual(this.obj, other), this.getValidateMsg("object.deepEqual", { deepEqual: other })) : this;
  };
  ObjectValidator2.prototype.hasKeys = function hasKeys(keys2) {
    var this$1$1 = this;
    return this.obj ? this.validate(keys2.every(function(el) {
      return this$1$1.obj[el];
    }), this.getValidateMsg("object.hasKeys", { keys: keys2 })) : this;
  };
  prototypeAccessors2.empty.get = function() {
    return this.validate(isEmptyObject(this.obj), this.getValidateMsg("object.empty"));
  };
  Object.defineProperties(ObjectValidator2.prototype, prototypeAccessors2);
  return ObjectValidator2;
}(Base$1);
var BooleanValidator = /* @__PURE__ */ function(Base3) {
  function BooleanValidator2(obj, options2) {
    Base3.call(this, obj, Object.assign(Object.assign({}, options2), { type: "boolean" }));
    this.validate(options2 && options2.strict ? isBoolean(this.obj) : true, this.getValidateMsg("type.boolean"));
  }
  if (Base3)
    BooleanValidator2.__proto__ = Base3;
  BooleanValidator2.prototype = Object.create(Base3 && Base3.prototype);
  BooleanValidator2.prototype.constructor = BooleanValidator2;
  var prototypeAccessors2 = { true: { configurable: true }, false: { configurable: true } };
  prototypeAccessors2.true.get = function() {
    return this.validate(this.obj === true, this.getValidateMsg("boolean.true"));
  };
  prototypeAccessors2.false.get = function() {
    return this.validate(this.obj === false, this.getValidateMsg("boolean.false"));
  };
  Object.defineProperties(BooleanValidator2.prototype, prototypeAccessors2);
  return BooleanValidator2;
}(Base$1);
var regexEmail = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var regexUrl = new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", "i");
var regexIp = /^(2(5[0-5]{1}|[0-4]\d{1})|[0-1]?\d{1,2})(\.(2(5[0-5]{1}|[0-4]\d{1})|[0-1]?\d{1,2})){3}$/;
var TypeValidator = /* @__PURE__ */ function(Base3) {
  function TypeValidator2(obj, options2) {
    Base3.call(this, obj, Object.assign(Object.assign({}, options2), { type: "type" }));
  }
  if (Base3)
    TypeValidator2.__proto__ = Base3;
  TypeValidator2.prototype = Object.create(Base3 && Base3.prototype);
  TypeValidator2.prototype.constructor = TypeValidator2;
  var prototypeAccessors2 = { email: { configurable: true }, url: { configurable: true }, ip: { configurable: true } };
  prototypeAccessors2.email.get = function() {
    this.type = "email";
    return this.validate(this.obj === void 0 || regexEmail.test(this.obj), this.getValidateMsg("type.email"));
  };
  prototypeAccessors2.url.get = function() {
    this.type = "url";
    return this.validate(this.obj === void 0 || regexUrl.test(this.obj), this.getValidateMsg("type.url"));
  };
  prototypeAccessors2.ip.get = function() {
    this.type = "ip";
    return this.validate(this.obj === void 0 || regexIp.test(this.obj), this.getValidateMsg("type.ip"));
  };
  Object.defineProperties(TypeValidator2.prototype, prototypeAccessors2);
  return TypeValidator2;
}(Base$1);
var CustomValidator = /* @__PURE__ */ function(Base3) {
  function CustomValidator2(obj, options2) {
    Base3.call(this, obj, Object.assign(Object.assign({}, options2), { type: "custom" }));
  }
  if (Base3)
    CustomValidator2.__proto__ = Base3;
  CustomValidator2.prototype = Object.create(Base3 && Base3.prototype);
  CustomValidator2.prototype.constructor = CustomValidator2;
  var prototypeAccessors2 = { validate: { configurable: true } };
  prototypeAccessors2.validate.get = function() {
    var _this = this;
    return function(validator, callback) {
      var ret;
      if (validator) {
        ret = validator(_this.obj, _this.addError.bind(_this));
        if (ret && ret.then) {
          if (callback) {
            ret.then(function() {
              callback && callback(_this.error);
            }, function(e) {
              console.error(e);
            });
          }
          return [ret, _this];
        } else {
          callback && callback(_this.error);
          return _this.error;
        }
      }
    };
  };
  Object.defineProperties(CustomValidator2.prototype, prototypeAccessors2);
  return CustomValidator2;
}(Base$1);
var Validate = function Validate2(obj, options2) {
  this.string = new StringValidator(obj, options2);
  this.number = new NumberValidator(obj, options2);
  this.array = new ArrayValidator(obj, options2);
  this.object = new ObjectValidator(obj, options2);
  this.boolean = new BooleanValidator(obj, options2);
  this.type = new TypeValidator(obj, options2);
  this.custom = new CustomValidator(obj, options2);
};
var Schema = function Schema2(schema, options2) {
  if (options2 === void 0)
    options2 = {};
  this.schema = schema;
  this.options = options2;
};
Schema.prototype.validate = function validate2(values2, callback) {
  var this$1$1 = this;
  if (!isObject(values2)) {
    return;
  }
  var promises = [];
  var errors = null;
  function setError(key, error2) {
    if (!errors) {
      errors = {};
    }
    if (!errors[key] || error2.requiredError) {
      errors[key] = error2;
    }
  }
  if (this.schema) {
    Object.keys(this.schema).forEach(function(key) {
      if (isArray(this$1$1.schema[key])) {
        var loop = function(i3) {
          var rule = this$1$1.schema[key][i3];
          var type = rule.type;
          var message = rule.message;
          if (!type && !rule.validator) {
            throw "You must specify a type to field " + key + "!";
          }
          var validator = new Validate(values2[key], Object.assign(Object.assign({}, this$1$1.options), { message, field: key }));
          var bv = validator.type[type] || null;
          if (!bv) {
            if (rule.validator) {
              bv = validator.custom.validate(rule.validator);
              if (Object.prototype.toString.call(bv) === "[object Array]" && bv[0].then) {
                promises.push({
                  function: bv[0],
                  _this: bv[1],
                  key
                });
              } else if (bv) {
                setError(key, bv);
              }
              return;
            } else {
              bv = validator[type];
            }
          }
          Object.keys(rule).forEach(function(r) {
            if (rule.required) {
              bv = bv.isRequired;
            }
            if (r !== "message" && bv[r] && rule[r] && typeof bv[r] === "object") {
              bv = bv[r];
            }
            if (bv[r] && rule[r] !== void 0 && typeof bv[r] === "function") {
              bv = bv[r](rule[r]);
            }
          });
          bv.collect(function(error2) {
            if (error2) {
              setError(key, error2);
            }
          });
          if (errors) {
            return "break";
          }
        };
        for (var i2 = 0; i2 < this$1$1.schema[key].length; i2++) {
          var returned = loop(i2);
          if (returned === "break")
            break;
        }
      }
    });
  }
  if (promises.length > 0) {
    Promise.all(promises.map(function(a) {
      return a.function;
    })).then(function() {
      promises.forEach(function(promise) {
        if (promise._this.error) {
          setError(promise.key, promise._this.error);
        }
      });
      callback && callback(errors);
    });
  } else {
    callback && callback(errors);
  }
};
var __assign$H = globalThis && globalThis.__assign || function() {
  __assign$H = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$H.apply(this, arguments);
};
var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$4 = globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
          return t2;
        if (y = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __read$B = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$e = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function cloneDeep(value) {
  return cloneDeepWith_1(value, function(val) {
    if (!isObject$e(val) && !isArray$c(val)) {
      return val;
    }
  });
}
var formatValidateMsg = function(validateMessages2, info2) {
  return cloneDeepWith_1(validateMessages2, function(val) {
    if (isFunction$5(val)) {
      return function(data) {
        return val(data, info2);
      };
    }
  });
};
function set(target2, field, value) {
  set_1(target2, field, cloneDeep(value));
  return target2;
}
function iterativelyGetKeys(obj, prefix) {
  if (prefix === void 0) {
    prefix = "";
  }
  if (!obj) {
    return [];
  }
  return Object.keys(obj).reduce(function(res, el) {
    if (typeof obj[el] === "object" && obj[el] !== null) {
      return __spreadArray$e(__spreadArray$e([], __read$B(res), false), __read$B(iterativelyGetKeys(obj[el], prefix + el + ".")), false);
    }
    return __spreadArray$e(__spreadArray$e([], __read$B(res), false), [prefix + el], false);
  }, []);
}
function isSyntheticEvent(e) {
  var _a;
  return ((_a = e === null || e === void 0 ? void 0 : e.constructor) === null || _a === void 0 ? void 0 : _a.name) === "SyntheticEvent" || (e === null || e === void 0 ? void 0 : e.nativeEvent) instanceof Event;
}
function schemaValidate(field, value, _rules, validateMessages2) {
  return __awaiter$4(this, void 0, void 0, function() {
    var rules, current;
    var _this = this;
    return __generator$4(this, function(_a) {
      rules = __spreadArray$e([], __read$B(_rules), false);
      current = 0;
      return [2, new Promise(function(resolve) {
        return __awaiter$4(_this, void 0, void 0, function() {
          var warning, validate3;
          var _this2 = this;
          return __generator$4(this, function(_a2) {
            warning = [];
            validate3 = function(rule) {
              return __awaiter$4(_this2, void 0, void 0, function() {
                var next, _rule, schema;
                var _a3, _b;
                return __generator$4(this, function(_c) {
                  next = function() {
                    if (current < rules.length - 1) {
                      current++;
                      return validate3(rules[current]);
                    }
                    return resolve({ error: null, warning });
                  };
                  if (!rule) {
                    return [2, next()];
                  }
                  _rule = __assign$H({}, rule);
                  if (!_rule.type && !_rule.validator) {
                    _rule.type = "string";
                  }
                  schema = new Schema((_a3 = {}, _a3[field] = [_rule], _a3), {
                    ignoreEmptyString: true,
                    validateMessages: validateMessages2
                  });
                  schema.validate((_b = {}, _b[field] = value, _b), function(error2) {
                    if (error2) {
                      if (rule.validateLevel === "warning") {
                        warning.push(error2[field].message);
                      } else {
                        return resolve({
                          error: error2,
                          warning
                        });
                      }
                    }
                    return next();
                  });
                  return [2];
                });
              });
            };
            validate3(rules[current]);
            return [2];
          });
        });
      })];
    });
  });
}
var ID_SUFFIX = "_input";
var __extends$2 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ValidateError = function(_super) {
  __extends$2(ValidateError2, _super);
  function ValidateError2(errors) {
    var _this = _super.call(this, "form validate error, get errors by error.errors") || this;
    _this.errors = {};
    _this.errors = errors;
    return _this;
  }
  return ValidateError2;
}(Error);
function promisify(fn) {
  return Object.defineProperty(function() {
    var _this = this;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (typeof args[args.length - 1] === "function")
      fn.apply(this, args);
    else {
      return new Promise(function(resolve, reject) {
        args[args.length] = function(err, res) {
          if (err)
            return reject(new ValidateError(err));
          resolve(res);
        };
        args.length++;
        fn.apply(_this, args);
      });
    }
  }, "name", { value: fn.name });
}
var __assign$G = globalThis && globalThis.__assign || function() {
  __assign$G = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$G.apply(this, arguments);
};
var __read$A = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$d = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Store = function() {
  function Store2() {
    var _this = this;
    this.registerFields = [];
    this.registerWatchers = [];
    this.touchedFields = {};
    this.store = {};
    this.initialValues = {};
    this.callbacks = {};
    this.innerSetCallbacks = function(values2) {
      _this.callbacks = values2;
    };
    this.registerWatcher = function(item2) {
      _this.registerWatchers.push(item2);
      return function() {
        _this.registerWatchers = _this.registerWatchers.filter(function(x) {
          return x !== item2;
        });
      };
    };
    this.registerField = function(item2) {
      _this.registerFields.push(item2);
      _this.notifyWatchers();
      return function() {
        _this.registerFields = _this.registerFields.filter(function(x) {
          return x !== item2;
        });
        _this.notifyWatchers();
      };
    };
    this.getRegisteredFields = function(hasField) {
      if (hasField) {
        return _this.registerFields.filter(function(control) {
          var _a;
          return control.hasFieldProps() && !((_a = control.props) === null || _a === void 0 ? void 0 : _a.isFormList);
        });
      }
      return _this.registerFields;
    };
    this.getRegisteredField = function(field) {
      return _this.registerFields.filter(function(x) {
        return x.props.field === field;
      })[0];
    };
    this.notify = function(type, info2) {
      if (type === "setFieldValue" || type === "innerSetValue" && !info2.ignore) {
        _this._pushTouchField(info2.changeValues ? iterativelyGetKeys(info2.changeValues) : _this._getIterativelyKeysByField(info2.field));
      }
      _this.registerFields.forEach(function(item2) {
        item2.onStoreChange && item2.onStoreChange(type, __assign$G(__assign$G({}, info2), { current: _this.store }));
      });
    };
    this.innerSetInitialValues = function(values2) {
      if (!values2)
        return;
      _this.initialValues = cloneDeep(values2);
      Object.keys(values2).forEach(function(field) {
        set(_this.store, field, values2[field]);
      });
    };
    this.innerSetInitialValue = function(field, value) {
      if (!field)
        return;
      _this.initialValues[field] = value;
      if (!_this._inTouchFields(field)) {
        set(_this.store, field, get_1(_this.initialValues, field));
      }
    };
    this.innerSetFieldValue = function(field, value, options2) {
      var _a, _b, _c;
      if (!field)
        return;
      var prev = cloneDeep(_this.store);
      set(_this.store, field, value);
      _this.triggerValuesChange((_a = {}, _a[field] = value, _a));
      _this.triggerTouchChange((_b = {}, _b[field] = value, _b));
      _this.notify("innerSetValue", __assign$G(__assign$G({ prev, field }, options2), { changeValues: (_c = {}, _c[field] = value, _c) }));
    };
    this.innerGetStore = function() {
      return _this.store;
    };
    this.getTouchedFields = function() {
      return _this.getRegisteredFields(true).filter(function(item2) {
        return item2.isTouched();
      }).map(function(x) {
        return x.props.field;
      });
    };
    this.setFieldValue = function(field, value) {
      var _a;
      if (!field)
        return;
      _this.setFields((_a = {}, _a[field] = { value }, _a));
    };
    this.setFieldsValue = function(values2) {
      if (isObject$e(values2)) {
        var fields = Object.keys(values2);
        var obj_1 = {};
        fields.forEach(function(field) {
          obj_1[field] = {
            value: values2[field]
          };
        });
        _this.setFields(obj_1);
      }
    };
    this.setFields = function(obj) {
      var fields = Object.keys(obj);
      var changeValues = {};
      fields.forEach(function(field) {
        var _a;
        var item2 = obj[field];
        var prev = cloneDeep(_this.store);
        if (item2) {
          var info2 = {};
          if ("error" in item2) {
            info2.errors = item2.error;
          }
          if ("warning" in item2) {
            info2.warnings = item2.warning;
          }
          if ("touched" in item2) {
            info2.touched = item2.touched;
          }
          if ("value" in item2) {
            set(_this.store, field, item2.value);
            changeValues[field] = item2.value;
          }
          _this.notify("setFieldValue", {
            data: info2,
            prev,
            field,
            changeValues: (_a = {}, _a[field] = item2.value, _a)
          });
        }
      });
      _this.triggerValuesChange(changeValues);
    };
    this.getFieldValue = function(field) {
      return cloneDeep(get_1(_this.store, field));
    };
    this.getFieldError = function(field) {
      var item2 = _this.getRegisteredField(field);
      return item2 ? item2.getErrors() : null;
    };
    this.getFieldsError = function(fields) {
      var errors = {};
      if (isArray$c(fields)) {
        fields.map(function(field) {
          var error2 = _this.getFieldError(field);
          if (error2) {
            errors[field] = error2;
          }
        });
      } else {
        _this.getRegisteredFields(true).forEach(function(item2) {
          if (item2.getErrors()) {
            errors[item2.props.field] = item2.getErrors();
          }
        });
      }
      return errors;
    };
    this.getFields = function() {
      return cloneDeep(_this.store);
    };
    this.getFieldsValue = function(fields) {
      var values2 = {};
      if (isArray$c(fields)) {
        fields.forEach(function(key) {
          set(values2, key, _this.getFieldValue(key));
        });
        return values2;
      }
      _this.getRegisteredFields(true).forEach(function(_a) {
        var field = _a.props.field;
        var value = get_1(_this.store, field);
        set(values2, field, value);
      });
      return values2;
    };
    this.resetFields = function(fieldKeys) {
      var prev = cloneDeep(_this.store);
      var fields = isString$1(fieldKeys) ? [fieldKeys] : fieldKeys;
      if (fields && isArray$c(fields)) {
        var changeValues_1 = {};
        fields.forEach(function(field) {
          set(_this.store, field, _this.initialValues[field]);
          changeValues_1[field] = get_1(_this.store, field);
        });
        _this.triggerValuesChange(changeValues_1);
        _this.notify("reset", { prev, field: fields });
        _this._popTouchField(fields);
      } else {
        var newValues_1 = {};
        var changeValues_2 = cloneDeep(_this.store);
        Object.keys(_this.initialValues).forEach(function(field) {
          set(newValues_1, field, _this.initialValues[field]);
        });
        _this.store = newValues_1;
        _this.getRegisteredFields(true).forEach(function(item2) {
          var key = item2.props.field;
          set(changeValues_2, key, get_1(_this.store, key));
        });
        _this.triggerValuesChange(changeValues_2);
        _this._popTouchField();
        _this.notify("reset", { prev, field: Object.keys(changeValues_2) });
      }
    };
    this.validate = promisify(function(fieldsOrCallback, cb) {
      var callback = function() {
      };
      var controlItems = _this.getRegisteredFields(true);
      if (isArray$c(fieldsOrCallback) && fieldsOrCallback.length > 0) {
        controlItems = controlItems.filter(function(x) {
          return fieldsOrCallback.indexOf(x.props.field) > -1;
        });
        callback = cb || callback;
      } else if (typeof fieldsOrCallback === "function") {
        callback = fieldsOrCallback;
      }
      var promises = controlItems.map(function(x) {
        return x.validateField();
      });
      Promise.all(promises).then(function(result) {
        var errors = {};
        var values2 = {};
        result.map(function(x) {
          if (x.error) {
            errors = __assign$G(__assign$G({}, errors), x.error);
          }
          set(values2, x.field, x.value);
        });
        if (Object.keys(errors).length) {
          var onValidateFail = _this.callbacks.onValidateFail;
          onValidateFail && onValidateFail(errors);
          callback && callback(errors, cloneDeep(values2));
        } else {
          callback && callback(null, cloneDeep(values2));
        }
      });
    });
    this.submit = function() {
      _this.validate(function(errors, values2) {
        if (!errors) {
          var onSubmit = _this.callbacks.onSubmit;
          onSubmit && onSubmit(values2);
        } else {
          var onSubmitFailed = _this.callbacks.onSubmitFailed;
          onSubmitFailed && onSubmitFailed(errors);
        }
      });
    };
    this.clearFields = function(fieldKeys) {
      var prev = cloneDeep(_this.store);
      var fields = isString$1(fieldKeys) ? [fieldKeys] : fieldKeys;
      if (fields && isArray$c(fields)) {
        var changeValues_3 = {};
        fields.forEach(function(field) {
          set(_this.store, field, void 0);
          changeValues_3[field] = get_1(_this.store, field);
        });
        _this.triggerValuesChange(changeValues_3);
        _this.notify("setFieldValue", {
          prev,
          field: fields,
          data: {
            errors: null,
            warnings: null
          }
        });
      } else {
        var changeValues_4 = {};
        _this.store = {};
        _this.getRegisteredFields(true).forEach(function(item2) {
          var key = item2.props.field;
          set(changeValues_4, key, void 0);
        });
        _this.triggerValuesChange(changeValues_4);
        _this.notify("setFieldValue", {
          prev,
          field: Object.keys(changeValues_4),
          data: {
            errors: null,
            warnings: null
          }
        });
      }
    };
  }
  Store2.prototype.notifyWatchers = function() {
    this.registerWatchers.forEach(function(item2) {
      item2();
    });
  };
  Store2.prototype.triggerValuesChange = function(value) {
    if (value && Object.keys(value).length) {
      var onValuesChange = this.callbacks.onValuesChange;
      onValuesChange && onValuesChange(value, this.getFields());
    }
    this.notifyWatchers();
  };
  Store2.prototype.triggerTouchChange = function(value) {
    if (value && Object.keys(value).length) {
      var onChange = this.callbacks.onChange;
      onChange && onChange(value, this.getFields());
    }
  };
  Store2.prototype._getIterativelyKeysByField = function(field) {
    if (!field) {
      return [];
    }
    var fields = [].concat(field);
    var keys2 = fields.map(function(item2) {
      return iterativelyGetKeys(set({}, item2, void 0));
    }).reduce(function(total, next) {
      return total.concat(next);
    }, []);
    return __spreadArray$d([field], __read$A(keys2), false);
  };
  Store2.prototype._inTouchFields = function(field) {
    var _this = this;
    var keys2 = this._getIterativelyKeysByField(field);
    return keys2.some(function(item2) {
      return has_1(_this.touchedFields, item2);
    });
  };
  Store2.prototype._popTouchField = function(field) {
    if (field === void 0) {
      this.touchedFields = {};
    }
    var keys2 = this._getIterativelyKeysByField(field);
    this.touchedFields = omit_1(this.touchedFields, keys2);
  };
  Store2.prototype._pushTouchField = function(field) {
    var _this = this;
    [].concat(field).forEach(function(key) {
      setWith_1(_this.touchedFields, key, void 0, Object);
    });
  };
  return Store2;
}();
var Store$1 = Store;
function getFormInstance() {
  var store = new Store$1();
  return {
    getFieldsValue: store.getFieldsValue,
    getFieldValue: store.getFieldValue,
    getFieldError: store.getFieldError,
    getFieldsError: store.getFieldsError,
    getTouchedFields: store.getTouchedFields,
    getFields: store.getFields,
    setFieldValue: store.setFieldValue,
    setFieldsValue: store.setFieldsValue,
    setFields: store.setFields,
    resetFields: store.resetFields,
    clearFields: store.clearFields,
    submit: store.submit,
    validate: store.validate,
    scrollToField: function() {
    },
    getInnerMethods: function(inner) {
      var methods2 = {};
      if (inner) {
        [
          "registerField",
          "registerWatcher",
          "innerSetInitialValues",
          "innerSetInitialValue",
          "innerSetCallbacks",
          "innerSetFieldValue",
          "innerGetStore"
        ].map(function(key) {
          methods2[key] = store[key];
        });
      }
      return methods2;
    }
  };
}
function useForm(form) {
  var formRef = useRef(form);
  if (!formRef.current) {
    if (form) {
      formRef.current = form;
    } else {
      formRef.current = getFormInstance();
    }
  }
  return [formRef.current];
}
var FormContext = createContext({
  layout: "horizontal",
  labelCol: { span: 5, offset: 0 },
  labelAlign: "right",
  wrapperCol: { span: 19, offset: 0 },
  requiredSymbol: true,
  getFormElementId: function() {
    return "arco-";
  },
  store: {
    getFieldsValue: NOOP,
    getFieldValue: NOOP,
    getFieldError: NOOP,
    getFieldsError: NOOP,
    getTouchedFields: NOOP,
    getFields: NOOP,
    setFieldValue: NOOP,
    setFieldsValue: NOOP,
    setFields: NOOP,
    resetFields: NOOP,
    submit: NOOP,
    validate: NOOP,
    scrollToField: NOOP,
    getInnerMethods: function() {
      return {
        registerField: NOOP
      };
    }
  }
});
var FormItemContext = createContext({});
var FormProviderContext = createContext({});
var FormListContext = createContext({});
var __assign$F = globalThis && globalThis.__assign || function() {
  __assign$F = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$F.apply(this, arguments);
};
var __rest$g = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$z = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function getFormElementId(prefix, field) {
  var id = field.replace(/[\[\.]/g, "_").replace(/\]/g, "");
  return prefix ? prefix + "-" + id : "" + id;
}
var defaultProps$d = {
  layout: "horizontal",
  labelCol: { span: 5, offset: 0 },
  labelAlign: "right",
  wrapperCol: { span: 19, offset: 0 },
  requiredSymbol: true,
  wrapper: "form",
  validateTrigger: "onChange"
};
var Form$1 = function(baseProps, ref) {
  var _a, _b;
  var ctx = useContext(ConfigContext);
  var formProviderCtx = useContext(FormProviderContext);
  var wrapperRef = useRef(null);
  var _c = __read$z(useForm(baseProps.form), 1), formInstance = _c[0];
  var isMount = useRef();
  var props = useMergeProps(baseProps, defaultProps$d, (_a = ctx.componentConfig) === null || _a === void 0 ? void 0 : _a.Form);
  var layout = props.layout, labelCol = props.labelCol, wrapperCol = props.wrapperCol, Wrapper2 = props.wrapper, id = props.id, requiredSymbol = props.requiredSymbol, labelAlign = props.labelAlign, disabled = props.disabled, colon = props.colon, className = props.className, validateTrigger = props.validateTrigger, formPrefixCls = props.prefixCls, validateMessages2 = props.validateMessages, rest = __rest$g(props, ["layout", "labelCol", "wrapperCol", "wrapper", "id", "requiredSymbol", "labelAlign", "disabled", "colon", "className", "validateTrigger", "prefixCls", "validateMessages"]);
  var prefixCls2 = formPrefixCls || ctx.getPrefixCls("form");
  var size = "size" in props ? props.size : ctx.size;
  var innerMethods = formInstance.getInnerMethods(true);
  if (!isMount.current) {
    innerMethods.innerSetInitialValues(props.initialValues);
  }
  useEffect(function() {
    isMount.current = true;
  }, []);
  useEffect(function() {
    var unregister;
    if (formProviderCtx.register) {
      unregister = formProviderCtx.register(props.id, formInstance);
    }
    return unregister;
  }, [props.id, formInstance]);
  useImperativeHandle(ref, function() {
    return formInstance;
  });
  formInstance.scrollToField = function(field, options2) {
    var node = wrapperRef.current;
    var id2 = props.id;
    if (!node) {
      return;
    }
    var fieldNode = node.querySelector("#" + getFormElementId(id2, field));
    if (!fieldNode) {
      fieldNode = node.querySelector("#" + getFormElementId(id2, field) + ID_SUFFIX);
    }
    fieldNode && scrollIntoView(fieldNode, __assign$F({ behavior: "smooth", block: "nearest", scrollMode: "if-needed" }, options2));
  };
  innerMethods.innerSetCallbacks({
    onValuesChange: function(value, values2) {
      props.onValuesChange && props.onValuesChange(value, values2);
      formProviderCtx.onFormValuesChange && formProviderCtx.onFormValuesChange(props.id, value);
    },
    onChange: props.onChange,
    onValidateFail: function(errors) {
      if (props.scrollToFirstError) {
        var options2 = isObject$e(props.scrollToFirstError) ? props.scrollToFirstError : {};
        formInstance.scrollToField(Object.keys(errors)[0], options2);
      }
    },
    onSubmitFailed: props.onSubmitFailed,
    onSubmit: function(values2) {
      props.onSubmit && props.onSubmit(values2);
      formProviderCtx.onFormSubmit && formProviderCtx.onFormSubmit(props.id, values2);
    }
  });
  var contextProps = {
    requiredSymbol,
    labelAlign,
    disabled,
    colon,
    labelCol,
    wrapperCol,
    layout,
    store: formInstance,
    prefixCls: prefixCls2,
    validateTrigger,
    validateMessages: merge_1({}, (_b = ctx.locale.Form) === null || _b === void 0 ? void 0 : _b.validateMessages, validateMessages2),
    getFormElementId: function(field) {
      return getFormElementId(id, field);
    }
  };
  var FormContext$1 = FormContext;
  return React__default.createElement(ConfigProvider, __assign$F({}, ctx, { size }), React__default.createElement(FormContext$1.Provider, { value: contextProps }, React__default.createElement(Wrapper2, __assign$F({ ref: wrapperRef }, omit$1(rest, [
    "form",
    "size",
    "initialValues",
    "onValuesChange",
    "onChange",
    "wrapperProps",
    "scrollToFirstError",
    "onSubmit",
    "onSubmitFailed"
  ]), props.wrapperProps, { className: cs$1(prefixCls2, prefixCls2 + "-" + layout, prefixCls2 + "-size-" + size, className), style: props.style, onSubmit: function(e) {
    e.preventDefault();
    e.stopPropagation();
    formInstance.submit();
  }, id }), props.children)));
};
var FormComponent = forwardRef(Form$1);
FormComponent.displayName = "Form";
var Form$2 = FormComponent;
var RowContext = createContext({});
var __assign$E = globalThis && globalThis.__assign || function() {
  __assign$E = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$E.apply(this, arguments);
};
var __rest$f = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var defaultProps$c = {
  span: 24
};
function getFlexString(flex) {
  if (typeof flex === "string" && /\d+[px|%|em|rem|]{1}/.test(flex)) {
    return "0 0 " + flex;
  }
  return flex;
}
function Col$1(baseProps, ref) {
  var _a;
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig2 = _b.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$c, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2["Grid.Col"]);
  var _c = useContext(RowContext), gutter = _c.gutter, div = _c.div;
  var className = props.className, style = props.style, children = props.children, span = props.span, offset = props.offset, order = props.order, pull = props.pull, push = props.push, xs = props.xs, sm = props.sm, md = props.md, lg = props.lg, xl = props.xl, xxl = props.xxl, flex = props.flex, rest = __rest$f(props, ["className", "style", "children", "span", "offset", "order", "pull", "push", "xs", "sm", "md", "lg", "xl", "xxl", "flex"]);
  function adaptationGrid(prefixCls3, mergeClassName2) {
    var screenList = { xs, sm, md, lg, xl, xxl };
    Object.keys(screenList).forEach(function(screen) {
      var screenValue = screenList[screen];
      if (isNumber$1(screenValue)) {
        if (screenValue >= 0) {
          mergeClassName2[prefixCls3 + "-" + screen + "-" + screenValue] = true;
        }
      } else if (isObject$e(screenValue)) {
        mergeClassName2[prefixCls3 + "-" + screen + "-" + screenValue.span] = screenValue.span;
        mergeClassName2[prefixCls3 + "-" + screen + "-offset-" + screenValue.offset] = screenValue.offset;
        mergeClassName2[prefixCls3 + "-" + screen + "-order-" + screenValue.order] = screenValue.order;
        mergeClassName2[prefixCls3 + "-" + screen + "-pull-" + screenValue.pull] = screenValue.pull;
        mergeClassName2[prefixCls3 + "-" + screen + "-push-" + screenValue.push] = screenValue.push;
      }
    });
    return mergeClassName2;
  }
  var prefixCls2 = getPrefixCls("col");
  var mergeClassName = (_a = {}, _a["" + prefixCls2] = !div, _a[prefixCls2 + "-order-" + order] = order, _a[prefixCls2 + "-" + span] = !div && !xs && !sm && !md && !lg && !xl && !xxl, _a[prefixCls2 + "-offset-" + offset] = offset, _a[prefixCls2 + "-pull-" + pull] = pull, _a[prefixCls2 + "-push-" + push] = push, _a);
  mergeClassName = adaptationGrid(prefixCls2, mergeClassName);
  var classNames = cs$1(flex ? prefixCls2 : mergeClassName, className);
  var paddingStyle = {};
  if (Array.isArray(gutter) && !div) {
    var paddingHorizontal = gutter[0] && gutter[0] / 2 || 0;
    var paddingVertical = gutter[1] && gutter[1] / 2 || 0;
    if (paddingHorizontal) {
      paddingStyle.paddingLeft = paddingHorizontal;
      paddingStyle.paddingRight = paddingHorizontal;
    }
    if (paddingVertical) {
      paddingStyle.paddingTop = paddingVertical;
      paddingStyle.paddingBottom = paddingVertical;
    }
  }
  var flexStyle = useMemo(function() {
    return getFlexString(flex) ? { flex: getFlexString(flex) } : {};
  }, [flex]);
  return React__default.createElement("div", __assign$E({ ref }, rest, { style: __assign$E(__assign$E(__assign$E({}, style), paddingStyle), flexStyle), className: classNames }), children);
}
var ColComponent = forwardRef(Col$1);
ColComponent.displayName = "Col";
var Col$2 = ColComponent;
var __assign$D = globalThis && globalThis.__assign || function() {
  __assign$D = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$D.apply(this, arguments);
};
var __rest$e = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$y = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var defaultProps$b = {
  gutter: 0,
  align: "start",
  justify: "start"
};
function Row$1(baseProps, ref) {
  var _a;
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig2 = _b.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$b, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2["Grid.Row"]);
  var className = props.className, style = props.style, children = props.children, div = props.div, align = props.align, justify = props.justify, gutter = props.gutter, rest = __rest$e(props, ["className", "style", "children", "div", "align", "justify", "gutter"]);
  var _c = __read$y(useState({
    xs: true,
    sm: true,
    md: true,
    lg: true,
    xl: true,
    xxl: true
  }), 2), screens2 = _c[0], setScreens = _c[1];
  var token = useRef();
  useEffect(function() {
    token.current = ResponsiveObserve.subscribe(function(screens3) {
      if (!Array.isArray(gutter) && typeof gutter === "object" || Array.isArray(gutter) && (typeof gutter[0] === "object" || typeof gutter[1] === "object")) {
        setScreens(screens3);
      }
    });
    return function() {
      ResponsiveObserve.unsubscribe(token.current);
    };
  }, []);
  function getGutter(gutter2) {
    var result = 0;
    if (typeof gutter2 === "object") {
      for (var i2 = 0; i2 < responsiveArray.length; i2++) {
        var breakpoint = responsiveArray[i2];
        if (screens2[breakpoint] && gutter2[breakpoint] !== void 0) {
          result = gutter2[breakpoint];
          break;
        }
      }
    } else {
      result = gutter2;
    }
    return result;
  }
  var prefixCls2 = getPrefixCls("row");
  var classNames = cs$1((_a = {}, _a["" + prefixCls2] = !div, _a[prefixCls2 + "-align-" + align] = align, _a[prefixCls2 + "-justify-" + justify] = justify, _a), className);
  var marginStyle = {};
  var gutterHorizontal = getGutter(Array.isArray(gutter) ? gutter[0] : gutter);
  var gutterVertical = getGutter(Array.isArray(gutter) ? gutter[1] : 0);
  if ((gutterHorizontal || gutterVertical) && !div) {
    var marginHorizontal = -gutterHorizontal / 2;
    var marginVertical = -gutterVertical / 2;
    if (marginHorizontal) {
      marginStyle.marginLeft = marginHorizontal;
      marginStyle.marginRight = marginHorizontal;
    }
    if (marginVertical) {
      marginStyle.marginTop = marginVertical;
      marginStyle.marginBottom = marginVertical;
    }
  }
  return React__default.createElement("div", __assign$D({ ref }, omit$1(rest, ["gutter"]), { style: __assign$D(__assign$D({}, style), marginStyle), className: classNames }), React__default.createElement(RowContext.Provider, { value: { gutter: [gutterHorizontal, gutterVertical], div } }, children));
}
var RowComponent = forwardRef(Row$1);
RowComponent.displayName = "Row";
var Row$2 = RowComponent;
var Grid = {
  Col: Col$2,
  Row: Row$2
};
var VALIDATE_STATUS = {
  error: "error",
  success: "success",
  warning: "warning",
  validating: "validating"
};
var __extends$1 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$C = globalThis && globalThis.__assign || function() {
  __assign$C = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$C.apply(this, arguments);
};
var __read$x = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$c = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function isFieldMath(field, fields) {
  var fieldObj = setWith_1({}, field, void 0, Object);
  return fields.some(function(item2) {
    return has_1(fieldObj, item2);
  });
}
var Control = function(_super) {
  __extends$1(Control2, _super);
  function Control2(props, context) {
    var _this = _super.call(this, props) || this;
    _this.errors = null;
    _this.warnings = null;
    _this.isDestroyed = false;
    _this.getErrors = function() {
      return _this.errors;
    };
    _this.isTouched = function() {
      return _this.touched;
    };
    _this.hasFieldProps = function() {
      return !!_this.props.field;
    };
    _this.clearFormItemError = function(field) {
      if (field === void 0) {
        field = _this.props.field;
      }
      var updateFormItem = _this.context.updateFormItem;
      updateFormItem && updateFormItem(field, { errors: null, warnings: null });
    };
    _this.updateFormItem = function() {
      if (_this.isDestroyed)
        return;
      _this.forceUpdate();
      var updateFormItem = _this.context.updateFormItem;
      updateFormItem && updateFormItem(_this.props.field, {
        errors: _this.errors,
        warnings: _this.warnings
      });
    };
    _this.onStoreChange = function(type, info2) {
      var fields = isArray$c(info2.field) ? info2.field : [info2.field];
      var _a = _this.props, field = _a.field, shouldUpdate = _a.shouldUpdate;
      var shouldUpdateItem = function(extra) {
        if (shouldUpdate) {
          var shouldRender = false;
          if (isFunction$5(shouldUpdate)) {
            shouldRender = shouldUpdate(info2.prev, info2.current, __assign$C({ field: info2.field }, extra));
          } else {
            shouldRender = !isEqualWith_1(info2.prev, info2.current);
          }
          if (shouldRender) {
            _this.updateFormItem();
          }
        }
      };
      switch (type) {
        case "reset":
          _this.touched = false;
          _this.errors = null;
          _this.warnings = null;
          _this.updateFormItem();
          break;
        case "innerSetValue":
          if (isFieldMath(field, fields)) {
            _this.touched = true;
            _this.updateFormItem();
            return;
          }
          shouldUpdateItem({
            isInner: true,
            isFormList: info2.isFormList
          });
          break;
        case "setFieldValue":
          if (isFieldMath(field, fields)) {
            _this.touched = true;
            if (info2.data && "touched" in info2.data) {
              _this.touched = info2.data.touched;
            }
            if (info2.data && "warnings" in info2.data) {
              _this.warnings = isNullOrUndefined(info2.data.warnings) ? [] : [].concat(info2.data.warnings);
            }
            if (info2.data && "errors" in info2.data) {
              _this.errors = info2.data.errors;
            } else if (!isEqualWith_1(get_1(info2.prev, field), get_1(info2.current, field))) {
              _this.errors = null;
            }
            _this.updateFormItem();
            return;
          }
          shouldUpdateItem();
          break;
      }
    };
    _this.innerSetFieldValue = function(field, value) {
      if (!field)
        return;
      var store = _this.context.store;
      var methods2 = store.getInnerMethods(true);
      methods2.innerSetFieldValue(field, value);
      var changedValue = {};
      set_1(changedValue, field, value);
      _this.props.onValuesChange && _this.props.onValuesChange(changedValue, __assign$C({}, store.getFieldsValue()));
    };
    _this.getTriggerHandler = function(children) {
      return function(_value) {
        var _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var store = _this.context.store;
        var _b = _this.props, field = _b.field, trigger = _b.trigger, normalize = _b.normalize, getValueFromEvent = _b.getValueFromEvent;
        var value = isFunction$5(getValueFromEvent) ? getValueFromEvent.apply(void 0, __spreadArray$c([_value], __read$x(args), false)) : _value;
        var normalizeValue = value;
        if (isSyntheticEvent(value)) {
          value.stopPropagation();
          return;
        }
        if (typeof normalize === "function") {
          normalizeValue = normalize(value, store.getFieldValue(field), __assign$C({}, store.getFieldsValue()));
        }
        _this.touched = true;
        _this.innerSetFieldValue(field, normalizeValue);
        _this.validateField(trigger);
        if (children && children.props && children.props[trigger]) {
          (_a = children.props)[trigger].apply(_a, __spreadArray$c([normalizeValue], __read$x(args), false));
        }
      };
    };
    _this.validateField = function(triggerType) {
      var _a = _this.context, store = _a.store, ctxValidateTrigger = _a.validateTrigger, validateMessages2 = _a.validateMessages;
      var _b = _this.props, field = _b.field, rules = _b.rules, validateTrigger = _b.validateTrigger;
      var value = store.getFieldValue(field);
      var _rules = !triggerType ? rules : (rules || []).filter(function(rule) {
        var triggers = [].concat(rule.validateTrigger || validateTrigger || ctxValidateTrigger);
        return triggers.indexOf(triggerType) > -1;
      });
      if (_rules && _rules.length && field) {
        return schemaValidate(field, value, _rules, validateMessages2).then(function(_a2) {
          var error2 = _a2.error, warning = _a2.warning;
          _this.errors = error2 ? error2[field] : null;
          _this.warnings = warning || null;
          _this.updateFormItem();
          return Promise.resolve({ error: error2, value, field });
        });
      }
      if (_this.errors) {
        _this.errors = null;
        _this.warnings = null;
        _this.updateFormItem();
      }
      return Promise.resolve({ error: null, value, field });
    };
    _this.getChild = function() {
      var children = _this.props.children;
      var store = _this.context.store;
      if (isFunction$5(children)) {
        return children(store.getFields(), __assign$C({}, store));
      }
      return children;
    };
    if ("initialValue" in props && _this.hasFieldProps()) {
      var innerMethods = context.store.getInnerMethods(true);
      innerMethods.innerSetInitialValue(props.field, props.initialValue);
    }
    return _this;
  }
  Control2.prototype.componentDidMount = function() {
    var store = this.context.store;
    if (store) {
      var innerMethods = store.getInnerMethods(true);
      this.removeRegisterField = innerMethods.registerField(this);
    }
    this.isDestroyed = false;
  };
  Control2.prototype.componentDidUpdate = function(prevProps) {
    if (prevProps.field !== this.props.field && this.props._key && prevProps._key === this.props._key) {
      this.updateFormItem();
      this.clearFormItemError(prevProps.field);
    }
  };
  Control2.prototype.componentWillUnmount = function() {
    this.removeRegisterField && this.removeRegisterField();
    this.removeRegisterField = null;
    this.clearFormItemError();
    this.isDestroyed = true;
  };
  Control2.prototype.getValidateTrigger = function() {
    var _validateTrigger = this.props.validateTrigger || this.context.validateTrigger || "onChange";
    var rules = this.props.rules || [];
    var result = [];
    rules.map(function(item2) {
      result = result.concat(item2.validateTrigger || _validateTrigger);
    });
    return Array.from(new Set(result));
  };
  Control2.prototype.renderControl = function(children, id) {
    var _a;
    var _this = this;
    var _b;
    var _c = this.props, field = _c.field, _d = _c.trigger, trigger = _d === void 0 ? "onChange" : _d, _e = _c.triggerPropName, triggerPropName = _e === void 0 ? "value" : _e, validateStatus = _c.validateStatus, formatter = _c.formatter;
    var _f = this.context, store = _f.store, ctxDisabled = _f.disabled;
    var disabled = "disabled" in this.props ? this.props.disabled : ctxDisabled;
    var child = React__default.Children.only(children);
    var childProps = {
      id: cs$1(((_b = child.props) === null || _b === void 0 ? void 0 : _b.id) || (_a = {}, _a["" + id + ID_SUFFIX] = id, _a))
    };
    this.getValidateTrigger().forEach(function(vt) {
      childProps[vt] = function(e) {
        _this.validateField(vt);
        child.props[vt] && child.props[vt](e);
      };
    });
    childProps[trigger] = this.getTriggerHandler(child);
    if (disabled !== void 0) {
      childProps.disabled = disabled;
    }
    var _value = store.getFieldValue(field);
    if (isFunction$5(formatter)) {
      _value = formatter(_value);
    }
    childProps[triggerPropName] = _value;
    if (!validateStatus && this.errors) {
      childProps.error = true;
    }
    return React__default.cloneElement(child, childProps);
  };
  Control2.prototype.render = function() {
    var _a = this.props, noStyle = _a.noStyle, field = _a.field, isFormList = _a.isFormList, hasFeedback = _a.hasFeedback;
    var validateStatus = this.props.validateStatus || (this.errors ? "error" : "");
    var _b = this.context, prefixCls2 = _b.prefixCls, getFormElementId2 = _b.getFormElementId;
    var child = this.getChild();
    var id = this.hasFieldProps() ? getFormElementId2(field) : void 0;
    if (this.hasFieldProps() && !isFormList && React__default.Children.count(child) === 1) {
      child = this.renderControl(child, id);
    }
    if (noStyle) {
      return child;
    }
    return React__default.createElement("div", { className: prefixCls2 + "-item-control-wrapper" }, React__default.createElement("div", { className: prefixCls2 + "-item-control", id }, React__default.createElement("div", { className: prefixCls2 + "-item-control-children" }, child, validateStatus && hasFeedback && React__default.createElement("div", { className: prefixCls2 + "-item-feedback" }, validateStatus === "warning" && React__default.createElement(IconExclamationCircleFill$1, null), validateStatus === "success" && React__default.createElement(IconCheckCircleFill$1, null), validateStatus === "error" && React__default.createElement(IconCloseCircleFill$1, null), validateStatus === "validating" && React__default.createElement(IconLoading$1, null)))));
  };
  Control2.defaultProps = {
    trigger: "onChange",
    triggerPropName: "value"
  };
  Control2.isFormControl = true;
  Control2.contextType = FormItemContext;
  return Control2;
}(Component);
var FormControl = Control;
var FormItemLabel = function(_a) {
  var htmlFor = _a.htmlFor, showColon = _a.showColon, label = _a.label, requiredSymbol = _a.requiredSymbol, required = _a.required, rules = _a.rules, prefix = _a.prefix;
  var isRequiredRule = isArray$c(rules) && rules.some(function(rule) {
    return rule && rule.required;
  });
  var symbolPosition = isObject$e(requiredSymbol) ? requiredSymbol.position : "start";
  var symbolNode = (required || isRequiredRule) && !!requiredSymbol && React__default.createElement("strong", { className: prefix + "-form-item-symbol" }, React__default.createElement("svg", { fill: "currentColor", viewBox: "0 0 1024 1024", width: "1em", height: "1em" }, React__default.createElement("path", { d: "M583.338667 17.066667c18.773333 0 34.133333 15.36 34.133333 34.133333v349.013333l313.344-101.888a34.133333 34.133333 0 0 1 43.008 22.016l42.154667 129.706667a34.133333 34.133333 0 0 1-21.845334 43.178667l-315.733333 102.4 208.896 287.744a34.133333 34.133333 0 0 1-7.509333 47.786666l-110.421334 80.213334a34.133333 34.133333 0 0 1-47.786666-7.509334L505.685333 706.218667 288.426667 1005.226667a34.133333 34.133333 0 0 1-47.786667 7.509333l-110.421333-80.213333a34.133333 34.133333 0 0 1-7.509334-47.786667l214.186667-295.253333L29.013333 489.813333a34.133333 34.133333 0 0 1-22.016-43.008l42.154667-129.877333a34.133333 34.133333 0 0 1 43.008-22.016l320.512 104.106667L412.672 51.2c0-18.773333 15.36-34.133333 34.133333-34.133333h136.533334z" })));
  return label ? React__default.createElement("label", { htmlFor: htmlFor && "" + htmlFor + ID_SUFFIX }, symbolPosition !== "end" && symbolNode, " ", label, symbolPosition === "end" && React__default.createElement(React__default.Fragment, null, " ", symbolNode), showColon ? ":" : "") : null;
};
var FormItemLabel$1 = FormItemLabel;
var __assign$B = globalThis && globalThis.__assign || function() {
  __assign$B = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$B.apply(this, arguments);
};
var __rest$d = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$w = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$b = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Row = Grid.Row;
var Col = Grid.Col;
var FormItemTip = function(_a) {
  var _b;
  var prefixCls2 = _a.prefixCls, help = _a.help, propsErrors = _a.errors, warnings = _a.warnings;
  var errorTip = propsErrors.map(function(item2, i2) {
    if (item2) {
      return React__default.createElement("div", { key: i2, role: "alert" }, item2.message);
    }
  });
  var warningTip = [];
  warnings.map(function(item2, i2) {
    warningTip.push(React__default.createElement("div", { key: i2, role: "alert", className: prefixCls2 + "-message-help-warning" }, item2));
  });
  var isHelpTip = !isUndefined(help) || !!warningTip.length;
  var visible = isHelpTip || !!errorTip.length;
  return visible && React__default.createElement(CSSTransition$1, { in: visible, appear: true, classNames: "formblink", timeout: 300, unmountOnExit: true }, React__default.createElement("div", { className: cs$1(prefixCls2 + "-message", (_b = {}, _b[prefixCls2 + "-message-help"] = isHelpTip, _b)) }, !isUndefined(help) ? help : React__default.createElement(React__default.Fragment, null, errorTip.length > 0 && errorTip, warningTip.length > 0 && warningTip)));
};
var Item$2 = function(props, ref) {
  var _a, _b, _c, _d;
  var _e, _f;
  var _g = useContext(ConfigContext), getPrefixCls = _g.getPrefixCls, prefix = _g.prefixCls;
  var topFormContext = useContext(FormItemContext);
  var formListContext = useContext(FormListContext);
  var _h = __read$w(useState(null), 2), errors = _h[0], setErrors = _h[1];
  var _j = __read$w(useState(null), 2), warnings = _j[0], setWarnings = _j[1];
  var formContext = useContext(FormContext);
  var prefixCls2 = formContext.prefixCls || getPrefixCls("form");
  var formLayout = props.layout || formContext.layout;
  var labelAlign = props.labelAlign || formContext.labelAlign;
  var isDestroyed = useRef(false);
  var updateInnerFormItem = function(field, params) {
    if (params === void 0) {
      params = {};
    }
    if (isDestroyed.current) {
      return;
    }
    var _a2 = params || {}, errors2 = _a2.errors, warnings2 = _a2.warnings;
    setErrors(function(innerErrors) {
      var newErrors = __assign$B({}, innerErrors || {});
      if (errors2) {
        newErrors[field] = errors2;
      } else {
        delete newErrors[field];
      }
      return newErrors;
    });
    setWarnings(function(current) {
      var newVal = __assign$B({}, current || {});
      if (warnings2 && warnings2.length) {
        newVal[field] = warnings2;
      } else {
        delete newVal[field];
      }
      return newVal;
    });
  };
  var updateFormItem = isObject$e(props.noStyle) && props.noStyle.showErrorTip && topFormContext.updateFormItem ? topFormContext.updateFormItem : updateInnerFormItem;
  useEffect(function() {
    isDestroyed.current = false;
    return function() {
      isDestroyed.current = true;
      setErrors(null);
      setWarnings(null);
    };
  }, []);
  var contextProps = __assign$B(__assign$B({}, formContext), { validateMessages: formContext.validateMessages && formatValidateMsg(formContext.validateMessages, {
    label: props.label
  }), prefixCls: prefixCls2, updateFormItem, disabled: "disabled" in props ? props.disabled : formContext.disabled });
  var label = props.label, extra = props.extra, className = props.className, style = props.style, validateStatus = props.validateStatus, hidden = props.hidden, rest = __rest$d(props, ["label", "extra", "className", "style", "validateStatus", "hidden"]);
  var labelClassNames = cs$1(prefixCls2 + "-label-item", (_a = {}, _a[prefixCls2 + "-label-item-left"] = labelAlign === "left", _a));
  var errorInfo = errors ? Object.values(errors) : [];
  var warningInfo = warnings ? Object.values(warnings).reduce(function(total, next) {
    return total.concat(next);
  }, []) : [];
  var itemStatus = useMemo(function() {
    if (validateStatus) {
      return validateStatus;
    }
    if (errorInfo.length) {
      return VALIDATE_STATUS.error;
    }
    if (warningInfo.length) {
      return VALIDATE_STATUS.warning;
    }
    return void 0;
  }, [errors, warnings, validateStatus]);
  var hasHelp = useMemo(function() {
    return !isUndefined(props.help) || warningInfo.length > 0;
  }, [props.help, warnings]);
  var classNames = cs$1(prefixCls2 + "-item", (_b = {}, _b[prefixCls2 + "-item-error"] = hasHelp || !validateStatus && itemStatus === VALIDATE_STATUS.error, _b[prefixCls2 + "-item-status-" + itemStatus] = itemStatus, _b[prefixCls2 + "-item-has-help"] = hasHelp, _b[prefixCls2 + "-item-hidden"] = hidden, _b[prefixCls2 + "-item-has-feedback"] = itemStatus && props.hasFeedback, _b), prefixCls2 + "-layout-" + formLayout, className);
  var cloneElementWithDisabled = function() {
    var _a2, _b2;
    var field = props.field, children = props.children;
    var disabled = "disabled" in props ? props.disabled : formContext.disabled;
    if (isFunction$5(children)) {
      return React__default.createElement(FormControl, __assign$B({ disabled }, props, field ? { key: field, _key: field } : {}), function() {
        var rest2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          rest2[_i] = arguments[_i];
        }
        return children.apply(void 0, __spreadArray$b([], __read$w(rest2), false));
      });
    }
    if (isArray$c(children)) {
      var childrenDom = React__default.Children.map(children, function(child, i2) {
        var key2 = isObject$e(child) && child.key || i2;
        var childProps2 = !isUndefined(disabled) ? { key: key2, disabled } : { key: key2 };
        return isObject$e(child) ? cloneElement(child, childProps2) : child;
      });
      return React__default.createElement(FormControl, __assign$B({}, props, { field: void 0 }), childrenDom);
    }
    if (React__default.Children.count(children) === 1) {
      if (field) {
        var key = ((_a2 = formListContext === null || formListContext === void 0 ? void 0 : formListContext.getItemKey) === null || _a2 === void 0 ? void 0 : _a2.call(formListContext, field)) || field;
        return React__default.createElement(FormControl, __assign$B({ disabled }, props, { key, _key: key }), children);
      }
      if (isObject$e(children)) {
        if ((_b2 = children.type) === null || _b2 === void 0 ? void 0 : _b2.isFormControl) {
          return children;
        }
        var childProps = isUndefined(disabled) ? {} : { disabled };
        return React__default.createElement(FormControl, __assign$B({}, props, { field: void 0 }), cloneElement(children, childProps));
      }
    }
    return children;
  };
  var FormItemContext$1 = FormItemContext;
  var newFormContext = __assign$B({}, formContext);
  if (!props.noStyle) {
    newFormContext.wrapperCol = void 0;
    newFormContext.labelCol = void 0;
  }
  return React__default.createElement(FormContext.Provider, { value: newFormContext }, React__default.createElement(FormItemContext$1.Provider, { value: contextProps }, props.noStyle ? cloneElementWithDisabled() : React__default.createElement(Row, __assign$B({ ref }, omit$1(rest, [
    "children",
    "prefixCls",
    "store",
    "initialValue",
    "field",
    "labelCol",
    "wrapperCol",
    "colon",
    "disabled",
    "rules",
    "trigger",
    "triggerPropName",
    "validateTrigger",
    "noStyle",
    "required",
    "hasFeedback",
    "help",
    "normalize",
    "formatter",
    "getValueFromEvent",
    "shouldUpdate",
    "field",
    "isInner",
    "labelAlign",
    "layout",
    "requiredSymbol",
    "isFormList"
  ]), { className: classNames, div: formLayout !== "horizontal", style }), label ? React__default.createElement(Col, __assign$B({}, props.labelCol || formContext.labelCol, { className: cs$1(labelClassNames, (_e = props.labelCol) === null || _e === void 0 ? void 0 : _e.className, (_f = formContext.labelCol) === null || _f === void 0 ? void 0 : _f.className, (_c = {}, _c[prefixCls2 + "-label-item-flex"] = !props.labelCol && !formContext.labelCol, _c)) }), React__default.createElement(FormItemLabel$1, { htmlFor: props.field && formContext.getFormElementId(props.field), label, prefix, requiredSymbol: "requiredSymbol" in props ? props.requiredSymbol : formContext.requiredSymbol, required: props.required, rules: props.rules, showColon: "colon" in props ? props.colon : formContext.colon })) : null, React__default.createElement(Col, __assign$B({ className: cs$1(prefixCls2 + "-item-wrapper", (_d = {}, _d[prefixCls2 + "-item-wrapper-flex"] = !props.wrapperCol && !formContext.wrapperCol, _d)) }, props.wrapperCol || formContext.wrapperCol), cloneElementWithDisabled(), React__default.createElement(FormItemTip, { prefixCls: prefixCls2, help: props.help, errors: errorInfo, warnings: warningInfo }), extra && React__default.createElement("div", { className: prefixCls2 + "-extra" }, extra)))));
};
var ItemComponent$1 = forwardRef(Item$2);
ItemComponent$1.defaultProps = {
  trigger: "onChange",
  triggerPropName: "value"
};
ItemComponent$1.displayName = "FormItem";
var FormItem = ItemComponent$1;
var __assign$A = globalThis && globalThis.__assign || function() {
  __assign$A = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$A.apply(this, arguments);
};
var __read$v = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$a = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var isIndexLegal = function(index2, value) {
  return !isUndefined(index2) && index2 >= 0 && index2 < value.length;
};
var List$2 = function(props) {
  var field = props.field, children = props.children, initialValue = props.initialValue;
  var keysRef = useRef({
    id: 0,
    keys: []
  });
  var extra = "initialValue" in props ? { initialValue } : {};
  var currentKeys = keysRef.current.keys;
  return React__default.createElement(FormListContext.Provider, { value: {
    getItemKey: function(fieldKey) {
      var keys2 = fieldKey === null || fieldKey === void 0 ? void 0 : fieldKey.replace(/\[|\]/g, ".").split(".");
      var startIndex = keys2.indexOf(field);
      var index2 = keys2[startIndex + 1];
      return field + "_" + currentKeys.indexOf(index2) + "_" + keys2.slice(startIndex + 2).join("_");
    }
  } }, React__default.createElement(FormItem, __assign$A({ field }, extra, { isFormList: true, noStyle: true, shouldUpdate: function(prev, current, info2) {
    if (info2 && info2.isInner && !info2.isFormList && info2.field !== field) {
      return false;
    }
    return !isEqualWith_1(get_1(prev, field), get_1(current, field));
  } }), function(_, methods2) {
    var getFieldValue = methods2.getFieldValue, getInnerMethods = methods2.getInnerMethods;
    var innerSetFieldValue = getInnerMethods(true).innerSetFieldValue;
    var values2 = getFieldValue(field) || [];
    var add = function(defaultValue, index2) {
      if (isSyntheticEvent(defaultValue)) {
        return;
      }
      var key = keysRef.current.id;
      keysRef.current.id += 1;
      var oldValue = getFieldValue(field) || [];
      var newValue = oldValue;
      if (index2 !== void 0 && index2 >= 0 && index2 <= oldValue.length) {
        currentKeys.splice(index2, 0, key);
        newValue = __spreadArray$a(__spreadArray$a(__spreadArray$a([], __read$v(oldValue.slice(0, index2)), false), [defaultValue], false), __read$v(oldValue.slice(index2)), false);
      } else {
        currentKeys.push(key);
        newValue = __spreadArray$a(__spreadArray$a([], __read$v(oldValue), false), [defaultValue], false);
      }
      innerSetFieldValue(field, newValue, {
        isFormList: true,
        ignore: defaultValue === void 0
      });
    };
    var remove = function(index2) {
      var value = getFieldValue(field) || [];
      var newValue = value.filter(function(_2, i2) {
        return i2 !== index2;
      });
      currentKeys.splice(index2, 1);
      innerSetFieldValue(field, __spreadArray$a([], __read$v(newValue), false), { isFormList: true });
    };
    var move = function(fromIndex, toIndex) {
      var value = getFieldValue(field) || [];
      if (fromIndex === toIndex || !isIndexLegal(fromIndex, value) || !isIndexLegal(toIndex, value)) {
        return;
      }
      var fromId = currentKeys[fromIndex];
      currentKeys.splice(fromIndex, 1);
      currentKeys.splice(toIndex, 0, fromId);
      var fromItem = value[fromIndex];
      var newValue = __spreadArray$a([], __read$v(value), false);
      newValue.splice(fromIndex, 1);
      newValue.splice(toIndex, 0, fromItem);
      innerSetFieldValue(field, newValue, { isFormList: true });
    };
    return isFunction$5(children) && children(values2.map(function(_2, index2) {
      var key = currentKeys[index2];
      if (key === void 0) {
        key = keysRef.current.id;
        currentKeys.push(key);
        keysRef.current.id += 1;
      }
      return {
        field: field + "[" + index2 + "]",
        key
      };
    }), {
      add,
      remove,
      move
    });
  }));
};
List$2.displayName = "FormList";
var FormList = List$2;
var FormProviderComponent = function(props, _) {
  var formsRef = useRef({});
  var register = useCallback(function(name2, form) {
    if (name2) {
      formsRef.current[name2] = form;
    }
    return function() {
      delete formsRef.current[name2];
    };
  }, []);
  var onFormSubmit = useCallback(function(name2, changedValues) {
    props.onFormSubmit && props.onFormSubmit(name2, changedValues, {
      forms: formsRef.current
    });
  }, [props.onFormSubmit]);
  var onFormValuesChange = useCallback(function(name2, values2) {
    props.onFormValuesChange && props.onFormValuesChange(name2, values2, {
      forms: formsRef.current
    });
  }, [props.onFormValuesChange]);
  return React__default.createElement(FormProviderContext.Provider, { value: {
    onFormValuesChange,
    onFormSubmit,
    register
  } }, props.children);
};
var FormProvider = forwardRef(FormProviderComponent);
FormProvider.displayName = "FormProvider";
var FormProvider$1 = FormProvider;
var __read$u = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var useWatch = function(field, form) {
  var formCtx = useContext(FormContext);
  var formInstance = form || formCtx.store;
  var _a = __read$u(useState(formInstance === null || formInstance === void 0 ? void 0 : formInstance.getFieldValue(field)), 2), value = _a[0], setValue = _a[1];
  var valueRef = useRef(JSON.stringify(value));
  useEffect(function() {
    if (!formInstance) {
      return;
    }
    var registerWatcher = (formInstance === null || formInstance === void 0 ? void 0 : formInstance.getInnerMethods(true)).registerWatcher;
    var updateValue = function() {
      var newValue = get_1(formInstance.getFieldsValue(), field);
      var newValueString = JSON.stringify(newValue);
      if (valueRef.current !== newValueString) {
        setValue(newValue);
        valueRef.current = newValueString;
      }
    };
    updateValue();
    var cancelWatch = registerWatcher && registerWatcher(updateValue);
    return function() {
      cancelWatch && cancelWatch();
    };
  }, []);
  return value;
};
var useWatch$1 = useWatch;
var useFormContext = function() {
  var formCtx = useContext(FormContext);
  return {
    form: formCtx.store,
    disabled: formCtx.disabled
  };
};
var useFormContext$1 = useFormContext;
var FormComp = Form$2;
FormComp.Provider = FormProvider$1;
FormComp.Item = FormItem;
FormComp.List = FormList;
FormComp.Control = FormControl;
FormComp.useForm = useForm;
FormComp.useFormContext = useFormContext$1;
FormComp.useWatch = useWatch$1;
var Form = FormComp;
function strip(num, precision) {
  if (precision === void 0) {
    precision = 15;
  }
  return +parseFloat(Number(num).toPrecision(precision));
}
function digitLength(num) {
  var eSplit = num.toString().split(/[eE]/);
  var len = (eSplit[0].split(".")[1] || "").length - +(eSplit[1] || 0);
  return len > 0 ? len : 0;
}
function float2Fixed(num) {
  if (num.toString().indexOf("e") === -1) {
    return Number(num.toString().replace(".", ""));
  }
  var dLen = digitLength(num);
  return dLen > 0 ? strip(Number(num) * Math.pow(10, dLen)) : Number(num);
}
function checkBoundary(num) {
  if (_boundaryCheckingState) {
    if (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) {
      console.warn(num + " is beyond boundary when transfer to integer, the results may not be accurate");
    }
  }
}
function iteratorOperation(arr, operation) {
  var num1 = arr[0], num2 = arr[1], others = arr.slice(2);
  var res = operation(num1, num2);
  others.forEach(function(num) {
    res = operation(res, num);
  });
  return res;
}
function times() {
  var nums = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    nums[_i] = arguments[_i];
  }
  if (nums.length > 2) {
    return iteratorOperation(nums, times);
  }
  var num1 = nums[0], num2 = nums[1];
  var num1Changed = float2Fixed(num1);
  var num2Changed = float2Fixed(num2);
  var baseNum = digitLength(num1) + digitLength(num2);
  var leftValue = num1Changed * num2Changed;
  checkBoundary(leftValue);
  return leftValue / Math.pow(10, baseNum);
}
function plus() {
  var nums = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    nums[_i] = arguments[_i];
  }
  if (nums.length > 2) {
    return iteratorOperation(nums, plus);
  }
  var num1 = nums[0], num2 = nums[1];
  var baseNum = Math.pow(10, Math.max(digitLength(num1), digitLength(num2)));
  return (times(num1, baseNum) + times(num2, baseNum)) / baseNum;
}
function minus() {
  var nums = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    nums[_i] = arguments[_i];
  }
  if (nums.length > 2) {
    return iteratorOperation(nums, minus);
  }
  var num1 = nums[0], num2 = nums[1];
  var baseNum = Math.pow(10, Math.max(digitLength(num1), digitLength(num2)));
  return (times(num1, baseNum) - times(num2, baseNum)) / baseNum;
}
function divide() {
  var nums = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    nums[_i] = arguments[_i];
  }
  if (nums.length > 2) {
    return iteratorOperation(nums, divide);
  }
  var num1 = nums[0], num2 = nums[1];
  var num1Changed = float2Fixed(num1);
  var num2Changed = float2Fixed(num2);
  checkBoundary(num1Changed);
  checkBoundary(num2Changed);
  return times(num1Changed / num2Changed, strip(Math.pow(10, digitLength(num2) - digitLength(num1))));
}
function round(num, ratio) {
  var base = Math.pow(10, ratio);
  var result = divide(Math.round(Math.abs(times(num, base))), base);
  if (num < 0 && result !== 0) {
    result = times(result, -1);
  }
  return result;
}
var _boundaryCheckingState = true;
function enableBoundaryChecking(flag) {
  if (flag === void 0) {
    flag = true;
  }
  _boundaryCheckingState = flag;
}
var index = {
  strip,
  plus,
  minus,
  times,
  divide,
  round,
  digitLength,
  float2Fixed,
  enableBoundaryChecking
};
function ownKeys$8(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$8(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$8(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$8(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconPlusComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$8(_objectSpread$8({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-plus")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M5 24h38M24 5v38"
  }));
}
var IconPlus = /* @__PURE__ */ React__default.forwardRef(IconPlusComponent);
IconPlus.defaultProps = {
  isIcon: true
};
IconPlus.displayName = "IconPlus";
var IconPlus$1 = IconPlus;
function ownKeys$7(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$7(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$7(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$7(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconMinusComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$7(_objectSpread$7({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-minus")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M5 24h38"
  }));
}
var IconMinus = /* @__PURE__ */ React__default.forwardRef(IconMinusComponent);
IconMinus.defaultProps = {
  isIcon: true
};
IconMinus.displayName = "IconMinus";
var IconMinus$1 = IconMinus;
function toFixed(number, precision) {
  var pow = Math.pow(10, precision);
  return (Math.round(number * pow) / pow).toFixed(precision);
}
function toSafeString(number) {
  var nativeNumberStr = number.toString();
  if (Number.isNaN(+number) || !nativeNumberStr.includes("e")) {
    return nativeNumberStr;
  }
  try {
    var isNegative = number < 0;
    var absoluteValue = Math.abs(+number);
    var digitLength_1 = index.digitLength(absoluteValue);
    var integerNum = index.float2Fixed(absoluteValue);
    var integerStr_1 = integerNum.toString().replace(/e\+(\d+)/i, function(_, $1) {
      return new Array(+$1).fill(0).join("");
    });
    return "" + (isNegative ? "-" : "") + (digitLength_1 === 0 ? integerStr_1 : integerStr_1.replace(new RegExp("\\d{1," + digitLength_1 + "}$"), function(match) {
      var decimalStr = ("" + new Array(digitLength_1).fill(0).join("") + match).slice(-digitLength_1);
      return (integerStr_1.length <= digitLength_1 ? 0 : "") + "." + decimalStr;
    }));
  } catch (e) {
  }
  return nativeNumberStr;
}
var __assign$z = globalThis && globalThis.__assign || function() {
  __assign$z = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$z.apply(this, arguments);
};
var __rest$c = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$t = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
index.enableBoundaryChecking(false);
var AUTO_CHANGE_INTERVAL = 200;
var AUTO_CHANGE_START_DELAY = 1e3;
var defaultProps$a = {
  max: Infinity,
  min: -Infinity,
  step: 1,
  mode: "embed",
  parser: function(input) {
    return input.replace(/[^\w\.-]+/g, "");
  }
};
function InputNumber(baseProps, ref) {
  var _a;
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, ctxSize = _b.size, componentConfig2 = _b.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$a, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.InputNumber);
  var className = props.className, style = props.style, defaultValue = props.defaultValue, disabled = props.disabled, error2 = props.error, readOnly = props.readOnly, placeholder = props.placeholder, hideControl = props.hideControl, suffix = props.suffix, prefix = props.prefix, icons = props.icons, mode = props.mode, size = props.size, step = props.step, precision = props.precision, min = props.min, max = props.max, parser = props.parser, formatter = props.formatter, onBlur3 = props.onBlur, onFocus3 = props.onFocus, onChange = props.onChange, onKeyDown = props.onKeyDown, rest = __rest$c(props, ["className", "style", "defaultValue", "disabled", "error", "readOnly", "placeholder", "hideControl", "suffix", "prefix", "icons", "mode", "size", "step", "precision", "min", "max", "parser", "formatter", "onBlur", "onFocus", "onChange", "onKeyDown"]);
  var prefixCls2 = getPrefixCls("input-number");
  var mergedSize = size || ctxSize;
  var mergedPrecision = function() {
    if (isNumber$1(precision)) {
      var decimal = ("" + step).split(".")[1];
      var stepPrecision = decimal && decimal.length || 0;
      return Math.max(stepPrecision, precision);
    }
    return null;
  }();
  var _c = __read$t(useState("defaultValue" in props ? defaultValue : void 0), 2), innerValue = _c[0], setInnerValue = _c[1];
  var value = function() {
    var mergedValue = "value" in props ? props.value : innerValue;
    return typeof mergedValue === "string" && mergedValue !== "" ? +mergedValue : mergedValue;
  }();
  var _d = __read$t(useState(""), 2), inputValue = _d[0], setInputValue = _d[1];
  var _e = __read$t(useState(false), 2), isOutOfRange = _e[0], setIsOutOfRange = _e[1];
  var _f = __read$t(useState(false), 2), isUserInputting = _f[0], setIsUserInputting = _f[1];
  var isEmptyValue2 = value === "" || value === void 0 || value === null;
  var refAutoTimer = useRef(null);
  var refInput = useRef(null);
  var refHasOperateSincePropValueChanged = useRef(false);
  useImperativeHandle(ref, function() {
    return refInput.current;
  }, []);
  var setValue = function(newVal) {
    setInnerValue(newVal);
    var newValue = isNumber$1(+newVal) ? +newVal : void 0;
    if (newValue !== value) {
      onChange && onChange(newValue);
    }
  };
  var stop2 = function() {
    refAutoTimer.current && clearTimeout(refAutoTimer.current);
    refAutoTimer.current = null;
  };
  var getLegalValue = useCallback(function(changedValue) {
    var finalValue = Number(changedValue);
    if (!changedValue && changedValue !== 0) {
      finalValue = void 0;
    } else if (!isNumber$1(finalValue)) {
      finalValue = changedValue === "-" ? changedValue : "";
    }
    if (finalValue < min) {
      finalValue = min;
    }
    if (finalValue > max) {
      finalValue = max;
    }
    return isNumber$1(finalValue) ? isNumber$1(mergedPrecision) ? Number(toFixed(finalValue, mergedPrecision)) : finalValue : void 0;
  }, [min, max, mergedPrecision]);
  useEffect(function() {
    return function() {
      return stop2();
    };
  }, []);
  useEffect(function() {
    refHasOperateSincePropValueChanged.current = false;
  }, [props.value]);
  useEffect(function() {
    var _isOutOfRange = isNumber$1(min) && value < min || isNumber$1(max) && value > max;
    if (_isOutOfRange && refHasOperateSincePropValueChanged.current) {
      setValue(getLegalValue(value));
    }
    setIsOutOfRange(_isOutOfRange);
  }, [min, max, value, getLegalValue]);
  var handleArrowKey = function(event2, method, needRepeat) {
    if (needRepeat === void 0) {
      needRepeat = false;
    }
    event2.persist();
    event2.preventDefault();
    setIsUserInputting(false);
    if (disabled) {
      return;
    }
    var finalValue = min === -Infinity ? 0 : min;
    if (!isEmptyValue2) {
      finalValue = index[method](value, step);
    }
    setValue(getLegalValue(finalValue));
    refInput.current && refInput.current.focus();
    if (needRepeat) {
      var isFirstRepeat = refAutoTimer.current === null;
      refAutoTimer.current = setTimeout(function() {
        return event2.target.dispatchEvent(event2.nativeEvent);
      }, isFirstRepeat ? AUTO_CHANGE_START_DELAY : AUTO_CHANGE_INTERVAL);
    }
  };
  var getDisplayInputValue = function() {
    var _value;
    if (isUserInputting) {
      _value = inputValue;
    } else if (isNumber$1(value) && isNumber$1(mergedPrecision)) {
      _value = toFixed(value, mergedPrecision);
    } else if (value == null) {
      _value = "";
    } else {
      _value = toSafeString(value);
    }
    return formatter ? formatter(_value) : _value;
  };
  var inputEventHandlers = {
    onChange: function(value2) {
      setIsUserInputting(true);
      var targetValue = value2.trim().replace(//g, ".");
      targetValue = parser ? parser(targetValue) : targetValue;
      if (isNumber$1(+targetValue) || targetValue === "-" || !targetValue || targetValue === ".") {
        var formatValue2 = getLegalValue(targetValue);
        setInputValue(targetValue);
        setValue(formatValue2);
      }
    },
    onKeyDown: function(e) {
      e.stopPropagation();
      var key = e.key;
      if (key === ArrowDown.key) {
        handleArrowKey(e, "minus");
      } else if (key === ArrowUp.key) {
        handleArrowKey(e, "plus");
      }
      stop2();
      onKeyDown && onKeyDown(e);
    },
    onFocus: function(e) {
      var _a2, _b2;
      refHasOperateSincePropValueChanged.current = true;
      setInputValue((_b2 = (_a2 = refInput.current) === null || _a2 === void 0 ? void 0 : _a2.dom) === null || _b2 === void 0 ? void 0 : _b2.value);
      onFocus3 && onFocus3(e);
    },
    onBlur: function(e) {
      setValue(getLegalValue(value));
      setIsUserInputting(false);
      onBlur3 && onBlur3(e);
    }
  };
  var getControlButtonEventsHandlers = function(method) {
    return readOnly ? {} : {
      onMouseDown: function(e) {
        return handleArrowKey(e, method, true);
      },
      onMouseLeave: stop2,
      onMouseUp: stop2
    };
  };
  var shouldRenderButton = !hideControl && mode === "button";
  var shouldRenderLayer = !hideControl && !readOnly && mode === "embed";
  var renderStepButton = function(method, icon) {
    var _a2;
    return React__default.createElement("div", __assign$z({ className: cs$1(prefixCls2 + "-step-button", (_a2 = {}, _a2[prefixCls2 + "-step-button-disabled"] = disabled || (method === "plus" ? +value >= +max : +value <= +min), _a2)) }, getControlButtonEventsHandlers(method)), icon);
  };
  return React__default.createElement(Input$5, __assign$z({ _ignorePropsFromGlobal: true, role: "spinbutton", "aria-valuemax": max, "aria-valuemin": min, "aria-valuenow": value }, omit$1(rest, ["allowClear"]), inputEventHandlers, { style, className: cs$1(prefixCls2, prefixCls2 + "-mode-" + mode, prefixCls2 + "-size-" + mergedSize, (_a = {}, _a[prefixCls2 + "-readonly"] = readOnly, _a[prefixCls2 + "-illegal-value"] = !isEmptyValue2 && isOutOfRange, _a), className), ref: refInput, size: mergedSize, error: error2, disabled, readOnly, value: getDisplayInputValue(), placeholder, prefix: prefix && React__default.createElement("div", { className: prefixCls2 + "-prefix" }, prefix), suffix: React__default.createElement(React__default.Fragment, null, shouldRenderLayer && React__default.createElement("div", { className: prefixCls2 + "-step-layer" }, renderStepButton("plus", icons && icons.up ? icons.up : React__default.createElement(IconUp$1, null)), renderStepButton("minus", icons && icons.down ? icons.down : React__default.createElement(IconDown$1, null))), suffix && React__default.createElement("div", { className: prefixCls2 + "-suffix" }, suffix)), addBefore: shouldRenderButton && renderStepButton("minus", icons && icons.minus ? icons.minus : React__default.createElement(IconMinus$1, null)), addAfter: shouldRenderButton && renderStepButton("plus", icons && icons.plus ? icons.plus : React__default.createElement(IconPlus$1, null)) }));
}
var InputNumberComponent = React__default.forwardRef(InputNumber);
InputNumberComponent.displayName = "InputNumber";
var InputNumber$1 = InputNumberComponent;
var __assign$y = globalThis && globalThis.__assign || function() {
  __assign$y = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$y.apply(this, arguments);
};
var StepType;
(function(StepType2) {
  StepType2[StepType2["previous"] = 0] = "previous";
  StepType2[StepType2["next"] = 1] = "next";
})(StepType || (StepType = {}));
function Pager(props) {
  var _a;
  var locale = useContext(ConfigContext).locale;
  var onClick = function(e) {
    var pageNum2 = props.pageNum, onClick2 = props.onClick, disabled = props.disabled;
    if (e.currentTarget.dataset.active === "true") {
      return;
    }
    e.stopPropagation();
    if (!disabled) {
      onClick2 && onClick2(pageNum2);
    }
  };
  var pageNum = props.pageNum, current = props.current, rootPrefixCls = props.rootPrefixCls, pageItemStyle = props.pageItemStyle, activePageItemStyle = props.activePageItemStyle, itemRender = props.itemRender;
  var prefixCls2 = rootPrefixCls + "-item";
  var isActive = current === pageNum;
  var classnames2 = cs$1(prefixCls2, isActive ? prefixCls2 + "-active" : "");
  var style = pageItemStyle;
  if (isActive) {
    style = __assign$y(__assign$y({}, style), activePageItemStyle);
  }
  var ariaCurrentProps = isActive ? { "aria-current": true } : {};
  return React__default.createElement("li", __assign$y({ style, className: classnames2, onClick, "aria-label": (_a = locale.Pagination.currentPage) === null || _a === void 0 ? void 0 : _a.replace("{0}", pageNum) }, ariaCurrentProps), itemRender ? itemRender(pageNum, "page", pageNum) : pageNum);
}
function getIcon(name2, icons) {
  switch (name2) {
    case "prev":
      return icons && icons.prev ? icons.prev : React__default.createElement(IconLeft$1, null);
    case "next":
      return icons && icons.next ? icons.next : React__default.createElement(IconRight$1, null);
    case "more":
      return icons && icons.more ? icons.more : React__default.createElement(IconMore$1, null);
    default:
      return null;
  }
}
var JumpPager = function(props) {
  var _a, _b;
  var locale = useContext(ConfigContext).locale;
  var rootPrefixCls = props.rootPrefixCls, current = props.current, allPages = props.allPages, jumpPage = props.jumpPage, icons = props.icons, disabled = props.disabled, pageItemStyle = props.pageItemStyle, itemRender = props.itemRender;
  var minCurrent = allPages > 0 ? 1 : 0;
  var nextPage = Math.min(allPages, Math.max(minCurrent, current + jumpPage));
  var prefix = rootPrefixCls + "-item " + rootPrefixCls + "-item-jumper";
  var cls = cs$1(prefix);
  var onClick = function() {
    !disabled && props.onClick && props.onClick(nextPage);
  };
  var originElement = getIcon("more", icons);
  var ariaLabel = jumpPage > 0 ? (_a = locale.Pagination.nextSomePages) === null || _a === void 0 ? void 0 : _a.replace("{0}", jumpPage) : (_b = locale.Pagination.prevSomePages) === null || _b === void 0 ? void 0 : _b.replace("{0}", -jumpPage);
  return React__default.createElement("li", { style: pageItemStyle, className: cls, onClick, "aria-label": ariaLabel }, itemRender ? itemRender(void 0, "more", originElement) : originElement);
};
var StepPager = function(props) {
  var _a;
  var locale = useContext(ConfigContext).locale;
  var rootPrefixCls = props.rootPrefixCls, current = props.current, allPages = props.allPages, type = props.type, icons = props.icons, disabled = props.disabled, pageItemStyle = props.pageItemStyle, itemRender = props.itemRender;
  var prefixCls2 = rootPrefixCls + "-item";
  var StepIcon = type === StepType.previous ? getIcon("prev", icons) : getIcon("next", icons);
  var _disabled = false;
  if (allPages === 0) {
    _disabled = true;
  } else if (type === StepType.previous) {
    _disabled = current <= 1;
  } else {
    _disabled = current === allPages;
  }
  var innerDisabled = disabled || _disabled;
  var nextPage = current + (type === StepType.previous ? -1 : 1);
  nextPage = Math.max(0, Math.min(allPages, nextPage));
  var pageType = StepType.previous === type ? "prev" : "next";
  var cls = cs$1(prefixCls2, prefixCls2 + "-" + pageType, (_a = {}, _a[prefixCls2 + "-disabled"] = innerDisabled, _a));
  var onClick = function() {
    if (innerDisabled) {
      return;
    }
    props.onClick && props.onClick(nextPage);
  };
  return React__default.createElement("li", { style: pageItemStyle, className: cls, onClick, "aria-label": locale.Pagination[pageType] }, itemRender ? itemRender(void 0, pageType, StepIcon) : StepIcon);
};
var __assign$x = globalThis && globalThis.__assign || function() {
  __assign$x = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$x.apply(this, arguments);
};
var noop$1 = function() {
};
var Option = Select$2.Option;
var _SizeOptions = [10, 20, 30, 40, 50];
function PageOption(props) {
  var selectRef = useRef();
  var locale = useContext(ConfigContext).locale;
  var _a = props.sizeCanChange, sizeCanChange = _a === void 0 ? false : _a, _b = props.onPageSizeChange, onPageSizeChange = _b === void 0 ? noop$1 : _b, rootPrefixCls = props.rootPrefixCls, _c = props.sizeOptions, sizeOptions = _c === void 0 ? _SizeOptions : _c, _d = props.pageSize, pageSize = _d === void 0 ? 10 : _d, size = props.size, selectProps = props.selectProps, disabled = props.disabled;
  return sizeCanChange && React__default.createElement("div", { ref: selectRef, className: rootPrefixCls + "-option", "aria-label": locale.Pagination.pageSize }, React__default.createElement(Select$2, __assign$x({ value: sizeOptions.indexOf(pageSize) !== -1 ? pageSize : sizeOptions[0], onChange: function(value) {
    onPageSizeChange(value);
  }, size, getPopupContainer: function() {
    return selectRef.current;
  }, disabled }, selectProps), sizeOptions.map(function(num) {
    return React__default.createElement(Option, { key: num, value: num }, num + " " + locale.Pagination.countPerPage);
  })));
}
var __assign$w = globalThis && globalThis.__assign || function() {
  __assign$w = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$w.apply(this, arguments);
};
var __read$s = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function PageJumper(props) {
  var defaultInputText = props.simple ? props.current : void 0;
  var locale = useContext(ConfigContext).locale;
  var _a = __read$s(useState(defaultInputText), 2), inputText = _a[0], setInputText = _a[1];
  var inputRef = useRef();
  useEffect(function() {
    if (props.simple) {
      setInputText(props.current);
    }
  }, [props.simple, props.current]);
  var handleChange = function(val) {
    var value = parseInt(val, 10);
    setInputText(isNaN(value) ? void 0 : value);
  };
  var handleJump = function() {
    var onPageChange = props.onPageChange, totalPages2 = props.totalPages, current = props.current, simple2 = props.simple;
    if (isUndefined(inputText)) {
      return;
    }
    if (inputText === current && !simple2) {
      setInputText(void 0);
      return;
    }
    var page = isNaN(Number(inputText)) ? current : Number(inputText);
    if (page < 1) {
      page = 1;
    } else if (page > totalPages2) {
      page = totalPages2;
    }
    setInputText(simple2 ? page : void 0);
    isFunction$5(onPageChange) && onPageChange(page);
  };
  var onFocus3 = function() {
    var input = inputRef.current.dom;
    if (String(inputText) && input) {
      input.setSelectionRange(0, String(inputText).length);
    }
  };
  var rootPrefixCls = props.rootPrefixCls, totalPages = props.totalPages, simple = props.simple, size = props.size, disabled = props.disabled;
  var prefixCls2 = rootPrefixCls + "-jumper";
  var inputConfig = __assign$w({ showJumper: true }, isObject$e(simple) ? simple : {});
  return React__default.createElement("div", { className: "" + prefixCls2 }, !simple && React__default.createElement("span", { className: prefixCls2 + "-text-goto" }, locale.Pagination.goto), inputConfig.showJumper ? React__default.createElement(Input$5, { _ignorePropsFromGlobal: true, ref: function(ref) {
    return inputRef.current = ref;
  }, className: prefixCls2 + "-input", value: !isUndefined(inputText) ? inputText.toString() : void 0, size, disabled: disabled || !totalPages, onChange: handleChange, onPressEnter: handleJump, onFocus: onFocus3, onBlur: handleJump }) : React__default.createElement("span", null, inputText), simple && React__default.createElement(React__default.Fragment, null, React__default.createElement("span", { className: prefixCls2 + "-separator" }, "/"), React__default.createElement("span", null, totalPages)));
}
var __assign$v = globalThis && globalThis.__assign || function() {
  __assign$v = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$v.apply(this, arguments);
};
var __read$r = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var _defaultCurrent = 1;
var _defaultPageSize = 10;
function getAllPages(pageSize, total) {
  return Math.ceil(total / pageSize);
}
function getBufferSize(bufferSize, allPages) {
  var min = 0;
  var max = Math.floor(allPages / 2) - 1;
  var newBufferSize = Math.max(bufferSize, min);
  return Math.min(newBufferSize, max);
}
var defaultProps$9 = {
  total: 0,
  pageSizeChangeResetCurrent: true,
  bufferSize: 2
};
function Pagination(baseProps, ref) {
  var _a;
  var _b;
  var _c = useContext(ConfigContext), getPrefixCls = _c.getPrefixCls, ctxSize = _c.size, locale = _c.locale, componentConfig2 = _c.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$9, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Pagination);
  var propTotal = props.total, propPageSize = props.pageSize, propCurrent = props.current, propShowMore = props.showMore, pageSizeChangeResetCurrent = props.pageSizeChangeResetCurrent, defaultCurrent = props.defaultCurrent, defaultPageSize = props.defaultPageSize;
  var _d = __read$r(useState(propCurrent || defaultCurrent || _defaultCurrent), 2), current = _d[0], setCurrent = _d[1];
  var _e = __read$r(useState(propPageSize || defaultPageSize || _defaultPageSize), 2), pageSize = _e[0], setPageSize = _e[1];
  var _f = __read$r(useState(propTotal), 2), total = _f[0], setTotal = _f[1];
  var _g = __read$r(useState(!!propShowMore), 2), showMore = _g[0], setShowMore = _g[1];
  if (propCurrent && !props.onChange) {
    console.warn("Warning: you have provide current prop for pagination but without onChange handler , this will cause no-change when you change page. ");
  }
  useEffect(function() {
    if ("total" in props && propTotal !== total) {
      setTotal(propTotal);
    }
    if (!!propShowMore !== showMore) {
      setShowMore(!!propShowMore);
    }
    if (propPageSize && propPageSize !== pageSize) {
      setPageSize(propPageSize);
      var currentAllPages = getAllPages(propPageSize, propTotal);
      var nextCurrent = current > currentAllPages ? currentAllPages : current;
      if (nextCurrent !== current) {
        setCurrent(nextCurrent);
      }
    }
    if (propCurrent && propCurrent !== current) {
      setCurrent(propCurrent);
    }
  }, [propPageSize, propTotal, propShowMore, propCurrent]);
  var onChange = function(pageNumber, size2) {
    if (pageNumber === void 0) {
      pageNumber = current;
    }
    if (size2 === void 0) {
      size2 = pageSize;
    }
    var onChange2 = props.onChange;
    onChange2 && onChange2(pageNumber, size2);
  };
  var onPageSizeChange = function(pageSize2) {
    var onPageSizeChange2 = props.onPageSizeChange;
    var allPages2 = getAllPages(pageSize2, total);
    var newState = {
      pageSize: pageSize2
    };
    if (pageSizeChangeResetCurrent) {
      newState.current = 1;
    } else {
      newState.current = current > allPages2 ? allPages2 : current;
    }
    if (!("pageSize" in props)) {
      setPageSize(newState.pageSize);
    }
    if (!("current" in props) && current !== newState.current) {
      setCurrent(newState.current);
    }
    onPageSizeChange2 && onPageSizeChange2(pageSize2, newState.current);
    onChange(pageSizeChangeResetCurrent ? 1 : newState.current, pageSize2);
  };
  var onPageNumberChange = function(pageNumber) {
    if (!("current" in props)) {
      setCurrent(pageNumber);
    }
    onChange(pageNumber);
  };
  var className = props.className, style = props.style, pageItemStyle = props.pageItemStyle, activePageItemStyle = props.activePageItemStyle, showTotal = props.showTotal, sizeCanChange = props.sizeCanChange, sizeOptions = props.sizeOptions, simple = props.simple, mini = props.mini, showJumper = props.showJumper, selectProps = props.selectProps, icons = props.icons, disabled = props.disabled, itemRender = props.itemRender, hideOnSinglePage = props.hideOnSinglePage;
  var size = props.size || ctxSize;
  var prefixCls2 = getPrefixCls("pagination");
  var innerSize = mini ? "mini" : size;
  var classNames = cs$1(prefixCls2, prefixCls2 + "-size-" + innerSize, (_a = {}, _a[prefixCls2 + "-simple"] = simple, _a[prefixCls2 + "-disabled"] = disabled, _a), className);
  var renderPager;
  var pageList = [];
  var allPages = getAllPages(pageSize, total);
  var bufferSize = getBufferSize(props.bufferSize, allPages);
  if (hideOnSinglePage && allPages <= 1) {
    return null;
  }
  var pagerProps = {
    onClick: onPageNumberChange,
    rootPrefixCls: prefixCls2,
    simple,
    current,
    allPages,
    icons,
    disabled,
    pageItemStyle,
    activePageItemStyle,
    itemRender
  };
  if (simple) {
    var prefix = prefixCls2 + "-item-simple";
    renderPager = React__default.createElement("ul", { className: prefixCls2 + "-list" }, React__default.createElement(StepPager, __assign$v({ key: "previous" }, pagerProps, { type: StepType.previous })), React__default.createElement("li", { className: prefix + "-pager" }, React__default.createElement(PageJumper, { disabled, rootPrefixCls: prefixCls2, totalPages: allPages, current, onPageChange: onPageNumberChange, simple: { showJumper: typeof showJumper === "boolean" ? showJumper : true }, size: innerSize })), React__default.createElement(StepPager, __assign$v({ key: "next" }, pagerProps, { type: StepType.next })));
  } else {
    var beginFoldPage = 1 + 2 + bufferSize;
    var endFoldPage = allPages - 2 - bufferSize;
    if (allPages <= 4 + bufferSize * 2 || current === beginFoldPage && current === endFoldPage) {
      for (var i2 = 1; i2 <= allPages; i2++) {
        pageList.push(React__default.createElement(Pager, __assign$v({}, pagerProps, { key: i2, pageNum: i2 })));
      }
    } else {
      var left = 1;
      var right = allPages;
      var hasJumpPre = true;
      var hasJumpNext = true;
      if (current > beginFoldPage && current < endFoldPage) {
        right = current + bufferSize;
        left = current - bufferSize;
      } else if (current <= beginFoldPage) {
        hasJumpPre = false;
        left = 1;
        right = Math.max(beginFoldPage, bufferSize + current);
      } else if (current >= endFoldPage) {
        hasJumpNext = false;
        right = allPages;
        left = Math.min(endFoldPage, current - bufferSize);
      }
      for (var i2 = left; i2 <= right; i2++) {
        pageList.push(React__default.createElement(Pager, __assign$v({ key: i2, pageNum: i2 }, pagerProps)));
      }
      var JumpPre = React__default.createElement(JumpPager, __assign$v({}, pagerProps, { key: left - 1, type: StepType.previous, jumpPage: -(bufferSize * 2 + 1) }));
      var JumpNext = React__default.createElement(JumpPager, __assign$v({}, pagerProps, { key: right + 1, type: StepType.next, jumpPage: bufferSize * 2 + 1 }));
      var FirstPager = React__default.createElement(Pager, __assign$v({ key: 1, pageNum: 1 }, pagerProps));
      var LastPager = React__default.createElement(Pager, __assign$v({}, pagerProps, { key: allPages, pageNum: allPages }));
      if (hasJumpPre) {
        pageList[0] = React__default.cloneElement(pageList[0], {
          className: prefixCls2 + "-item-after-pre"
        });
        pageList.unshift(JumpPre);
        pageList.unshift(FirstPager);
      }
      if (hasJumpNext) {
        pageList[pageList.length - 1] = React__default.cloneElement(pageList[pageList.length - 1], {
          className: prefixCls2 + "-item-before-next"
        });
        pageList.push(JumpNext);
        pageList.push(LastPager);
      }
    }
    renderPager = React__default.createElement("ul", { className: prefixCls2 + "-list" }, React__default.createElement(StepPager, __assign$v({}, pagerProps, { key: "previous", type: StepType.previous })), pageList, showMore && React__default.createElement(JumpPager, __assign$v({}, pagerProps, { key: allPages + 1, type: StepType.next, jumpPage: bufferSize * 2 + 1 })), React__default.createElement(StepPager, __assign$v({ key: "next" }, pagerProps, { type: StepType.next })));
  }
  var totalElement = null;
  if (typeof showTotal === "boolean" && showTotal) {
    totalElement = React__default.createElement("div", { className: prefixCls2 + "-total-text" }, (_b = locale.Pagination.total) === null || _b === void 0 ? void 0 : _b.replace("{0}", total));
  }
  if (typeof showTotal === "function") {
    totalElement = React__default.createElement("div", { className: prefixCls2 + "-total-text" }, showTotal(total, [(current - 1) * pageSize + 1, current * pageSize]));
  }
  return React__default.createElement("div", { className: classNames, style, ref }, totalElement, renderPager, React__default.createElement(PageOption, { disabled, rootPrefixCls: prefixCls2, sizeCanChange, sizeOptions, onPageSizeChange, pageSize, size: innerSize, selectProps }), !simple && showJumper && React__default.createElement(PageJumper, { disabled, rootPrefixCls: prefixCls2, totalPages: allPages, current, onPageChange: onPageNumberChange, size: innerSize }));
}
var PaginationComponent = forwardRef(Pagination);
PaginationComponent.displayName = "Pagination";
var Pagination$1 = PaginationComponent;
var __assign$u = globalThis && globalThis.__assign || function() {
  __assign$u = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$u.apply(this, arguments);
};
var __rest$b = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function Meta(props, ref) {
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var className = props.className, avatar = props.avatar, title2 = props.title, description = props.description, others = __rest$b(props, ["className", "avatar", "title", "description"]);
  var prefixCls2 = getPrefixCls("list");
  var baseClassName = prefixCls2 + "-item-meta";
  var hasAvatar = !!avatar;
  var hasContent = !!(title2 || description);
  return React__default.createElement("div", __assign$u({ ref }, others, { className: cs$1(baseClassName, className) }), hasAvatar && React__default.createElement("div", { className: baseClassName + "-avatar" }, avatar), hasContent && React__default.createElement("div", { className: baseClassName + "-content" }, title2 && React__default.createElement("div", { className: baseClassName + "-title" }, title2), description && React__default.createElement("div", { className: baseClassName + "-description" }, description)));
}
var MetaComponent = React__default.forwardRef(Meta);
MetaComponent.displayName = "ListItemMeta";
var Meta$1 = MetaComponent;
var __assign$t = globalThis && globalThis.__assign || function() {
  __assign$t = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$t.apply(this, arguments);
};
var __rest$a = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var defaultProps$8 = {
  actionLayout: "horizontal"
};
function Item(baseProps, ref) {
  var _a = useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, componentConfig2 = _a.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$8, componentConfig2 && componentConfig2["List.Item"]);
  var children = props.children, className = props.className, actions = props.actions, extra = props.extra, actionLayout = props.actionLayout, rest = __rest$a(props, ["children", "className", "actions", "extra", "actionLayout"]);
  var prefixCls2 = getPrefixCls("list");
  var baseClassName = prefixCls2 + "-item";
  var metaContent = [];
  var mainContent = [];
  React__default.Children.forEach(children, function(element) {
    if (element && element.type && element.type === Meta$1) {
      metaContent.push(element);
    } else {
      mainContent.push(element);
    }
  });
  var content = mainContent.length ? React__default.createElement("div", { className: baseClassName + "-content" }, mainContent) : null;
  var extraContent = extra ? React__default.createElement("div", { className: baseClassName + "-extra-content" }, extra) : null;
  var actionsContent = actions && actions.length ? React__default.createElement("div", { className: baseClassName + "-action" }, actions.map(function(action, i2) {
    return React__default.createElement("li", { key: baseClassName + "-action-" + i2 }, action);
  })) : null;
  return React__default.createElement("div", __assign$t({ role: "listitem", ref, className: cs$1(baseClassName, className) }, rest), React__default.createElement("div", { className: baseClassName + "-main" }, metaContent, content, actionLayout === "vertical" ? actionsContent : null), actionLayout === "horizontal" ? actionsContent : null, extraContent);
}
var ForwardRefItem = React__default.forwardRef(Item);
var ItemComponent = ForwardRefItem;
ItemComponent.displayName = "ListItem";
ItemComponent.Meta = Meta$1;
var Item$1 = ItemComponent;
var __assign$s = globalThis && globalThis.__assign || function() {
  __assign$s = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$s.apply(this, arguments);
};
function scrollIntoViewIfNeed(node, options2) {
  if (node) {
    scrollIntoView(node, __assign$s({ block: "start", behavior: "instant", scrollMode: "if-needed" }, options2));
    var height = node.offsetHeight;
    var scaleHeight = node.getBoundingClientRect().height;
    if (options2 && options2.boundary && height !== scaleHeight) {
      var parentNode = isFunction$5(options2.boundary) ? options2.boundary(node) : options2.boundary;
      parentNode.scrollTop = Math.round(parentNode.scrollTop * (height / scaleHeight));
    }
  }
}
var __assign$r = globalThis && globalThis.__assign || function() {
  __assign$r = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$r.apply(this, arguments);
};
var __rest$9 = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$q = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var DEFAULT_PAGE_SIZE = 10;
var DEFAULT_PAGE_CURRENT = 1;
var SizeList = ["small", "default", "large"];
var defaultProps$7 = {
  split: true,
  bordered: true,
  defaultCurrent: 1,
  offsetBottom: 0,
  throttleDelay: 500
};
function List(baseProps, ref) {
  var _a = useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, loadingElement = _a.loadingElement, ctxSize = _a.size, renderEmpty2 = _a.renderEmpty, componentConfig2 = _a.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$7, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.List);
  var style = props.style, wrapperStyle = props.wrapperStyle, className = props.className, wrapperClassName = props.wrapperClassName, _b = props.children, children = _b === void 0 ? [] : _b, _c = props.dataSource, dataSource = _c === void 0 ? [] : _c, propSize = props.size, footer = props.footer, header = props.header, pagination = props.pagination, bordered = props.bordered, split = props.split, render = props.render, grid = props.grid, loading = props.loading, hoverable = props.hoverable, scrollLoading = props.scrollLoading, paginationInFooter = props.paginationInFooter, offsetBottom = props.offsetBottom, throttleDelay = props.throttleDelay, defaultCurrent = props.defaultCurrent, noDataElement = props.noDataElement, listRef = props.listRef, onReachBottom = props.onReachBottom, onListScroll = props.onListScroll;
  var size = propSize || (SizeList.indexOf(ctxSize) > -1 ? ctxSize : "default");
  var prefixCls2 = getPrefixCls("list");
  var refDom = useRef(null);
  var refVirtualList = useRef(null);
  var refScrollElement = useRef(null);
  var refItemListWrapper = useRef(null);
  var refCanTriggerReachBottom = useRef(true);
  var _d = __read$q(useState(pagination && typeof pagination === "object" ? pagination.pageSize || pagination.defaultPageSize || DEFAULT_PAGE_SIZE : DEFAULT_PAGE_SIZE), 2), pageSize = _d[0], setPageSize = _d[1];
  var _e = __read$q(useState(pagination && typeof pagination === "object" ? pagination.current || pagination.defaultCurrent || DEFAULT_PAGE_CURRENT : DEFAULT_PAGE_CURRENT), 2), paginationCurrent = _e[0], setPaginationCurrent = _e[1];
  var _f = __read$q(useState(defaultCurrent), 2), pageCurrentForScroll = _f[0], setPageCurrentForScroll = _f[1];
  var childrenCount = React__default.Children.count(children);
  useImperativeHandle(listRef, function() {
    return {
      dom: refDom.current,
      scrollIntoView: function(index2, options2) {
        if (refVirtualList.current) {
          refVirtualList.current.scrollTo({ index: index2, options: options2 });
        } else if (refItemListWrapper.current) {
          var node = refItemListWrapper.current.children[index2];
          node && scrollIntoViewIfNeed(node, __assign$r({ boundary: refScrollElement.current }, options2));
        }
      }
    };
  });
  var virtualListProps = props.virtualListProps ? props.virtualListProps : props.height ? { height: props.height } : void 0;
  var paginationProps = __assign$r(__assign$r({ pageSize, current: paginationCurrent, total: dataSource.length > 0 ? dataSource.length : childrenCount }, typeof pagination === "object" ? pagination : {}), { onPageSizeChange: function(size2, current) {
    setPageSize(size2);
    pagination && typeof pagination === "object" && pagination.onPageSizeChange && pagination.onPageSizeChange(size2, current);
  }, onChange: function(pageNumber, pageSize2) {
    setPaginationCurrent(pageNumber);
    pagination && typeof pagination === "object" && pagination.onChange && pagination.onChange(pageNumber, pageSize2);
  } });
  paginationProps.current = Math.min(paginationProps.current, Math.ceil(paginationProps.total / paginationProps.pageSize));
  var needHandleScroll = !!(onListScroll || onReachBottom);
  var throttledScrollHandler = useCallback(throttle_1(function() {
    if (onListScroll) {
      onListScroll(refScrollElement.current);
      return;
    }
    var _a2 = refScrollElement.current, scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
    var scrollBottom = scrollHeight - (scrollTop + clientHeight);
    if (Math.abs(scrollBottom) < offsetBottom + 1) {
      if (refCanTriggerReachBottom.current) {
        setPageCurrentForScroll(pageCurrentForScroll + 1);
        onReachBottom && onReachBottom(pageCurrentForScroll + 1);
        refCanTriggerReachBottom.current = false;
      }
    } else {
      refCanTriggerReachBottom.current = true;
    }
  }, throttleDelay), [throttleDelay, pageCurrentForScroll, onListScroll, onReachBottom]);
  var renderListItems = function() {
    var getCurrentPageItems = function(items) {
      var current = paginationProps.current, pageSize2 = paginationProps.pageSize;
      var startIndex = (current - 1) * pageSize2;
      return pagination && items.length > startIndex ? items.slice(startIndex, startIndex + pageSize2) : items;
    };
    var getItems = function(originItems, render2) {
      var currentPageItems = getCurrentPageItems(originItems);
      return render2 ? currentPageItems.map(render2) : currentPageItems;
    };
    var getGrid = function(originItems, render2) {
      var currentPageItems = getCurrentPageItems(originItems);
      if (grid.column || grid.span) {
        var items = [];
        var gutter = grid.gutter, justify = grid.justify, align = grid.align, gridRowSize = grid.column, colProps_1 = __rest$9(grid, ["gutter", "justify", "align", "column"]);
        var rowSize = gridRowSize || Math.floor(24 / grid.span);
        var span_1 = colProps_1.span || Math.floor(24 / rowSize);
        var startNum_1 = 0;
        var _loop_1 = function() {
          var nextStartNum = startNum_1 + rowSize;
          var currentRow = ~~(startNum_1 / rowSize);
          items.push(React__default.createElement(Row$2, { key: currentRow, className: prefixCls2 + "-row", gutter, justify, align }, currentPageItems.slice(startNum_1, nextStartNum).map(function(item2, index2) {
            return React__default.createElement(Col$2, __assign$r({ key: currentRow + "_" + index2, className: prefixCls2 + "-row-col" }, colProps_1, { span: span_1 }), render2 ? render2(item2, startNum_1 + index2) : item2);
          })));
          startNum_1 = nextStartNum;
        };
        while (startNum_1 < currentPageItems.length) {
          _loop_1();
        }
        return items;
      }
      return React__default.createElement(Row$2, { className: prefixCls2 + "-row", gutter: grid.gutter }, currentPageItems.map(function(item2, index2) {
        return React__default.createElement(Col$2, __assign$r({ className: prefixCls2 + "-row-col" }, omit$1(grid, ["gutter"]), { key: index2 }), render2 ? render2(item2, index2) : item2);
      }));
    };
    if (dataSource.length > 0 && render) {
      return grid ? getGrid(dataSource, render) : getItems(dataSource, render);
    }
    if (childrenCount > 0) {
      return grid ? getGrid(children) : getItems(children);
    }
    if (!scrollLoading) {
      return noDataElement || renderEmpty2("List");
    }
    return null;
  };
  var renderList = function() {
    var _a2;
    var listItems = renderListItems();
    var isVirtual = virtualListProps && Array.isArray(listItems);
    var paginationElement = pagination ? React__default.createElement(Pagination$1, __assign$r({}, paginationProps, { className: cs$1(prefixCls2 + "-pagination", paginationProps && paginationProps.className) })) : null;
    var paginationElementInsideFooter = paginationInFooter ? paginationElement : null;
    var paginationElementOutsideFooter = paginationInFooter ? null : paginationElement;
    var scrollLoadingEle = scrollLoading !== void 0 && scrollLoading !== null ? React__default.createElement("div", { className: prefixCls2 + "-item " + prefixCls2 + "-scroll-loading" }, scrollLoading) : null;
    return React__default.createElement("div", { ref: function(_ref2) {
      ref = _ref2;
      refDom.current = ref;
    }, style: wrapperStyle, className: cs$1(prefixCls2 + "-wrapper", wrapperClassName) }, React__default.createElement("div", { style, className: cs$1(prefixCls2, prefixCls2 + "-" + size, (_a2 = {}, _a2[prefixCls2 + "-no-border"] = !bordered, _a2[prefixCls2 + "-no-split"] = !split, _a2[prefixCls2 + "-hoverable"] = hoverable, _a2), className), ref: function(ref2) {
      if (!isVirtual) {
        refScrollElement.current = ref2;
      }
    }, onScroll: !isVirtual && needHandleScroll ? throttledScrollHandler : void 0 }, header ? React__default.createElement("div", { className: prefixCls2 + "-header" }, header) : null, isVirtual ? React__default.createElement(React__default.Fragment, null, React__default.createElement(VirtualList$1, __assign$r({ role: "list", ref: function(ref2) {
      if (ref2) {
        refVirtualList.current = ref2;
        refScrollElement.current = ref2.dom;
      }
    }, className: prefixCls2 + "-content " + prefixCls2 + "-virtual", data: scrollLoadingEle ? listItems.concat(scrollLoadingEle) : listItems, isStaticItemHeight: false, onScroll: needHandleScroll ? throttledScrollHandler : void 0 }, virtualListProps), function(child) {
      return child;
    })) : React__default.createElement("div", { role: "list", className: prefixCls2 + "-content", ref: refItemListWrapper }, listItems, scrollLoadingEle), footer || paginationElementInsideFooter ? React__default.createElement("div", { className: prefixCls2 + "-footer" }, footer, paginationElementInsideFooter) : null), paginationElementOutsideFooter);
  };
  return "loading" in props ? React__default.createElement(Spin$1, { style: { display: "block" }, loading, element: loadingElement || React__default.createElement(Spin$1, null) }, renderList()) : renderList();
}
var ListComponent = React__default.forwardRef(List);
ListComponent.displayName = "List";
ListComponent.Item = Item$1;
var List$1 = ListComponent;
var __assign$q = globalThis && globalThis.__assign || function() {
  __assign$q = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$q.apply(this, arguments);
};
function ConfirmModal(props) {
  var _a = getModalConfig(), prefixCls2 = _a.prefixCls, simple = _a.simple;
  return React__default.createElement(Modal$1, __assign$q({ prefixCls: prefixCls2, simple }, props), props.content);
}
var normalizeConfig = function(_config) {
  if (_config.isNotice) {
    var icon = _config.icon;
    if (!icon && icon !== null) {
      switch (_config.noticeType) {
        case "info":
          icon = React__default.createElement(IconInfoCircleFill$1, null);
          break;
        case "success":
          icon = React__default.createElement(IconCheckCircleFill$1, null);
          break;
        case "warning":
          icon = React__default.createElement(IconExclamationCircleFill$1, null);
          break;
        case "error":
          icon = React__default.createElement(IconCloseCircleFill$1, null);
          break;
      }
    }
    _config.title = React__default.createElement("span", null, icon, _config.title);
    _config.hideCancel = true;
  } else {
    _config.title = React__default.createElement("span", null, _config.icon !== null && (_config.icon || React__default.createElement(IconExclamationCircleFill$1, null)), _config.title);
  }
  return _config;
};
function confirm(config2, renderFunc) {
  var div = document.createElement("div");
  document.body.appendChild(div);
  var configProviderProps = getConfigProviderProps();
  function render(props) {
    ReactDOM.render(React__default.createElement(ConfigProvider, __assign$q({}, configProviderProps), React__default.createElement(ConfirmModal, __assign$q({}, props, { onCancel }))), div);
  }
  var renderFunction = renderFunc || render;
  var modalConfig2 = __assign$q(__assign$q({}, config2), { visible: false });
  var onOk = function() {
    var ret;
    var _onOk = config2.onOk || config2.onConfirm;
    if (_onOk) {
      ret = _onOk();
    }
    if (ret && ret.then) {
      modalConfig2.confirmLoading = true;
      renderFunction(modalConfig2);
      ret.then(function() {
        onCancel(true);
      }, function(e) {
        console.error(e);
        modalConfig2.confirmLoading = false;
        renderFunction(modalConfig2);
      });
    }
    if (!ret) {
      onCancel(true);
    }
  };
  modalConfig2.onOk = onOk;
  modalConfig2 = normalizeConfig(modalConfig2);
  modalConfig2.visible = true;
  renderFunction(modalConfig2);
  function destroy() {
    var unmountEle = ReactDOM.unmountComponentAtNode(div);
    if (unmountEle && div.parentNode) {
      div.parentNode.removeChild(div);
    }
    for (var i2 = 0; i2 < destroyList.length; i2++) {
      var fn = destroyList[i2];
      if (fn === close) {
        destroyList.splice(i2, 1);
        break;
      }
    }
  }
  function onCancel(isOnOk) {
    !isOnOk && config2.onCancel && config2.onCancel();
    modalConfig2.visible = false;
    modalConfig2.afterClose = function() {
      config2.afterClose && config2.afterClose();
      destroy();
    };
    renderFunction(modalConfig2);
  }
  function update2(newConfig) {
    modalConfig2 = __assign$q(__assign$q(__assign$q({}, modalConfig2), { title: config2.title }), newConfig);
    modalConfig2 = normalizeConfig(modalConfig2);
    renderFunction(modalConfig2);
  }
  function close() {
    modalConfig2.visible = false;
    modalConfig2.afterClose = function() {
      config2.afterClose && config2.afterClose();
      destroy();
    };
    renderFunction(modalConfig2);
  }
  destroyList.push(close);
  return {
    close,
    update: update2
  };
}
var __read$p = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$9 = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var ContextHolderElement = forwardRef(function(_props, ref) {
  var _a = __read$p(useState([]), 2), instances = _a[0], setInstances = _a[1];
  function addInstance2(ins) {
    setInstances(function(originInstances) {
      return __spreadArray$9(__spreadArray$9([], __read$p(originInstances), false), [ins], false);
    });
  }
  function removeInstance(ins) {
    setInstances(function(originInstances) {
      return originInstances.filter(function(originIns) {
        return ins !== originIns;
      });
    });
  }
  useImperativeHandle(ref, function() {
    return {
      addInstance: addInstance2,
      removeInstance
    };
  });
  return React__default.createElement(React__default.Fragment, null, instances);
});
var ContextHolderElement$1 = ContextHolderElement;
var __assign$p = globalThis && globalThis.__assign || function() {
  __assign$p = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$p.apply(this, arguments);
};
var __read$o = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function HookModal(props, ref) {
  var _a = __read$o(useState(true), 2), visible = _a[0], setVisible = _a[1];
  var _b = __read$o(useState(props), 2), config2 = _b[0], setConfig = _b[1];
  useImperativeHandle(ref, function() {
    return {
      update: setConfig,
      close: function() {
        setVisible(false);
      }
    };
  });
  function onOk() {
    var ret = config2.onOk && config2.onOk();
    if (ret && ret.then) {
      setConfig(__assign$p(__assign$p({}, config2), { confirmLoading: true }));
      ret.then(function() {
        setVisible(false);
      }, function(e) {
        console.error(e);
        setConfig(__assign$p(__assign$p({}, config2), { confirmLoading: false }));
      });
    }
    if (!ret) {
      setVisible(false);
    }
  }
  function onCancel() {
    config2.onCancel && config2.onCancel();
    setVisible(false);
  }
  return React__default.createElement(Modal$1, __assign$p({ unmountOnExit: true, simple: true }, config2, { visible, onOk, onCancel }), config2.content);
}
var HookModal$1 = forwardRef(HookModal);
var __assign$o = globalThis && globalThis.__assign || function() {
  __assign$o = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$o.apply(this, arguments);
};
function useModal() {
  var contextHolderRef = createRef();
  var holderEle = React__default.createElement(ContextHolderElement$1, { ref: contextHolderRef });
  var uuid2 = 0;
  function addNewModal(config2) {
    var _a;
    uuid2 += 1;
    var modalRef = createRef();
    function afterClose() {
      config2.afterClose && config2.afterClose();
      removeModalInstance();
    }
    var modal = React__default.createElement(HookModal$1, __assign$o({ key: uuid2, ref: modalRef }, normalizeConfig(config2), { afterClose }));
    contextHolderRef.current.addInstance(modal);
    function removeModalInstance() {
      contextHolderRef.current.removeInstance(modal);
    }
    function close() {
      modalRef.current.close();
    }
    destroyList.push(close);
    return {
      close,
      update: (_a = modalRef.current) === null || _a === void 0 ? void 0 : _a.update
    };
  }
  var modalFuncs = {
    confirm: function(config2) {
      return addNewModal(__assign$o({}, config2));
    }
  };
  ["info", "success", "warning", "error"].forEach(function(type) {
    modalFuncs[type] = function(config2) {
      return addNewModal(__assign$o(__assign$o({}, config2), { isNotice: true, noticeType: type }));
    };
  });
  return [modalFuncs, holderEle];
}
var __assign$n = globalThis && globalThis.__assign || function() {
  __assign$n = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$n.apply(this, arguments);
};
var __rest$8 = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$n = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var cursorPosition = null;
var globalDialogIndex = 0;
if (!isServerRendering) {
  document.documentElement.addEventListener("click", function(e) {
    cursorPosition = {
      left: e.clientX,
      top: e.clientY
    };
    setTimeout(function() {
      cursorPosition = null;
    }, 100);
  }, true);
}
var defaultProps$6 = {
  mask: true,
  maskClosable: true,
  mountOnEnter: true,
  escToExit: true,
  getPopupContainer: function() {
    return document.body;
  },
  alignCenter: true
};
function Modal(baseProps, ref) {
  var _a, _b;
  var _c;
  var context = useContext(ConfigContext);
  var props = useMergeProps(baseProps, defaultProps$6, (_c = context.componentConfig) === null || _c === void 0 ? void 0 : _c.Modal);
  var className = props.className, style = props.style, visible = props.visible, simple = props.simple, title2 = props.title, children = props.children, cancelText = props.cancelText, okText = props.okText, okButtonProps = props.okButtonProps, cancelButtonProps = props.cancelButtonProps, _d = props.getPopupContainer, getPopupContainer = _d === void 0 ? function() {
    return document.body;
  } : _d, footer = props.footer, afterClose = props.afterClose, confirmLoading = props.confirmLoading, mountOnEnter = props.mountOnEnter, unmountOnExit = props.unmountOnExit, afterOpen = props.afterOpen, hideCancel = props.hideCancel, autoFocus = props.autoFocus, focusLock = props.focusLock, maskClosable = props.maskClosable, mask2 = props.mask, alignCenter = props.alignCenter, getChildrenPopupContainer = props.getChildrenPopupContainer, wrapClassName = props.wrapClassName, escToExit = props.escToExit, modalRender = props.modalRender, maskStyle = props.maskStyle, wrapStyle = props.wrapStyle, closeIcon = props.closeIcon, rest = __rest$8(props, ["className", "style", "visible", "simple", "title", "children", "cancelText", "okText", "okButtonProps", "cancelButtonProps", "getPopupContainer", "footer", "afterClose", "confirmLoading", "mountOnEnter", "unmountOnExit", "afterOpen", "hideCancel", "autoFocus", "focusLock", "maskClosable", "mask", "alignCenter", "getChildrenPopupContainer", "wrapClassName", "escToExit", "modalRender", "maskStyle", "wrapStyle", "closeIcon"]);
  var modalWrapperRef = useRef(null);
  var contentWrapper = useRef(null);
  var _e = __read$n(useState(visible), 2), wrapperVisible = _e[0], setWrapperVisible = _e[1];
  var _f = __read$n(useState(), 2), popupZIndex = _f[0], setPopupZIndex = _f[1];
  var cursorPositionRef = useRef(null);
  var haveOriginTransformOrigin = useRef(false);
  var maskClickRef = useRef(false);
  var dialogIndex = useRef();
  if (!dialogIndex.current) {
    dialogIndex.current = globalDialogIndex++;
  }
  var _g = __read$n(useMergeValue(false, {
    defaultValue: false,
    value: confirmLoading
  }), 2), loading = _g[0], setLoading = _g[1];
  var prefixCls2 = context.getPrefixCls("modal", props.prefixCls);
  var locale = context.locale;
  var defaultClosable = !simple;
  var closable = "closable" in props ? props.closable : defaultClosable;
  var getContainer = useCallback(function() {
    return findDOMNode(getPopupContainer());
  }, [getPopupContainer]);
  useOverflowHidden(getContainer, { hidden: visible && mask2 });
  var onCancel = function() {
    props.onCancel && props.onCancel();
  };
  var onEscExit = function(event2) {
    if (escToExit && visible && event2.key === Esc.key) {
      event2.stopPropagation();
      onCancel();
    }
  };
  var inExit = useRef(false);
  var onClickMask = function(e) {
    if (!maskClickRef.current)
      return;
    maskClickRef.current = false;
    if (!inExit.current && maskClosable && mask2 && e.target === e.currentTarget) {
      setTimeout(function() {
        onCancel();
      }, 100);
    }
  };
  var onConfirmModal = function(e) {
    var onConfirm = props.onConfirm, onOk = props.onOk;
    var _onConfirm = onOk || onConfirm;
    var ret;
    if (_onConfirm) {
      ret = _onConfirm(e);
    }
    if (ret && ret.then) {
      setLoading(true);
      ret.then(function() {
        setLoading(false);
      }, function(e2) {
        setLoading(false);
        console.error(e2);
      });
    }
  };
  useEffect(function() {
    var timer = null;
    if (escToExit) {
      timer = setTimeout(function() {
        var _a2;
        (_a2 = modalWrapperRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
      });
    }
    return function() {
      timer && clearTimeout(timer);
    };
  }, [visible, escToExit]);
  useEffect(function() {
    var _a2;
    if (visible && popupZIndex === void 0) {
      if (modalWrapperRef.current) {
        var zIndex = +((_a2 = window.getComputedStyle(modalWrapperRef.current, null)) === null || _a2 === void 0 ? void 0 : _a2.zIndex);
        if (!isNaN(zIndex)) {
          setPopupZIndex(zIndex + 1);
        }
      }
    }
  }, [visible, popupZIndex]);
  var renderFooter = function() {
    if (footer === null)
      return;
    var cancelButtonNode = React__default.createElement(Button$4, __assign$n({ onClick: onCancel }, cancelButtonProps), cancelText || locale.Modal.cancelText);
    var okButtonNode = React__default.createElement(Button$4, __assign$n({ loading, onClick: onConfirmModal, type: "primary" }, okButtonProps), okText || locale.Modal.okText);
    var footerContent = isFunction$5(footer) ? footer(cancelButtonNode, okButtonNode) : footer || React__default.createElement(React__default.Fragment, null, !hideCancel && cancelButtonNode, okButtonNode);
    return React__default.createElement("div", { className: prefixCls2 + "-footer" }, footerContent);
  };
  var globalFocusLockConfig = context.focusLock.modal;
  var globalFocusLock = !!globalFocusLockConfig;
  var globalAutoFocus = isObject$e(globalFocusLockConfig) && globalFocusLockConfig.autoFocus;
  var innerFocusLock = focusLock !== void 0 ? focusLock : globalFocusLock;
  var innerAutoFocus = autoFocus !== void 0 ? autoFocus : globalAutoFocus;
  var element = React__default.createElement(ConfigProvider, __assign$n({}, context, { prefixCls: props.prefixCls || context.prefixCls, locale, zIndex: popupZIndex || 1050, getPopupContainer: function(node) {
    return typeof getChildrenPopupContainer === "function" ? getChildrenPopupContainer(node) : contentWrapper.current;
  } }), title2 && React__default.createElement("div", { className: prefixCls2 + "-header" }, React__default.createElement("div", { className: prefixCls2 + "-title", id: "arco-dialog-" + dialogIndex.current }, title2)), React__default.createElement("div", { ref: contentWrapper, className: prefixCls2 + "-content" }, children), renderFooter(), closable && (closeIcon !== void 0 ? React__default.createElement("span", { onClick: onCancel, className: prefixCls2 + "-close-icon" }, closeIcon) : React__default.createElement(IconHover, { tabIndex: -1, onClick: onCancel, className: prefixCls2 + "-close-icon", role: "button", "aria-label": "Close" }, React__default.createElement(IconClose$1, null))));
  var ariaProps = title2 ? { "aria-labelledby": "arco-dialog-" + dialogIndex.current } : {};
  var modalDom = React__default.createElement("div", __assign$n({ role: "dialog" }, ariaProps, { className: cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-simple"] = simple, _a), className), style }), innerFocusLock ? React__default.createElement(FocusLock, { disabled: !visible, autoFocus: innerAutoFocus, lockProps: {
    tabIndex: -1,
    onKeyDown: onEscExit
  } }, element) : element);
  var setTransformOrigin = function(e) {
    if (haveOriginTransformOrigin.current)
      return;
    var transformOrigin = "";
    if (cursorPositionRef.current) {
      var eRect = e.getBoundingClientRect();
      var _a2 = cursorPositionRef.current, left = _a2.left, top_1 = _a2.top;
      transformOrigin = left - eRect.left + "px " + (top_1 - eRect.top) + "px";
    }
    e.style.transformOrigin = transformOrigin;
  };
  return React__default.createElement(Portal, { visible, forceRender: !mountOnEnter, getContainer: getPopupContainer }, React__default.createElement("div", { ref }, mask2 ? React__default.createElement(CSSTransition$1, { in: visible, timeout: 400, appear: true, mountOnEnter, classNames: "fadeModal", unmountOnExit, onEnter: function(e) {
    e.style.display = "block";
  }, onExited: function(e) {
    e.style.display = "none";
  } }, React__default.createElement("div", { "aria-hidden": true, className: prefixCls2 + "-mask", style: maskStyle })) : null, React__default.createElement("div", __assign$n({}, omit$1(rest, [
    "content",
    "icon",
    "showIcon",
    "isNotice",
    "noticeType",
    "onCancel",
    "onOk",
    "onConfirm",
    "closable",
    "prefixCls"
  ]), {
    tabIndex: !innerFocusLock || !innerAutoFocus ? -1 : null,
    ref: modalWrapperRef,
    className: cs$1(prefixCls2 + "-wrapper", (_b = {}, _b[prefixCls2 + "-wrapper-no-mask"] = !mask2, _b[prefixCls2 + "-wrapper-align-center"] = alignCenter, _b), wrapClassName),
    style: __assign$n(__assign$n({}, wrapStyle || {}), {
      display: visible || wrapperVisible ? "block" : "none",
      overflow: !visible && wrapperVisible ? "hidden" : ""
    }),
    onKeyDown: !innerFocusLock || !innerAutoFocus ? onEscExit : null,
    onMouseDown: function(e) {
      maskClickRef.current = e.target === e.currentTarget;
    },
    onClick: onClickMask
  }), React__default.createElement(CSSTransition$1, { in: visible, timeout: 400, appear: true, classNames: "zoomModal", unmountOnExit, mountOnEnter, onEnter: function(e) {
    setWrapperVisible(true);
    cursorPositionRef.current = cursorPosition;
    haveOriginTransformOrigin.current = !!e.style.transformOrigin;
    setTransformOrigin(e);
  }, onEntered: function(e) {
    setTransformOrigin(e);
    cursorPositionRef.current = null;
    afterOpen && afterOpen();
  }, onExit: function() {
    inExit.current = true;
  }, onExited: function(e) {
    setWrapperVisible(false);
    setTransformOrigin(e);
    afterClose && afterClose();
    inExit.current = false;
  } }, React__default.cloneElement(isFunction$5(modalRender) ? modalRender(modalDom) : modalDom, {
    onMouseDown: function() {
      maskClickRef.current = false;
    },
    onMouseUp: function() {
      maskClickRef.current = false;
    }
  })))));
}
var ExportedModalComponent = forwardRef(Modal);
ExportedModalComponent.displayName = "Modal";
ExportedModalComponent.config = setModalConfig;
ExportedModalComponent.confirm = function(props) {
  return confirm(props);
};
ExportedModalComponent.useModal = useModal;
["info", "success", "warning", "error"].forEach(function(type) {
  ExportedModalComponent[type] = function(props) {
    return confirm(__assign$n(__assign$n({}, props), { isNotice: true, noticeType: type }));
  };
});
ExportedModalComponent.destroyAll = function() {
  while (destroyList.length) {
    var close_1 = destroyList.pop();
    if (close_1) {
      close_1();
    }
  }
};
var Modal$1 = ExportedModalComponent;
var __read$m = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var SliderButton = function(props) {
  var _a;
  var style = props.style, disabled = props.disabled, prefixCls2 = props.prefixCls, value = props.value, vertical = props.vertical, tooltipVisible = props.tooltipVisible, tooltipPosition = props.tooltipPosition, formatTooltip = props.formatTooltip, getTooltipContainer = props.getTooltipContainer, onMoving = props.onMoving, onMoveEnd = props.onMoveEnd, onMoveBegin = props.onMoveBegin;
  var _b = __read$m(useState(false), 2), isActive = _b[0], setIsActive = _b[1];
  var _c = __read$m(useMergeValue(false, { value: tooltipVisible }), 2), popupVisible = _c[0], setPopupVisible = _c[1];
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var position = useMemo(function() {
    return tooltipPosition || (vertical ? "right" : "top");
  }, [tooltipPosition, vertical]);
  var delayTimer = useRef(null);
  var inButtonOrPopup = useRef(false);
  var isDragging = useRef(false);
  var tooltip = useRef(null);
  function handleMouseDown(e) {
    e.stopPropagation();
    if (disabled)
      return;
    moveStart(e);
    setIsActive(true);
    on(window, "mousemove", moving);
    on(window, "touchmove", moving);
    on(window, "mouseup", moveEnd);
    on(window, "touchend", moveEnd);
    on(window, "contextmenu", moveEnd);
  }
  function handleMouseEnter() {
    inButtonOrPopup.current = true;
    clearDelayTimer();
    if (!popupVisible) {
      delayTimer.current = setTimeout(function() {
        updatePopupVisible(true);
      }, 50);
    }
  }
  function handleMouseLeave() {
    inButtonOrPopup.current = false;
    if (!isDragging.current) {
      clearDelayTimer();
      delayTimer.current = setTimeout(function() {
        updatePopupVisible(false);
      }, 200);
    }
  }
  function moveStart(e) {
    e.preventDefault();
    var activeElement = document.activeElement;
    activeElement && activeElement.blur && activeElement.blur();
    isFunction$5(onMoveBegin) && onMoveBegin();
  }
  function moving(e) {
    isDragging.current = true;
    if (e.type === "touchstart") {
      e.clientY = e.touches[0].clientY;
      e.clientX = e.touches[0].clientX;
    }
    isFunction$5(onMoving) && onMoving(e.clientX, e.clientY);
  }
  function moveEnd() {
    isDragging.current = false;
    setIsActive(false);
    offEvents();
    updatePopupVisible(inButtonOrPopup.current);
    isFunction$5(onMoveEnd) && onMoveEnd();
  }
  function offEvents() {
    clearDelayTimer();
    off(window, "mousemove", moving);
    off(window, "touchmove", moving);
    off(window, "mouseup", moveEnd);
    off(window, "touchend", moveEnd);
    off(window, "contextmenu", moveEnd);
  }
  function clearDelayTimer() {
    if (delayTimer.current) {
      clearTimeout(delayTimer.current);
      delayTimer.current = null;
    }
  }
  function updatePopupVisible(value2) {
    if (isDragging.current)
      return;
    var newPopupVisible = "tooltipVisible" in props ? tooltipVisible : value2;
    setPopupVisible(newPopupVisible);
  }
  function handlePopupMouseEnter() {
    inButtonOrPopup.current = true;
    clearDelayTimer();
  }
  var tooltipText = useMemo(function() {
    return isFunction$5(formatTooltip) ? formatTooltip(value) : value;
  }, [formatTooltip, value]);
  function renderTooltipContent(position2) {
    var tooltipPrefixCls = getPrefixCls("tooltip");
    return React__default.createElement("div", { className: cs$1(tooltipPrefixCls + "-content", tooltipPrefixCls + "-content-" + position2), onMouseLeave: handleMouseLeave, onMouseEnter: handlePopupMouseEnter, onClick: function(e) {
      e.stopPropagation();
    } }, React__default.createElement("div", { className: tooltipPrefixCls + "-content-inner" }, tooltipText));
  }
  useEffect(function() {
    tooltip && tooltip.current && tooltip.current.updatePopupPosition();
  }, [value]);
  return React__default.createElement(Trigger$1, { style: { maxWidth: 350 }, classNames: "zoomInFadeOut", duration: {
    enter: 300,
    exit: 100
  }, showArrow: true, popupAlign: {
    left: 12,
    right: 12,
    top: 12,
    bottom: 12
  }, ref: tooltip, popup: function() {
    return renderTooltipContent(position);
  }, popupVisible, disabled: tooltipVisible === false, getPopupContainer: getTooltipContainer, position, childrenPrefix: getPrefixCls("tooltip") }, React__default.createElement("div", { className: cs$1(prefixCls2 + "-button", (_a = {}, _a[prefixCls2 + "-button-active"] = isActive, _a)), onMouseDown: handleMouseDown, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, style, role: "slider", "aria-valuemax": props.maxValue, "aria-valuemin": props.minValue, "aria-valuenow": value, "aria-disabled": !!disabled, tabIndex: 0, "aria-valuetext": isString$1(tooltipText) || isNumber$1(tooltipText) ? String(tooltipText) : void 0 }));
};
var SliderButton$1 = memo(SliderButton);
var __read$l = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function getPrecision(val) {
  var decimal = ("" + val).split(".")[1];
  return decimal && decimal.length || 0;
}
function formatPercent(val) {
  return val * 100 + "%";
}
function getOffset(val, range2) {
  var value = Number(val);
  if (range2 && !isNaN(value)) {
    var _a = __read$l(range2, 2), min = _a[0], max = _a[1];
    return divide(minus(value, min), minus(max, min));
  }
  return 0;
}
function valueInRange(val, range2) {
  var value = Number(val);
  range2.sort(function(a, b) {
    return a - b;
  });
  return value >= range2[0] && value <= range2[1];
}
function isNotEmpty(val) {
  return val || val === 0;
}
function rateToFloat(val) {
  var rate = parseFloat(val);
  var fixedRate = rate > 1 ? (rate / 100).toFixed(2) : rate;
  var floatRate = parseFloat(fixedRate);
  if (!isNaN(floatRate) && floatRate >= 0 && floatRate <= 1) {
    return floatRate;
  }
  return void 0;
}
function getIntervalOffset(val, intervalConfig) {
  var currentInterval = intervalConfig.find(function(config2) {
    return val >= config2.begin && val <= config2.end;
  });
  if (currentInterval) {
    var beginOffset = currentInterval.beginOffset, begin = currentInterval.begin, end = currentInterval.end, endOffset = currentInterval.endOffset;
    var offsetInInterval = getOffset(val, [begin, end]);
    var intervalOffset = minus(endOffset, beginOffset);
    var offset = times(offsetInInterval, intervalOffset);
    return plus(beginOffset, offset);
  }
}
var Marks = function(props) {
  var _a = props.data, data = _a === void 0 ? [] : _a, vertical = props.vertical, prefixCls2 = props.prefixCls, reverse = props.reverse, intervalConfigs = props.intervalConfigs;
  if (!data.length)
    return null;
  return React__default.createElement("div", { className: prefixCls2 + "-marks" }, data.map(function(_a2) {
    var _b, _c;
    var key = _a2.key, content = _a2.content;
    var offset = formatPercent(getIntervalOffset(+key, intervalConfigs));
    var dom = null;
    if (isObject$e(content) && isNotEmpty(content.text)) {
      dom = content.text;
    } else if (isNotEmpty(content)) {
      dom = content;
    }
    return isNotEmpty(dom) && React__default.createElement("div", { className: prefixCls2 + "-marks-text", "aria-hidden": true, key, style: vertical ? (_b = {}, _b[reverse ? "top" : "bottom"] = offset, _b) : (_c = {}, _c[reverse ? "right" : "left"] = offset, _c), onMouseDown: function(e) {
      e.stopPropagation();
      isFunction$5(props.onMouseDown) && props.onMouseDown(parseFloat(key));
    } }, dom);
  }));
};
var Marks$1 = memo(Marks);
var __assign$m = globalThis && globalThis.__assign || function() {
  __assign$m = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$m.apply(this, arguments);
};
var Dots = function(props) {
  var _a = props.data, data = _a === void 0 ? [] : _a, _b = props.value, value = _b === void 0 ? [] : _b, vertical = props.vertical, prefixCls2 = props.prefixCls, reverse = props.reverse, intervalConfigs = props.intervalConfigs;
  if (!data.length)
    return null;
  return React__default.createElement("div", { className: prefixCls2 + "-dots" }, data.map(function(_a2) {
    var _b2, _c, _d;
    var key = _a2.key, content = _a2.content;
    var offset = formatPercent(getIntervalOffset(+key, intervalConfigs));
    return React__default.createElement("div", { className: prefixCls2 + "-dot-wrapper", key, style: __assign$m({}, vertical ? (_b2 = {}, _b2[reverse ? "top" : "bottom"] = offset, _b2) : (_c = {}, _c[reverse ? "right" : "left"] = offset, _c)), onMouseDown: function(e) {
      e.stopPropagation();
      isFunction$5(props.onMouseDown) && props.onMouseDown(parseFloat(key));
    } }, isObject$e(content) && content.dot ? content.dot : React__default.createElement("div", { className: cs$1(prefixCls2 + "-dot", (_d = {}, _d[prefixCls2 + "-dot-active"] = valueInRange(key, value), _d)) }));
  }));
};
var Dots$1 = memo(Dots);
var __assign$l = globalThis && globalThis.__assign || function() {
  __assign$l = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$l.apply(this, arguments);
};
var __read$k = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$8 = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Input$1 = function(props) {
  var _a;
  var value = props.value, range2 = props.range, min = props.min, max = props.max, step = props.step, disabled = props.disabled, prefixCls2 = props.prefixCls, onChange = props.onChange, _b = props.extra, extra = _b === void 0 ? [] : _b;
  var baseProps = {
    min,
    max,
    step,
    disabled
  };
  var _c = __read$k(useState(value), 2), innerValue = _c[0], setInnerValue = _c[1];
  var beginExtraProps = extra[0];
  var endExtraProps = range2 ? extra[1] : extra[0];
  useEffect(function() {
    setInnerValue(value);
  }, [value]);
  var handleChange = function(val) {
    onChange === null || onChange === void 0 ? void 0 : onChange(val);
  };
  var handleBlur = function() {
    setInnerValue(__spreadArray$8([], __read$k(value), false).sort(function(a, b) {
      return a - b;
    }));
  };
  return React__default.createElement("div", { className: cs$1(prefixCls2 + "-input", (_a = {}, _a[prefixCls2 + "-input-group"] = range2, _a)), onBlur: handleBlur }, range2 && [
    React__default.createElement(InputNumber$1, __assign$l({}, __assign$l(__assign$l({ hideControl: true }, beginExtraProps), baseProps), { value: innerValue[0], key: 0, onChange: function(val) {
      handleChange([val, innerValue[1]]);
      (beginExtraProps === null || beginExtraProps === void 0 ? void 0 : beginExtraProps.onChange) && (beginExtraProps === null || beginExtraProps === void 0 ? void 0 : beginExtraProps.onChange(val));
    } })),
    React__default.createElement("div", { key: 1, className: prefixCls2 + "-input-range" }, React__default.createElement("span", { className: prefixCls2 + "-input-range-content" }))
  ], React__default.createElement(InputNumber$1, __assign$l({}, __assign$l(__assign$l({ hideControl: true }, endExtraProps), baseProps), { key: 2, value: innerValue[1], onChange: function(val) {
    handleChange([innerValue[0], val]);
    (endExtraProps === null || endExtraProps === void 0 ? void 0 : endExtraProps.onChange) && (endExtraProps === null || endExtraProps === void 0 ? void 0 : endExtraProps.onChange(val));
  } })));
};
var Input$2 = memo(Input$1);
var Ticks = memo(function Ticks2(props) {
  var min = props.min, max = props.max, value = props.value, prefixCls2 = props.prefixCls, vertical = props.vertical, reverse = props.reverse, intervalConfigs = props.intervalConfigs;
  var stepsMap = new Map();
  var getCurrentSteps = function(interval) {
    var step = interval.step, begin = interval.begin, end = interval.end;
    var stepsLength = Math.floor((end - begin) / step);
    for (var i2 = 0; i2 <= stepsLength; i2++) {
      var stepVal = plus(i2 * step, begin);
      if (stepVal <= min || stepVal >= max)
        continue;
      var offset = formatPercent(getIntervalOffset(stepVal, intervalConfigs));
      stepsMap.set(offset, { offset, isActive: valueInRange(stepVal, value) });
    }
  };
  var steps = useMemo(function() {
    stepsMap.clear();
    intervalConfigs.forEach(function(interval) {
      return getCurrentSteps(interval);
    });
    return Array.from(stepsMap.values());
  }, [intervalConfigs]);
  return React__default.createElement("div", { className: prefixCls2 + "-ticks" }, steps.map(function(item2, index2) {
    var _a, _b, _c;
    return React__default.createElement("div", { key: index2, className: cs$1(prefixCls2 + "-tick", (_a = {}, _a[prefixCls2 + "-tick-active"] = item2.isActive, _a)), style: vertical ? (_b = {}, _b[reverse ? "top" : "bottom"] = item2.offset, _b) : (_c = {}, _c[reverse ? "right" : "left"] = item2.offset, _c) });
  }));
});
var __read$j = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function useLegalValue(props) {
  var isRange = props.isRange, min = props.min, max = props.max, onlyMarkValue = props.onlyMarkValue, intervalConfigs = props.intervalConfigs, marks = props.marks;
  function getPrecisionValue(val) {
    var _a = intervalConfigs.find(function(config2) {
      return val >= config2.begin && val <= config2.end;
    }), begin = _a.begin, step = _a.step;
    var offsetVal = val - begin;
    var stepNum = Math.round(offsetVal / step);
    var precision = getPrecision(step);
    var currentIntervalPrecision = parseFloat(times(step, stepNum).toFixed(precision));
    return plus(begin, currentIntervalPrecision);
  }
  function getMarkValue(val) {
    if (!isObject$e(marks) || isEmptyObject$1(marks)) {
      console.warn("marks must be an object when onlyMarkValue is true");
      return min;
    }
    if (marks[val]) {
      return val;
    }
    var keys2 = Object.keys(marks);
    var diffs = keys2.map(function(x) {
      return Math.abs(val - parseFloat(x));
    });
    var minIndex = diffs.indexOf(Math.min.apply(null, diffs));
    return parseFloat(keys2[minIndex]);
  }
  function getLegalValue(val) {
    if (isUndefined(val))
      return min;
    if (val <= min)
      return min;
    if (val >= max)
      return max;
    if (onlyMarkValue)
      return getMarkValue(val);
    return getPrecisionValue(val);
  }
  function isLegalValue(val) {
    return getLegalValue(val) === val;
  }
  function getLegalRangeValue(val) {
    var _a = __read$j([min, min], 2), beginVal = _a[0], endVal = _a[1];
    if (isRange) {
      if (isArray$c(val)) {
        beginVal = getLegalValue(val[0]);
        endVal = getLegalValue(val[1]);
      } else {
        console.error("value must be an array when range is true");
      }
    } else if (isNumber$1(val)) {
      endVal = getLegalValue(val);
    } else {
      console.error("value must be a number when range is false");
    }
    return [beginVal, endVal];
  }
  return {
    getLegalRangeValue,
    getLegalValue,
    isLegalValue
  };
}
var __read$i = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function getIntervals(nums) {
  if (nums.length < 2) {
    return [];
  }
  var result = [];
  for (var i2 = 1; i2 < nums.length; i2++) {
    var begin = nums[i2 - 1];
    var end = nums[i2];
    result.push([begin, end]);
  }
  return result;
}
function useInterval(props) {
  var _a = props.marks, marks = _a === void 0 ? {} : _a, getIntervalConfig = props.getIntervalConfig, max = props.max, min = props.min;
  var _b = useMemo(function() {
    var markKeys = Object.keys(marks).filter(function(key) {
      return isNumber$1(+key) && +key >= min && +key <= max;
    }).sort(function(a, b) {
      return +a > +b ? 1 : -1;
    });
    var markList2 = markKeys.map(function(key) {
      return { key, content: marks[key] };
    });
    var markValues = markKeys.map(function(key) {
      return +key;
    });
    if (markValues.length === 0) {
      markValues = [min, max];
    } else {
      if (markValues[0] > min) {
        markValues.unshift(min);
        markList2.unshift({ key: "" + min, content: "" });
      }
      if (markValues.slice(-1)[0] < max) {
        markValues.push(max);
        markList2.push({ key: "" + max, content: "" });
      }
    }
    var markIntervals2 = getIntervals(markValues);
    return { markIntervals: markIntervals2, markList: markList2 };
  }, [marks, min, max]), markIntervals = _b.markIntervals, markList = _b.markList;
  if (!isFunction$5(getIntervalConfig)) {
    return {
      intervalConfigs: [
        { begin: min, end: max, step: props.step, beginOffset: 0, endOffset: 1, width: 1 }
      ],
      markList
    };
  }
  var getStepAndWidth = function(_a2, index2) {
    var _b2 = __read$i(_a2, 2), begin = _b2[0], end = _b2[1];
    var config2 = { step: props.step, width: 0 };
    var customConfig = getIntervalConfig([begin, end], index2) || {};
    var step = customConfig.step;
    var width = rateToFloat(customConfig.width);
    if (isNumber$1(step) && step) {
      config2.step = step;
    }
    if (isNumber$1(width) && width) {
      config2.width = width;
    }
    return config2;
  };
  var getIntervalConfigs = function() {
    var remainWidth = 1;
    var remainLen = max - min;
    var stepAndWidthConfig = markIntervals.map(function(_a2, index2) {
      var _b2 = __read$i(_a2, 2), begin = _b2[0], end = _b2[1];
      var stepAndWidth = getStepAndWidth([begin, end], index2);
      var width = stepAndWidth.width;
      if (width) {
        width = Math.min(remainWidth, width);
        var len = end - begin;
        remainLen -= len;
        remainWidth -= width;
      }
      return { width, step: stepAndWidth.step };
    });
    if (stepAndWidthConfig.every(function(_a2) {
      var width = _a2.width;
      return width;
    }) && remainWidth) {
      var lastIntervalConfig = stepAndWidthConfig[markIntervals.length - 1];
      lastIntervalConfig.width += remainWidth;
    }
    var allConfigs = [];
    markIntervals.forEach(function(_a2, index2) {
      var _b2 = __read$i(_a2, 2), begin = _b2[0], end = _b2[1];
      var _c = stepAndWidthConfig[index2], step = _c.step, width = _c.width;
      var config2 = { begin, end, step, beginOffset: 0, endOffset: 0, width };
      if (!config2.width) {
        config2.width = remainWidth * ((end - begin) / remainLen);
      }
      var prevIndex = allConfigs.length - 1;
      if (allConfigs[prevIndex]) {
        config2.beginOffset = allConfigs[prevIndex].endOffset;
      }
      config2.endOffset = Math.min(1, config2.beginOffset + config2.width);
      allConfigs.push(config2);
    });
    return allConfigs;
  };
  var intervalConfigs = getIntervalConfigs();
  return {
    intervalConfigs,
    markList
  };
}
var __assign$k = globalThis && globalThis.__assign || function() {
  __assign$k = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$k.apply(this, arguments);
};
var __read$h = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$7 = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function isSameOrder(firstNums, secondNums) {
  var diff1 = firstNums[0] - firstNums[1];
  var diff2 = secondNums[0] - secondNums[1];
  return diff1 <= 0 === diff2 <= 0;
}
var defaultProps$5 = {
  max: 100,
  min: 0,
  step: 1
};
function Slider(baseProps, ref) {
  var _a, _b, _c;
  var _d = useContext(ConfigContext), getPrefixCls = _d.getPrefixCls, componentConfig2 = _d.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$5, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Slider);
  var className = props.className, style = props.style, tooltipVisible = props.tooltipVisible, tooltipPosition = props.tooltipPosition, disabled = props.disabled, min = props.min, max = props.max, propRange = props.range, step = props.step, showTicks = props.showTicks, marks = props.marks, onlyMarkValue = props.onlyMarkValue, vertical = props.vertical, showInput = props.showInput, reverse = props.reverse, getIntervalConfig = props.getIntervalConfig;
  var range2 = !!propRange;
  var rangeConfig = isObject$e(propRange) ? __assign$k({}, propRange) : { draggableBar: false };
  var _e = useInterval({
    min,
    max,
    onlyMarkValue,
    step,
    marks,
    getIntervalConfig
  }), intervalConfigs = _e.intervalConfigs, markList = _e.markList;
  var _f = useLegalValue({
    isRange: range2,
    min,
    max,
    onlyMarkValue,
    step,
    intervalConfigs,
    marks
  }), getLegalValue = _f.getLegalValue, getLegalRangeValue = _f.getLegalRangeValue, isLegalValue = _f.isLegalValue;
  var _g = __read$h(useMergeValue(range2 ? [min, min] : min, {
    defaultValue: props.defaultValue,
    value: props.value
  }), 2), value = _g[0], setValue = _g[1];
  var curVal = getLegalRangeValue(value);
  var lastVal = useRef(curVal);
  var _h = __read$h(curVal, 2), beginVal = _h[0], endVal = _h[1];
  useUpdate(function() {
    lastVal.current = getLegalRangeValue(value);
  }, [value, getLegalRangeValue]);
  if (!isSameOrder(curVal, lastVal.current)) {
    _a = __read$h([endVal, beginVal], 2), beginVal = _a[0], endVal = _a[1];
  }
  var beginOffset = getIntervalOffset(beginVal, intervalConfigs);
  var endOffset = getIntervalOffset(endVal, intervalConfigs);
  var isShowInput = showInput && !onlyMarkValue;
  var extraInputProps = useMemo(function() {
    if (isShowInput && (isArray$c(showInput) || isObject$e(showInput))) {
      return isArray$c(showInput) ? __spreadArray$7([], __read$h(showInput), false) : [__assign$k({}, showInput), __assign$k({}, showInput)];
    }
    return [];
  }, [isShowInput, showInput]);
  var prefixCls2 = getPrefixCls("slider");
  var roadRef = useRef(null);
  var position = useRef({
    left: 0,
    height: 0,
    top: 0,
    width: 0
  });
  var isDragging = useRef(false);
  var barStartDragVal = useRef(0);
  function getEmitParams(_a2) {
    var _b2;
    var _c2 = __read$h(_a2, 2), beginVal2 = _c2[0], endVal2 = _c2[1];
    if (beginVal2 > endVal2) {
      _b2 = __read$h([endVal2, beginVal2], 2), beginVal2 = _b2[0], endVal2 = _b2[1];
    }
    return range2 ? [beginVal2, endVal2] : endVal2;
  }
  function updateValue(val) {
    var _a2 = __read$h(val, 2), newBeginVal = _a2[0], newEndVal = _a2[1];
    newBeginVal = getLegalValue(newBeginVal);
    newEndVal = getLegalValue(newEndVal);
    lastVal.current = [newBeginVal, newEndVal];
    var emitParams = getEmitParams([newBeginVal, newEndVal]);
    setValue(emitParams);
    return emitParams;
  }
  function onChange(val) {
    var emitParams = updateValue(val);
    if (isFunction$5(props.onChange)) {
      props.onChange(emitParams);
    }
  }
  function onMouseUp() {
    if (isFunction$5(props.onAfterChange)) {
      var emitParams = getEmitParams(lastVal.current);
      props.onAfterChange(emitParams);
    }
  }
  function inRange(val) {
    var _a2;
    var _b2 = __read$h([beginVal, endVal], 2), range1 = _b2[0], range22 = _b2[1];
    if (range1 > range22) {
      _a2 = __read$h([range22, range1], 2), range1 = _a2[0], range22 = _a2[1];
    }
    if (range2)
      return val >= range1 && val <= range22;
    return val <= range22;
  }
  function getValueByCoords(x, y) {
    var _a2 = position.current, left = _a2.left, top = _a2.top, width = _a2.width, height = _a2.height;
    var roadLength = width;
    var diff = reverse ? left + width - x : x - left;
    if (vertical) {
      roadLength = height;
      diff = reverse ? y - top : top + height - y;
    }
    if (roadLength <= 0) {
      return 0;
    }
    var offset = Math.max(divide(diff, roadLength), 0);
    offset = Math.min(1, offset);
    var currentInterval = intervalConfigs.find(function(config2) {
      return offset >= config2.beginOffset && offset <= config2.endOffset;
    });
    var begin = currentInterval.begin, beginOffset2 = currentInterval.beginOffset, currentStep = currentInterval.step, endOffset2 = currentInterval.endOffset, end = currentInterval.end;
    var currentValueOffset = offset - beginOffset2;
    var currentIntervalOffset = endOffset2 - beginOffset2;
    var valueInInterval = currentValueOffset / currentIntervalOffset * (end - begin);
    var stepNum = Math.round(valueInInterval / currentStep);
    return plus(begin, times(stepNum, currentStep));
  }
  function getBarStyle(offsets) {
    var _a2, _b2, _c2;
    var _d2 = __read$h(offsets, 2), begin = _d2[0], end = _d2[1];
    if (begin > end) {
      _a2 = __read$h([end, begin], 2), begin = _a2[0], end = _a2[1];
    }
    var beginOffset2 = formatPercent(begin);
    var endOffset2 = formatPercent(1 - end);
    return vertical ? (_b2 = {}, _b2[reverse ? "top" : "bottom"] = beginOffset2, _b2[reverse ? "bottom" : "top"] = endOffset2, _b2) : (_c2 = {}, _c2[reverse ? "right" : "left"] = beginOffset2, _c2[reverse ? "left" : "right"] = endOffset2, _c2);
  }
  function getBtnStyle(offset) {
    var _a2, _b2;
    return vertical ? (_a2 = {}, _a2[reverse ? "top" : "bottom"] = formatPercent(offset), _a2) : (_b2 = {}, _b2[reverse ? "right" : "left"] = formatPercent(offset), _b2);
  }
  function getTooltipProps() {
    var tooltipProps = {
      getTooltipContainer: props.getTooltipContainer,
      formatTooltip: props.formatTooltip
    };
    if ("tooltipPosition" in props) {
      tooltipProps.tooltipPosition = tooltipPosition;
    }
    if ("tooltipVisible" in props) {
      tooltipProps.tooltipVisible = tooltipVisible;
    }
    return tooltipProps;
  }
  function getPosition() {
    position.current = roadRef.current.getBoundingClientRect();
  }
  function onRoadMouseDown(e) {
    getPosition();
    var val = getValueByCoords(e.clientX, e.clientY);
    if (rangeConfig.draggableBar && inRange(val)) {
      barStartDragVal.current = getLegalValue(val);
      on(window, "mousemove", onBarMouseMove);
      on(window, "mouseup", onBarMouseUp);
    } else {
      handleJumpClick(val);
    }
  }
  function handleJumpClick(val) {
    if (disabled)
      return;
    var value2 = getLegalValue(val);
    if (range2 && endVal - value2 > value2 - beginVal) {
      onChange([value2, endVal]);
    } else {
      onChange([beginVal, value2]);
    }
    onMouseUp();
  }
  function handleInputChange(val) {
    onChange(val);
    onMouseUp();
  }
  function handleBeginMove(x, y) {
    isDragging.current = true;
    onChange([getValueByCoords(x, y), endVal]);
  }
  function handleEndMove(x, y) {
    isDragging.current = true;
    onChange([beginVal, getValueByCoords(x, y)]);
  }
  function handleMoveEnd() {
    isDragging.current = false;
    onMouseUp();
  }
  function onBarMouseMove(e) {
    var newVal = getLegalValue(getValueByCoords(e.clientX, e.clientY));
    var offsetVal = newVal - barStartDragVal.current;
    var newBeginVal = beginVal + offsetVal;
    var newEndVal = endVal + offsetVal;
    if (isLegalValue(newBeginVal) && isLegalValue(newEndVal)) {
      onChange([newBeginVal, newEndVal]);
    }
  }
  function onBarMouseUp() {
    off(window, "mousemove", onBarMouseMove);
    off(window, "mouseup", onBarMouseUp);
    onMouseUp();
  }
  return React__default.createElement("div", { className: cs$1(prefixCls2, (_b = {}, _b[prefixCls2 + "-vertical"] = vertical, _b[prefixCls2 + "-with-marks"] = marks, _b[prefixCls2 + "-reverse"] = reverse, _b), className), style, ref }, React__default.createElement("div", { className: prefixCls2 + "-wrapper" }, React__default.createElement("div", { ref: roadRef, className: cs$1(prefixCls2 + "-road", (_c = {}, _c[prefixCls2 + "-road-disabled"] = disabled, _c[prefixCls2 + "-road-vertical"] = vertical, _c)), onMouseDown: onRoadMouseDown }, React__default.createElement("div", { className: prefixCls2 + "-bar", style: getBarStyle([beginOffset, endOffset]) }), showTicks && React__default.createElement(Ticks, { intervalConfigs, min, max, value: [beginVal, endVal], prefixCls: prefixCls2, vertical, reverse }), React__default.createElement(Dots$1, { data: markList, intervalConfigs, value: [beginVal, endVal], vertical, prefixCls: prefixCls2, reverse, onMouseDown: handleJumpClick }), React__default.createElement(Marks$1, { data: markList, intervalConfigs, vertical, prefixCls: prefixCls2, reverse, onMouseDown: handleJumpClick }), range2 && React__default.createElement(SliderButton$1, __assign$k({ style: getBtnStyle(beginOffset), disabled, prefixCls: prefixCls2, value: beginVal, maxValue: max, minValue: min, vertical }, getTooltipProps(), { onMoveBegin: getPosition, onMoving: handleBeginMove, onMoveEnd: handleMoveEnd })), React__default.createElement(SliderButton$1, __assign$k({ style: getBtnStyle(endOffset), disabled, prefixCls: prefixCls2, value: endVal, maxValue: max, minValue: min, vertical }, getTooltipProps(), { onMoveBegin: getPosition, onMoving: handleEndMove, onMoveEnd: handleMoveEnd }))), isShowInput && React__default.createElement(Input$2, { min, max, step, value: [beginVal, endVal], range: range2, disabled, prefixCls: prefixCls2, onChange: handleInputChange, extra: extraInputProps })));
}
var SliderComponent = forwardRef(Slider);
SliderComponent.displayName = "Slider";
var Slider$1 = memo(SliderComponent);
var __assign$j = globalThis && globalThis.__assign || function() {
  __assign$j = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$j.apply(this, arguments);
};
var __rest$7 = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var defaultProps$4 = {
  size: "small",
  direction: "horizontal"
};
function Space(baseProps, ref) {
  var _a;
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig2 = _b.componentConfig, rtl = _b.rtl;
  var props = useMergeProps(baseProps, defaultProps$4, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Space);
  var className = props.className, style = props.style, children = props.children, size = props.size, direction = props.direction, align = props.align, wrap2 = props.wrap, split = props.split, rest = __rest$7(props, ["className", "style", "children", "size", "direction", "align", "wrap", "split"]);
  var prefixCls2 = getPrefixCls("space");
  var innerAlign = align || (direction === "horizontal" ? "center" : "");
  var classNames = cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-" + direction] = direction, _a[prefixCls2 + "-align-" + innerAlign] = innerAlign, _a[prefixCls2 + "-wrap"] = wrap2, _a[prefixCls2 + "-rtl"] = rtl, _a), className);
  function getMargin(size2) {
    if (isNumber$1(size2)) {
      return size2;
    }
    switch (size2) {
      case "mini":
        return 4;
      case "small":
        return 8;
      case "medium":
        return 16;
      case "large":
        return 24;
      default:
        return 8;
    }
  }
  var childrenList = React__default.Children.toArray(children);
  function getMarginStyle(index2) {
    var _a2, _b2, _c, _d;
    var isLastOne = childrenList.length === index2 + 1;
    var marginDirection = rtl ? "marginLeft" : "marginRight";
    if (typeof size === "string" || typeof size === "number") {
      var margin = getMargin(size);
      if (wrap2) {
        return isLastOne ? { marginBottom: margin } : (_a2 = {}, _a2["" + marginDirection] = margin, _a2.marginBottom = margin, _a2);
      }
      return !isLastOne ? (_b2 = {}, _b2[direction === "vertical" ? "marginBottom" : marginDirection] = margin, _b2) : {};
    }
    if (isArray$c(size)) {
      var marginHorizontal = getMargin(size[0]);
      var marginBottom = getMargin(size[1]);
      if (wrap2) {
        return isLastOne ? { marginBottom } : (_c = {}, _c["" + marginDirection] = marginHorizontal, _c.marginBottom = marginBottom, _c);
      }
      if (direction === "vertical") {
        return { marginBottom };
      }
      return _d = {}, _d["" + marginDirection] = marginHorizontal, _d;
    }
  }
  return React__default.createElement("div", __assign$j({ ref, className: classNames, style }, rest), childrenList.map(function(child, index2) {
    var shouldRenderSplit = split !== void 0 && split !== null && index2 > 0;
    return React__default.createElement(Fragment, { key: index2 }, shouldRenderSplit && React__default.createElement("div", { className: prefixCls2 + "-item-split" }, split), React__default.createElement("div", { className: prefixCls2 + "-item", style: getMarginStyle(index2) }, child));
  }));
}
var SpaceComponent = forwardRef(Space);
SpaceComponent.displayName = "Space";
var Space$1 = SpaceComponent;
var __assign$i = globalThis && globalThis.__assign || function() {
  __assign$i = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$i.apply(this, arguments);
};
var __rest$6 = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$g = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var defaultProps$3 = {
  type: "circle"
};
function Switch(baseProps, ref) {
  var _a;
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, ctxSize = _b.size, componentConfig2 = _b.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$3, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Switch);
  var className = props.className, children = props.children, _c = props.style, style = _c === void 0 ? {} : _c, disabled = props.disabled, propSize = props.size, loading = props.loading, onChange = props.onChange, type = props.type, checkedText = props.checkedText, uncheckedText = props.uncheckedText, checkedIcon = props.checkedIcon, uncheckedIcon = props.uncheckedIcon, rest = __rest$6(props, ["className", "children", "style", "disabled", "size", "loading", "onChange", "type", "checkedText", "uncheckedText", "checkedIcon", "uncheckedIcon"]);
  var prefixCls2 = getPrefixCls("switch");
  var size = propSize || ctxSize;
  var _d = __read$g(useState(props.defaultChecked), 2), checked = _d[0], setChecked = _d[1];
  var mergedChecked = "checked" in props ? props.checked : checked;
  var onHandleClick = function(event2) {
    if (loading) {
      return;
    }
    props.onClick && props.onClick(event2);
    if (!("checked" in props)) {
      setChecked(!mergedChecked);
    }
    onChange && onChange(!mergedChecked, event2);
  };
  var classNames = cs$1(prefixCls2, size === "small" ? prefixCls2 + "-" + size : void 0, (_a = {}, _a[prefixCls2 + "-type-" + type] = type, _a[prefixCls2 + "-checked"] = mergedChecked, _a[prefixCls2 + "-loading"] = loading, _a), className);
  var checkedElement = checkedText;
  var unCheckedElement = uncheckedText;
  if (children && isArray$c(children)) {
    checkedElement = children.find(function(child) {
      return child.key === "open";
    });
    unCheckedElement = children.find(function(child) {
      return child.key === "close";
    });
  } else if (children && isObject$e(children)) {
    if (children.key === "open") {
      checkedElement = children;
    } else if (children.key === "close") {
      unCheckedElement = children;
    }
  }
  var extraProps = omit$1(rest, ["onChange", "checked", "error"]);
  return React__default.createElement("button", __assign$i({ ref, role: "switch", "aria-checked": !!mergedChecked }, extraProps, { style, className: classNames, disabled, onClick: onHandleClick, type: "button" }), React__default.createElement("div", { className: prefixCls2 + "-dot" }, !loading && (checkedIcon || uncheckedIcon) && React__default.createElement(SwitchTransition$1, null, React__default.createElement(CSSTransition$1, { key: mergedChecked ? "checked" : "unchecked", classNames: "fadeIn", timeout: 200 }, React__default.createElement("span", { className: prefixCls2 + "-dot-icon" }, mergedChecked ? checkedIcon : uncheckedIcon))), loading && React__default.createElement("span", { className: prefixCls2 + "-dot-icon" }, React__default.createElement(IconLoading$1, null))), size !== "small" && type !== "line" && (checkedElement || unCheckedElement) && React__default.createElement(React__default.Fragment, null, React__default.createElement("div", { className: prefixCls2 + "-text-holder" }, checkedElement && mergedChecked && checkedElement, unCheckedElement && !mergedChecked && unCheckedElement), React__default.createElement(CSSTransition$1, { in: mergedChecked, classNames: "switchSlideText", timeout: 200 }, React__default.createElement("div", { className: prefixCls2 + "-text" }, checkedElement && mergedChecked && checkedElement, unCheckedElement && !mergedChecked && unCheckedElement))));
}
var ForwardRefSwitch = forwardRef(Switch);
var SwitchComponent = ForwardRefSwitch;
SwitchComponent.__BYTE_SWITCH = true;
SwitchComponent.displayName = "Switch";
var Switch$1 = SwitchComponent;
var __assign$h = globalThis && globalThis.__assign || function() {
  __assign$h = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$h.apply(this, arguments);
};
var __rest$5 = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function TabPane$2(props, ref) {
  var shouldRender = useRef(false);
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var children = props.children, className = props.className, style = props.style, lazyload = props.lazyload, isActive = props.isActive, rest = __rest$5(props, ["children", "className", "style", "lazyload", "isActive"]);
  var prefixCls2 = getPrefixCls("tabs");
  shouldRender.current = lazyload ? shouldRender.current || isActive : true;
  return shouldRender.current && React__default.createElement("div", __assign$h({ ref }, omit$1(rest, ["destroyOnHide", "title", "closable"]), { className: cs$1(prefixCls2 + "-pane", className), style }), children);
}
var TabPaneRef = React__default.forwardRef(TabPane$2);
TabPaneRef.displayName = "TabPane";
TabPaneRef.isTabPane = true;
var TabPane$3 = TabPaneRef;
function DropdownIcon(props) {
  var prefixCls2 = props.prefixCls, currentOffset = props.currentOffset, headerSize = props.headerSize, headerWrapperSize = props.headerWrapperSize, getTitleRef = props.getTitleRef, paneChildren = props.paneChildren, direction = props.direction;
  var paneKeys = paneChildren.map(function(child) {
    return child.key;
  });
  var size = direction === "vertical" ? headerSize.height : headerSize.width;
  var wrapperSize = direction === "vertical" ? headerWrapperSize.height : headerWrapperSize.width;
  var tabSizes = useMemo(function() {
    var map = {};
    var wrapperRect = headerWrapperSize.domRect;
    paneKeys.map(function(key) {
      var titleDom = getTitleRef(key);
      if (!titleDom)
        return;
      var rect = titleDom.getBoundingClientRect();
      map[key] = {
        left: rect.left - wrapperRect.left,
        right: rect.left - wrapperRect.left + rect.width,
        top: rect.top - wrapperRect.top,
        bottom: rect.top - wrapperRect.top + rect.height
      };
    });
    return map;
  }, [paneKeys.join(","), size, wrapperSize]);
  var rangeIndex = useMemo(function() {
    var start2 = -1;
    var end = -1;
    for (var key in tabSizes) {
      var _a = tabSizes[key], left = _a.left, right = _a.right;
      if (left >= currentOffset && right - currentOffset <= wrapperSize && start2 === -1) {
        start2 = paneKeys.indexOf(key);
        end = start2;
      }
      if (left >= currentOffset && right - currentOffset > wrapperSize) {
        end = paneKeys.indexOf(key);
        break;
      }
    }
    return [start2, end];
  }, [tabSizes, paneKeys.join(","), currentOffset]);
  return React__default.createElement(Dropdown$1, { trigger: "click", droplist: React__default.createElement(Menu$1, { onClickMenuItem: props.onClickTab }, paneChildren.map(function(child, index2) {
    if (index2 < rangeIndex[0] || index2 >= rangeIndex[1]) {
      return React__default.createElement(Menu$1.Item, { key: child.key, disabled: child.disabled }, child.props.title);
    }
  })) }, React__default.createElement(IconHover, { role: "button", "aria-label": "expand tabs", prefix: prefixCls2 + "-dropdown", className: prefixCls2 + "-dropdown-icon" }, React__default.createElement(IconDown$1, null)));
}
var TabNavIcon = function(props) {
  var _a, _b, _c, _d;
  var direction = props.direction, headerSize = props.headerSize, headerWrapperSize = props.headerWrapperSize, prefixCls2 = props.prefixCls, iconPos = props.iconPos, curOffset = props.currentOffset, align = props.align;
  var wrapHeight = headerWrapperSize.height, wrapWidth = headerWrapperSize.width;
  var headerHeight = headerSize.height, headerWidth = headerSize.width;
  var maxHeightOffset = headerHeight - wrapHeight;
  var maxWidthOffset = headerWidth - wrapWidth;
  var onChange = function(offset) {
    if (offset !== props.currentOffset) {
      props.onChange && props.onChange(offset);
    }
  };
  var handleHozClick = function(e, pos) {
    e.preventDefault();
    var nextOffset;
    if (align === "left") {
      nextOffset = pos === "left" ? curOffset - wrapWidth : curOffset + wrapWidth;
    } else {
      nextOffset = pos === "left" ? curOffset + wrapWidth : curOffset - wrapWidth;
    }
    onChange(nextOffset);
  };
  var handleVerticalClick = function(e, pos) {
    e.preventDefault();
    var nextOffset;
    if (pos === "up") {
      nextOffset = curOffset - wrapHeight;
    } else {
      nextOffset = curOffset + wrapHeight;
      if (nextOffset >= headerHeight)
        return;
    }
    onChange(nextOffset);
  };
  var disabledPrev = false;
  var disabledNext = false;
  if (align === "left") {
    disabledPrev = curOffset <= 0;
    disabledNext = direction === "vertical" ? curOffset >= maxHeightOffset : curOffset >= maxWidthOffset;
  } else {
    disabledPrev = direction === "vertical" ? curOffset >= maxHeightOffset : curOffset >= maxWidthOffset;
    disabledNext = curOffset <= 0;
  }
  return direction === "vertical" ? iconPos === "prev" ? React__default.createElement(IconHover, { disabled: disabledPrev, prefix: prefixCls2, className: cs$1(prefixCls2 + "-up-icon", (_a = {}, _a[prefixCls2 + "-nav-icon-disabled"] = disabledPrev, _a)), onClick: function(e) {
    handleVerticalClick(e, "up");
  } }, React__default.createElement(IconUp$1, null)) : React__default.createElement(IconHover, { prefix: prefixCls2, className: cs$1(prefixCls2 + "-down-icon", (_b = {}, _b[prefixCls2 + "-nav-icon-disabled"] = disabledNext, _b)), disabled: disabledNext, onClick: function(e) {
    handleVerticalClick(e, "down");
  } }, React__default.createElement(IconDown$1, null)) : iconPos === "prev" ? React__default.createElement(IconHover, { prefix: prefixCls2, disabled: disabledPrev, className: cs$1(prefixCls2 + "-left-icon", (_c = {}, _c[prefixCls2 + "-nav-icon-disabled"] = disabledPrev, _c)), onClick: function(e) {
    handleHozClick(e, "left");
  } }, React__default.createElement(IconLeft$1, null)) : React__default.createElement(IconHover, { prefix: prefixCls2, className: cs$1(prefixCls2 + "-right-icon", (_d = {}, _d[prefixCls2 + "-nav-icon-disabled"] = disabledNext, _d)), disabled: disabledNext, onClick: function(e) {
    handleHozClick(e, "right");
  } }, React__default.createElement(IconRight$1, null));
};
var TabNavIcon$1 = TabNavIcon;
var getRectDiff = function(node, parentNode) {
  var nodeRect = node.getBoundingClientRect();
  var parentRect = parentNode.getBoundingClientRect();
  var scaleX = parentNode.offsetWidth / parentRect.width;
  var scaleY = parentNode.offsetHeight / parentRect.height;
  return {
    left: (nodeRect.left - parentRect.left) * scaleX,
    top: (nodeRect.top - parentRect.top) * scaleY,
    right: (nodeRect.right - parentRect.right) * scaleX,
    bottom: (nodeRect.bottom - parentRect.bottom) * scaleY
  };
};
var updateScrollOffset = function(parentNode, direction) {
  var scrollLeft = parentNode.scrollLeft;
  var scrollTop = parentNode.scrollTop;
  if (direction === "horizontal" && scrollLeft) {
    parentNode.scrollTo({ left: -1 * scrollLeft });
  }
  if (direction === "vertical" && scrollTop) {
    parentNode.scrollTo({ top: -1 * scrollTop });
  }
};
var getKeyDownEvent = function(_a) {
  var onPressEnter = _a.onPressEnter;
  return {
    onKeyDown: function(e) {
      var keyCode = e.keyCode || e.which;
      if (keyCode === Enter.code) {
        onPressEnter(e);
      }
    }
  };
};
var __assign$g = globalThis && globalThis.__assign || function() {
  __assign$g = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$g.apply(this, arguments);
};
var TabHeaderTitle = function(_a, ref) {
  var _b;
  var prefixCls2 = _a.prefixCls, onDeleteTab = _a.onDeleteTab, tabKey = _a.tabKey, isActive = _a.isActive, onClickTab = _a.onClickTab, _c = _a.disabled, disabled = _c === void 0 ? false : _c, title2 = _a.title, editable = _a.editable, renderTitle = _a.renderTitle, deleteIcon = _a.deleteIcon, deleteButton = _a.deleteButton, getIdPrefix = _a.getIdPrefix, index2 = _a.index;
  var render = isFunction$5(renderTitle) ? renderTitle : function(node) {
    return node;
  };
  var handleDeleteTab = function(e) {
    e.stopPropagation();
    if (disabled)
      return;
    onDeleteTab();
  };
  var handleTabClick = function(e) {
    if (disabled)
      return;
    onClickTab(e);
  };
  return render(React__default.createElement("div", { ref, key: tabKey, className: cs$1(prefixCls2 + "-header-title", (_b = {}, _b[prefixCls2 + "-header-title-active"] = isActive, _b[prefixCls2 + "-header-title-editable"] = editable, _b[prefixCls2 + "-header-title-disabled"] = disabled, _b)), role: "tab", "aria-selected": isActive, tabIndex: disabled ? -1 : 0, "aria-disabled": disabled || void 0, id: getIdPrefix(index2).tab, "aria-controls": getIdPrefix(index2).tabpane, onClick: handleTabClick, onKeyDown: function(event2) {
    var keyCode = event2.keyCode || event2.which;
    if (keyCode === Enter.code) {
      handleTabClick(event2);
    }
  } }, React__default.createElement("span", { className: prefixCls2 + "-header-title-text" }, title2), editable && React__default.createElement("span", __assign$g({ role: "button", "aria-label": "remove tab", "aria-disabled": disabled || void 0, tabIndex: disabled ? -1 : 0, className: prefixCls2 + "-close-icon" }, getKeyDownEvent({ onPressEnter: handleDeleteTab }), { onClick: handleDeleteTab }), deleteButton || React__default.createElement(IconHover, { prefix: prefixCls2 }, deleteIcon || React__default.createElement(IconClose$1, null)))), {
    key: tabKey,
    isActive,
    disabled,
    editable
  });
};
var TabHeaderTitle$1 = React__default.forwardRef(TabHeaderTitle);
var getInkStyle = function(direction, curTitle, headerRef) {
  var style = {};
  if (curTitle) {
    var diffStyle = getRectDiff(curTitle, headerRef);
    if (direction === "vertical") {
      style = {
        top: diffStyle.top + "px",
        height: curTitle.offsetHeight + "px",
        left: "",
        width: ""
      };
    } else {
      style = {
        left: diffStyle.left + "px",
        width: curTitle.offsetWidth + "px",
        top: "",
        height: ""
      };
    }
  }
  return style;
};
var TabInk = function(_a) {
  var _b;
  var prefixCls2 = _a.prefixCls, animation = _a.animation, disabled = _a.disabled, direction = _a.direction, getTitleRef = _a.getTitleRef, activeTab = _a.activeTab, getHeaderRef = _a.getHeaderRef;
  var inkRef = useRef();
  var inkStyleRef = useRef();
  useEffect(function() {
    var setInkStyle = throttleByRaf(function() {
      var newStyle = getInkStyle(direction, getTitleRef(activeTab), getHeaderRef("headerRef").current);
      if (newStyle && !isEqualWith_1(inkStyleRef.current, newStyle)) {
        inkStyleRef.current = newStyle;
        Object.keys(newStyle).forEach(function(key) {
          inkRef.current.style[key] = newStyle[key];
        });
      }
    });
    setInkStyle();
    return function() {
      setInkStyle.cancel && setInkStyle.cancel();
    };
  });
  return React__default.createElement("div", { className: cs$1(prefixCls2 + "-header-ink", (_b = {}, _b[prefixCls2 + "-header-ink-no-animation"] = !animation, _b[prefixCls2 + "-header-ink-disabled"] = disabled, _b)), ref: inkRef });
};
var TabInk$1 = TabInk;
var __read$f = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function DomSize() {
  var domRef = useRef();
  var _a = __read$f(useState({
    height: 0,
    width: 0
  }), 2), size = _a[0], setSize = _a[1];
  useEffect(function() {
    if (domRef.current) {
      setSize({
        height: domRef.current.offsetHeight,
        width: domRef.current.offsetWidth,
        domRect: domRef.current.getBoundingClientRect()
      });
    }
  }, []);
  return [domRef, size, setSize];
}
function useHeaderScroll(props) {
  var headerWrapperRef = props.headerWrapperRef, headerOffset = props.headerOffset, align = props.align, isScrollable2 = props.isScrollable, direction = props.direction, onScroll = props.onScroll;
  function onOffset(offsetX, offsetY) {
    var offset = 0;
    if (direction === "vertical") {
      offset = headerOffset + offsetY;
    } else {
      offset = align === "left" ? headerOffset + offsetX : headerOffset - offsetX;
    }
    onScroll && onScroll(offset);
  }
  var lastWheelDirectionRef = useRef("x");
  function onWheel(e) {
    if (!isScrollable2)
      return;
    e.preventDefault();
    var deltaX = e.deltaX, deltaY = e.deltaY;
    var offset = 0;
    var absX = Math.abs(deltaX);
    var absY = Math.abs(deltaY);
    if (absX === absY) {
      offset = lastWheelDirectionRef.current === "x" ? deltaX : deltaY;
    } else if (absX > absY) {
      offset = deltaX;
      lastWheelDirectionRef.current = "x";
    } else {
      offset = deltaY;
      lastWheelDirectionRef.current = "y";
    }
    onOffset(offset, offset);
  }
  var positionRef = useRef({
    clientX: 0,
    clientY: 0
  });
  var getPosition = function(e) {
    return e && e.touches && e.touches.length && e.touches[0];
  };
  var onTouchMove = function(e) {
    if (e.cancelable)
      e.preventDefault();
    var position = getPosition(e);
    if (!position)
      return;
    var _a = positionRef.current, clientX = _a.clientX, clientY = _a.clientY;
    var offsetX = position.clientX - clientX;
    var offsetY = position.clientY - clientY;
    onOffset(-offsetX, -offsetY);
  };
  var onTouchMoveEnd = function() {
    off(document.documentElement, "touchmove", onTouchMove);
    off(document.documentElement, "touchend", onTouchMoveEnd);
  };
  var onTouchStart = function(e) {
    if (!isScrollable2)
      return;
    var position = getPosition(e);
    if (!position)
      return;
    positionRef.current = {
      clientX: position.clientX,
      clientY: position.clientY
    };
    on(document.documentElement, "touchmove", onTouchMove, { passive: false });
    on(window, "touchend", onTouchMoveEnd, { passive: false });
  };
  var eventProxy = useRef(null);
  eventProxy.current = { onWheel, onTouchStart };
  useEffect(function() {
    on(headerWrapperRef.current, "wheel", function(e) {
      eventProxy.current.onWheel(e);
    }, { passive: false });
    on(headerWrapperRef.current, "touchstart", function(e) {
      eventProxy.current.onTouchStart(e);
    }, { passive: true });
  }, [headerWrapperRef.current]);
}
var __assign$f = globalThis && globalThis.__assign || function() {
  __assign$f = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$f.apply(this, arguments);
};
var __read$e = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var DIRECTION_VERTICAL = "vertical";
var ALIGN_RIGHT = "right";
var ALIGN_LEFT = "left";
var SCROLL_MAP = {
  delete: true,
  add: true
};
var getHeaderStyle = function(_a) {
  var direction = _a.direction, _b = _a.align, align = _b === void 0 ? ALIGN_LEFT : _b, headerOffset = _a.headerOffset;
  var value = "translateX(" + -headerOffset + "px)";
  if (align === ALIGN_RIGHT) {
    value = "translateX(" + headerOffset + "px)";
  }
  if (direction === DIRECTION_VERTICAL) {
    value = "translateY(" + -headerOffset + "px)";
  }
  return setTransformStyle(value);
};
var getCurrentHeaderOffset = function(_a) {
  var direction = _a.direction, _b = _a.align, align = _b === void 0 ? ALIGN_LEFT : _b, headerDom = _a.headerDom, headerWrapperDom = _a.headerWrapperDom;
  var diffStyle = getRectDiff(headerDom, headerWrapperDom);
  if (direction === DIRECTION_VERTICAL)
    return -diffStyle.top;
  if (align === ALIGN_RIGHT)
    return diffStyle.right;
  return -diffStyle.left;
};
var TabHeader = React__default.forwardRef(function(props, ref) {
  var _a, _b;
  var ctxProps = useContext(TabsContext);
  var mergeProps2 = __assign$f(__assign$f({}, props), ctxProps);
  var _c = __read$e(DomSize(), 3), headerWrapperRef = _c[0], headerWrapperSize = _c[1], setHeaderWrapperSize = _c[2];
  var _d = __read$e(DomSize(), 3), headerRef = _d[0], headerSize = _d[1], setHeaderSize = _d[2];
  var _e = __read$e(DomSize(), 3), scrollWrapperRef = _e[0], scrollWrapperSize = _e[1], setScrollWrapperSize = _e[2];
  var titleRef = useRef({});
  var _f = __read$e(useState(0), 2), headerOffset = _f[0], setHeaderOffset = _f[1];
  var _g = __read$e(useState(true), 2), shouldScroll = _g[0], setShouldScroll = _g[1];
  var paneChildren = mergeProps2.paneChildren, editable = mergeProps2.editable, prefixCls2 = mergeProps2.prefixCls, onAddTab = mergeProps2.onAddTab, direction = mergeProps2.direction, _h = mergeProps2.type, type = _h === void 0 ? "line" : _h, _j = mergeProps2.overflow, overflow = _j === void 0 ? "scroll" : _j, activeTab = mergeProps2.activeTab, showAddButton = mergeProps2.showAddButton, _k = mergeProps2.size, size = _k === void 0 ? "default" : _k, style = mergeProps2.style, tabPosition = mergeProps2.tabPosition, className = mergeProps2.className, extra = mergeProps2.extra, animation = mergeProps2.animation, icons = mergeProps2.icons, deleteButton = mergeProps2.deleteButton, addButton = mergeProps2.addButton, renderTabTitle = mergeProps2.renderTabTitle, scrollAfterEdit = mergeProps2.scrollAfterEdit, _l = mergeProps2.scrollPosition, scrollPosition = _l === void 0 ? "auto" : _l;
  var scrollConfig = isObject$e(scrollAfterEdit) ? __assign$f(__assign$f({}, SCROLL_MAP), scrollAfterEdit) : SCROLL_MAP;
  var align = type === "capsule" ? ALIGN_RIGHT : ALIGN_LEFT;
  var isScrollable2 = useMemo(function() {
    var res = mergeProps2.direction === "vertical" ? scrollWrapperSize.height < headerSize.height : scrollWrapperSize.width < headerSize.width;
    return res;
  }, [mergeProps2.direction, scrollWrapperSize, headerSize]);
  var updateScrollWrapperSize = function() {
    if (scrollWrapperRef.current) {
      var dom = scrollWrapperRef.current;
      setScrollWrapperSize({
        height: dom.offsetHeight,
        width: dom.offsetWidth
      });
    }
  };
  var onWrapperResize = throttleByRaf(function(entry) {
    updateScrollWrapperSize();
    var dom = entry[0] && entry[0].target;
    if (dom) {
      setHeaderWrapperSize({
        height: dom.offsetHeight,
        width: dom.offsetWidth,
        domRect: dom.getBoundingClientRect()
      });
    }
  });
  var onHeaderResize = throttleByRaf(function(entry) {
    var dom = entry[0] && entry[0].target;
    if (dom) {
      setHeaderSize({
        height: dom.offsetHeight,
        width: dom.offsetWidth,
        domRect: dom.getBoundingClientRect()
      });
    }
  });
  var getValidOffset = useCallback(function(offset) {
    var maxOffset = direction === DIRECTION_VERTICAL ? headerSize.height - headerWrapperSize.height : headerSize.width - headerWrapperSize.width;
    var validOffset = offset;
    validOffset = Math.min(maxOffset, validOffset);
    validOffset = Math.max(validOffset, 0);
    return validOffset;
  }, [direction, headerSize, headerWrapperSize]);
  var updateHeaderOffset = function(offset) {
    var nextOffset = getValidOffset(offset);
    if (nextOffset !== headerOffset) {
      setHeaderOffset(nextOffset);
    }
  };
  useEffect(function() {
    return function() {
      onHeaderResize.cancel && onHeaderResize.cancel();
      onWrapperResize.cancel && onWrapperResize.cancel();
    };
  }, []);
  useEffect(function() {
    if (!shouldScroll) {
      setShouldScroll(true);
      return;
    }
    var getActiveTabOffset = function() {
      var currentTitleNode = titleRef.current[activeTab];
      if (!currentTitleNode || !isScrollable2) {
        return 0;
      }
      var diffStyle = getRectDiff(currentTitleNode, headerWrapperRef.current);
      var currentOffset = getCurrentHeaderOffset({
        direction,
        align,
        headerDom: headerRef.current,
        headerWrapperDom: headerWrapperRef.current
      });
      if (direction === "vertical") {
        var nextOffset_1 = currentOffset;
        var scrollAlign_1 = scrollPosition;
        var topOffset = currentOffset + diffStyle.top;
        var bottomOffset = currentOffset + diffStyle.bottom;
        if (scrollAlign_1 === "auto") {
          scrollAlign_1 = diffStyle.top < 0 ? "start" : diffStyle.bottom > 0 ? "end" : scrollPosition;
        }
        if (scrollAlign_1 === "start") {
          nextOffset_1 = topOffset;
        } else if (scrollAlign_1 === "end") {
          nextOffset_1 = bottomOffset;
        } else if (scrollAlign_1 === "center") {
          nextOffset_1 = topOffset - (diffStyle.top - diffStyle.bottom) / 2;
        } else if (isNumber$1(scrollAlign_1)) {
          nextOffset_1 = Math.max(topOffset - scrollAlign_1, bottomOffset);
        }
        return nextOffset_1;
      }
      if (align === "right") {
        var startOffset_1 = currentOffset - diffStyle.left;
        var endOffset_1 = currentOffset - diffStyle.right;
        var scrollAlign_2 = scrollPosition;
        var nextOffset_2 = currentOffset;
        if (scrollPosition === "auto") {
          scrollAlign_2 = diffStyle.left < 0 ? "start" : diffStyle.right > 0 ? "end" : scrollPosition;
        }
        if (scrollAlign_2 === "start") {
          nextOffset_2 = startOffset_1;
        } else if (scrollAlign_2 === "end") {
          nextOffset_2 = endOffset_1;
        } else if (scrollAlign_2 === "center") {
          nextOffset_2 = startOffset_1 + (diffStyle.left - diffStyle.right) / 2;
        } else if (isNumber$1(scrollAlign_2)) {
          nextOffset_2 = Math.min(startOffset_1 + scrollAlign_2, endOffset_1);
        }
        return nextOffset_2;
      }
      var nextOffset = currentOffset;
      var scrollAlign = scrollPosition;
      var startOffset = currentOffset + diffStyle.left;
      var endOffset = currentOffset + diffStyle.right;
      if (scrollPosition === "auto") {
        scrollAlign = diffStyle.left < 0 ? "start" : diffStyle.right > 0 ? "end" : scrollPosition;
      }
      if (scrollAlign === "start") {
        nextOffset = startOffset;
      } else if (scrollAlign === "end") {
        nextOffset = endOffset;
      } else if (scrollAlign === "center") {
        nextOffset = startOffset - (diffStyle.left - diffStyle.right) / 2;
      } else if (isNumber$1(scrollAlign)) {
        nextOffset = Math.max(startOffset - scrollAlign, endOffset);
      }
      return nextOffset;
    };
    updateScrollOffset(headerWrapperRef.current, direction);
    var offset = getActiveTabOffset();
    offset = getValidOffset(offset);
    setHeaderOffset(offset);
  }, [activeTab, direction, overflow, isScrollable2, type, getValidOffset, scrollPosition]);
  var headerStyle = getHeaderStyle({
    direction,
    align,
    headerOffset
  });
  var isDropdown = isScrollable2 && overflow === "dropdown" && direction !== "vertical";
  var isScroll = isScrollable2 && !isDropdown;
  var isEditable = editable && (type === "card" || type === "card-gutter" || type === "line");
  var handleDelete = function(child) {
    mergeProps2.onDeleteTab && mergeProps2.onDeleteTab(child.key);
    setShouldScroll(scrollConfig.delete);
  };
  var handleAdd = function() {
    onAddTab && onAddTab();
    setShouldScroll(scrollConfig.add);
  };
  var renderAddIcon = function(isEditable2) {
    return isEditable2 && showAddButton && React__default.createElement("div", __assign$f({ className: prefixCls2 + "-add-icon", "aria-label": "add tab", tabIndex: 0, role: "button", onClick: handleAdd }, getKeyDownEvent({ onPressEnter: handleAdd })), addButton || React__default.createElement(IconHover, { prefix: prefixCls2 + "-add" }, React__default.createElement("span", { className: prefixCls2 + "-add" }, (icons === null || icons === void 0 ? void 0 : icons.add) || React__default.createElement(IconPlus$1, null))));
  };
  useHeaderScroll({
    headerWrapperRef,
    headerOffset,
    align,
    direction,
    isScrollable: isScrollable2,
    onScroll: function(offset) {
      updateHeaderOffset(offset);
    }
  });
  return React__default.createElement("div", { className: cs$1(prefixCls2 + "-header-nav", prefixCls2 + "-header-nav-" + direction, prefixCls2 + "-header-nav-" + tabPosition, prefixCls2 + "-header-size-" + size, prefixCls2 + "-header-nav-" + type, className), style, ref }, React__default.createElement("div", { className: cs$1(prefixCls2 + "-header-scroll", (_a = {}, _a[prefixCls2 + "-header-overflow-scroll"] = isScroll, _a[prefixCls2 + "-header-overflow-dropdown"] = isDropdown, _a)), ref: scrollWrapperRef }, isScroll && React__default.createElement(TabNavIcon$1, {
    iconPos: "prev",
    prefixCls: prefixCls2,
    currentOffset: headerOffset,
    headerSize,
    headerWrapperSize,
    direction,
    align,
    onChange: updateHeaderOffset
  }), React__default.createElement(ResizeObserver, { onResize: onWrapperResize }, React__default.createElement("div", { className: prefixCls2 + "-header-wrapper", ref: headerWrapperRef }, React__default.createElement(ResizeObserver, { onResize: onHeaderResize }, React__default.createElement("div", { className: cs$1(prefixCls2 + "-header", (_b = {}, _b[prefixCls2 + "-header-no-padding"] = !props.headerPadding && direction === "horizontal" && ["line", "text"].indexOf(type) > -1, _b)), ref: headerRef, style: headerStyle }, paneChildren.map(function(child, index2) {
    return React__default.createElement(TabHeaderTitle$1, __assign$f({ key: index2, ref: function(node) {
      titleRef.current[child.key] = node;
    }, tabKey: child.key }, child.props, { prefixCls: prefixCls2, onDeleteTab: function() {
      return handleDelete(child);
    }, renderTitle: props.children || renderTabTitle, onClickTab: function() {
      mergeProps2.onClickTab && mergeProps2.onClickTab(child.key);
    }, isActive: activeTab === child.key, editable: isEditable && child.props.closable !== false, deleteIcon: icons === null || icons === void 0 ? void 0 : icons.delete, deleteButton, getIdPrefix: ctxProps.getIdPrefix, index: index2 }));
  }), type === "line" && React__default.createElement(TabInk$1, { disabled: !!paneChildren.find(function(child) {
    return child && child.props && child.props.disabled && child.key === activeTab;
  }), prefixCls: prefixCls2, animation, direction, getTitleRef: function(key) {
    return titleRef.current[key];
  }, activeTab, getHeaderRef: function() {
    return headerRef;
  } }))), !isScrollable2 && renderAddIcon(isEditable))), isScroll && React__default.createElement(TabNavIcon$1, { prefixCls: prefixCls2, currentOffset: headerOffset, headerSize, headerWrapperSize, direction, align, onChange: updateHeaderOffset }), isDropdown && React__default.createElement(DropdownIcon, { onClickTab: mergeProps2.onClickTab, paneChildren, prefixCls: prefixCls2, currentOffset: headerOffset, headerSize, headerWrapperSize, getTitleRef: function(key) {
    return titleRef.current[key];
  }, direction }), (isEditable && isScrollable2 || extra) && React__default.createElement("div", { className: prefixCls2 + "-header-extra" }, isScrollable2 && renderAddIcon(isEditable), extra)));
});
TabHeader.displayName = "TabHeader";
var TabHeader$1 = TabHeader;
function TabContent(props) {
  var _a;
  var animation = props.animation, activeTab = props.activeTab, prefixCls2 = props.prefixCls, paneChildren = props.paneChildren, direction = props.direction, lazyload = props.lazyload, destroyOnHide = props.destroyOnHide;
  var activeIndex = paneChildren.findIndex(function(p) {
    return p.key === activeTab;
  });
  var ctxProps = useContext(TabsContext);
  if (paneChildren.every(function(x) {
    return (x === null || x === void 0 ? void 0 : x.props) && (!("children" in x.props) || x.props.children === null);
  })) {
    return null;
  }
  var classNamesContentInner = cs$1(prefixCls2 + "-content-inner", (_a = {}, _a[prefixCls2 + "-animation"] = animation, _a));
  return React__default.createElement("div", { className: prefixCls2 + "-content " + prefixCls2 + "-content-" + direction }, React__default.createElement("div", { className: classNamesContentInner, style: {
    marginLeft: "-" + activeIndex * 100 + "%"
  } }, paneChildren.map(function(child, index2) {
    var _a2;
    var _b = ctxProps.getIdPrefix(index2), tabpane = _b.tabpane, tab = _b.tab;
    var mergedDestroyOnHide = "destroyOnHide" in child.props ? child.props.destroyOnHide : destroyOnHide;
    var isActive = child.key === activeTab;
    return React__default.createElement("div", { key: child.key, className: cs$1(prefixCls2 + "-content-item", (_a2 = {}, _a2[prefixCls2 + "-content-item-active"] = isActive, _a2)), role: "tabpanel", id: tabpane, "aria-hidden": isActive ? void 0 : true, tabIndex: isActive ? 0 : -1, "aria-labelledby": tab }, activeIndex !== index2 && mergedDestroyOnHide ? null : React__default.cloneElement(child, {
      lazyload,
      isActive
    }));
  })));
}
var __assign$e = globalThis && globalThis.__assign || function() {
  __assign$e = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$e.apply(this, arguments);
};
var __rest$4 = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$d = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var sizeList = ["mini", "small", "default", "large"];
var __ARCO_TABS_SEED_INDEX = 0;
var getPaneChildren = function(props) {
  var children = props.children;
  var paneChildren = [];
  React__default.Children.forEach(children, function(child) {
    if (child && child.type && child.type.isTabPane) {
      paneChildren.push(child);
    }
  });
  return paneChildren;
};
var getTabPaneAnimation = function(props) {
  var direction = props.direction, tabPosition = props.tabPosition, animation = props.animation;
  if (direction === "vertical" || tabPosition === "left" || tabPosition === "right") {
    return false;
  }
  if (isObject$e(animation)) {
    return "tabPane" in animation ? animation.tabPane : false;
  }
  return animation;
};
var defaultProps$2 = {
  tabPosition: "top",
  type: "line",
  overflow: "scroll",
  showAddButton: true,
  lazyload: true,
  headerPadding: true,
  scrollPosition: "auto"
};
var TabsContext = React__default.createContext({});
function Tabs(baseProps, ref) {
  var _a;
  var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, ctxSize = _b.size, componentConfig2 = _b.componentConfig;
  var props = useMergeProps(baseProps, defaultProps$2, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Tabs);
  var paneChildren = getPaneChildren(props);
  var tabsRef = useRef();
  var _c = __read$d(useMergeValue(paneChildren[0] && paneChildren[0].key, {
    defaultValue: "defaultActiveTab" in props ? props.defaultActiveTab : void 0,
    value: "activeTab" in props ? props.activeTab : void 0
  }), 2), activeTab = _c[0], setActiveTab = _c[1];
  var prefixCls2 = getPrefixCls("tabs");
  var size = props.size || (sizeList.indexOf(ctxSize) > -1 ? ctxSize : "default");
  var animation = props.animation, className = props.className, direction = props.direction, style = props.style, type = props.type, justify = props.justify, destroyOnHide = props.destroyOnHide, lazyload = props.lazyload, onChange = props.onChange, onClickTab = props.onClickTab, onDeleteTab = props.onDeleteTab, renderTabHeader = props.renderTabHeader, rest = __rest$4(props, ["animation", "className", "direction", "style", "type", "justify", "destroyOnHide", "lazyload", "onChange", "onClickTab", "onDeleteTab", "renderTabHeader"]);
  var idPrefix = useMemo(function() {
    return prefixCls2 + "-" + __ARCO_TABS_SEED_INDEX++ + "-";
  }, []);
  var tabPosition = direction === "vertical" ? "left" : props.tabPosition;
  var tabHeaderProps = {
    animation: isObject$e(animation) && "inkBar" in animation ? animation.inkBar : true,
    activeTab,
    tabPosition,
    direction: ["left", "right"].indexOf(tabPosition) > -1 ? "vertical" : "horizontal",
    paneChildren,
    onClickTab: function(key) {
      isFunction$5(onClickTab) && onClickTab(key);
      if (key !== activeTab) {
        if (!("activeTab" in props)) {
          setActiveTab(key);
        }
        isFunction$5(onChange) && onChange(key);
      }
    },
    onDeleteTab,
    prefixCls: prefixCls2
  };
  useImperativeHandle(ref, function() {
    return tabsRef;
  }, []);
  var TabContentDom = React__default.createElement(TabContent, { direction: ["left", "right"].indexOf(tabPosition) > -1 ? "vertical" : "horizontal", animation: getTabPaneAnimation(props), activeTab, paneChildren, prefixCls: prefixCls2, destroyOnHide, lazyload });
  return React__default.createElement("div", __assign$e({}, omit$1(rest, [
    "headerPadding",
    "tabPosition",
    "defaultActiveTab",
    "showAddButton",
    "extra",
    "onAddTab",
    "activeTab",
    "overflow",
    "editable",
    "renderTabTitle",
    "addButton",
    "deleteButton",
    "icons",
    "children",
    "size",
    "type",
    "scrollPosition",
    "offsetAlign"
  ]), { style, className: cs$1(prefixCls2, prefixCls2 + "-" + (["left", "right"].indexOf(tabPosition) > -1 ? "vertical" : "horizontal"), prefixCls2 + "-" + type, prefixCls2 + "-" + tabPosition, prefixCls2 + "-size-" + size, (_a = {}, _a[prefixCls2 + "-justify"] = justify, _a), className), ref: tabsRef }), React__default.createElement(TabsContext.Provider, { value: __assign$e(__assign$e({}, tabHeaderProps), { getIdPrefix: function(suffix) {
    return {
      tab: idPrefix + "tab-" + suffix,
      tabpane: idPrefix + "panel-" + suffix
    };
  } }) }, tabPosition === "bottom" && TabContentDom, isFunction$5(renderTabHeader) ? renderTabHeader(__assign$e(__assign$e(__assign$e({}, omit$1(props, ["children", "style", "className"])), { size }), tabHeaderProps), TabHeader$1) : React__default.createElement(TabHeader$1, __assign$e({}, omit$1(props, ["children", "style", "className"]), { size })), tabPosition !== "bottom" && TabContentDom));
}
var ForwardRefTabs = React__default.forwardRef(Tabs);
var TabsComponent = ForwardRefTabs;
TabsComponent.displayName = "Tabs";
TabsComponent.TabPane = TabPane$3;
var Tabs$1 = TabsComponent;
function ownKeys$6(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$6(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconDeleteComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$6(_objectSpread$6({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-delete")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M5 11h5.5m0 0v29a1 1 0 0 0 1 1h25a1 1 0 0 0 1-1V11m-27 0H16m21.5 0H43m-5.5 0H32m-16 0V7h16v4m-16 0h16M20 18v15m8-15v15"
  }));
}
var IconDelete = /* @__PURE__ */ React__default.forwardRef(IconDeleteComponent);
IconDelete.defaultProps = {
  isIcon: true
};
IconDelete.displayName = "IconDelete";
var IconDelete$1 = IconDelete;
function ownKeys$5(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$5(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconFileComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$5(_objectSpread$5({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-file")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M16 21h16m-16 8h10m11 13H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2Z"
  }));
}
var IconFile = /* @__PURE__ */ React__default.forwardRef(IconFileComponent);
IconFile.defaultProps = {
  isIcon: true
};
IconFile.displayName = "IconFile";
var IconFile$1 = IconFile;
var TreeContext = createContext({});
var __assign$d = globalThis && globalThis.__assign || function() {
  __assign$d = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$d.apply(this, arguments);
};
function getKey$1(option) {
  return option.key || option._key;
}
var TreeAnimation = function(props) {
  var _a;
  var treeContext = useContext(TreeContext);
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var prefixCls2 = getPrefixCls("tree-node");
  var _b = treeContext.getTreeState(), expandedKeys = _b.expandedKeys, currentExpandKeys = _b.currentExpandKeys;
  var expanded = props.expanded;
  useEffect(function() {
    return function() {
      treeContext.onExpandEnd && treeContext.onExpandEnd(props._key);
    };
  }, []);
  var childrenPropsList = useMemo(function() {
    var result = [];
    var loop = function(list2) {
      list2.forEach(function(item2) {
        var data = treeContext.getFieldInfo(item2);
        result.push(data);
        if (data.children && data.children.length) {
          loop(data.children);
        }
      });
    };
    loop(props.childrenData || []);
    return result;
  }, [props.childrenData]);
  var filtedData = useMemo(function() {
    var result = [];
    if (childrenPropsList.length) {
      var expandedKeysSet_1 = new Set(expandedKeys || []);
      childrenPropsList.forEach(function(data) {
        var _a2;
        var isShow;
        var itemProps = __assign$d({}, treeContext.key2nodeProps[data.key]);
        if (expanded) {
          isShow = itemProps.parentKey === props._key || ((_a2 = itemProps.pathParentKeys) === null || _a2 === void 0 ? void 0 : _a2.every(function(key) {
            return expandedKeysSet_1.has(key);
          }));
        } else if (itemProps.pathParentKeys) {
          var index2 = itemProps.pathParentKeys.indexOf(props._key);
          isShow = itemProps.pathParentKeys.slice(index2 + 1).every(function(key) {
            return expandedKeysSet_1.has(key);
          });
        }
        if (isShow) {
          result.push(__assign$d(__assign$d(__assign$d({}, itemProps), treeContext.getNodeProps(itemProps, expandedKeysSet_1)), { key: data.key }));
        }
      });
    }
    return result;
  }, [childrenPropsList, props._key, expanded]);
  var realHeight = (_a = treeContext.virtualListProps) === null || _a === void 0 ? void 0 : _a.height;
  realHeight = isNumber$1(realHeight) ? realHeight : 0;
  useEffect(function() {
    if (currentExpandKeys.indexOf(props._key) > -1 && filtedData.length === 0) {
      treeContext.onExpandEnd(props._key);
    }
  }, [filtedData, currentExpandKeys]);
  return React__default.createElement(CSSTransition$1, { in: currentExpandKeys.indexOf(props._key) > -1 && filtedData.length > 0, unmountOnExit: true, classNames: "tree-slide-expand", timeout: {
    enter: 200,
    exit: 0
  }, onEnter: function(e) {
    var scrollHeight = e.scrollHeight;
    e.style.height = expanded ? 0 : Math.min(realHeight || scrollHeight, e.scrollHeight) + "px";
  }, onEntering: function(e) {
    var scrollHeight = e.scrollHeight;
    e.style.height = expanded ? Math.min(realHeight || scrollHeight, scrollHeight) + "px" : 0;
  }, onEntered: function(e) {
    e.style.height = props.expanded ? "" : 0;
    treeContext.onExpandEnd(props._key);
  }, onExit: function(e) {
    e.style.display = "none";
  } }, React__default.createElement(VirtualList$1, __assign$d({ itemKey: getKey$1, className: prefixCls2 + "-list", isStaticItemHeight: false }, treeContext.virtualListProps, { data: filtedData, "aria-hidden": true, style: { overflow: "hidden" } }), function(child) {
    return React__default.createElement(Node$1, __assign$d({}, child));
  }));
};
var AnimationNode = TreeAnimation;
var __assign$c = globalThis && globalThis.__assign || function() {
  __assign$c = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$c.apply(this, arguments);
};
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$3 = globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
          return t2;
        if (y = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __read$c = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$6 = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function TreeNode(props, ref) {
  var _a, _b, _c;
  var _this = this;
  var treeContext = useContext(TreeContext);
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var nodeTitleRef = useRef();
  var _d = __read$c(useState({
    isAllowDrop: true,
    isDragOver: false,
    dragPosition: 0,
    isDragging: false
  }), 2), state = _d[0], setState = _d[1];
  var _e = props._key, _key = _e === void 0 ? "" : _e, title2 = props.title, icon = props.icon, checkable = props.checkable, selected = props.selected, disabled = props.disabled, disableCheckbox = props.disableCheckbox, isLeaf = props.isLeaf, draggable = props.draggable, expanded = props.expanded, showLine = props.showLine, loading = props.loading, _f = props.selectable, selectable = _f === void 0 ? true : _f;
  var prefixCls2 = getPrefixCls("tree-node");
  var classNames = cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-selected"] = selected, _a[prefixCls2 + "-is-leaf"] = isLeaf, _a[prefixCls2 + "-expanded"] = expanded, _a[prefixCls2 + "-disabled-selectable"] = !selectable, _a[prefixCls2 + "-disabled"] = disabled, _a[prefixCls2 + "-draggable"] = draggable, _a), props.className);
  var icons = function() {
    var treeIcons = isFunction$5(treeContext.icons) ? treeContext.icons(props) : treeContext.icons;
    var propsIcons = isFunction$5(props.icons) ? props.icons(props) : props.icons;
    return __assign$c(__assign$c({}, treeIcons), propsIcons);
  }();
  var setExpand = useCallback(function(newExpand) {
    if (newExpand === expanded) {
      return;
    }
    treeContext.onExpand && treeContext.onExpand(newExpand, _key);
  }, [expanded, treeContext.onExpand]);
  var switchExpandStatus = useCallback(function() {
    return __awaiter$3(_this, void 0, void 0, function() {
      var isLeaf2, expanded2;
      var _a2;
      return __generator$3(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            isLeaf2 = props.isLeaf, expanded2 = props.expanded;
            if (isLeaf2) {
              return [2];
            }
            if (!(!((_a2 = props.childrenData) === null || _a2 === void 0 ? void 0 : _a2.length) && isFunction$5(treeContext.loadMore) && !expanded2))
              return [3, 2];
            return [4, treeContext.loadMore(props)];
          case 1:
            _b2.sent();
            return [3, 3];
          case 2:
            setExpand(!expanded2);
            _b2.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }, [props, setExpand, treeContext.loadMore]);
  var getPrefixIcon = function() {
    if (loading) {
      return "loadingIcon" in icons ? icons.loadingIcon : React__default.createElement(IconLoading$1, null);
    }
    var icon2 = null;
    var needIconHover = false;
    if (!isLeaf) {
      var defaultIcon = showLine ? React__default.createElement("span", { className: prefixCls2 + "-" + (expanded ? "minus" : "plus") + "-icon" }) : React__default.createElement(IconCaretDown$1, null);
      icon2 = "switcherIcon" in icons ? icons.switcherIcon : defaultIcon;
      needIconHover = !showLine;
    } else if (showLine) {
      icon2 = "switcherIcon" in icons ? icons.switcherIcon : React__default.createElement(IconFile$1, null);
      needIconHover = true;
    }
    if (icon2) {
      icon2 = React__default.createElement("span", { className: prefixCls2 + "-switcher-icon", "aria-label": expanded ? "fold button" : "expand button", role: "button", tabIndex: 0, onClick: switchExpandStatus }, icon2);
      return needIconHover ? React__default.createElement(IconHover, { prefix: prefixCls2 }, icon2) : icon2;
    }
  };
  var updateDragOverState = useCallback(throttleByRaf(function(e) {
    var dom = nodeTitleRef.current;
    if (!dom)
      return;
    var rect = dom.getBoundingClientRect();
    var offsetY = window.pageYOffset + rect.top;
    var pageY = e.pageY;
    var gapHeight = rect.height / 4;
    var diff = pageY - offsetY;
    var position = diff < gapHeight ? -1 : diff < rect.height - gapHeight ? 0 : 1;
    var isAllowDrop = treeContext.allowDrop(props, position);
    setState(__assign$c(__assign$c({}, state), { isAllowDrop, isDragOver: true, dragPosition: position }));
    treeContext.onNodeDragOver && treeContext.onNodeDragOver(e, props, position);
  }), [treeContext.onNodeDragOver]);
  var handleCheck = function(checked, e) {
    var disableCheckbox2 = props.disableCheckbox, disabled2 = props.disabled;
    if (disableCheckbox2 || disabled2) {
      return;
    }
    treeContext.onCheck && treeContext.onCheck(checked, _key, e);
  };
  return React__default.createElement(React__default.Fragment, null, React__default.createElement("div", { style: props.style, className: classNames, ref, role: "treeitem", "aria-disabled": disabled, "aria-expanded": expanded }, React__default.createElement("span", { className: prefixCls2 + "-indent", "aria-hidden": true }, __spreadArray$6([], __read$c(Array(props._level)), false).map(function(_, i2) {
    var _a2;
    return React__default.createElement("span", { className: cs$1(prefixCls2 + "-indent-block", (_a2 = {}, _a2[prefixCls2 + "-indent-block-lineless"] = props._lineless && props._lineless[i2], _a2)), key: i2 });
  })), React__default.createElement("span", { className: cs$1(prefixCls2 + "-switcher", (_b = {}, _b[prefixCls2 + "-switcher-expanded"] = expanded, _b)) }, getPrefixIcon()), checkable ? React__default.createElement(Checkbox$1, { disabled: disableCheckbox || disabled, value: _key, indeterminate: props.indeterminated, checked: props.checked, onChange: handleCheck }) : null, React__default.createElement("span", { "aria-grabbed": state.isDragging, ref: nodeTitleRef, className: cs$1(prefixCls2 + "-title", (_c = {}, _c[prefixCls2 + "-title-draggable"] = draggable, _c[prefixCls2 + "-title-gap-top"] = state.isDragOver && state.isAllowDrop && state.dragPosition < 0, _c[prefixCls2 + "-title-gap-bottom"] = state.isDragOver && state.isAllowDrop && state.dragPosition > 0, _c[prefixCls2 + "-title-highlight"] = !state.isDragging && state.isDragOver && state.isAllowDrop && state.dragPosition === 0, _c[prefixCls2 + "-title-dragging"] = state.isDragging, _c[prefixCls2 + "-title-block"] = props.blockNode, _c)), onClick: function(e) {
    var onSelect = treeContext.onSelect, actionOnClick = treeContext.actionOnClick;
    if (!props.disabled) {
      var actions = [].concat(actionOnClick);
      if (selectable && actions.indexOf("select") > -1) {
        onSelect && onSelect(_key, e);
      }
      if (actions.indexOf("expand") > -1) {
        switchExpandStatus();
      }
      if (checkable && actions.indexOf("check") > -1) {
        handleCheck(!props.checked, e);
      }
    }
  }, draggable, onDrop: function(e) {
    e.stopPropagation();
    e.preventDefault();
    treeContext.onNodeDrop && treeContext.onNodeDrop(e, props, state.dragPosition);
    updateDragOverState.cancel();
    setState(__assign$c(__assign$c({}, state), { isDragOver: false, dragPosition: 0 }));
  }, onDragStart: function(e) {
    if (!draggable)
      return;
    e.stopPropagation();
    setState(__assign$c(__assign$c({}, state), { isDragging: true }));
    treeContext.onNodeDragStart && treeContext.onNodeDragStart(e, props);
    try {
      e.dataTransfer.setData("text/plain", "");
    } catch (error2) {
    }
  }, onDragEnd: function(e) {
    if (!draggable)
      return;
    e.stopPropagation();
    updateDragOverState.cancel();
    setState(__assign$c(__assign$c({}, state), { isDragOver: false, isDragging: false }));
    treeContext.onNodeDragEnd && treeContext.onNodeDragEnd(e, props);
  }, onDragOver: function(e) {
    e.preventDefault();
    e.stopPropagation();
    e.persist();
    updateDragOverState(e);
  }, onDragLeave: function(e) {
    if (!draggable)
      return;
    e.stopPropagation();
    updateDragOverState.cancel();
    setState(__assign$c(__assign$c({}, state), { isDragOver: false }));
    treeContext.onNodeDragLeave && treeContext.onNodeDragLeave(e, props);
  } }, icon && React__default.createElement("span", { className: prefixCls2 + "-icon " + prefixCls2 + "-custom-icon" }, icon), React__default.createElement("span", { className: prefixCls2 + "-title-text" }, isFunction$5(treeContext.renderTitle) ? treeContext.renderTitle(props) : title2), draggable && React__default.createElement("span", { className: prefixCls2 + "-icon " + prefixCls2 + "-drag-icon" }, "dragIcon" in icons ? icons.dragIcon : React__default.createElement(IconDragDotVertical$1, null))), isFunction$5(treeContext.renderExtra) && treeContext.renderExtra(props)), React__default.createElement(AnimationNode, __assign$c({}, props)));
}
var TreeNodeComponent = forwardRef(TreeNode);
TreeNodeComponent.displayName = "TreeNode";
var Node$1 = React__default.memo(TreeNodeComponent);
var __assign$b = globalThis && globalThis.__assign || function() {
  __assign$b = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$b.apply(this, arguments);
};
var __read$b = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$5 = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function getKey(option) {
  return option.key || option._key;
}
function NodeList(props, ref) {
  var className = props.className, style = props.style, filterNode = props.filterNode, virtualListProps = props.virtualListProps, expandedKeys = props.expandedKeys, currentExpandKeys = props.currentExpandKeys, saveCacheNode = props.saveCacheNode, nodeList = props.nodeList, getNodeProps = props.getNodeProps;
  var isVirtual = (virtualListProps === null || virtualListProps === void 0 ? void 0 : virtualListProps.threshold) !== null;
  var virtualListRef = useRef();
  var treeWrapperRef = useRef();
  var expandedKeysSet = useMemo(function() {
    return new Set(expandedKeys);
  }, [expandedKeys]);
  var visibleKeys = useMemo(function() {
    var newKeys = new Set();
    var currentExpandKeysSet = new Set(currentExpandKeys);
    nodeList.forEach(function(nodeProps) {
      var pathParentKeys = nodeProps.pathParentKeys || [];
      if (pathParentKeys.every(function(key) {
        return !currentExpandKeysSet.has(key) && expandedKeysSet.has(key);
      })) {
        newKeys.add(nodeProps._key);
      }
    });
    return newKeys;
  }, [expandedKeysSet, currentExpandKeys, nodeList]);
  var calcChildrenList = useCallback(function() {
    return nodeList.filter(function(item2) {
      var pass = !filterNode || filterNode && filterNode(item2);
      if (pass && visibleKeys.has(item2.key)) {
        return true;
      }
      saveCacheNode(React__default.createElement(Node$1, __assign$b({}, item2, getNodeProps(item2), { key: item2.key })));
      return false;
    });
  }, [nodeList, filterNode, visibleKeys]);
  var _a = __read$b(useState(function() {
    return calcChildrenList();
  }), 2), childrenList = _a[0], setChildrenList = _a[1];
  useUpdate(function() {
    setChildrenList(calcChildrenList());
  }, [calcChildrenList]);
  useImperativeHandle(ref, function() {
    return {
      scrollIntoView: function(_index, nodeProps) {
        var index2 = _index;
        var isKey2 = typeof _index === "string";
        if (isKey2) {
          var key_1 = _index;
          if (!visibleKeys.has(_index) && nodeProps && nodeProps.pathParentKeys) {
            key_1 = __spreadArray$5([], __read$b(nodeProps.pathParentKeys), false).reverse().find(function(key) {
              return visibleKeys.has(key);
            }) || index2;
          }
          index2 = childrenList.findIndex(function(_a2) {
            var _key = _a2._key;
            return _key === key_1;
          });
        }
        if (!isVirtual && treeWrapperRef.current) {
          var wrapperDom = treeWrapperRef.current;
          var node = wrapperDom ? wrapperDom.children[index2] : null;
          node && scrollIntoViewIfNeed(node, {
            boundary: wrapperDom.parentElement
          });
        } else if (virtualListRef.current) {
          virtualListRef.current.scrollTo({ index: index2 });
        }
      }
    };
  });
  return isVirtual ? React__default.createElement(VirtualList$1, __assign$b({ className, style, ref: virtualListRef, data: childrenList, isStaticItemHeight: false, itemKey: getKey, onMouseDown: props.onMouseDown }, props.ariaProps, virtualListProps), function(item2) {
    var node = React__default.createElement(Node$1, __assign$b({}, item2, getNodeProps(item2, expandedKeysSet), { key: item2.key }));
    saveCacheNode(node);
    return node;
  }) : React__default.createElement("div", __assign$b({ role: "tree", tabIndex: 0, className, style, ref: treeWrapperRef }, props.ariaProps, { onMouseDown: props.onMouseDown }), childrenList.map(function(item2) {
    var node = React__default.createElement(Node$1, __assign$b({}, item2, getNodeProps(item2, expandedKeysSet), { key: item2.key }));
    saveCacheNode(node);
    return node;
  }));
}
var NodeList$1 = forwardRef(NodeList);
var __assign$a = globalThis && globalThis.__assign || function() {
  __assign$a = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$a.apply(this, arguments);
};
var __read$a = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$4 = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var getTreeDataFromTreeChildren = function(treeChildren) {
  var loop = function(children) {
    return React__default.Children.map(children, function(child) {
      if (!React__default.isValidElement(child)) {
        return;
      }
      var key = child.key;
      return __assign$a(__assign$a({}, child.props), { key, children: loop(child.props.children) });
    });
  };
  return loop(treeChildren);
};
function getChildNodeKeys(node, key2nodeProps) {
  var nodes = new Set();
  var loop = function(children) {
    children.map(function(child) {
      var key = child.key;
      var item2 = key2nodeProps[key];
      if (!item2 || item2.disabled || item2.disableCheckbox || item2.checkable === false) {
        return;
      }
      nodes.add(key);
      loop(item2.children || []);
    });
  };
  if (node) {
    loop(node.children || []);
  }
  return nodes;
}
var updateParent = function(key, key2nodeProps, allKeys, indeterminateKeysSet) {
  var pathParentKeys = __spreadArray$4([], __read$a(key2nodeProps[key].pathParentKeys), false);
  pathParentKeys.reverse().forEach(function(itemKey) {
    var parent2 = key2nodeProps[itemKey];
    if (parent2 && !parent2.disabled && !parent2.disableCheckbox && parent2.checkable !== false) {
      var total_1 = 0;
      var number_1 = 0;
      parent2.children.some(function(_a) {
        var key2 = _a.key;
        var item2 = key2nodeProps[key2];
        if (!item2 || item2.disabled || item2.disableCheckbox || item2.checkable === false) {
          return false;
        }
        total_1++;
        if (allKeys.has(key2)) {
          number_1++;
        } else if (indeterminateKeysSet.has(key2)) {
          number_1 += 0.5;
          return true;
        }
      });
      if (!number_1 || number_1 === total_1) {
        indeterminateKeysSet.delete(itemKey);
      } else {
        indeterminateKeysSet.add(itemKey);
      }
      if (number_1 && number_1 === total_1) {
        allKeys.add(itemKey);
      } else {
        allKeys.delete(itemKey);
      }
    }
  });
};
function getCheckedKeysByInitKeys(checkedKeys, key2nodeProps) {
  var checkedKeysSet = new Set(checkedKeys || []);
  var indeterminateKeysSet = new Set();
  var childCheckedKeysSet = new Set();
  checkedKeys.forEach(function(key) {
    if (!childCheckedKeysSet.has(key)) {
      var childKeys = getChildNodeKeys(key2nodeProps[key], key2nodeProps);
      childKeys.forEach(function(v) {
        childCheckedKeysSet.add(v);
      });
    }
    if (key2nodeProps[key] && !key2nodeProps[key].pathParentKeys.some(function(_key) {
      return checkedKeysSet.has(_key);
    })) {
      updateParent(key, key2nodeProps, checkedKeysSet, indeterminateKeysSet);
    }
  });
  return {
    checkedKeys: __spreadArray$4([], __read$a(new Set(__spreadArray$4(__spreadArray$4([], __read$a(checkedKeysSet), false), __read$a(childCheckedKeysSet), false))), false),
    indeterminateKeys: __spreadArray$4([], __read$a(indeterminateKeysSet), false)
  };
}
function getAllCheckedKeysByCheck(key, checked, checkedKeys, key2nodeProps, indeterminateKeys) {
  if (!key2nodeProps[key]) {
    return {
      checkedKeys,
      indeterminateKeys
    };
  }
  var checkedKeysSet = new Set(checkedKeys);
  var indeterminateKeysSet = new Set(indeterminateKeys);
  var childKeys = getChildNodeKeys(key2nodeProps[key], key2nodeProps);
  var allKeys = checkedKeysSet;
  if (checked) {
    allKeys.add(key);
    indeterminateKeysSet.delete(key);
    childKeys.forEach(function(v) {
      allKeys.add(v);
    });
  } else {
    indeterminateKeysSet.delete(key);
    allKeys.delete(key);
    childKeys.forEach(function(v) {
      allKeys.delete(v);
    });
  }
  updateParent(key, key2nodeProps, checkedKeysSet, indeterminateKeysSet);
  return {
    checkedKeys: __spreadArray$4([], __read$a(allKeys), false),
    indeterminateKeys: __spreadArray$4([], __read$a(indeterminateKeysSet), false)
  };
}
var __extends = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$9 = globalThis && globalThis.__assign || function() {
  __assign$9 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$9.apply(this, arguments);
};
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$2 = globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
          return t2;
        if (y = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest$3 = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read$9 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$3 = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DefaultFieldNames$1 = {
  key: "key",
  title: "title",
  children: "children",
  selectable: "selectable",
  disabled: "disabled",
  disableCheckbox: "disableCheckbox",
  checkable: "checkable",
  isLeaf: "isLeaf"
};
var defaultProps$1 = {
  selectable: true,
  autoExpandParent: true,
  checkedStrategy: "all",
  actionOnClick: "select",
  allowDrop: function() {
    return true;
  },
  fieldNames: DefaultFieldNames$1
};
var needMergeKeys = [
  "style",
  "className",
  "height",
  "size",
  "blockNode",
  "autoExpandParent",
  "checkedStrategy",
  "fieldNames",
  "icons",
  "virtualListProps",
  "showLine",
  "selectable",
  "allowDrop",
  "actionOnClick"
];
var Tree = function(_super) {
  __extends(Tree2, _super);
  function Tree2(props, context) {
    var _this = _super.call(this, props, context) || this;
    _this.cacheNodes = {};
    _this.key2nodeProps = {};
    _this.getMergedProps = function(baseProps) {
      var componentConfig2 = _this.context.componentConfig;
      var props2 = baseProps || _this.props;
      return needMergeKeys.reduce(function(_props, key) {
        if (props2[key] !== void 0) {
          _props[key] = props2[key];
        } else if ((componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Tree) && (componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Tree[key]) !== void 0) {
          _props[key] = componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.Tree[key];
        } else if (defaultProps$1[key] !== void 0) {
          _props[key] = defaultProps$1[key];
        }
        return _props;
      }, {});
    };
    _this.scrollIntoView = function(_index, nodeProps) {
      var index2 = _index;
      if (typeof _index === "string" || nodeProps) {
        index2 = _index || nodeProps._key;
      }
      if (_this.nodeListRef) {
        _this.nodeListRef.scrollIntoView(index2, nodeProps || _this.key2nodeProps[index2]);
      }
    };
    _this.getTreeData = function() {
      return "treeData" in _this.props ? _this.props.treeData : getTreeDataFromTreeChildren(_this.props.children);
    };
    _this.needUpdateTreeData = function(prevProps, props2) {
      var keys2 = [
        "fieldNames",
        "selectable",
        "draggable",
        "checkStrictly",
        "showLine",
        "blockNode",
        "checkable",
        "treeData",
        "children"
      ];
      return prevProps.treeData !== props2.treeData || prevProps.children !== props2.children || keys2.some(function(key) {
        return isEqualWith_1(prevProps[key], props2[key]);
      });
    };
    _this.getFieldInfo = function(data) {
      var mergedProps = _this.getMergedProps();
      var selectable = mergedProps.selectable;
      var fieldNames = __assign$9(__assign$9({}, DefaultFieldNames$1), "treeData" in _this.props ? mergedProps.fieldNames : {});
      var result = {
        children: data[fieldNames.children],
        selectable: fieldNames.selectable in data ? data[fieldNames.selectable] : selectable,
        checkable: fieldNames.checkable in data ? data[fieldNames.checkable] : _this.props.checkable,
        title: data[fieldNames.title],
        disabled: data[fieldNames.disabled],
        disableCheckbox: data[fieldNames.disableCheckbox],
        isLeaf: data[fieldNames.isLeaf],
        key: data[fieldNames.key]
      };
      if (!(fieldNames.key in data)) {
        delete result.key;
      }
      return result;
    };
    _this.getNodeList = function(treedata, prefix) {
      _this.key2nodeProps = {};
      var prefixCls2 = prefix || _this.context.getPrefixCls("tree");
      var nodeList2 = [];
      var currentIndex = 0;
      var _a2 = _this.getMergedProps(), showLine = _a2.showLine, blockNode = _a2.blockNode;
      var loop = function(treeData2, father) {
        var totalLength = treeData2.length;
        return treeData2.map(function(data, index2) {
          var _a3 = _this.getFieldInfo(data), children = _a3.children, selectable = _a3.selectable, checkable = _a3.checkable, _b = _a3.key, key = _b === void 0 ? ((father === null || father === void 0 ? void 0 : father._key) || "") + "-" + index2 : _b, rest = __rest$3(_a3, ["children", "selectable", "checkable", "key"]);
          var nodeProps = __assign$9(__assign$9(__assign$9({
            dataRef: data,
            draggable: _this.props.draggable,
            selectable,
            checkable,
            showLine,
            blockNode
          }, data), rest), {
            key,
            children,
            _key: key,
            _index: currentIndex++,
            parentKey: father ? father._key : void 0,
            pathParentKeys: father && father.pathParentKeys || [],
            _level: father._level || 0,
            _lineless: father && father._lineless ? __spreadArray$3(__spreadArray$3([], __read$9(father._lineless || []), false), [father._isTail], false) : []
          });
          if (totalLength === index2 + 1) {
            nodeProps.className = cs$1(prefixCls2 + "-node-is-tail", nodeProps.className);
          }
          nodeList2.push(nodeProps);
          _this.key2nodeProps[key] = nodeProps;
          if (children && children.length) {
            _this.key2nodeProps[key].children = loop(children, {
              _key: key,
              _level: nodeProps._level + 1,
              _lineless: nodeProps._lineless,
              _isTail: totalLength === index2 + 1,
              pathParentKeys: __spreadArray$3(__spreadArray$3([], __read$9((father === null || father === void 0 ? void 0 : father.pathParentKeys) || []), false), [key], false)
            });
          }
          return nodeProps;
        });
      };
      loop(treedata || [], {});
      return nodeList2;
    };
    _this.getInitExpandedKeys = function(keys2) {
      if (!_this.getMergedProps().autoExpandParent) {
        return keys2 || [];
      }
      if (!keys2) {
        return Object.keys(_this.key2nodeProps).filter(function(key) {
          var props2 = _this.key2nodeProps[key];
          return props2.children && props2.children.length;
        });
      }
      var expandedKeys = {};
      keys2.forEach(function(key) {
        var item2 = _this.key2nodeProps[key];
        if (!item2) {
          return;
        }
        expandedKeys[key] = 1;
        if (item2.pathParentKeys) {
          item2.pathParentKeys.forEach(function(x) {
            expandedKeys[x] = 1;
          });
        }
      });
      return Object.keys(expandedKeys);
    };
    _this.getInitCheckedKeys = function(keys2) {
      if (!_this.props.checkStrictly) {
        var _a2 = getCheckedKeysByInitKeys(keys2, _this.key2nodeProps), checkedKeys2 = _a2.checkedKeys, indeterminateKeys = _a2.indeterminateKeys;
        return {
          checkedKeys: checkedKeys2,
          halfCheckedKeys: indeterminateKeys
        };
      }
      return {
        checkedKeys: keys2,
        halfCheckedKeys: _this.props.halfCheckedKeys || []
      };
    };
    _this.handleSelect = function(key, e) {
      var onSelect = _this.props.onSelect;
      var extra = { e, node: _this.cacheNodes[key] };
      if (_this.props.multiple) {
        var selectedKeys = __spreadArray$3([], __read$9(_this.state.selectedKeys), false);
        var index2 = selectedKeys.indexOf(key);
        if (index2 > -1) {
          selectedKeys.splice(index2, 1);
          extra.selected = false;
        } else {
          extra.selected = true;
          selectedKeys.push(key);
        }
        extra.selectedNodes = selectedKeys.map(function(x) {
          return _this.cacheNodes[x];
        });
        if (!("selectedKeys" in _this.props)) {
          _this.setState({ selectedKeys });
        }
        onSelect && onSelect(selectedKeys, extra);
      } else {
        extra.selected = true;
        extra.selectedNodes = [_this.cacheNodes[key]];
        if (!("selectedKeys" in _this.props)) {
          _this.setState({ selectedKeys: [key] });
        }
        onSelect && onSelect([key], extra);
      }
    };
    _this.handleCheck = function(checked, key, e) {
      var checkedStrategy = _this.getMergedProps().checkedStrategy;
      var _a2 = _this.props, onCheck = _a2.onCheck, checkStrictly = _a2.checkStrictly;
      var extra = { e, node: _this.cacheNodes[key] };
      var checkedKeys2 = _this.state.checkedKeys;
      var halfCheckedKeys2 = _this.state.halfCheckedKeys;
      if (checkStrictly) {
        if (checked) {
          checkedKeys2 = checkedKeys2.concat(key);
        } else {
          checkedKeys2 = checkedKeys2.filter(function(item2) {
            return item2 !== key;
          });
        }
        var newState = {};
        if (!("checkedKeys" in _this.props)) {
          newState.checkedKeys = checkedKeys2;
        }
        if (!("halfCheckedKeys" in _this.props)) {
          newState.halfCheckedKeys = halfCheckedKeys2;
        }
        if (!isEmptyObject$1(newState)) {
          _this.setState(__assign$9({}, newState));
        }
      } else {
        var _b = getAllCheckedKeysByCheck(key, checked, checkedKeys2, _this.key2nodeProps, halfCheckedKeys2), newCheckedKeys = _b.checkedKeys, indeterminateKeys = _b.indeterminateKeys;
        checkedKeys2 = newCheckedKeys;
        halfCheckedKeys2 = indeterminateKeys;
        if (!("checkedKeys" in _this.props)) {
          _this.setState({ checkedKeys: checkedKeys2, halfCheckedKeys: halfCheckedKeys2 });
        } else {
          _this.setState({ halfCheckedKeys: halfCheckedKeys2 });
        }
        if (checkedStrategy === Tree2.SHOW_PARENT) {
          checkedKeys2 = checkedKeys2.filter(function(x) {
            var item2 = _this.key2nodeProps[x];
            if (!item2 || checkedKeys2.indexOf(item2.parentKey) === -1) {
              return true;
            }
          });
        } else if (checkedStrategy === Tree2.SHOW_CHILD) {
          checkedKeys2 = checkedKeys2.filter(function(x) {
            var item2 = _this.key2nodeProps[x];
            if (!item2 || !item2.children || !item2.children.length) {
              return true;
            }
          });
        }
      }
      onCheck && onCheck(checkedKeys2, __assign$9({ checkedNodes: checkedKeys2.map(function(x) {
        return _this.cacheNodes[x];
      }).filter(function(x) {
        return x;
      }), checked, halfCheckedKeys: halfCheckedKeys2, halfCheckedNodes: halfCheckedKeys2.map(function(x) {
        return _this.cacheNodes[x];
      }).filter(function(x) {
        return x;
      }) }, extra));
    };
    _this.handleLoadMore = function(node) {
      var loadMore = _this.props.loadMore;
      if (isFunction$5(loadMore)) {
        var _a2 = _this.state, _b = _a2.loadingKeys, loadingKeys = _b === void 0 ? [] : _b, loadedKeys = _a2.loadedKeys;
        _this.setState({
          loadingKeys: Array.from(new Set(__spreadArray$3(__spreadArray$3([], __read$9(loadingKeys), false), [node._key], false))),
          loadedKeys: loadedKeys.filter(function(x) {
            return x !== node._key;
          })
        }, function() {
          return __awaiter$2(_this, void 0, void 0, function() {
            var e_1;
            return __generator$2(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  _a3.trys.push([0, 2, , 3]);
                  return [4, loadMore(this.cacheNodes[node._key])];
                case 1:
                  _a3.sent();
                  this.setState({
                    loadedKeys: Array.from(new Set(__spreadArray$3(__spreadArray$3([], __read$9(this.state.loadedKeys), false), [node._key], false))),
                    loadingKeys: this.state.loadingKeys.filter(function(x) {
                      return x !== node._key;
                    })
                  });
                  this.handleExpand(!node.expanded, node._key);
                  return [3, 3];
                case 2:
                  e_1 = _a3.sent();
                  console.error("[tree]load data error: ", e_1);
                  this.setState({
                    loadingKeys: this.state.loadingKeys.filter(function(x) {
                      return x !== node._key;
                    })
                  });
                  return [3, 3];
                case 3:
                  return [2];
              }
            });
          });
        });
      }
    };
    _this.handleNodeDragStart = function(e, node) {
      _this.dragNode = _this.cacheNodes[node._key];
      _this.dropPosition = 0;
      var onDragStart = _this.props.onDragStart;
      onDragStart && onDragStart(e, _this.cacheNodes[node._key]);
    };
    _this.handleNodeDragEnd = function(e, node) {
      _this.dragNode = null;
      _this.dropPosition = 0;
      var onDragEnd = _this.props.onDragEnd;
      onDragEnd && onDragEnd(e, _this.cacheNodes[node._key]);
    };
    _this.handleNodeDragOver = function(e, node, dropPosition) {
      _this.dropPosition = dropPosition;
      var onDragOver = _this.props.onDragOver;
      onDragOver && onDragOver(e, _this.cacheNodes[node._key]);
    };
    _this.handleNodeDragLeave = function(e, node) {
      _this.dropPosition = 0;
      var onDragLeave = _this.props.onDragLeave;
      onDragLeave && onDragLeave(e, _this.cacheNodes[node._key]);
    };
    _this.isChildOfNode = function(node, target2) {
      var current = _this.key2nodeProps[node.parentKey];
      while (current) {
        var _key = current._key, parentKey = current.parentKey;
        if (_key === target2.props._key) {
          return true;
        }
        if (parentKey === _key)
          return;
        current = _this.key2nodeProps[parentKey];
      }
    };
    _this.isSameNode = function(node1, node2) {
      if (node1 === void 0 || node2 === void 0)
        return false;
      if (node1 === node2)
        return true;
      var key1 = node1.key;
      var key2 = node2.key;
      if (key1 !== void 0 || key2 !== void 0)
        return key1 === key2;
      var _key1 = node1.props._key;
      var _key2 = node2.props._key;
      if (_key1 === void 0 && _key2 === void 0)
        return false;
      return _key1 === _key2;
    };
    _this.handleNodeDrop = function(e, node, dropPosition) {
      if (_this.dragNode) {
        var allowDrop = _this.getMergedProps().allowDrop;
        var onDrop = _this.props.onDrop;
        var nodeInstance = _this.cacheNodes[node._key];
        if (onDrop && !_this.isChildOfNode(node, _this.dragNode) && !_this.isSameNode(_this.dragNode, nodeInstance)) {
          if (allowDrop && !allowDrop({ dropNode: nodeInstance, dragNode: _this.dragNode, dropPosition })) {
            return;
          }
          onDrop({
            dragNode: _this.dragNode,
            dropNode: nodeInstance,
            dropPosition,
            e
          });
        }
      }
    };
    _this.handleAllowDrop = function(node, dropPosition) {
      var allowDrop = _this.getMergedProps().allowDrop;
      var isAllowDrop = true;
      if (typeof allowDrop === "function") {
        isAllowDrop = allowDrop({
          dropNode: _this.cacheNodes[node._key],
          dragNode: _this.dragNode,
          dropPosition
        });
      }
      return isAllowDrop;
    };
    _this.handleExpand = function(expanded, key) {
      var _a2 = _this.state, currentExpandKeys = _a2.currentExpandKeys, _b = _a2.expandedKeys, expandedKeys = _b === void 0 ? [] : _b;
      var onExpand = _this.props.onExpand;
      if (currentExpandKeys.indexOf(key) > -1) {
        return;
      }
      var newExpandedKeys = [];
      if (expanded) {
        newExpandedKeys = Array.from(new Set(__spreadArray$3(__spreadArray$3([], __read$9(expandedKeys), false), [key], false)));
      } else {
        newExpandedKeys = expandedKeys.filter(function(k) {
          return k !== key;
        });
      }
      if (!("expandedKeys" in _this.props)) {
        _this.setState({
          expandedKeys: newExpandedKeys,
          currentExpandKeys: __spreadArray$3(__spreadArray$3([], __read$9(currentExpandKeys), false), [key], false)
        });
      }
      onExpand && onExpand(newExpandedKeys, {
        expanded,
        node: _this.cacheNodes[key],
        expandedNodes: newExpandedKeys.map(function(x) {
          return _this.cacheNodes[x];
        }).filter(function(x) {
          return x;
        })
      });
    };
    _this.getNodeProps = function(nodeProps, expandedKeysSet) {
      var autoExpandParent = _this.getMergedProps().autoExpandParent;
      var loadMore = _this.props.loadMore;
      var _a2 = _this.state, selectedKeys = _a2.selectedKeys, expandedKeys = _a2.expandedKeys, checkedKeys2 = _a2.checkedKeys, halfCheckedKeys2 = _a2.halfCheckedKeys, _b = _a2.loadingKeys, loadingKeys = _b === void 0 ? [] : _b, _c = _a2.loadedKeys, loadedKeys = _c === void 0 ? [] : _c;
      var hasChildren = nodeProps.children && nodeProps.children.length;
      var otherProps = {
        isLeaf: !hasChildren,
        autoExpandParent: hasChildren ? autoExpandParent : false,
        expanded: expandedKeysSet ? expandedKeysSet.has(nodeProps._key) : expandedKeys.indexOf(nodeProps._key) > -1
      };
      if (loadMore) {
        var loaded = loadedKeys.indexOf(nodeProps._key) > -1;
        otherProps.loaded = loaded;
        otherProps.isLeaf = hasChildren ? false : nodeProps.isLeaf;
      }
      return __assign$9(__assign$9(__assign$9({}, nodeProps), otherProps), { selected: selectedKeys && selectedKeys.indexOf(nodeProps._key) > -1, indeterminated: (halfCheckedKeys2 === null || halfCheckedKeys2 === void 0 ? void 0 : halfCheckedKeys2.indexOf(nodeProps._key)) > -1, loading: loadingKeys.indexOf(nodeProps._key) > -1, checked: checkedKeys2 && checkedKeys2.indexOf(nodeProps._key) > -1, selectedKeys, checkedKeys: checkedKeys2, loadingKeys, loadedKeys, expandedKeys: _this.state.expandedKeys, childrenData: nodeProps.children || [], children: null });
    };
    _this.handleExpandEnd = function(key) {
      var currentExpandKeys = _this.state.currentExpandKeys;
      if (currentExpandKeys.indexOf(key) > -1) {
        _this.setState({
          currentExpandKeys: currentExpandKeys.filter(function(v) {
            return v !== key;
          })
        });
      }
    };
    _this.getTreeState = function() {
      return _this.state;
    };
    _this.state = {};
    var treeData = _this.getTreeData();
    var nodeList = _this.getNodeList(treeData, context.getPrefixCls("tree"));
    var _a = _this.getInitCheckedKeys(props.checkedKeys || props.defaultCheckedKeys || []), checkedKeys = _a.checkedKeys, halfCheckedKeys = _a.halfCheckedKeys;
    _this.state = {
      selectedKeys: props.selectedKeys || props.defaultSelectedKeys || [],
      checkedKeys,
      halfCheckedKeys,
      expandedKeys: _this.getInitExpandedKeys(props.expandedKeys || props.defaultExpandedKeys),
      loadedKeys: [],
      loadingKeys: [],
      currentExpandKeys: [],
      nodeList
    };
    return _this;
  }
  Tree2.getDerivedStateFromProps = function(nextProps, state) {
    var newState = {};
    if ("selectedKeys" in nextProps && !isEqualWith_1(nextProps.selectedKeys, state.selectedKeys)) {
      newState.selectedKeys = nextProps.selectedKeys || [];
    }
    if (Object.keys(newState).length) {
      return newState;
    }
    return null;
  };
  Tree2.prototype.componentDidUpdate = function(prevProps) {
    var _this = this;
    var prevMergedProps = this.getMergedProps(prevProps);
    var mergedProps = this.getMergedProps();
    if (prevProps !== this.props || !isEqualWith_1(prevMergedProps, mergedProps)) {
      var newState_1 = {};
      if (this.needUpdateTreeData(__assign$9({ prevMergedProps }, prevProps), __assign$9(__assign$9({}, mergedProps), this.props))) {
        var treeData = this.getTreeData();
        var nodeList = this.getNodeList(treeData);
        newState_1.treeData = treeData;
        newState_1.nodeList = nodeList;
      }
      if (newState_1.treeData || "checkedKeys" in this.props && !isEqualWith_1(prevProps.checkedKeys, this.props.checkedKeys)) {
        var currentCheckedKeys = "checkedKeys" in this.props ? this.props.checkedKeys : this.state.checkedKeys;
        var _a = this.getInitCheckedKeys(currentCheckedKeys || []), halfCheckedKeys = _a.halfCheckedKeys, checkedKeys = _a.checkedKeys;
        if (!isEqualWith_1(checkedKeys, this.state.checkedKeys)) {
          newState_1.checkedKeys = checkedKeys;
        }
        if (!isEqualWith_1(halfCheckedKeys, this.state.halfCheckedKeys)) {
          newState_1.halfCheckedKeys = halfCheckedKeys;
        }
      }
      if (this.props.checkStrictly && "halfCheckedKeys" in this.props && !isEqualWith_1(prevProps.halfCheckedKeys, this.props.halfCheckedKeys)) {
        newState_1.halfCheckedKeys = this.props.halfCheckedKeys;
      }
      if ("expandedKeys" in this.props && !isEqualWith_1(this.props.expandedKeys, prevProps.expandedKeys)) {
        newState_1.expandedKeys = this.props.expandedKeys;
        newState_1.currentExpandKeys = __spreadArray$3(__spreadArray$3([], __read$9(newState_1.expandedKeys), false), __read$9(this.state.expandedKeys), false).reduce(function(total, next) {
          var index2 = total.indexOf(next);
          if (index2 === -1) {
            total.push(next);
          } else {
            total.splice(index2, 1);
          }
          return total;
        }, []).filter(function(key, _, array) {
          var _a2;
          if (_this.key2nodeProps[key]) {
            var pathParentKeys = _this.key2nodeProps[key].pathParentKeys;
            if (pathParentKeys.some(function(x) {
              return array.indexOf(x) > -1;
            })) {
              return false;
            }
            return (_a2 = _this.key2nodeProps[key].children) === null || _a2 === void 0 ? void 0 : _a2.length;
          }
        });
      }
      var currentExpandKeys = newState_1.currentExpandKeys || this.state.currentExpandKeys;
      if (newState_1.treeData && currentExpandKeys) {
        newState_1.currentExpandKeys = currentExpandKeys.filter(function(key) {
          var item2 = newState_1.treeData.find(function(node) {
            return node._key === key;
          });
          return item2 && item2.children && item2.children.length;
        });
      }
      if (Object.keys(newState_1).length) {
        this.setState(newState_1);
      }
    }
  };
  Tree2.prototype.render = function() {
    var _a;
    var _this = this;
    this.cacheNodes = {};
    var _b = this.getMergedProps(), className = _b.className, showLine = _b.showLine, size = _b.size, _virtualListProps = _b.virtualListProps, height = _b.height, style = _b.style, icons = _b.icons, actionOnClick = _b.actionOnClick;
    var _c = this.props, loadMore = _c.loadMore, checkable = _c.checkable;
    var virtualListProps = _virtualListProps ? __assign$9({ threshold: 100 }, _virtualListProps) : height ? { height, threshold: 100 } : {
      threshold: null
    };
    var getPrefixCls = this.context.getPrefixCls;
    var prefixCls2 = getPrefixCls("tree");
    return React__default.createElement(TreeContext.Provider, { value: {
      icons,
      key2nodeProps: this.key2nodeProps,
      getFieldInfo: this.getFieldInfo,
      getTreeState: this.getTreeState,
      getNodeProps: this.getNodeProps,
      onExpandEnd: this.handleExpandEnd,
      onSelect: this.handleSelect,
      onCheck: this.handleCheck,
      onNodeDragStart: this.handleNodeDragStart,
      onNodeDragEnd: this.handleNodeDragEnd,
      onNodeDragLeave: this.handleNodeDragLeave,
      onNodeDragOver: this.handleNodeDragOver,
      onNodeDrop: this.handleNodeDrop,
      onExpand: this.handleExpand,
      renderExtra: this.props.renderExtra,
      renderTitle: this.props.renderTitle,
      loadMore: loadMore && this.handleLoadMore,
      allowDrop: this.handleAllowDrop,
      actionOnClick,
      virtualListProps
    } }, React__default.createElement(NodeList$1, { ref: function(node) {
      _this.nodeListRef = node;
    }, className: cs$1(prefixCls2, (_a = {}, _a[prefixCls2 + "-checkable"] = checkable, _a[prefixCls2 + "-show-line"] = showLine, _a[prefixCls2 + "-size-" + size] = size, _a), className), style, filterNode: this.props.filterNode, virtualListProps, expandedKeys: this.state.expandedKeys, currentExpandKeys: this.state.currentExpandKeys, getNodeProps: this.getNodeProps, nodeList: this.state.nodeList, onMouseDown: this.props.onMouseDown, saveCacheNode: function(node) {
      _this.cacheNodes[node.key] = node;
    }, ariaProps: {
      role: "tree",
      "aria-multiselectable": this.props.multiple,
      tabIndex: 0
    } }));
  };
  Tree2.displayName = "Tree";
  Tree2.SHOW_PARENT = "parent";
  Tree2.SHOW_ALL = "all";
  Tree2.SHOW_CHILD = "child";
  Tree2.Node = Node$1;
  Tree2.contextType = ConfigContext;
  return Tree2;
}(Component);
var Tree$1 = Tree;
var normalizeValueToArray = function(val) {
  var value = val;
  if (!isArray$c(val)) {
    value = val === null || val === void 0 ? [] : [val];
  }
  return value.map(function(x) {
    if (isObject$e(x)) {
      return x.value;
    }
    return x;
  });
};
var __assign$8 = globalThis && globalThis.__assign || function() {
  __assign$8 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$8.apply(this, arguments);
};
var __read$8 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var parseValue = function(v, key2nodeProps, valueMap) {
  if (v === void 0 || v === null) {
    return [];
  }
  var value = isArray$c(v) ? v : [v];
  return value.map(function(x) {
    var result = isObject$e(x) ? __assign$8({}, x) : { value: x, label: void 0 };
    var item2 = key2nodeProps[result.value];
    if (item2) {
      result.label = result.label || item2.title;
      result.disabled = item2.disabled;
    } else if (isArray$c(valueMap)) {
      var v_1 = valueMap.find(function(y) {
        return y.value === result.value;
      });
      result = __assign$8(__assign$8({}, result), v_1);
    }
    if (isUndefined(result.label)) {
      result.label = result.value;
    }
    return result;
  });
};
var getInitCheckKeys = function(keys2, key2nodeProps, indeterminateKeys, props) {
  if (!props.treeCheckStrictly) {
    var _a = getCheckedKeysByInitKeys(keys2, key2nodeProps), allCheckedKeys = _a.checkedKeys, halfKeys = _a.indeterminateKeys;
    var checkedKeys_1 = allCheckedKeys;
    indeterminateKeys.current = halfKeys;
    if (props.treeCheckedStrategy === Tree$1.SHOW_PARENT) {
      checkedKeys_1 = checkedKeys_1.filter(function(x) {
        var item2 = key2nodeProps[x];
        if (!item2 || checkedKeys_1.indexOf(item2.parentKey) === -1) {
          return true;
        }
      });
    } else if (props.treeCheckedStrategy === Tree$1.SHOW_CHILD) {
      checkedKeys_1 = checkedKeys_1.filter(function(x) {
        var item2 = key2nodeProps[x];
        if (!item2 || !item2.children || !item2.children.length) {
          return true;
        }
      });
    }
    return checkedKeys_1;
  }
  indeterminateKeys.current = [];
  return keys2;
};
var useStateValue = function(props, key2nodeProps, indeterminateKeys) {
  var calcValue = function() {
    var propsValue = props.value || props.defaultValue || [];
    if (props.treeCheckable) {
      var initCheckedKeys = getInitCheckKeys(normalizeValueToArray(propsValue), key2nodeProps, indeterminateKeys, props);
      var parsedPropValue = parseValue(propsValue, key2nodeProps);
      var parsedCheckedValue = parseValue(initCheckedKeys, key2nodeProps, parsedPropValue);
      return parsedCheckedValue;
    }
    return parseValue(propsValue, key2nodeProps);
  };
  var _a = __read$8(useState(calcValue()), 2), value = _a[0], setValue = _a[1];
  useUpdate(function() {
    var nextValue = calcValue();
    if ("value" in props) {
      if (props.labelInValue) {
        if (!isEqualWith_1(normalizeValueToArray(value), normalizeValueToArray(nextValue))) {
          setValue(nextValue);
        }
      } else if (!isEqualWith_1(value, nextValue)) {
        setValue(nextValue);
      }
    }
  }, [
    props.treeCheckedStrategy,
    props.treeCheckStrictly,
    props.treeCheckable,
    props.value,
    key2nodeProps
  ]);
  var setStateValue = useCallback(function(newValue, extra) {
    var onChange = props.onChange, labelInValue = props.labelInValue;
    var multiple = props.multiple || props.treeCheckable;
    if (!("value" in props)) {
      setValue(newValue);
    }
    var tmp;
    if (multiple) {
      tmp = newValue.map(function(x) {
        return labelInValue ? { label: x.label, value: x.value } : x.value;
      });
    } else {
      tmp = labelInValue ? newValue[0] : newValue[0] && newValue[0].value;
    }
    onChange && onChange(tmp, extra);
  }, [props.onChange, props.labelInValue, props.multiple, props.treeCheckable, props.value]);
  return [value, setStateValue];
};
var useStateValue$1 = useStateValue;
var DefaultFieldNames = {
  key: "key",
  title: "title",
  children: "children",
  selectable: "selectable",
  disabled: "disabled",
  disableCheckbox: "disableCheckbox",
  checkable: "checkable",
  isLeaf: "isLeaf"
};
var __read$7 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function useTreeData(props) {
  var prevProps = usePrevious(props) || {};
  var getData = function() {
    return props.treeData || getTreeDataFromTreeChildren(props.children);
  };
  var _a = __read$7(useState(getData()), 2), treeData = _a[0], setTreeData = _a[1];
  useUpdate(function() {
    if (props.treeData !== prevProps.treeData || props.children !== prevProps.children) {
      setTreeData(getData());
    }
  }, [props]);
  return [treeData];
}
var __assign$7 = globalThis && globalThis.__assign || function() {
  __assign$7 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$7.apply(this, arguments);
};
var __read$6 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$2 = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var getKey2NodeProps = function(treedata, prefixCls2, fieldNames) {
  var key2nodeProps = {};
  var currentIndex = 0;
  var loop = function(treeData, father) {
    var totalLength = treeData.length;
    return treeData.map(function(data, index2) {
      var children = data[fieldNames.children];
      var key = fieldNames.key in data ? data[fieldNames.key] : ((father === null || father === void 0 ? void 0 : father._key) || "") + "-" + index2;
      var nodeProps = __assign$7(__assign$7({}, data), { title: data[fieldNames.title], selectable: data[fieldNames.selectable], disabled: data[fieldNames.disabled], disableCheckbox: data[fieldNames.disableCheckbox], checkable: data[fieldNames.checkable], isLeaf: data[fieldNames.isLeaf], key, children, _key: key, parentKey: father ? father._key : void 0, pathParentKeys: father && father.pathParentKeys || [], _level: father._level || 0, _index: currentIndex++ });
      if (totalLength === index2 + 1) {
        nodeProps.className = cs$1(prefixCls2 + "-node-is-tail", nodeProps.className);
      }
      key2nodeProps[key] = nodeProps;
      if (children && children.length) {
        key2nodeProps[key].children = loop(children, {
          _key: key,
          _level: nodeProps._level + 1,
          pathParentKeys: __spreadArray$2(__spreadArray$2([], __read$6((father === null || father === void 0 ? void 0 : father.pathParentKeys) || []), false), [key], false)
        });
      }
      return nodeProps;
    });
  };
  loop(treedata || [], {});
  return key2nodeProps;
};
var useKeyCache = function(treeData, fieldNames) {
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var _fieldNames = __assign$7(__assign$7({}, DefaultFieldNames), fieldNames);
  var dispatch = useForceUpdate();
  var prefixCls2 = getPrefixCls("tree");
  var cache = useRef(getKey2NodeProps(treeData, prefixCls2, _fieldNames));
  useUpdate(function() {
    cache.current = getKey2NodeProps(treeData, prefixCls2, _fieldNames);
    dispatch();
  }, [treeData]);
  return cache.current;
};
var useKeyCache$1 = useKeyCache;
var __assign$6 = globalThis && globalThis.__assign || function() {
  __assign$6 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$6.apply(this, arguments);
};
var __read$5 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$1 = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function TreeList(props, ref) {
  var value = props.value, multiple = props.multiple, loadMore = props.loadMore, treeCheckedStrategy = props.treeCheckedStrategy, treeCheckStrictly = props.treeCheckStrictly, treeData = props.treeData, treeProps = props.treeProps, prefixCls2 = props.prefixCls, treeCheckable = props.treeCheckable;
  var propsRenderTitle = treeProps && treeProps.renderTitle;
  var treeRef = useRef();
  var handleCheck = useCallback(function(keys2, _a) {
    var checkedNodes = _a.checkedNodes, checked = _a.checked, node = _a.node;
    var newValue = keys2.map(function(key) {
      var item2 = checkedNodes.find(function(x) {
        return x && x.props._key === key;
      });
      if (!item2) {
        var tmp = value.find(function(x) {
          return x.value === key;
        });
        return tmp || {
          label: key,
          value: key
        };
      }
      return {
        label: item2.props.title,
        value: item2.props._key,
        disabled: item2.props.disabled
      };
    });
    props.onChange(newValue, {
      checked,
      trigger: node === null || node === void 0 ? void 0 : node.props
    });
  }, [props.onChange, value]);
  var handleChange = useCallback(function(_, _a) {
    var node = _a.node, selected = _a.selected;
    var newValue = [
      {
        value: node.props._key,
        label: node.props.title
      }
    ];
    if (multiple) {
      newValue = __spreadArray$1([], __read$5(value), false);
      var index2 = newValue.findIndex(function(x) {
        return x.value === node.props._key;
      });
      if (index2 > -1) {
        newValue.splice(index2, 1);
      } else {
        newValue.push({
          value: node.props._key,
          label: node.props.title
        });
      }
    }
    props.onChange(newValue, { trigger: node === null || node === void 0 ? void 0 : node.props, selected });
  }, [props.onChange, value, multiple]);
  var handleCheckableSelect = useCallback(function(_, _a) {
    var node = _a.node, e = _a.e;
    var _b = node.props, checked = _b.checked, checkable = _b.checkable, disabled = _b.disabled, disableCheckbox = _b.disableCheckbox;
    if (treeRef.current && !disableCheckbox && !disabled && checkable !== false) {
      treeRef.current.handleCheck && treeRef.current.handleCheck(!checked, node.props._key, e);
    }
  }, []);
  var handleLoadMore = useCallback(function(treeNode) {
    if (isFunction$5(loadMore)) {
      var dataRef = treeNode.props.dataRef;
      return loadMore(treeNode, dataRef);
    }
    return [];
  }, [loadMore]);
  var renderTitle = useCallback(function(nodeProps) {
    if (propsRenderTitle) {
      return propsRenderTitle(nodeProps);
    }
    var inputValue = props.inputValue;
    var title2 = nodeProps.title;
    if (inputValue && isString$1(title2)) {
      var index2 = title2.toLowerCase().indexOf(inputValue.toLowerCase());
      if (index2 === -1) {
        return title2;
      }
      var prefix = title2.substr(0, index2);
      var suffix = title2.substr(index2 + inputValue.length);
      return React__default.createElement("span", null, prefix, React__default.createElement("span", { className: prefixCls2 + "-highlight" }, title2.substr(index2, inputValue.length)), suffix);
    }
    return title2;
  }, [prefixCls2, props.inputValue, propsRenderTitle]);
  var extraProps = useMemo(function() {
    return props.treeCheckable ? {
      onCheck: handleCheck,
      checkedKeys: value.map(function(x) {
        return x.value;
      })
    } : {};
  }, [handleCheck, value, props.treeCheckable]);
  var selectedKeys = useMemo(function() {
    return props.treeCheckable ? [] : value.map(function(x) {
      return x.value;
    });
  }, [props.treeCheckable, value]);
  var onSelect = useCallback(function(_, extra) {
    props.treeCheckable ? handleCheckableSelect(_, extra) : handleChange(_, extra);
  }, [props.treeCheckable, handleCheckableSelect, handleChange]);
  useImperativeHandle(ref, function() {
    return treeRef.current;
  }, []);
  return React__default.createElement(Tree$1, __assign$6({ ref: treeRef, size: props.size, blockNode: true, filterNode: props.filterNode }, treeProps, { checkable: treeCheckable, multiple, loadMore: props.loadMore ? handleLoadMore : void 0, checkedStrategy: treeCheckedStrategy, checkStrictly: treeCheckStrictly, onMouseDown: function(e) {
    e.preventDefault();
  } }, extraProps, { treeData, fieldNames: props.fieldNames, renderTitle, onSelect, selectedKeys }));
}
var TreeList$1 = forwardRef(TreeList);
var __assign$5 = globalThis && globalThis.__assign || function() {
  __assign$5 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$5.apply(this, arguments);
};
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$1 = globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
          return t2;
        if (y = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __read$4 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function isEmptyValue(value) {
  return !value || isArray$c(value) && value.length === 0 || isObject$e(value) && Object.keys(value).length === 0;
}
var globalTreeSelectIndex = 0;
var defaultProps = {
  bordered: true,
  treeCheckedStrategy: Tree$1.SHOW_CHILD,
  fieldNames: DefaultFieldNames
};
var TreeSelect = function(baseProps, ref) {
  var _a = useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, renderEmpty2 = _a.renderEmpty, componentConfig2 = _a.componentConfig;
  var props = useMergeProps(baseProps, defaultProps, componentConfig2 === null || componentConfig2 === void 0 ? void 0 : componentConfig2.TreeSelect);
  var triggerRef = useRef();
  var treeRef = useRef(null);
  var refSelectView = useRef(null);
  var indeterminateKeys = useRef([]);
  var _b = __read$4(useTreeData(props), 1), treeData = _b[0];
  var key2nodeProps = useKeyCache$1(treeData, props.fieldNames);
  var _c = __read$4(useState(), 2), hitKeys = _c[0], setHitKeys = _c[1];
  var _d = __read$4(useMergeValue(false, {
    value: props.popupVisible
  }), 2), popupVisible = _d[0], setPopupVisible = _d[1];
  var _e = __read$4(useState(), 2), inputValue = _e[0], setInputValue = _e[1];
  var _f = __read$4(useStateValue$1(props, key2nodeProps, indeterminateKeys), 2), value = _f[0], setValue = _f[1];
  var multiple = props.multiple || props.treeCheckable;
  var prefixCls2 = getPrefixCls("tree-select");
  var isFilterNode = inputValue && !isFunction$5(props.onSearch);
  var instancePopupID = useMemo(function() {
    var id = prefixCls2 + "-popup-" + globalTreeSelectIndex;
    globalTreeSelectIndex++;
    return id;
  }, []);
  var handleSearch = useCallback(function(inputText) {
    var search = debounce_1(function(inputText2) {
      return __awaiter$1(void 0, void 0, void 0, function() {
        var hitKeys2;
        return __generator$1(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!isFunction$5(props.onSearch))
                return [3, 2];
              return [4, props.onSearch(inputText2)];
            case 1:
              _a2.sent();
              return [2];
            case 2:
              if (!inputText2)
                return [2, treeData];
              hitKeys2 = new Set();
              Object.keys(key2nodeProps).forEach(function(key) {
                var nodeProps = key2nodeProps[key];
                var isHit = false;
                if (isFunction$5(props.filterTreeNode)) {
                  if (props.filterTreeNode(inputText2, React__default.createElement(Tree$1.Node, __assign$5({}, nodeProps)))) {
                    isHit = true;
                  }
                } else {
                  var text = nodeProps.value || nodeProps._key;
                  if (text && text.indexOf(inputText2) > -1) {
                    isHit = true;
                  }
                }
                if (isHit) {
                  hitKeys2.add(nodeProps.key);
                }
              });
              setHitKeys(hitKeys2);
              return [2];
          }
        });
      });
    }, 100);
    return search(inputText);
  }, [props.onSearch, treeData, key2nodeProps, props.filterTreeNode]);
  var resetInputValue = function() {
    var retainInputValueWhileSelect = true;
    if (isObject$e(props.showSearch)) {
      retainInputValueWhileSelect = props.showSearch.retainInputValueWhileSelect !== false;
    }
    if (props.multiple && !retainInputValueWhileSelect) {
      setInputValue("");
      handleSearch("");
    }
  };
  var triggerChange = useCallback(function(newValue, extra) {
    setValue(newValue, extra);
    resetInputValue();
    if (!multiple) {
      setPopupVisible(false);
    }
  }, [setValue]);
  var handleRemoveCheckedItem = function(item2, index2, e) {
    e.stopPropagation();
    if (item2.disabled) {
      return;
    }
    if (!props.treeCheckable || props.treeCheckStrictly || !key2nodeProps[item2.value]) {
      var newValue = value.filter(function(_, i2) {
        return i2 !== index2;
      });
      triggerChange(newValue, {
        trigger: key2nodeProps[item2.value] || item2,
        checked: false,
        selected: false
      });
      return;
    }
    var result = getAllCheckedKeysByCheck(item2.value, false, normalizeValueToArray(value), key2nodeProps, indeterminateKeys.current);
    indeterminateKeys.current = result.indeterminateKeys;
    triggerChange(parseValue(result.checkedKeys, key2nodeProps, value), {
      trigger: key2nodeProps[item2.value],
      checked: false,
      selected: false
    });
  };
  useEffect(function() {
    inputValue !== void 0 && handleSearch(inputValue);
  }, [inputValue]);
  var searchKeys = useMemo(function() {
    var newKeys = [];
    if (inputValue) {
      for (var key in key2nodeProps) {
        var item2 = key2nodeProps[key];
        var pathKeys = __spreadArray(__spreadArray([], __read$4(item2.pathParentKeys), false), [key], false);
        if (pathKeys.some(function(_key) {
          return hitKeys && hitKeys.has(_key);
        })) {
          newKeys = newKeys.concat(pathKeys);
        }
      }
    }
    return Array.from(new Set(newKeys));
  }, [inputValue, key2nodeProps, hitKeys]);
  useEffect(function() {
    popupVisible && setTimeout(function() {
      var target2 = value[0];
      if (treeRef.current && target2) {
        treeRef.current.scrollIntoView(target2.value);
      }
    });
    inputValue && setInputValue("");
  }, [popupVisible]);
  useImperativeHandle(ref, function() {
    return {
      focus: function() {
        refSelectView.current && refSelectView.current.focus();
      },
      blur: function() {
        refSelectView.current && refSelectView.current.blur();
      }
    };
  });
  var filterNode = useCallback(function(node) {
    return isFilterNode ? searchKeys.indexOf(node._key) > -1 : true;
  }, [isFilterNode, searchKeys]);
  var renderText = useCallback(function(val) {
    var _a2 = val || {}, _b2 = _a2.label, label = _b2 === void 0 ? "" : _b2, disabled = _a2.disabled;
    return { text: label, disabled };
  }, []);
  var tryUpdateSelectValue = function(value2) {
    setValue(value2, {});
  };
  return React__default.createElement(Trigger$1, __assign$5({ autoAlignPopupWidth: false, autoAlignPopupMinWidth: true, ref: triggerRef, classNames: "slideDynamicOrigin", trigger: "click", position: "bl", getPopupContainer: props.getPopupContainer, popupAlign: { bottom: 4 }, unmountOnExit: props.unmountOnExit }, props.triggerProps, { className: cs$1(prefixCls2 + "-trigger", props.triggerProps && props.triggerProps.className), popup: function() {
    var _a2, _b2, _c2;
    var dropdownRender = props.dropdownRender;
    var dom = isFilterNode && isEmptyValue(searchKeys) || isEmptyValue(treeData) ? props.notFoundContent || renderEmpty2("TreeSelect") : React__default.createElement(TreeList$1, __assign$5({ prefixCls: prefixCls2, ref: treeRef }, props, { inputValue, filterNode, value, onChange: triggerChange, multiple, treeData }));
    return React__default.createElement("div", { id: instancePopupID, className: prefixCls2 + "-popup", style: __assign$5({ maxHeight: ((_a2 = props.treeProps) === null || _a2 === void 0 ? void 0 : _a2.height) || ((_c2 = (_b2 = props.treeProps) === null || _b2 === void 0 ? void 0 : _b2.virtualListProps) === null || _c2 === void 0 ? void 0 : _c2.height) ? "unset" : "" }, props.dropdownMenuStyle) }, isFunction$5(dropdownRender) ? dropdownRender(dom) : dom);
  }, disabled: props.disabled, onVisibleChange: function(visible) {
    setPopupVisible(visible);
    props.onVisibleChange && props.onVisibleChange(visible);
  }, popupVisible }), typeof props.triggerElement === "function" ? function() {
    var _a2;
    var valueForCallback;
    if (multiple) {
      valueForCallback = value.map(function(x) {
        return props.labelInValue ? { label: x.label, value: x.value } : x.value;
      });
    } else {
      valueForCallback = props.labelInValue ? value[0] : (_a2 = value[0]) === null || _a2 === void 0 ? void 0 : _a2.value;
    }
    return props.triggerElement({ value: valueForCallback });
  }() : props.triggerElement || React__default.createElement(SelectView$1, __assign$5({ ref: refSelectView, ariaControls: instancePopupID }, props, {
    popupVisible,
    value: !multiple && isArray$c(value) ? value[0] : value,
    inputValue,
    isEmptyValue: isEmptyValue(value),
    prefixCls: prefixCls2,
    isMultiple: multiple,
    renderText,
    onSort: tryUpdateSelectValue,
    onRemoveCheckedItem: handleRemoveCheckedItem,
    onClear: function(e) {
      e.stopPropagation();
      triggerChange([], {});
      props.onClear && props.onClear(!!popupVisible);
    },
    onKeyDown: function(e) {
      e.stopPropagation();
    },
    onFocus: function(e) {
      e && e.stopPropagation();
    },
    onChangeInputValue: function(input) {
      setInputValue(input);
    }
  })));
};
var ForwardRefTreeSelect = forwardRef(TreeSelect);
var TreeSelectComponent = ForwardRefTreeSelect;
TreeSelectComponent.displayName = "TreeSelect";
TreeSelectComponent.Node = Tree$1.Node;
TreeSelectComponent.SHOW_ALL = Tree$1.SHOW_ALL;
TreeSelectComponent.SHOW_PARENT = Tree$1.SHOW_PARENT;
TreeSelectComponent.SHOW_CHILD = Tree$1.SHOW_CHILD;
var TreeSelect$1 = TreeSelectComponent;
function Typography$2(props, ref) {
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var prefixCls2 = getPrefixCls("typography");
  var className = props.className, style = props.style, children = props.children;
  var classNames = cs$1(prefixCls2, className);
  return React__default.createElement("article", { ref, style, className: classNames }, children);
}
var TypographyComponent = forwardRef(Typography$2);
TypographyComponent.displayName = "Typography";
var OriginTypography = TypographyComponent;
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
          return t2;
        if (y = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
function clipboard(text) {
  return __awaiter(this, void 0, void 0, function() {
    var err_1, span, selection, range2, success;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          if (!(navigator.clipboard && navigator.clipboard.writeText))
            return [3, 4];
          _a.label = 1;
        case 1:
          _a.trys.push([1, 3, , 4]);
          return [4, navigator.clipboard.writeText(text)];
        case 2:
          _a.sent();
          return [2];
        case 3:
          err_1 = _a.sent();
          console.error(err_1 !== null && err_1 !== void 0 ? err_1 : new DOMException("The request is not allowed", "NotAllowedError"));
          return [3, 4];
        case 4:
          span = document.createElement("span");
          span.textContent = text;
          span.style.whiteSpace = "pre";
          document.body.appendChild(span);
          selection = window.getSelection();
          range2 = window.document.createRange();
          selection.removeAllRanges();
          range2.selectNode(span);
          selection.addRange(range2);
          success = false;
          try {
            success = window.document.execCommand("copy");
          } catch (err) {
            console.log("error", err);
          }
          selection.removeAllRanges();
          window.document.body.removeChild(span);
          return [2, success ? Promise.resolve() : Promise.reject(new DOMException("The request is not allowed", "NotAllowedError"))];
      }
    });
  });
}
function ownKeys$4(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$4(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconCopyComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$4(_objectSpread$4({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-copy")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M20 6h18a2 2 0 0 1 2 2v22M8 16v24c0 1.105.891 2 1.996 2h20.007A1.99 1.99 0 0 0 32 40.008V15.997A1.997 1.997 0 0 0 30 14H10a2 2 0 0 0-2 2Z"
  }));
}
var IconCopy = /* @__PURE__ */ React__default.forwardRef(IconCopyComponent);
IconCopy.defaultProps = {
  isIcon: true
};
IconCopy.displayName = "IconCopy";
var IconCopy$1 = IconCopy;
function ownKeys$3(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$3(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconEditComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$3(_objectSpread$3({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-edit")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "m30.48 19.038 5.733-5.734a1 1 0 0 0 0-1.414l-5.586-5.586a1 1 0 0 0-1.414 0l-5.734 5.734m7 7L15.763 33.754a1 1 0 0 1-.59.286l-6.048.708a1 1 0 0 1-1.113-1.069l.477-6.31a1 1 0 0 1 .29-.631l14.7-14.7m7 7-7-7M6 42h36"
  }));
}
var IconEdit = /* @__PURE__ */ React__default.forwardRef(IconEditComponent);
IconEdit.defaultProps = {
  isIcon: true
};
IconEdit.displayName = "IconEdit";
var IconEdit$1 = IconEdit;
var isSingleNode = function(child) {
  return isString$1(child) || isNumber$1(child);
};
function mergedToString(children) {
  var mergedResult = [""];
  React__default.Children.forEach(children, function(child) {
    var prevIndex = mergedResult.length - 1;
    var prevChild = mergedResult[prevIndex];
    if (isSingleNode(child) && isSingleNode(prevChild)) {
      mergedResult[prevIndex] = "" + prevChild + child;
    } else if (child && child.props && child.props.children) {
      mergedResult.push(mergedToString(child.props.children));
    }
  });
  return mergedResult.join("");
}
var __read$3 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function Operations(props) {
  var children = props.children, copyable = props.copyable, editable = props.editable, ellipsis = props.ellipsis, expanding = props.expanding, setEditing = props.setEditing, onClickExpand = props.onClickExpand, forceShowExpand = props.forceShowExpand, isEllipsis = props.isEllipsis, _a = props.currentContext, currentContext = _a === void 0 ? {} : _a;
  var getPrefixCls = currentContext.getPrefixCls, locale = currentContext.locale;
  var prefixCls2 = getPrefixCls("typography");
  var _b = __read$3(useState(false), 2), isCopied = _b[0], setCopied = _b[1];
  var copyTimer = useRef(null);
  var copyConfig = isObject$e(copyable) ? copyable : {};
  var ellipsisConfig = isObject$e(ellipsis) ? ellipsis : {};
  var editableConfig = isObject$e(editable) ? editable : {};
  var expandNodes = isArray$c(ellipsisConfig.expandNodes) ? ellipsisConfig.expandNodes : [locale.Typography.fold, locale.Typography.unfold];
  useEffect(function() {
    return function() {
      clearTimeout(copyTimer.current);
      copyTimer.current = null;
    };
  }, []);
  function onClickCopy(e) {
    if (isCopied)
      return;
    var text = copyConfig.text !== void 0 ? copyConfig.text : mergedToString(children);
    clipboard(text);
    setCopied(true);
    copyConfig.onCopy && copyConfig.onCopy(text, e);
    copyTimer.current = setTimeout(function() {
      setCopied(false);
    }, 3e3);
  }
  var tooltips = copyConfig.tooltips || [locale.Typography.copy, locale.Typography.copied];
  var copyElement = copyable && React__default.createElement(Tooltip$1, { content: isCopied ? tooltips[1] : tooltips[0] }, React__default.createElement("span", { className: isCopied ? prefixCls2 + "-operation-copied" : prefixCls2 + "-operation-copy", onClick: onClickCopy }, isCopied ? React__default.createElement(IconCheckCircleFill$1, null) : copyConfig.icon || React__default.createElement(IconCopy$1, null)));
  var editElement = editable && React__default.createElement(Tooltip$1, { content: locale.Typography.edit }, React__default.createElement("span", { className: prefixCls2 + "-operation-edit", onClick: function(e) {
    editableConfig.onStart && editableConfig.onStart(mergedToString(children), e);
    setEditing(true);
  } }, React__default.createElement(IconEdit$1, null)));
  var ellipsisElement = forceShowExpand || ellipsisConfig.expandable && isEllipsis ? React__default.createElement("a", { className: prefixCls2 + "-operation-expand", onClick: onClickExpand }, expanding ? expandNodes[0] : expandNodes[1]) : null;
  return React__default.createElement(React__default.Fragment, null, ellipsisElement, editElement, copyElement);
}
function EditContent(props) {
  var prefixCls2 = props.prefixCls, children = props.children, setEditing = props.setEditing, editableConfig = props.editableConfig;
  var className = cs$1(prefixCls2 + "-typography", prefixCls2 + "-edit-content");
  var str = mergedToString(children);
  var input = useRef(null);
  useEffect(function() {
    input.current && input.current.focus && input.current.focus();
    if (input.current && input.current.dom) {
      var length_1 = input.current.dom.value.length;
      input.current.dom.setSelectionRange(length_1, length_1);
    }
  }, []);
  function onEnd() {
    setEditing(false);
    editableConfig.onEnd && editableConfig.onEnd(str);
  }
  function onChange(value) {
    editableConfig.onChange && editableConfig.onChange(value);
  }
  function onBlur3() {
    onEnd();
  }
  return React__default.createElement("div", { className }, React__default.createElement(Input$5.TextArea, { onBlur: onBlur3, ref: input, value: str, autoSize: true, onChange, onPressEnter: onEnd }));
}
var __assign$4 = globalThis && globalThis.__assign || function() {
  __assign$4 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$4.apply(this, arguments);
};
var __read$2 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var MEASURE_LINE_HEIGHT_TEXT = "hxj";
var MEASURE_STATUS;
(function(MEASURE_STATUS2) {
  MEASURE_STATUS2[MEASURE_STATUS2["INIT"] = 0] = "INIT";
  MEASURE_STATUS2[MEASURE_STATUS2["BEFORE_MEASURE"] = 1] = "BEFORE_MEASURE";
  MEASURE_STATUS2[MEASURE_STATUS2["MEASURING"] = 2] = "MEASURING";
  MEASURE_STATUS2[MEASURE_STATUS2["MEASURE_END"] = 3] = "MEASURE_END";
  MEASURE_STATUS2[MEASURE_STATUS2["NO_NEED_ELLIPSIS"] = 4] = "NO_NEED_ELLIPSIS";
})(MEASURE_STATUS || (MEASURE_STATUS = {}));
function useEllipsis(props) {
  var children = props.children, _a = props.rows, rows = _a === void 0 ? 1 : _a, width = props.width, expanding = props.expanding, renderMeasureContent = props.renderMeasureContent, simpleEllipsis = props.simpleEllipsis, onEllipsis = props.onEllipsis, suffix = props.suffix, expandNodes = props.expandNodes, expandable = props.expandable, ellipsisStr = props.ellipsisStr;
  var singleRowNode = useRef();
  var mirrorNode = useRef();
  var _b = __read$2(useState([0, 0, 0]), 2), binarySearchIndex = _b[0], setBinarySearchIndex = _b[1];
  var _c = __read$2(useState(0), 2), lineHeight = _c[0], setLineHeight = _c[1];
  var _d = __read$2(useState(MEASURE_STATUS.NO_NEED_ELLIPSIS), 2), status = _d[0], setStatus = _d[1];
  var _e = __read$2(binarySearchIndex, 3), startLoc = _e[0], midLoc = _e[1], endLoc = _e[2];
  var _f = __read$2(useState(false), 2), isEllipsis = _f[0], setIsEllipsis = _f[1];
  var nodeList = useMemo(function() {
    return React__default.Children.toArray(children);
  }, [children]);
  var closedLoc = useRef(0);
  useUpdate(function() {
    onEllipsis && onEllipsis(isEllipsis);
  }, [isEllipsis]);
  var isSimpleNode = function(node) {
    return isString$1(node) || isNumber$1(node);
  };
  var getTotalLen = function(list2) {
    var total = 0;
    list2.forEach(function(node) {
      if (isSimpleNode) {
        total += String(node).length;
      } else {
        total += 1;
      }
    });
    return total;
  };
  var totalLen = useMemo(function() {
    return getTotalLen(nodeList);
  }, [nodeList]);
  var updateSearchIndex = throttleByRaf(function(searchIndex) {
    return setBinarySearchIndex(searchIndex);
  });
  var getSlicedNode = function(sliceLen) {
    var slicedNode = [];
    var currentLen = 0;
    if (sliceLen >= totalLen) {
      return nodeList;
    }
    for (var index2 in nodeList) {
      var node = nodeList[index2];
      if (currentLen >= sliceLen) {
        return slicedNode;
      }
      var currentNodeLen = isSimpleNode(node) ? String(node).length : 1;
      if (currentNodeLen > sliceLen - currentLen) {
        slicedNode.push(String(node).slice(0, sliceLen - currentLen));
        currentLen = sliceLen;
        return slicedNode;
      }
      currentLen += currentNodeLen;
      slicedNode.push(node);
    }
    return slicedNode;
  };
  var measure = function() {
    var _a2, _b2;
    if (lineHeight) {
      if (status === MEASURE_STATUS.INIT) {
        var maxHeight = rows * lineHeight;
        var mirrorHeight = (_a2 = mirrorNode.current) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight;
        var currentEllipsis = mirrorHeight > maxHeight;
        if (!currentEllipsis || simpleEllipsis || expanding) {
          setStatus(MEASURE_STATUS.MEASURE_END);
          setIsEllipsis(currentEllipsis);
          setBinarySearchIndex([0, totalLen, totalLen]);
        } else {
          setIsEllipsis(true);
          setStatus(MEASURE_STATUS.BEFORE_MEASURE);
        }
      } else if (status === MEASURE_STATUS.BEFORE_MEASURE) {
        var totalWidth = singleRowNode === null || singleRowNode === void 0 ? void 0 : singleRowNode.current.offsetWidth;
        var closedWidth = rows * width;
        if (totalWidth > rows * width) {
          var startRatio = Math.max(closedWidth / totalWidth - 0.1, 0);
          var endRatio = Math.min(closedWidth / totalWidth + 0.1, 1);
          var closedStartLoc = Math.floor(startRatio * totalLen);
          var closedEndLoc = Math.ceil(endRatio * totalLen);
          var closedMiddleLoc = Math.floor((closedStartLoc + closedEndLoc) / 2);
          setBinarySearchIndex([closedStartLoc, closedMiddleLoc, closedEndLoc]);
          closedLoc.current = closedMiddleLoc;
        }
        setStatus(MEASURE_STATUS.MEASURING);
      } else if (status === MEASURE_STATUS.MEASURING) {
        if (startLoc !== endLoc - 1) {
          var mirrorHeight = (_b2 = mirrorNode.current) === null || _b2 === void 0 ? void 0 : _b2.offsetHeight;
          var maxHeight = rows * lineHeight;
          var nextStartLoc = startLoc;
          var nextEndLoc = endLoc;
          if (mirrorHeight <= maxHeight) {
            nextStartLoc = midLoc;
          } else {
            nextEndLoc = midLoc;
          }
          var nextMidLoc = Math.floor((nextEndLoc + nextStartLoc) / 2);
          updateSearchIndex([nextStartLoc, nextMidLoc, nextEndLoc]);
        } else {
          updateSearchIndex([startLoc, startLoc, startLoc]);
          setStatus(MEASURE_STATUS.MEASURE_END);
        }
      }
    }
  };
  useIsomorphicLayoutEffect$1(function() {
    if (props.rows && width) {
      setBinarySearchIndex([0, Math.floor(totalLen / 2), totalLen]);
      setStatus(MEASURE_STATUS.INIT);
    } else {
      setStatus(MEASURE_STATUS.NO_NEED_ELLIPSIS);
    }
  }, [
    totalLen,
    simpleEllipsis,
    expanding,
    width,
    suffix,
    expandNodes,
    expandable,
    ellipsisStr,
    props.rows
  ]);
  useIsomorphicLayoutEffect$1(function() {
    if (singleRowNode.current && status === MEASURE_STATUS.INIT) {
      var offsetHeight = singleRowNode.current.offsetHeight;
      setLineHeight(offsetHeight);
    }
  }, [status]);
  useIsomorphicLayoutEffect$1(function() {
    measure();
  }, [status, midLoc, startLoc, endLoc, lineHeight]);
  var basicStyle = {
    zIndex: -999,
    position: "fixed",
    opacity: 0,
    padding: 0,
    margin: 0
  };
  var singleRowNodeStyle = __assign$4({ whiteSpace: "nowrap" }, basicStyle);
  var mirrorNodeStyle = simpleEllipsis ? __assign$4({ textOverflow: "clip" }, basicStyle) : basicStyle;
  var ellipsisNode;
  if (status === MEASURE_STATUS.INIT || status === MEASURE_STATUS.BEFORE_MEASURE) {
    ellipsisNode = React__default.createElement(React__default.Fragment, null, React__default.createElement("div", { ref: singleRowNode, style: singleRowNodeStyle }, status === MEASURE_STATUS.INIT ? MEASURE_LINE_HEIGHT_TEXT : renderMeasureContent(children, false)), React__default.createElement("div", { ref: mirrorNode, style: __assign$4({ width }, mirrorNodeStyle) }, renderMeasureContent(children, isEllipsis)));
  } else if (status === MEASURE_STATUS.MEASURING) {
    ellipsisNode = React__default.createElement(React__default.Fragment, null, React__default.createElement("div", { ref: mirrorNode, style: __assign$4({ width }, mirrorNodeStyle) }, renderMeasureContent(getSlicedNode(midLoc), isEllipsis)), getSlicedNode(closedLoc.current));
  } else if (status === MEASURE_STATUS.MEASURE_END) {
    ellipsisNode = renderMeasureContent(getSlicedNode(midLoc), isEllipsis);
  } else if (status === MEASURE_STATUS.NO_NEED_ELLIPSIS) {
    ellipsisNode = renderMeasureContent(children, false);
  }
  return { ellipsisNode, isEllipsis, measureStatus: status };
}
var __read$1 = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var supportCss = function(key, value) {
  if (typeof window !== "undefined" && window.CSS && window.CSS.supports) {
    if (!isUndefined(value)) {
      return window.CSS.supports(key, value);
    }
    return window.CSS.supports(key);
  }
  if (typeof document !== "undefined" && document.createElement) {
    var elem = document.createElement("div");
    elem.setAttribute("style", key + ":" + value + ";");
    return typeof elem.style[key] !== "undefined";
  }
  return false;
};
var mutiEllipsisAttr = {
  display: " -webkit-box",
  "-webkit-line-clamp": 2
};
var isSupportMuti = function() {
  return Object.entries(mutiEllipsisAttr).every(function(_a) {
    var _b = __read$1(_a, 2), key = _b[0], value = _b[1];
    return supportCss(key, value);
  });
};
function useCssEllipsis(props) {
  var cssEllipsis = props.cssEllipsis, ellipsisStr = props.ellipsisStr, suffix = props.suffix, rows = props.rows;
  var simpleEllipsis = useMemo(function() {
    if (!cssEllipsis || rows > 1 && !isSupportMuti()) {
      return false;
    }
    return ellipsisStr === "..." && !suffix;
  }, [ellipsisStr, cssEllipsis, rows, suffix]);
  var singleRowStyle = {
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  };
  var mutiRowsStyle = {
    textOverflow: "ellipsis",
    whiteSpace: "normal",
    overflow: "hidden",
    WebkitLineClamp: "" + props.rows,
    WebkitBoxOrient: "vertical",
    display: "-webkit-box"
  };
  return {
    simpleEllipsis,
    ellipsisStyle: simpleEllipsis ? props.rows > 1 ? mutiRowsStyle : singleRowStyle : {}
  };
}
var __assign$3 = globalThis && globalThis.__assign || function() {
  __assign$3 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$3.apply(this, arguments);
};
var __rest$2 = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
var __read = globalThis && globalThis.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function getClassNameAndComponentName(props, prefixCls2) {
  var type = props.type, bold = props.bold, disabled = props.disabled, mark = props.mark, underline = props.underline, propDelete = props.delete, code2 = props.code;
  var component = [];
  var className = [];
  if (type) {
    className.push(prefixCls2 + "-" + type);
  }
  if (disabled) {
    className.push(prefixCls2 + "-disabled");
  }
  if (bold) {
    component.push("b");
  }
  if (underline) {
    component.push("u");
  }
  if (propDelete) {
    component.push("del");
  }
  if (code2) {
    component.push("code");
  }
  if (mark) {
    component.push("mark");
  }
  return {
    component,
    className
  };
}
function Base(props) {
  var componentType = props.componentType, style = props.style, className = props.className, children = props.children, editable = props.editable, ellipsis = props.ellipsis, heading = props.heading, blockquote = props.blockquote, rest = __rest$2(props, ["componentType", "style", "className", "children", "editable", "ellipsis", "heading", "blockquote"]);
  var configContext = useContext(ConfigContext);
  var getPrefixCls = configContext.getPrefixCls;
  var prefixCls2 = getPrefixCls("typography");
  var _a = getClassNameAndComponentName(props, prefixCls2), component = _a.component, componentClassName = _a.className;
  var _b = __read(useState(false), 2), editing = _b[0], setEditing = _b[1];
  var _c = __read(useState(0), 2), width = _c[0], setWidth = _c[1];
  var editableConfig = isObject$e(editable) ? editable : {};
  var mergedEditing = "editing" in editableConfig ? editableConfig.editing : editing;
  var ellipsisConfig = ellipsis ? __assign$3({ rows: 1, ellipsisStr: "...", cssEllipsis: false }, isObject$e(ellipsis) ? ellipsis : {}) : {};
  var _d = __read(useMergeValue(false, {
    defaultValue: ellipsisConfig.defaultExpanded,
    value: ellipsisConfig.expanded
  }), 2), expanding = _d[0], setExpanding = _d[1];
  var _e = useCssEllipsis(ellipsisConfig), simpleEllipsis = _e.simpleEllipsis, ellipsisStyle = _e.ellipsisStyle;
  var renderMeasureContent = function(node, isEllipsis2) {
    var ellipsisStr = !isUndefined(ellipsisConfig.ellipsisStr) ? ellipsisConfig.ellipsisStr : "...";
    var suffix = !isUndefined(ellipsisConfig.suffix) && ellipsisConfig.suffix;
    return React__default.createElement(React__default.Fragment, null, node, isEllipsis2 && !expanding && !simpleEllipsis ? ellipsisStr : "", suffix, renderOperations(isEllipsis2));
  };
  var _f = useEllipsis(__assign$3(__assign$3({}, ellipsisConfig), { children, expanding, width, renderMeasureContent, simpleEllipsis: simpleEllipsis || expanding })), ellipsisNode = _f.ellipsisNode, isEllipsis = _f.isEllipsis, measureStatus = _f.measureStatus;
  var handleResize = function(entry) {
    var contentRect = (entry === null || entry === void 0 ? void 0 : entry[0]).contentRect;
    if (contentRect) {
      var currentWidth = component.length ? contentRect.width - 16 : contentRect.width;
      var resizeStatus = simpleEllipsis && ellipsisConfig.rows === 1 ? [MEASURE_STATUS.NO_NEED_ELLIPSIS] : [MEASURE_STATUS.NO_NEED_ELLIPSIS, MEASURE_STATUS.MEASURE_END];
      if (resizeStatus.includes(measureStatus)) {
        setWidth(currentWidth);
      }
    }
  };
  function renderOperations(isEllipsis2) {
    return React__default.createElement(React__default.Fragment, null, React__default.createElement(Operations, __assign$3({}, props, {
      setEditing,
      onClickExpand,
      expanding,
      isEllipsis: isEllipsis2,
      currentContext: configContext
    })));
  }
  function onClickExpand(e) {
    setExpanding(!expanding);
    props.onClickExpand && props.onClickExpand(e);
    ellipsisConfig.onExpand && ellipsisConfig.onExpand(!expanding, e);
  }
  useUpdate(function() {
    ellipsisConfig.onEllipsis && ellipsisConfig.onEllipsis(isEllipsis);
  }, [isEllipsis]);
  function wrap2(content, component2, props2, innerProps) {
    if (innerProps === void 0) {
      innerProps = {};
    }
    var currentContent = content;
    component2.forEach(function(c, _index) {
      var _innerProps = _index === 0 ? innerProps : {};
      var _props = isObject$e(props2.mark) && props2.mark.color ? __assign$3({ style: { backgroundColor: props2.mark.color } }, _innerProps) : __assign$3({}, _innerProps);
      currentContent = React__default.createElement(c, __assign$3({}, _props), currentContent);
    });
    return currentContent;
  }
  function renderContent() {
    var fullText = mergedToString(React__default.Children.toArray(children));
    var showTooltip = ellipsisConfig.showTooltip;
    var tooltipType = isObject$e(ellipsisConfig.showTooltip) ? ellipsisConfig.showTooltip.type === "popover" ? "popover" : "tooltip" : "tooltip";
    var tooltipProps = isObject$e(ellipsisConfig.showTooltip) ? ellipsisConfig.showTooltip.props || {} : {};
    var TooltipComponent2 = tooltipType === "popover" ? Popover$1 : Tooltip$1;
    var titleProps = isEllipsis && !showTooltip && !expanding ? { title: fullText } : {};
    var baseProps = __assign$3({ style }, titleProps);
    var addTooltip = isEllipsis && showTooltip && !expanding;
    var TextComponent;
    if (componentType === "Paragraph") {
      TextComponent = blockquote ? "blockquote" : "div";
    } else if (componentType === "Title") {
      TextComponent = "h" + heading;
    } else if (componentType === "Text") {
      TextComponent = ellipsis ? "div" : "span";
    }
    var node = React__default.createElement(ResizeObserver, { onResize: handleResize }, React__default.createElement(TextComponent, __assign$3({ className: cs$1(prefixCls2, componentClassName, className) }, baseProps, omit$1(rest, [
      "spacing",
      "type",
      "close",
      "bold",
      "disabled",
      "mark",
      "underline",
      "delete",
      "code",
      "copyable",
      "isEllipsis",
      "expanding",
      "onClickExpand",
      "setEditing",
      "forceShowExpand"
    ])), simpleEllipsis && measureStatus !== MEASURE_STATUS.INIT && !expanding && isEllipsis ? wrap2(renderMeasureContent(React__default.createElement("span", { style: ellipsisStyle }, children), isEllipsis), component.length ? component : ["span"], props, { className: prefixCls2 + "-simple-ellipsis" }) : wrap2(ellipsisNode, component, props)));
    if (addTooltip) {
      return React__default.createElement(TooltipComponent2, __assign$3({ content: fullText }, tooltipProps), React__default.createElement("span", null, node));
    }
    return node;
  }
  return mergedEditing ? React__default.createElement(EditContent, __assign$3({}, props, { prefixCls: prefixCls2, setEditing, editableConfig })) : renderContent();
}
var __assign$2 = globalThis && globalThis.__assign || function() {
  __assign$2 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
var __rest$1 = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
};
function Title(props) {
  var _a = props.heading, heading = _a === void 0 ? 1 : _a, rest = __rest$1(props, ["heading"]);
  return React__default.createElement(Base, __assign$2({ heading }, rest, { componentType: "Title" }));
}
Title.displayName = "Title";
var __assign$1 = globalThis && globalThis.__assign || function() {
  __assign$1 = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
function Text$1(props) {
  return React__default.createElement(Base, __assign$1({}, props, { componentType: "Text" }));
}
Text$1.displayName = "Text";
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t2) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function Paragraph(props) {
  var _a = props.spacing, spacing = _a === void 0 ? "default" : _a, className = props.className;
  var getPrefixCls = useContext(ConfigContext).getPrefixCls;
  var prefixCls2 = getPrefixCls("typography");
  var classNames = spacing === "close" ? cs$1(prefixCls2 + "-spacing-close", className) : className;
  return React__default.createElement(Base, __assign({}, props, { componentType: "Paragraph", className: classNames }));
}
Paragraph.displayName = "Paragraph";
var Typography = OriginTypography;
Typography.Title = Title;
Typography.Text = Text$1;
Typography.Paragraph = Paragraph;
var Typography$1 = Typography;
function ownKeys$2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$2(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconUploadComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$2(_objectSpread$2({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-upload")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M14.93 17.071 24.001 8l9.071 9.071m-9.07 16.071v-25M40 35v6H8v-6"
  }));
}
var IconUpload = /* @__PURE__ */ React__default.forwardRef(IconUploadComponent);
IconUpload.defaultProps = {
  isIcon: true
};
IconUpload.displayName = "IconUpload";
var IconUpload$1 = IconUpload;
const transparentImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==";
const img = new Image();
img.width = 0;
img.height = 0;
img.src = transparentImage;
const fileNames = {
  key: "id"
};
function BlockTree(props) {
  const [blockTreeRef, setBlockTreeRef] = useState(null);
  const dragNode = useRef(null);
  const { treeData, allowDrop, onContextMenu, selectedKeys } = props;
  const treeDataRef = useRef(treeData);
  const {
    onDragStart: propsDragStart,
    onDrop: propsDrop,
    renderTitle: propsRenderTitle,
    onDragEnd: propsDragEnd,
    onSelect: propsSelect
  } = props;
  const [expandedKeys, setExpandedKeys] = useState([]);
  const onExpand = useCallback((keys2) => {
    setExpandedKeys(keys2);
  }, [setExpandedKeys]);
  useEffect(() => {
    if (props.defaultExpandAll) {
      const keys2 = [];
      const loop = (data) => {
        var _a;
        keys2.push(data.id);
        (_a = data.children) == null ? void 0 : _a.forEach(loop);
      };
      treeDataRef.current.forEach(loop);
      setExpandedKeys(keys2);
    }
  }, [props.defaultExpandAll]);
  useEffect(() => {
    setExpandedKeys((keys2) => props.expandedKeys ? [...keys2, ...props.expandedKeys] : keys2);
  }, [props.expandedKeys]);
  const onDragStart = useCallback((e, node) => {
    e.dataTransfer.dropEffect = "none";
    const dragNodeData = node.props.dataRef;
    dragNode.current = {
      dataRef: dragNodeData,
      parent: node.props.parent,
      key: node.props._key,
      parentKey: node.props.parentKey
    };
    propsDragStart == null ? void 0 : propsDragStart();
  }, [propsDragStart]);
  const onDragMove = useCallback((option) => {
    if (!dragNode.current)
      return false;
    const dropData = option.dropNode.props.dataRef;
    const dropId = option.dropNode.props._key;
    const currentDropData = {
      dragNode: { key: dragNode.current.key },
      dropNode: {
        dataRef: dropData,
        parent: option.dropNode.props.parent,
        key: dropId
      },
      dropPosition: option.dropPosition
    };
    const isAllowDrop = allowDrop(currentDropData);
    if (isAllowDrop) {
      return true;
    }
    return false;
  }, [allowDrop]);
  const onDrop = useCallback((info2) => {
    const { dropNode, dropPosition, e } = info2;
    e.dataTransfer.dropEffect = "move";
    if (!dragNode.current || !dropNode)
      return;
    const dropData = dropNode.props.dataRef;
    const currentDropData = {
      dragNode: dragNode.current,
      dropNode: {
        dataRef: dropData,
        parent: dropNode.props.parent,
        key: dropNode.props._key,
        parentKey: dropNode.props.parentKey
      },
      dropPosition
    };
    propsDrop(currentDropData);
  }, [propsDrop]);
  const renderTitle = useCallback((nodeData) => {
    return /* @__PURE__ */ React__default.createElement("div", {
      style: { display: "inline-flex", width: "100%" },
      onContextMenu: (ev) => onContextMenu && onContextMenu(nodeData, ev)
    }, propsRenderTitle(nodeData));
  }, [onContextMenu, propsRenderTitle]);
  const onDragEnd = useCallback(() => {
    dragNode.current = null;
    propsDragEnd == null ? void 0 : propsDragEnd();
  }, [propsDragEnd]);
  const onSelect = useCallback((selectedKeys2) => {
    propsSelect(selectedKeys2[0]);
  }, [propsSelect]);
  useEffect(() => {
    if (blockTreeRef) {
      blockTreeRef.addEventListener("dragover", (e) => {
        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = "move";
        }
      });
    }
  }, [blockTreeRef]);
  return useMemo(() => /* @__PURE__ */ React__default.createElement("div", {
    ref: setBlockTreeRef,
    onMouseLeave: props.onMouseLeave
  }, /* @__PURE__ */ React__default.createElement(CacheTree, {
    selectedKeys,
    expandedKeys,
    onExpand,
    draggable: true,
    size: "small",
    treeData,
    blockNode: true,
    fieldNames: fileNames,
    onDragEnd,
    onDragStart,
    onDrop,
    allowDrop: onDragMove,
    onSelect,
    renderTitle
  })), [
    treeData,
    props.onMouseLeave,
    expandedKeys,
    selectedKeys,
    onExpand,
    onDragEnd,
    onDragStart,
    onDrop,
    onDragMove,
    onSelect,
    renderTitle
  ]);
}
const cacheTreeDebounceCallback = lodash.exports.debounce((data, setCacheProps) => {
  setCacheProps(data);
}, 300);
function CacheTree(props) {
  const [cacheProps, setCacheProps] = useState(props);
  const lastProps = useRef(props);
  useEffect(() => {
    if (lastProps.current.treeData !== props.treeData) {
      lastProps.current = props;
      cacheTreeDebounceCallback(props, setCacheProps);
      return () => {
        cacheTreeDebounceCallback.cancel();
      };
    } else {
      lastProps.current = props;
      setCacheProps(props);
    }
  }, [props]);
  return useMemo(() => /* @__PURE__ */ React__default.createElement(Tree$1, __spreadValues({}, cacheProps)), [cacheProps]);
}
const wrap$1 = "_wrap_aul3a_1";
const listItem = "_listItem_aul3a_13";
const contextmenuMark = "_contextmenuMark_aul3a_23";
var styles$9 = {
  wrap: wrap$1,
  listItem,
  contextmenuMark
};
var rngBrowser = { exports: {} };
var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
if (getRandomValues) {
  var rnds8 = new Uint8Array(16);
  rngBrowser.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  var rnds = new Array(16);
  rngBrowser.exports = function mathRNG() {
    for (var i2 = 0, r; i2 < 16; i2++) {
      if ((i2 & 3) === 0)
        r = Math.random() * 4294967296;
      rnds[i2] = r >>> ((i2 & 3) << 3) & 255;
    }
    return rnds;
  };
}
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 256).toString(16).substr(1);
}
function bytesToUuid$2(buf, offset) {
  var i2 = offset || 0;
  var bth = byteToHex;
  return [
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]]
  ].join("");
}
var bytesToUuid_1 = bytesToUuid$2;
var rng$1 = rngBrowser.exports;
var bytesToUuid$1 = bytesToUuid_1;
var _nodeId;
var _clockseq;
var _lastMSecs = 0;
var _lastNSecs = 0;
function v1$1(options2, buf, offset) {
  var i2 = buf && offset || 0;
  var b = buf || [];
  options2 = options2 || {};
  var node = options2.node || _nodeId;
  var clockseq = options2.clockseq !== void 0 ? options2.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = rng$1();
    if (node == null) {
      node = _nodeId = [
        seedBytes[0] | 1,
        seedBytes[1],
        seedBytes[2],
        seedBytes[3],
        seedBytes[4],
        seedBytes[5]
      ];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options2.msecs !== void 0 ? options2.msecs : new Date().getTime();
  var nsecs = options2.nsecs !== void 0 ? options2.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options2.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options2.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i2++] = tl >>> 24 & 255;
  b[i2++] = tl >>> 16 & 255;
  b[i2++] = tl >>> 8 & 255;
  b[i2++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i2++] = tmh >>> 8 & 255;
  b[i2++] = tmh & 255;
  b[i2++] = tmh >>> 24 & 15 | 16;
  b[i2++] = tmh >>> 16 & 255;
  b[i2++] = clockseq >>> 8 | 128;
  b[i2++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i2 + n] = node[n];
  }
  return buf ? buf : bytesToUuid$1(b);
}
var v1_1 = v1$1;
var rng = rngBrowser.exports;
var bytesToUuid = bytesToUuid_1;
function v4$1(options2, buf, offset) {
  var i2 = buf && offset || 0;
  if (typeof options2 == "string") {
    buf = options2 === "binary" ? new Array(16) : null;
    options2 = null;
  }
  options2 = options2 || {};
  var rnds2 = options2.random || (options2.rng || rng)();
  rnds2[6] = rnds2[6] & 15 | 64;
  rnds2[8] = rnds2[8] & 63 | 128;
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i2 + ii] = rnds2[ii];
    }
  }
  return buf || bytesToUuid(rnds2);
}
var v4_1 = v4$1;
var v1 = v1_1;
var v4 = v4_1;
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
var uuid_1 = uuid;
function ownKeys$1(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$1(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconQuestionCircleComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread$1(_objectSpread$1({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-question-circle")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M42 24c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6s18 8.059 18 18Z"
  }), /* @__PURE__ */ React__default.createElement("path", {
    d: "M24.006 31v4.008m0-6.008L24 28c0-3 3-4 4.78-6.402C30.558 19.195 28.288 15 23.987 15c-4.014 0-5.382 2.548-5.388 4.514v.465"
  }));
}
var IconQuestionCircle = /* @__PURE__ */ React__default.forwardRef(IconQuestionCircleComponent);
IconQuestionCircle.defaultProps = {
  isIcon: true
};
IconQuestionCircle.displayName = "IconQuestionCircle";
var IconQuestionCircle$1 = IconQuestionCircle;
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty$1(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function IconAtComponent(iconProps, ref) {
  var _useContext = useContext(IconContext), _useContext$prefixCls = _useContext.prefixCls, prefixCls2 = _useContext$prefixCls === void 0 ? "arco" : _useContext$prefixCls;
  var spin = iconProps.spin, className = iconProps.className;
  var props = _objectSpread(_objectSpread({
    "aria-hidden": true,
    focusable: false,
    ref
  }, iconProps), {}, {
    className: "".concat(className ? className + " " : "").concat(prefixCls2, "-icon ").concat(prefixCls2, "-icon-at")
  });
  if (spin) {
    props.className = "".concat(props.className, " ").concat(prefixCls2, "-icon-loading");
  }
  delete props.spin;
  delete props.isIcon;
  return /* @__PURE__ */ React__default.createElement("svg", _extends({
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "4",
    viewBox: "0 0 48 48"
  }, props), /* @__PURE__ */ React__default.createElement("path", {
    d: "M31 23a7 7 0 1 1-14 0 7 7 0 0 1 14 0Zm0 0c0 3.038 2.462 6.5 5.5 6.5A5.5 5.5 0 0 0 42 24c0-9.941-8.059-18-18-18S6 14.059 6 24s8.059 18 18 18c4.244 0 8.145-1.469 11.222-3.925"
  }));
}
var IconAt = /* @__PURE__ */ React__default.forwardRef(IconAtComponent);
IconAt.defaultProps = {
  isIcon: true
};
IconAt.displayName = "IconAt";
var IconAt$1 = IconAt;
const container = "_container_jzksr_1";
const error = "_error_jzksr_6";
const item = "_item_jzksr_10";
const info = "_info_jzksr_18";
const btnWrap = "_btn-wrap_jzksr_43";
const upload = "_upload_jzksr_68";
const wrap = "_wrap_jzksr_80";
const urlInput = "_urlInput_jzksr_80";
var styles$8 = {
  container,
  error,
  item,
  info,
  "btn-wrap": "_btn-wrap_jzksr_43",
  btnWrap,
  upload,
  wrap,
  urlInput
};
function PromiseEach(promiseLikes) {
  const datas = [];
  let count = 0;
  return new Promise((resolve) => {
    promiseLikes.forEach((promiseLike) => __async(this, null, function* () {
      try {
        const data = yield promiseLike;
        datas.push(data);
      } catch (error2) {
        datas.push(error2);
      } finally {
        count++;
        if (count === promiseLikes.length) {
          resolve(true);
        }
      }
    }));
  });
}
class Uploader {
  constructor(uploadServer, options2) {
    __publicField(this, "options");
    __publicField(this, "el");
    __publicField(this, "uploadServer");
    __publicField(this, "handler", {
      start: [],
      progress: [],
      end: []
    });
    this.options = __spreadValues({
      limit: 1,
      autoUpload: true
    }, options2);
    this.uploadServer = uploadServer;
    this.el = this.createInput();
  }
  createInput() {
    Array.from(document.querySelectorAll(".uploader-form-input")).forEach((el2) => {
      el2 && document.body.removeChild(el2);
    });
    const el = document.createElement("input");
    el.className = "uploader-form-input";
    el.type = "file";
    el.style.display = "block";
    el.style.opacity = "0";
    el.style.width = "0";
    el.style.height = "0";
    el.style.position = "absolute";
    el.style.top = "0";
    el.style.left = "0";
    el.style.overflow = "hidden";
    el.multiple = this.options.limit > 1;
    if (this.options.accept) {
      el.accept = this.options.accept;
    }
    return el;
  }
  uploadFiles(files) {
    return __async(this, null, function* () {
      const results = files.map((file) => ({ file }));
      const uploadList = results.map((item2) => ({
        url: "",
        status: "pending",
        idx: `uploader-${lodash.exports.uniqueId()}`
      }));
      this.handler.start.map((fn) => fn(uploadList));
      yield PromiseEach(results.map((file, index2) => __async(this, null, function* () {
        try {
          const url = yield this.uploadFile(file);
          uploadList[index2].url = url;
          uploadList[index2].status = "done";
        } catch (error2) {
          uploadList[index2].status = "error";
        } finally {
          this.handler.progress.map((fn) => fn(uploadList));
        }
      })));
      this.handler.end.map((fn) => fn(uploadList));
    });
  }
  uploadFile(result) {
    return __async(this, null, function* () {
      return this.uploadServer(result.file);
    });
  }
  checkFile(files) {
    const typeError = this.checkTypes(files);
    if (typeError) {
      throw new Error(typeError);
    }
    const sizeError = this.checkSize(files);
    if (sizeError) {
      throw new Error(sizeError);
    }
  }
  checkTypes(files) {
    const accept = this.options.accept;
    if (accept) {
      let fileType = "";
      if (accept.indexOf("image") !== -1) {
        fileType = "image";
      } else if (accept.indexOf("video") !== -1) {
        fileType = "video";
      }
      for (const file of files) {
        if (file.type.indexOf(fileType) !== 0) {
          return "\u4E0A\u4F20\u6587\u4EF6\u7C7B\u578B\u9519\u8BEF!";
        }
      }
    }
    return null;
  }
  checkSize(files) {
    const options2 = this.options;
    for (const file of files) {
      if (options2.minSize && file.size < options2.minSize) {
        return `\u4E0A\u4F20\u6587\u4EF6\u4E0D\u80FD\u5C0F\u4E8E ${options2.minSize}`;
      }
      if (options2.maxSize && file.size > options2.maxSize) {
        return `\u4E0A\u4F20\u6587\u4EF6\u4E0D\u80FD\u5C0F\u4E8E ${options2.maxSize}`;
      }
    }
    return null;
  }
  chooseFile() {
    const el = this.el;
    document.body.appendChild(el);
    el.click();
    el.onchange = (e) => __async(this, null, function* () {
      let files = e.target.files || [];
      files = Array.prototype.slice.call(files);
      if (files.length === 0) {
        return;
      }
      this.checkFile(files);
      if (this.options.autoUpload) {
        this.uploadFiles(files);
      }
      el.onchange = null;
      el.parentNode && el.parentNode.removeChild(el);
    });
  }
  on(event2, fn) {
    const handler = this.handler[event2];
    handler.push(fn);
  }
  off(event2, fn) {
    const handles = this.handler[event2];
    this.handler[event2] = handles.filter((item2) => item2 !== fn);
  }
}
function classnames$1(...rest) {
  return rest.filter((item2) => typeof item2 === "string").join(" ");
}
function previewLoadImage(url) {
  return new Promise((resolve) => {
    const img2 = new Image();
    img2.setAttribute("crossOrigin", "Anonymous");
    img2.src = url;
    img2.onload = () => resolve(img2);
    img2.onerror = () => resolve(img2);
  });
}
function ImageUploader(props) {
  const { mergeTags: mergeTags2 } = useEditorProps();
  const [isUploading, setIsUploading] = useState(false);
  const [preview, setPreview] = useState(false);
  const uploadHandlerRef = useRef(props.uploadHandler);
  const onChange = props.onChange;
  const onUpload = useCallback(() => {
    if (isUploading) {
      return Message$1.warning("Uploading...");
    }
    if (!uploadHandlerRef.current)
      return;
    const uploader = new Uploader(uploadHandlerRef.current, {
      limit: 1,
      accept: "image/*"
    });
    uploader.on("start", (photos) => {
      setIsUploading(true);
      uploader.on("end", (data) => {
        var _a;
        const url = (_a = data[0]) == null ? void 0 : _a.url;
        if (url) {
          onChange(url);
        }
        setIsUploading(false);
      });
    });
    uploader.chooseFile();
  }, [isUploading, onChange]);
  const onPaste = useCallback((e) => __async(this, null, function* () {
    if (!uploadHandlerRef.current)
      return;
    const clipboardData = e.clipboardData;
    for (let i2 = 0; i2 < clipboardData.items.length; i2++) {
      const item2 = clipboardData.items[i2];
      if (item2.kind == "file") {
        const blob = item2.getAsFile();
        if (!blob || blob.size === 0) {
          return;
        }
        try {
          setIsUploading(true);
          const picture = yield uploadHandlerRef.current(blob);
          yield previewLoadImage(picture);
          props.onChange(picture);
          setIsUploading(false);
        } catch (error2) {
          Message$1.error((error2 == null ? void 0 : error2.message) || error2 || "Upload failed");
          setIsUploading(false);
        }
      }
    }
  }), [props]);
  const onRemove = useCallback(() => {
    props.onChange("");
  }, [props]);
  const content = useMemo(() => {
    if (isUploading) {
      return /* @__PURE__ */ React__default.createElement("div", {
        className: styles$8["item"]
      }, /* @__PURE__ */ React__default.createElement("div", {
        className: classnames$1(styles$8["info"])
      }, /* @__PURE__ */ React__default.createElement(Spin$1, null), /* @__PURE__ */ React__default.createElement("div", {
        className: styles$8["btn-wrap"]
      })));
    }
    if (!props.value) {
      return /* @__PURE__ */ React__default.createElement("div", {
        className: styles$8["upload"],
        onClick: onUpload
      }, /* @__PURE__ */ React__default.createElement(IconPlus$1, null), /* @__PURE__ */ React__default.createElement("div", null, "Upload"));
    }
    return /* @__PURE__ */ React__default.createElement("div", {
      className: styles$8["item"]
    }, /* @__PURE__ */ React__default.createElement("div", {
      className: classnames$1(styles$8["info"])
    }, /* @__PURE__ */ React__default.createElement("img", {
      src: props.value
    }), /* @__PURE__ */ React__default.createElement("div", {
      className: styles$8["btn-wrap"]
    }, /* @__PURE__ */ React__default.createElement("a", {
      title: "Preview",
      onClick: () => setPreview(true)
    }, /* @__PURE__ */ React__default.createElement(IconEye$1, null)), /* @__PURE__ */ React__default.createElement("a", {
      title: "Remove",
      onClick: () => onRemove()
    }, /* @__PURE__ */ React__default.createElement(IconDelete$1, null)))));
  }, [isUploading, onRemove, onUpload, props.value]);
  if (!props.uploadHandler) {
    return /* @__PURE__ */ React__default.createElement(Input$5, {
      value: props.value,
      onChange
    });
  }
  return /* @__PURE__ */ React__default.createElement("div", {
    className: styles$8.wrap
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: styles$8["container"]
  }, content, /* @__PURE__ */ React__default.createElement(Grid.Row, {
    style: { width: "100%" }
  }, mergeTags2 && /* @__PURE__ */ React__default.createElement(Popover$1, {
    trigger: "click",
    content: /* @__PURE__ */ React__default.createElement(MergeTags$1, {
      value: props.value,
      onChange
    })
  }, /* @__PURE__ */ React__default.createElement(Button$4, {
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-merge-tags"
    })
  })), /* @__PURE__ */ React__default.createElement(Input$5, {
    style: { flex: 1 },
    onPaste,
    value: props.value,
    onChange,
    disabled: isUploading
  }), props.autoCompleteOptions && /* @__PURE__ */ React__default.createElement(Dropdown$1, {
    position: "tr",
    droplist: /* @__PURE__ */ React__default.createElement(Menu$1, {
      onClickMenuItem: (indexStr) => {
        var _a;
        if (!props.autoCompleteOptions)
          return;
        onChange((_a = props.autoCompleteOptions[+indexStr]) == null ? void 0 : _a.value);
      }
    }, props.autoCompleteOptions.map((item2, index2) => {
      return /* @__PURE__ */ React__default.createElement(Menu$1.Item, {
        style: { display: "flex", alignItems: "center" },
        key: index2.toString()
      }, /* @__PURE__ */ React__default.createElement("img", {
        src: item2.value,
        style: { width: 20, height: 20 }
      }), "\u2003", /* @__PURE__ */ React__default.createElement("span", null, item2.label));
    }))
  }, /* @__PURE__ */ React__default.createElement(Button$4, {
    icon: /* @__PURE__ */ React__default.createElement(IconAt$1, null)
  })))), /* @__PURE__ */ React__default.createElement(Modal$1, {
    visible: preview,
    footer: null,
    onCancel: () => setPreview(false)
  }, /* @__PURE__ */ React__default.createElement("img", {
    alt: "Preview",
    style: { width: "100%" },
    src: props.value
  })));
}
function UploadField$1(props) {
  const { onChange, inputDisabled = false, accept, uploadHandler } = props;
  const [loading, setLoading] = useState(false);
  const { current: uploader } = useRef(new Uploader(uploadHandler, {
    limit: 1,
    accept
  }));
  useEffect(() => {
    uploader.on("start", () => {
      setLoading(true);
      uploader.on("end", (photos) => {
        setLoading(false);
        onChange(photos.filter((item2) => item2.status === "done").map((item2) => item2.url)[0] || "");
      });
    });
  }, [onChange, uploader]);
  const onClick = () => {
    if (loading)
      return;
    uploader.chooseFile();
  };
  return /* @__PURE__ */ React__default.createElement(Input$5, {
    prefix: loading ? /* @__PURE__ */ React__default.createElement(IconLoading$1, null) : /* @__PURE__ */ React__default.createElement(IconUpload$1, {
      onClick
    }),
    value: props.value,
    onChange: inputDisabled ? void 0 : (value) => onChange(value)
  });
}
const defaultImagesMap$1 = {
  IMAGE_59: "https://easy-email-m-ryan.vercel.app/images/06ca521d-9728-4de6-a709-1b75a828bfc3-2a9b1224-3d71-43b8-b52f-e7cdcdc9107b.png",
  AttributePanel_01: "https://easy-email-m-ryan.vercel.app/images/e22f78f2-aa76-408d-ba94-c95c7abe1908-image.png",
  AttributePanel_02: "https://easy-email-m-ryan.vercel.app/images/3e952a6e-2506-470e-b395-3e0d995157c5.png",
  AttributePanel_03: "https://easy-email-m-ryan.vercel.app/images/Fi_vI4vyLhTM-Tp6ivq4dR_ieGHk.png"
};
ImageManager.add(defaultImagesMap$1);
function getImg$1(name2) {
  return ImageManager.get(name2);
}
var noop = function() {
};
var isBrowser = typeof window !== "undefined";
var useLocalStorage = function(key, initialValue, options2) {
  if (!isBrowser) {
    return [initialValue, noop, noop];
  }
  if (!key) {
    throw new Error("useLocalStorage key may not be falsy");
  }
  var deserializer = options2 ? options2.raw ? function(value) {
    return value;
  } : options2.deserializer : JSON.parse;
  var initializer = useRef(function(key2) {
    try {
      var serializer = options2 ? options2.raw ? String : options2.serializer : JSON.stringify;
      var localStorageValue = localStorage.getItem(key2);
      if (localStorageValue !== null) {
        return deserializer(localStorageValue);
      } else {
        initialValue && localStorage.setItem(key2, serializer(initialValue));
        return initialValue;
      }
    } catch (_a2) {
      return initialValue;
    }
  });
  var _a = useState(function() {
    return initializer.current(key);
  }), state = _a[0], setState = _a[1];
  useLayoutEffect(function() {
    return setState(initializer.current(key));
  }, [key]);
  var set2 = useCallback(function(valOrFunc) {
    try {
      var newState = typeof valOrFunc === "function" ? valOrFunc(state) : valOrFunc;
      if (typeof newState === "undefined")
        return;
      var value = void 0;
      if (options2)
        if (options2.raw)
          if (typeof newState === "string")
            value = newState;
          else
            value = JSON.stringify(newState);
        else if (options2.serializer)
          value = options2.serializer(newState);
        else
          value = JSON.stringify(newState);
      else
        value = JSON.stringify(newState);
      localStorage.setItem(key, value);
      setState(deserializer(value));
    } catch (_a2) {
    }
  }, [key, setState]);
  var remove = useCallback(function() {
    try {
      localStorage.removeItem(key);
      setState(void 0);
    } catch (_a2) {
    }
  }, [key, setState]);
  return [state, set2, remove];
};
var useLocalStorage$1 = useLocalStorage;
const defaultPresetColor = [
  "#000000",
  "#FFFFFF",
  "#9b9b9b",
  "#d0021b",
  "#4a90e2",
  "#7ed321",
  "#bd10e0",
  "#f8e71c"
];
const CURRENT_COLORS_KEY = "CURRENT_COLORS_KEY";
const MAX_RECORD_SIZE = 20;
const PresetColorsContext = React__default.createContext({
  colors: [],
  addCurrentColor: () => {
  }
});
const PresetColorsProvider = (props) => {
  const [currentColors, setCurrentColors] = useLocalStorage$1(CURRENT_COLORS_KEY, defaultPresetColor);
  const currentColorsRef = useRefState(currentColors);
  const colorDivRef = useRef(document.createElement("div"));
  const addCurrentColor = useCallback(lodash.exports.debounce((newColor) => {
    colorDivRef.current.style.color = "";
    colorDivRef.current.style.color = newColor;
    if (colorDivRef.current.style.color) {
      if (currentColorsRef.current.includes(newColor))
        return;
      const newColors = [...new Set([...currentColorsRef.current, newColor])].filter(Boolean).slice(-MAX_RECORD_SIZE);
      setCurrentColors(newColors);
    }
  }, 500), [currentColorsRef, setCurrentColors]);
  const value = useMemo(() => {
    return {
      colors: currentColors,
      addCurrentColor
    };
  }, [addCurrentColor, currentColors]);
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(PresetColorsContext.Provider, {
      value
    }, props.children);
  }, [props.children, value]);
};
const helperText = "_helperText_1m9nq_1";
const labelHidden = "_label-hidden_1m9nq_9";
const editTab = "_editTab_1m9nq_20";
const inputWithUnit = "_inputWithUnit_1m9nq_27";
const inputWithUnitSelectOption = "_inputWithUnitSelectOption_1m9nq_35";
const colorPicker = "_colorPicker_1m9nq_40";
var styles$7 = {
  helperText,
  "label-hidden": "_label-hidden_1m9nq_9",
  labelHidden,
  editTab,
  inputWithUnit,
  inputWithUnitSelectOption,
  colorPicker
};
var colorString$1 = { exports: {} };
var colorName = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};
var simpleSwizzle = { exports: {} };
var isArrayish$1 = function isArrayish2(obj) {
  if (!obj || typeof obj === "string") {
    return false;
  }
  return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
};
var isArrayish = isArrayish$1;
var concat = Array.prototype.concat;
var slice = Array.prototype.slice;
var swizzle$1 = simpleSwizzle.exports = function swizzle2(args) {
  var results = [];
  for (var i2 = 0, len = args.length; i2 < len; i2++) {
    var arg = args[i2];
    if (isArrayish(arg)) {
      results = concat.call(results, slice.call(arg));
    } else {
      results.push(arg);
    }
  }
  return results;
};
swizzle$1.wrap = function(fn) {
  return function() {
    return fn(swizzle$1(arguments));
  };
};
var colorNames = colorName;
var swizzle = simpleSwizzle.exports;
var hasOwnProperty = Object.hasOwnProperty;
var reverseNames = Object.create(null);
for (var name in colorNames) {
  if (hasOwnProperty.call(colorNames, name)) {
    reverseNames[colorNames[name]] = name;
  }
}
var cs = colorString$1.exports = {
  to: {},
  get: {}
};
cs.get = function(string) {
  var prefix = string.substring(0, 3).toLowerCase();
  var val;
  var model;
  switch (prefix) {
    case "hsl":
      val = cs.get.hsl(string);
      model = "hsl";
      break;
    case "hwb":
      val = cs.get.hwb(string);
      model = "hwb";
      break;
    default:
      val = cs.get.rgb(string);
      model = "rgb";
      break;
  }
  if (!val) {
    return null;
  }
  return { model, value: val };
};
cs.get.rgb = function(string) {
  if (!string) {
    return null;
  }
  var abbr = /^#([a-f0-9]{3,4})$/i;
  var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
  var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
  var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
  var keyword = /^(\w+)$/;
  var rgb = [0, 0, 0, 1];
  var match;
  var i2;
  var hexAlpha;
  if (match = string.match(hex)) {
    hexAlpha = match[2];
    match = match[1];
    for (i2 = 0; i2 < 3; i2++) {
      var i22 = i2 * 2;
      rgb[i2] = parseInt(match.slice(i22, i22 + 2), 16);
    }
    if (hexAlpha) {
      rgb[3] = parseInt(hexAlpha, 16) / 255;
    }
  } else if (match = string.match(abbr)) {
    match = match[1];
    hexAlpha = match[3];
    for (i2 = 0; i2 < 3; i2++) {
      rgb[i2] = parseInt(match[i2] + match[i2], 16);
    }
    if (hexAlpha) {
      rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
    }
  } else if (match = string.match(rgba)) {
    for (i2 = 0; i2 < 3; i2++) {
      rgb[i2] = parseInt(match[i2 + 1], 0);
    }
    if (match[4]) {
      if (match[5]) {
        rgb[3] = parseFloat(match[4]) * 0.01;
      } else {
        rgb[3] = parseFloat(match[4]);
      }
    }
  } else if (match = string.match(per)) {
    for (i2 = 0; i2 < 3; i2++) {
      rgb[i2] = Math.round(parseFloat(match[i2 + 1]) * 2.55);
    }
    if (match[4]) {
      if (match[5]) {
        rgb[3] = parseFloat(match[4]) * 0.01;
      } else {
        rgb[3] = parseFloat(match[4]);
      }
    }
  } else if (match = string.match(keyword)) {
    if (match[1] === "transparent") {
      return [0, 0, 0, 0];
    }
    if (!hasOwnProperty.call(colorNames, match[1])) {
      return null;
    }
    rgb = colorNames[match[1]];
    rgb[3] = 1;
    return rgb;
  } else {
    return null;
  }
  for (i2 = 0; i2 < 3; i2++) {
    rgb[i2] = clamp(rgb[i2], 0, 255);
  }
  rgb[3] = clamp(rgb[3], 0, 1);
  return rgb;
};
cs.get.hsl = function(string) {
  if (!string) {
    return null;
  }
  var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
  var match = string.match(hsl);
  if (match) {
    var alpha = parseFloat(match[4]);
    var h = (parseFloat(match[1]) % 360 + 360) % 360;
    var s = clamp(parseFloat(match[2]), 0, 100);
    var l = clamp(parseFloat(match[3]), 0, 100);
    var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
    return [h, s, l, a];
  }
  return null;
};
cs.get.hwb = function(string) {
  if (!string) {
    return null;
  }
  var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
  var match = string.match(hwb);
  if (match) {
    var alpha = parseFloat(match[4]);
    var h = (parseFloat(match[1]) % 360 + 360) % 360;
    var w = clamp(parseFloat(match[2]), 0, 100);
    var b = clamp(parseFloat(match[3]), 0, 100);
    var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
    return [h, w, b, a];
  }
  return null;
};
cs.to.hex = function() {
  var rgba = swizzle(arguments);
  return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
};
cs.to.rgb = function() {
  var rgba = swizzle(arguments);
  return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
};
cs.to.rgb.percent = function() {
  var rgba = swizzle(arguments);
  var r = Math.round(rgba[0] / 255 * 100);
  var g = Math.round(rgba[1] / 255 * 100);
  var b = Math.round(rgba[2] / 255 * 100);
  return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
};
cs.to.hsl = function() {
  var hsla = swizzle(arguments);
  return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
};
cs.to.hwb = function() {
  var hwba = swizzle(arguments);
  var a = "";
  if (hwba.length >= 4 && hwba[3] !== 1) {
    a = ", " + hwba[3];
  }
  return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
};
cs.to.keyword = function(rgb) {
  return reverseNames[rgb.slice(0, 3)];
};
function clamp(num, min, max) {
  return Math.min(Math.max(min, num), max);
}
function hexDouble(num) {
  var str = Math.round(num).toString(16).toUpperCase();
  return str.length < 2 ? "0" + str : str;
}
const cssKeywords = colorName;
const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
  reverseKeywords[cssKeywords[key]] = key;
}
const convert$2 = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
};
var conversions$2 = convert$2;
for (const model of Object.keys(convert$2)) {
  if (!("channels" in convert$2[model])) {
    throw new Error("missing channels property: " + model);
  }
  if (!("labels" in convert$2[model])) {
    throw new Error("missing channel labels property: " + model);
  }
  if (convert$2[model].labels.length !== convert$2[model].channels) {
    throw new Error("channel and label counts mismatch: " + model);
  }
  const { channels, labels } = convert$2[model];
  delete convert$2[model].channels;
  delete convert$2[model].labels;
  Object.defineProperty(convert$2[model], "channels", { value: channels });
  Object.defineProperty(convert$2[model], "labels", { value: labels });
}
convert$2.rgb.hsl = function(rgb) {
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const min = Math.min(r, g, b);
  const max = Math.max(r, g, b);
  const delta = max - min;
  let h;
  let s;
  if (max === min) {
    h = 0;
  } else if (r === max) {
    h = (g - b) / delta;
  } else if (g === max) {
    h = 2 + (b - r) / delta;
  } else if (b === max) {
    h = 4 + (r - g) / delta;
  }
  h = Math.min(h * 60, 360);
  if (h < 0) {
    h += 360;
  }
  const l = (min + max) / 2;
  if (max === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max + min);
  } else {
    s = delta / (2 - max - min);
  }
  return [h, s * 100, l * 100];
};
convert$2.rgb.hsv = function(rgb) {
  let rdif;
  let gdif;
  let bdif;
  let h;
  let s;
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const v = Math.max(r, g, b);
  const diff = v - Math.min(r, g, b);
  const diffc = function(c) {
    return (v - c) / 6 / diff + 1 / 2;
  };
  if (diff === 0) {
    h = 0;
    s = 0;
  } else {
    s = diff / v;
    rdif = diffc(r);
    gdif = diffc(g);
    bdif = diffc(b);
    if (r === v) {
      h = bdif - gdif;
    } else if (g === v) {
      h = 1 / 3 + rdif - bdif;
    } else if (b === v) {
      h = 2 / 3 + gdif - rdif;
    }
    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
  }
  return [
    h * 360,
    s * 100,
    v * 100
  ];
};
convert$2.rgb.hwb = function(rgb) {
  const r = rgb[0];
  const g = rgb[1];
  let b = rgb[2];
  const h = convert$2.rgb.hsl(rgb)[0];
  const w = 1 / 255 * Math.min(r, Math.min(g, b));
  b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
  return [h, w * 100, b * 100];
};
convert$2.rgb.cmyk = function(rgb) {
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const k = Math.min(1 - r, 1 - g, 1 - b);
  const c = (1 - r - k) / (1 - k) || 0;
  const m = (1 - g - k) / (1 - k) || 0;
  const y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
};
function comparativeDistance(x, y) {
  return __pow(x[0] - y[0], 2) + __pow(x[1] - y[1], 2) + __pow(x[2] - y[2], 2);
}
convert$2.rgb.keyword = function(rgb) {
  const reversed = reverseKeywords[rgb];
  if (reversed) {
    return reversed;
  }
  let currentClosestDistance = Infinity;
  let currentClosestKeyword;
  for (const keyword of Object.keys(cssKeywords)) {
    const value = cssKeywords[keyword];
    const distance = comparativeDistance(rgb, value);
    if (distance < currentClosestDistance) {
      currentClosestDistance = distance;
      currentClosestKeyword = keyword;
    }
  }
  return currentClosestKeyword;
};
convert$2.keyword.rgb = function(keyword) {
  return cssKeywords[keyword];
};
convert$2.rgb.xyz = function(rgb) {
  let r = rgb[0] / 255;
  let g = rgb[1] / 255;
  let b = rgb[2] / 255;
  r = r > 0.04045 ? __pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  g = g > 0.04045 ? __pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? __pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
  const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
  const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
  const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
  return [x * 100, y * 100, z * 100];
};
convert$2.rgb.lab = function(rgb) {
  const xyz = convert$2.rgb.xyz(rgb);
  let x = xyz[0];
  let y = xyz[1];
  let z = xyz[2];
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 8856e-6 ? __pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 8856e-6 ? __pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 8856e-6 ? __pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  const l = 116 * y - 16;
  const a = 500 * (x - y);
  const b = 200 * (y - z);
  return [l, a, b];
};
convert$2.hsl.rgb = function(hsl) {
  const h = hsl[0] / 360;
  const s = hsl[1] / 100;
  const l = hsl[2] / 100;
  let t2;
  let t3;
  let val;
  if (s === 0) {
    val = l * 255;
    return [val, val, val];
  }
  if (l < 0.5) {
    t2 = l * (1 + s);
  } else {
    t2 = l + s - l * s;
  }
  const t1 = 2 * l - t2;
  const rgb = [0, 0, 0];
  for (let i2 = 0; i2 < 3; i2++) {
    t3 = h + 1 / 3 * -(i2 - 1);
    if (t3 < 0) {
      t3++;
    }
    if (t3 > 1) {
      t3--;
    }
    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }
    rgb[i2] = val * 255;
  }
  return rgb;
};
convert$2.hsl.hsv = function(hsl) {
  const h = hsl[0];
  let s = hsl[1] / 100;
  let l = hsl[2] / 100;
  let smin = s;
  const lmin = Math.max(l, 0.01);
  l *= 2;
  s *= l <= 1 ? l : 2 - l;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  const v = (l + s) / 2;
  const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
  return [h, sv * 100, v * 100];
};
convert$2.hsv.rgb = function(hsv) {
  const h = hsv[0] / 60;
  const s = hsv[1] / 100;
  let v = hsv[2] / 100;
  const hi = Math.floor(h) % 6;
  const f = h - Math.floor(h);
  const p = 255 * v * (1 - s);
  const q = 255 * v * (1 - s * f);
  const t2 = 255 * v * (1 - s * (1 - f));
  v *= 255;
  switch (hi) {
    case 0:
      return [v, t2, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t2];
    case 3:
      return [p, q, v];
    case 4:
      return [t2, p, v];
    case 5:
      return [v, p, q];
  }
};
convert$2.hsv.hsl = function(hsv) {
  const h = hsv[0];
  const s = hsv[1] / 100;
  const v = hsv[2] / 100;
  const vmin = Math.max(v, 0.01);
  let sl;
  let l;
  l = (2 - s) * v;
  const lmin = (2 - s) * vmin;
  sl = s * vmin;
  sl /= lmin <= 1 ? lmin : 2 - lmin;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
};
convert$2.hwb.rgb = function(hwb) {
  const h = hwb[0] / 360;
  let wh = hwb[1] / 100;
  let bl = hwb[2] / 100;
  const ratio = wh + bl;
  let f;
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }
  const i2 = Math.floor(6 * h);
  const v = 1 - bl;
  f = 6 * h - i2;
  if ((i2 & 1) !== 0) {
    f = 1 - f;
  }
  const n = wh + f * (v - wh);
  let r;
  let g;
  let b;
  switch (i2) {
    default:
    case 6:
    case 0:
      r = v;
      g = n;
      b = wh;
      break;
    case 1:
      r = n;
      g = v;
      b = wh;
      break;
    case 2:
      r = wh;
      g = v;
      b = n;
      break;
    case 3:
      r = wh;
      g = n;
      b = v;
      break;
    case 4:
      r = n;
      g = wh;
      b = v;
      break;
    case 5:
      r = v;
      g = wh;
      b = n;
      break;
  }
  return [r * 255, g * 255, b * 255];
};
convert$2.cmyk.rgb = function(cmyk) {
  const c = cmyk[0] / 100;
  const m = cmyk[1] / 100;
  const y = cmyk[2] / 100;
  const k = cmyk[3] / 100;
  const r = 1 - Math.min(1, c * (1 - k) + k);
  const g = 1 - Math.min(1, m * (1 - k) + k);
  const b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
};
convert$2.xyz.rgb = function(xyz) {
  const x = xyz[0] / 100;
  const y = xyz[1] / 100;
  const z = xyz[2] / 100;
  let r;
  let g;
  let b;
  r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  b = x * 0.0557 + y * -0.204 + z * 1.057;
  r = r > 31308e-7 ? 1.055 * __pow(r, 1 / 2.4) - 0.055 : r * 12.92;
  g = g > 31308e-7 ? 1.055 * __pow(g, 1 / 2.4) - 0.055 : g * 12.92;
  b = b > 31308e-7 ? 1.055 * __pow(b, 1 / 2.4) - 0.055 : b * 12.92;
  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r * 255, g * 255, b * 255];
};
convert$2.xyz.lab = function(xyz) {
  let x = xyz[0];
  let y = xyz[1];
  let z = xyz[2];
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 8856e-6 ? __pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 8856e-6 ? __pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 8856e-6 ? __pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  const l = 116 * y - 16;
  const a = 500 * (x - y);
  const b = 200 * (y - z);
  return [l, a, b];
};
convert$2.lab.xyz = function(lab) {
  const l = lab[0];
  const a = lab[1];
  const b = lab[2];
  let x;
  let y;
  let z;
  y = (l + 16) / 116;
  x = a / 500 + y;
  z = y - b / 200;
  const y2 = __pow(y, 3);
  const x2 = __pow(x, 3);
  const z2 = __pow(z, 3);
  y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
  x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
  z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
  x *= 95.047;
  y *= 100;
  z *= 108.883;
  return [x, y, z];
};
convert$2.lab.lch = function(lab) {
  const l = lab[0];
  const a = lab[1];
  const b = lab[2];
  let h;
  const hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  const c = Math.sqrt(a * a + b * b);
  return [l, c, h];
};
convert$2.lch.lab = function(lch) {
  const l = lch[0];
  const c = lch[1];
  const h = lch[2];
  const hr = h / 360 * 2 * Math.PI;
  const a = c * Math.cos(hr);
  const b = c * Math.sin(hr);
  return [l, a, b];
};
convert$2.rgb.ansi16 = function(args, saturation = null) {
  const [r, g, b] = args;
  let value = saturation === null ? convert$2.rgb.hsv(args)[2] : saturation;
  value = Math.round(value / 50);
  if (value === 0) {
    return 30;
  }
  let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
  if (value === 2) {
    ansi += 60;
  }
  return ansi;
};
convert$2.hsv.ansi16 = function(args) {
  return convert$2.rgb.ansi16(convert$2.hsv.rgb(args), args[2]);
};
convert$2.rgb.ansi256 = function(args) {
  const r = args[0];
  const g = args[1];
  const b = args[2];
  if (r === g && g === b) {
    if (r < 8) {
      return 16;
    }
    if (r > 248) {
      return 231;
    }
    return Math.round((r - 8) / 247 * 24) + 232;
  }
  const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
  return ansi;
};
convert$2.ansi16.rgb = function(args) {
  let color2 = args % 10;
  if (color2 === 0 || color2 === 7) {
    if (args > 50) {
      color2 += 3.5;
    }
    color2 = color2 / 10.5 * 255;
    return [color2, color2, color2];
  }
  const mult = (~~(args > 50) + 1) * 0.5;
  const r = (color2 & 1) * mult * 255;
  const g = (color2 >> 1 & 1) * mult * 255;
  const b = (color2 >> 2 & 1) * mult * 255;
  return [r, g, b];
};
convert$2.ansi256.rgb = function(args) {
  if (args >= 232) {
    const c = (args - 232) * 10 + 8;
    return [c, c, c];
  }
  args -= 16;
  let rem;
  const r = Math.floor(args / 36) / 5 * 255;
  const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
  const b = rem % 6 / 5 * 255;
  return [r, g, b];
};
convert$2.rgb.hex = function(args) {
  const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
  const string = integer.toString(16).toUpperCase();
  return "000000".substring(string.length) + string;
};
convert$2.hex.rgb = function(args) {
  const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!match) {
    return [0, 0, 0];
  }
  let colorString2 = match[0];
  if (match[0].length === 3) {
    colorString2 = colorString2.split("").map((char) => {
      return char + char;
    }).join("");
  }
  const integer = parseInt(colorString2, 16);
  const r = integer >> 16 & 255;
  const g = integer >> 8 & 255;
  const b = integer & 255;
  return [r, g, b];
};
convert$2.rgb.hcg = function(rgb) {
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const max = Math.max(Math.max(r, g), b);
  const min = Math.min(Math.min(r, g), b);
  const chroma = max - min;
  let grayscale;
  let hue;
  if (chroma < 1) {
    grayscale = min / (1 - chroma);
  } else {
    grayscale = 0;
  }
  if (chroma <= 0) {
    hue = 0;
  } else if (max === r) {
    hue = (g - b) / chroma % 6;
  } else if (max === g) {
    hue = 2 + (b - r) / chroma;
  } else {
    hue = 4 + (r - g) / chroma;
  }
  hue /= 6;
  hue %= 1;
  return [hue * 360, chroma * 100, grayscale * 100];
};
convert$2.hsl.hcg = function(hsl) {
  const s = hsl[1] / 100;
  const l = hsl[2] / 100;
  const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
  let f = 0;
  if (c < 1) {
    f = (l - 0.5 * c) / (1 - c);
  }
  return [hsl[0], c * 100, f * 100];
};
convert$2.hsv.hcg = function(hsv) {
  const s = hsv[1] / 100;
  const v = hsv[2] / 100;
  const c = s * v;
  let f = 0;
  if (c < 1) {
    f = (v - c) / (1 - c);
  }
  return [hsv[0], c * 100, f * 100];
};
convert$2.hcg.rgb = function(hcg) {
  const h = hcg[0] / 360;
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  if (c === 0) {
    return [g * 255, g * 255, g * 255];
  }
  const pure = [0, 0, 0];
  const hi = h % 1 * 6;
  const v = hi % 1;
  const w = 1 - v;
  let mg = 0;
  switch (Math.floor(hi)) {
    case 0:
      pure[0] = 1;
      pure[1] = v;
      pure[2] = 0;
      break;
    case 1:
      pure[0] = w;
      pure[1] = 1;
      pure[2] = 0;
      break;
    case 2:
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v;
      break;
    case 3:
      pure[0] = 0;
      pure[1] = w;
      pure[2] = 1;
      break;
    case 4:
      pure[0] = v;
      pure[1] = 0;
      pure[2] = 1;
      break;
    default:
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w;
  }
  mg = (1 - c) * g;
  return [
    (c * pure[0] + mg) * 255,
    (c * pure[1] + mg) * 255,
    (c * pure[2] + mg) * 255
  ];
};
convert$2.hcg.hsv = function(hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const v = c + g * (1 - c);
  let f = 0;
  if (v > 0) {
    f = c / v;
  }
  return [hcg[0], f * 100, v * 100];
};
convert$2.hcg.hsl = function(hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const l = g * (1 - c) + 0.5 * c;
  let s = 0;
  if (l > 0 && l < 0.5) {
    s = c / (2 * l);
  } else if (l >= 0.5 && l < 1) {
    s = c / (2 * (1 - l));
  }
  return [hcg[0], s * 100, l * 100];
};
convert$2.hcg.hwb = function(hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const v = c + g * (1 - c);
  return [hcg[0], (v - c) * 100, (1 - v) * 100];
};
convert$2.hwb.hcg = function(hwb) {
  const w = hwb[1] / 100;
  const b = hwb[2] / 100;
  const v = 1 - b;
  const c = v - w;
  let g = 0;
  if (c < 1) {
    g = (v - c) / (1 - c);
  }
  return [hwb[0], c * 100, g * 100];
};
convert$2.apple.rgb = function(apple) {
  return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
};
convert$2.rgb.apple = function(rgb) {
  return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
};
convert$2.gray.rgb = function(args) {
  return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};
convert$2.gray.hsl = function(args) {
  return [0, 0, args[0]];
};
convert$2.gray.hsv = convert$2.gray.hsl;
convert$2.gray.hwb = function(gray) {
  return [0, 100, gray[0]];
};
convert$2.gray.cmyk = function(gray) {
  return [0, 0, 0, gray[0]];
};
convert$2.gray.lab = function(gray) {
  return [gray[0], 0, 0];
};
convert$2.gray.hex = function(gray) {
  const val = Math.round(gray[0] / 100 * 255) & 255;
  const integer = (val << 16) + (val << 8) + val;
  const string = integer.toString(16).toUpperCase();
  return "000000".substring(string.length) + string;
};
convert$2.rgb.gray = function(rgb) {
  const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [val / 255 * 100];
};
const conversions$1 = conversions$2;
function buildGraph() {
  const graph = {};
  const models2 = Object.keys(conversions$1);
  for (let len = models2.length, i2 = 0; i2 < len; i2++) {
    graph[models2[i2]] = {
      distance: -1,
      parent: null
    };
  }
  return graph;
}
function deriveBFS(fromModel) {
  const graph = buildGraph();
  const queue = [fromModel];
  graph[fromModel].distance = 0;
  while (queue.length) {
    const current = queue.pop();
    const adjacents = Object.keys(conversions$1[current]);
    for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
      const adjacent = adjacents[i2];
      const node = graph[adjacent];
      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }
  return graph;
}
function link(from, to) {
  return function(args) {
    return to(from(args));
  };
}
function wrapConversion(toModel, graph) {
  const path = [graph[toModel].parent, toModel];
  let fn = conversions$1[graph[toModel].parent][toModel];
  let cur = graph[toModel].parent;
  while (graph[cur].parent) {
    path.unshift(graph[cur].parent);
    fn = link(conversions$1[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }
  fn.conversion = path;
  return fn;
}
var route$1 = function(fromModel) {
  const graph = deriveBFS(fromModel);
  const conversion = {};
  const models2 = Object.keys(graph);
  for (let len = models2.length, i2 = 0; i2 < len; i2++) {
    const toModel = models2[i2];
    const node = graph[toModel];
    if (node.parent === null) {
      continue;
    }
    conversion[toModel] = wrapConversion(toModel, graph);
  }
  return conversion;
};
const conversions = conversions$2;
const route = route$1;
const convert$1 = {};
const models = Object.keys(conversions);
function wrapRaw(fn) {
  const wrappedFn = function(...args) {
    const arg0 = args[0];
    if (arg0 === void 0 || arg0 === null) {
      return arg0;
    }
    if (arg0.length > 1) {
      args = arg0;
    }
    return fn(args);
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
function wrapRounded(fn) {
  const wrappedFn = function(...args) {
    const arg0 = args[0];
    if (arg0 === void 0 || arg0 === null) {
      return arg0;
    }
    if (arg0.length > 1) {
      args = arg0;
    }
    const result = fn(args);
    if (typeof result === "object") {
      for (let len = result.length, i2 = 0; i2 < len; i2++) {
        result[i2] = Math.round(result[i2]);
      }
    }
    return result;
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
models.forEach((fromModel) => {
  convert$1[fromModel] = {};
  Object.defineProperty(convert$1[fromModel], "channels", { value: conversions[fromModel].channels });
  Object.defineProperty(convert$1[fromModel], "labels", { value: conversions[fromModel].labels });
  const routes = route(fromModel);
  const routeModels = Object.keys(routes);
  routeModels.forEach((toModel) => {
    const fn = routes[toModel];
    convert$1[fromModel][toModel] = wrapRounded(fn);
    convert$1[fromModel][toModel].raw = wrapRaw(fn);
  });
});
var colorConvert = convert$1;
const colorString = colorString$1.exports;
const convert = colorConvert;
const skippedModels = [
  "keyword",
  "gray",
  "hex"
];
const hashedModelKeys = {};
for (const model of Object.keys(convert)) {
  hashedModelKeys[[...convert[model].labels].sort().join("")] = model;
}
const limiters = {};
function Color$1(object, model) {
  if (!(this instanceof Color$1)) {
    return new Color$1(object, model);
  }
  if (model && model in skippedModels) {
    model = null;
  }
  if (model && !(model in convert)) {
    throw new Error("Unknown model: " + model);
  }
  let i2;
  let channels;
  if (object == null) {
    this.model = "rgb";
    this.color = [0, 0, 0];
    this.valpha = 1;
  } else if (object instanceof Color$1) {
    this.model = object.model;
    this.color = [...object.color];
    this.valpha = object.valpha;
  } else if (typeof object === "string") {
    const result = colorString.get(object);
    if (result === null) {
      throw new Error("Unable to parse color from string: " + object);
    }
    this.model = result.model;
    channels = convert[this.model].channels;
    this.color = result.value.slice(0, channels);
    this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
  } else if (object.length > 0) {
    this.model = model || "rgb";
    channels = convert[this.model].channels;
    const newArray2 = Array.prototype.slice.call(object, 0, channels);
    this.color = zeroArray(newArray2, channels);
    this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
  } else if (typeof object === "number") {
    this.model = "rgb";
    this.color = [
      object >> 16 & 255,
      object >> 8 & 255,
      object & 255
    ];
    this.valpha = 1;
  } else {
    this.valpha = 1;
    const keys2 = Object.keys(object);
    if ("alpha" in object) {
      keys2.splice(keys2.indexOf("alpha"), 1);
      this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
    }
    const hashedKeys = keys2.sort().join("");
    if (!(hashedKeys in hashedModelKeys)) {
      throw new Error("Unable to parse color from object: " + JSON.stringify(object));
    }
    this.model = hashedModelKeys[hashedKeys];
    const { labels } = convert[this.model];
    const color2 = [];
    for (i2 = 0; i2 < labels.length; i2++) {
      color2.push(object[labels[i2]]);
    }
    this.color = zeroArray(color2);
  }
  if (limiters[this.model]) {
    channels = convert[this.model].channels;
    for (i2 = 0; i2 < channels; i2++) {
      const limit = limiters[this.model][i2];
      if (limit) {
        this.color[i2] = limit(this.color[i2]);
      }
    }
  }
  this.valpha = Math.max(0, Math.min(1, this.valpha));
  if (Object.freeze) {
    Object.freeze(this);
  }
}
Color$1.prototype = {
  toString() {
    return this.string();
  },
  toJSON() {
    return this[this.model]();
  },
  string(places) {
    let self2 = this.model in colorString.to ? this : this.rgb();
    self2 = self2.round(typeof places === "number" ? places : 1);
    const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
    return colorString.to[self2.model](args);
  },
  percentString(places) {
    const self2 = this.rgb().round(typeof places === "number" ? places : 1);
    const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
    return colorString.to.rgb.percent(args);
  },
  array() {
    return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
  },
  object() {
    const result = {};
    const { channels } = convert[this.model];
    const { labels } = convert[this.model];
    for (let i2 = 0; i2 < channels; i2++) {
      result[labels[i2]] = this.color[i2];
    }
    if (this.valpha !== 1) {
      result.alpha = this.valpha;
    }
    return result;
  },
  unitArray() {
    const rgb = this.rgb().color;
    rgb[0] /= 255;
    rgb[1] /= 255;
    rgb[2] /= 255;
    if (this.valpha !== 1) {
      rgb.push(this.valpha);
    }
    return rgb;
  },
  unitObject() {
    const rgb = this.rgb().object();
    rgb.r /= 255;
    rgb.g /= 255;
    rgb.b /= 255;
    if (this.valpha !== 1) {
      rgb.alpha = this.valpha;
    }
    return rgb;
  },
  round(places) {
    places = Math.max(places || 0, 0);
    return new Color$1([...this.color.map(roundToPlace(places)), this.valpha], this.model);
  },
  alpha(value) {
    if (value !== void 0) {
      return new Color$1([...this.color, Math.max(0, Math.min(1, value))], this.model);
    }
    return this.valpha;
  },
  red: getset("rgb", 0, maxfn(255)),
  green: getset("rgb", 1, maxfn(255)),
  blue: getset("rgb", 2, maxfn(255)),
  hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value) => (value % 360 + 360) % 360),
  saturationl: getset("hsl", 1, maxfn(100)),
  lightness: getset("hsl", 2, maxfn(100)),
  saturationv: getset("hsv", 1, maxfn(100)),
  value: getset("hsv", 2, maxfn(100)),
  chroma: getset("hcg", 1, maxfn(100)),
  gray: getset("hcg", 2, maxfn(100)),
  white: getset("hwb", 1, maxfn(100)),
  wblack: getset("hwb", 2, maxfn(100)),
  cyan: getset("cmyk", 0, maxfn(100)),
  magenta: getset("cmyk", 1, maxfn(100)),
  yellow: getset("cmyk", 2, maxfn(100)),
  black: getset("cmyk", 3, maxfn(100)),
  x: getset("xyz", 0, maxfn(95.047)),
  y: getset("xyz", 1, maxfn(100)),
  z: getset("xyz", 2, maxfn(108.833)),
  l: getset("lab", 0, maxfn(100)),
  a: getset("lab", 1),
  b: getset("lab", 2),
  keyword(value) {
    if (value !== void 0) {
      return new Color$1(value);
    }
    return convert[this.model].keyword(this.color);
  },
  hex(value) {
    if (value !== void 0) {
      return new Color$1(value);
    }
    return colorString.to.hex(this.rgb().round().color);
  },
  hexa(value) {
    if (value !== void 0) {
      return new Color$1(value);
    }
    const rgbArray = this.rgb().round().color;
    let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
    if (alphaHex.length === 1) {
      alphaHex = "0" + alphaHex;
    }
    return colorString.to.hex(rgbArray) + alphaHex;
  },
  rgbNumber() {
    const rgb = this.rgb().color;
    return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
  },
  luminosity() {
    const rgb = this.rgb().color;
    const lum = [];
    for (const [i2, element] of rgb.entries()) {
      const chan = element / 255;
      lum[i2] = chan <= 0.04045 ? chan / 12.92 : __pow((chan + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
  },
  contrast(color2) {
    const lum1 = this.luminosity();
    const lum2 = color2.luminosity();
    if (lum1 > lum2) {
      return (lum1 + 0.05) / (lum2 + 0.05);
    }
    return (lum2 + 0.05) / (lum1 + 0.05);
  },
  level(color2) {
    const contrastRatio = this.contrast(color2);
    if (contrastRatio >= 7) {
      return "AAA";
    }
    return contrastRatio >= 4.5 ? "AA" : "";
  },
  isDark() {
    const rgb = this.rgb().color;
    const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
    return yiq < 128;
  },
  isLight() {
    return !this.isDark();
  },
  negate() {
    const rgb = this.rgb();
    for (let i2 = 0; i2 < 3; i2++) {
      rgb.color[i2] = 255 - rgb.color[i2];
    }
    return rgb;
  },
  lighten(ratio) {
    const hsl = this.hsl();
    hsl.color[2] += hsl.color[2] * ratio;
    return hsl;
  },
  darken(ratio) {
    const hsl = this.hsl();
    hsl.color[2] -= hsl.color[2] * ratio;
    return hsl;
  },
  saturate(ratio) {
    const hsl = this.hsl();
    hsl.color[1] += hsl.color[1] * ratio;
    return hsl;
  },
  desaturate(ratio) {
    const hsl = this.hsl();
    hsl.color[1] -= hsl.color[1] * ratio;
    return hsl;
  },
  whiten(ratio) {
    const hwb = this.hwb();
    hwb.color[1] += hwb.color[1] * ratio;
    return hwb;
  },
  blacken(ratio) {
    const hwb = this.hwb();
    hwb.color[2] += hwb.color[2] * ratio;
    return hwb;
  },
  grayscale() {
    const rgb = this.rgb().color;
    const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
    return Color$1.rgb(value, value, value);
  },
  fade(ratio) {
    return this.alpha(this.valpha - this.valpha * ratio);
  },
  opaquer(ratio) {
    return this.alpha(this.valpha + this.valpha * ratio);
  },
  rotate(degrees) {
    const hsl = this.hsl();
    let hue = hsl.color[0];
    hue = (hue + degrees) % 360;
    hue = hue < 0 ? 360 + hue : hue;
    hsl.color[0] = hue;
    return hsl;
  },
  mix(mixinColor, weight) {
    if (!mixinColor || !mixinColor.rgb) {
      throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
    }
    const color1 = mixinColor.rgb();
    const color2 = this.rgb();
    const p = weight === void 0 ? 0.5 : weight;
    const w = 2 * p - 1;
    const a = color1.alpha() - color2.alpha();
    const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
    const w2 = 1 - w1;
    return Color$1.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));
  }
};
for (const model of Object.keys(convert)) {
  if (skippedModels.includes(model)) {
    continue;
  }
  const { channels } = convert[model];
  Color$1.prototype[model] = function(...args) {
    if (this.model === model) {
      return new Color$1(this);
    }
    if (args.length > 0) {
      return new Color$1(args, model);
    }
    return new Color$1([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
  };
  Color$1[model] = function(...args) {
    let color2 = args[0];
    if (typeof color2 === "number") {
      color2 = zeroArray(args, channels);
    }
    return new Color$1(color2, model);
  };
}
function roundTo(number, places) {
  return Number(number.toFixed(places));
}
function roundToPlace(places) {
  return function(number) {
    return roundTo(number, places);
  };
}
function getset(model, channel, modifier) {
  model = Array.isArray(model) ? model : [model];
  for (const m of model) {
    (limiters[m] || (limiters[m] = []))[channel] = modifier;
  }
  model = model[0];
  return function(value) {
    let result;
    if (value !== void 0) {
      if (modifier) {
        value = modifier(value);
      }
      result = this[model]();
      result.color[channel] = value;
      return result;
    }
    result = this[model]().color[channel];
    if (modifier) {
      result = modifier(result);
    }
    return result;
  };
}
function maxfn(max) {
  return function(v) {
    return Math.max(0, Math.min(max, v));
  };
}
function assertArray(value) {
  return Array.isArray(value) ? value : [value];
}
function zeroArray(array, length2) {
  for (let i2 = 0; i2 < length2; i2++) {
    if (typeof array[i2] !== "number") {
      array[i2] = 0;
    }
  }
  return array;
}
var color = Color$1;
var Color$2 = color;
const transparentColor$1 = "rgba(0,0,0,0)";
function ColorPickerContent(props) {
  const { colors: presetColors } = useContext(PresetColorsContext);
  const { onChange } = props;
  const [color2, setColor] = useState(props.value);
  useEffect(() => {
    setColor(props.value);
  }, [props.value]);
  const presetColorList = useMemo(() => {
    return [...presetColors.filter((item2) => item2 !== transparentColor$1).slice(-14)];
  }, [presetColors]);
  return /* @__PURE__ */ React__default.createElement("div", {
    className: styles$7.colorPicker,
    style: { width: 202, paddingTop: 12, paddingBottom: 12 }
  }, /* @__PURE__ */ React__default.createElement("div", {
    style: { padding: "0px 16px" }
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    wrap: true,
    size: "mini"
  }, presetColorList.map((item2) => {
    return /* @__PURE__ */ React__default.createElement("div", {
      title: item2,
      onClick: () => onChange(item2),
      key: item2,
      style: {
        border: "1px solid var(--color-neutral-3, rgb(229, 230, 235))",
        display: "inline-block",
        height: 20,
        width: 20,
        boxSizing: "border-box",
        padding: 4,
        borderRadius: 3,
        backgroundColor: item2,
        position: "relative",
        cursor: "pointer"
      }
    });
  }))), /* @__PURE__ */ React__default.createElement("div", {
    style: {
      padding: "6px 6px 0px 6px"
    }
  }, /* @__PURE__ */ React__default.createElement(Button$4, {
    type: "text",
    size: "small",
    style: {
      color: "#333",
      fontSize: 12,
      width: "100%",
      textAlign: "left",
      paddingLeft: 10,
      position: "relative"
    }
  }, /* @__PURE__ */ React__default.createElement("span", null, "Picker..."), /* @__PURE__ */ React__default.createElement("input", {
    style: {
      position: "absolute",
      width: "100%",
      height: "100%",
      zIndex: 1,
      left: 0,
      top: 0,
      opacity: 0
    },
    type: "color",
    value: color2 ? Color$2(color2).hex() : color2,
    onChange: (e) => onChange(e.target.value)
  }))), /* @__PURE__ */ React__default.createElement("style", null, `
          .form-alpha-picker {
            outline: 1px solid rgb(204, 204, 204, 0.6);
          }
          `));
}
const getCollapseItemEle = (node) => {
  if (!node)
    return document.body;
  if (node.classList.contains("arco-collapse-item")) {
    return node;
  }
  return getCollapseItemEle(node.parentElement);
};
const transparentColor = "rgba(0,0,0,0)";
function ColorPicker(props) {
  const { addCurrentColor } = useContext(PresetColorsContext);
  const [refEle, setRefEle] = useState(null);
  const { value = "", onChange, children, showInput = true } = props;
  const onInputChange = useCallback((value2) => {
    onChange == null ? void 0 : onChange(value2);
    addCurrentColor(value2);
  }, [addCurrentColor, onChange]);
  const getPopupContainer = useCallback(() => {
    return getCollapseItemEle(refEle);
  }, [refEle]);
  return /* @__PURE__ */ React__default.createElement("div", {
    style: { flex: 1, display: "flex" }
  }, /* @__PURE__ */ React__default.createElement(Popover$1, __spreadValues({
    title: props.label,
    trigger: "click",
    className: "color-picker-popup",
    content: /* @__PURE__ */ React__default.createElement(ColorPickerContent, {
      value,
      onChange: onInputChange
    }),
    getPopupContainer
  }, props), children || /* @__PURE__ */ React__default.createElement("div", {
    ref: setRefEle,
    style: {
      display: "inline-block",
      height: 32,
      width: 32,
      boxSizing: "border-box",
      padding: 4,
      border: "1px solid var(--color-neutral-3, rgb(229, 230, 235))",
      borderRadius: showInput ? void 0 : 4,
      fontSize: 0,
      borderRight: showInput ? "none" : void 0,
      position: "relative",
      cursor: "pointer"
    }
  }, props.value ? /* @__PURE__ */ React__default.createElement("span", {
    style: {
      position: "relative",
      display: "block",
      border: "1px solid var(--color-neutral-3, rgb(229, 230, 235))",
      borderRadius: 2,
      width: "100%",
      height: "100%",
      textAlign: "center",
      backgroundColor: value
    }
  }) : /* @__PURE__ */ React__default.createElement("img", {
    style: {
      maxWidth: "100%",
      maxHeight: "100%",
      filter: "invert(  0.78  )  drop-shadow(0 0px 0 rgb(0 0 0 / 45%))"
    },
    src: getImg$1("AttributePanel_02")
  }), /* @__PURE__ */ React__default.createElement("style", null, `
                [title="${transparentColor}"] {
                  background-image: url("https://res.cloudinary.com/flashmail/image/upload/v1656944736/cl4vlvzcm05911zsaor6aktl0/ce7qm7lxs5jm47ggabha.png") !important
                }

                `))), showInput && /* @__PURE__ */ React__default.createElement(Input$5, {
    value: props.value,
    style: { outline: "none", flex: 1 },
    onChange: onInputChange
  }));
}
function Select(props) {
  return /* @__PURE__ */ React__default.createElement(Select$2, __spreadProps(__spreadValues({}, props), {
    dropdownMenuClassName: "easy-email-overlay",
    style: lodash.exports.merge({ width: "100%" }, props.style),
    value: props.value,
    onChange: props.onChange
  }), props.options.map((item2, index2) => /* @__PURE__ */ React__default.createElement(Select$2.Option, {
    key: index2,
    value: item2.value
  }, item2.label)));
}
function RadioGroup(props) {
  const _a = props, { type, vertical } = _a, rest = __objRest(_a, ["type", "vertical"]);
  return /* @__PURE__ */ React__default.createElement(Radio.Group, __spreadProps(__spreadValues({}, rest), {
    style: lodash.exports.merge({ width: "100%" }, rest.style),
    value: rest.value,
    onChange: rest.onChange
  }), /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical,
    spacing: "extraTight"
  }, rest.options.map((item2, index2) => /* @__PURE__ */ React__default.createElement(Radio, {
    key: index2,
    value: item2.value
  }, item2.label))));
}
let primaryId = 0;
const parse = (v) => v;
function enhancer(Component2, changeAdapter) {
  return (props) => {
    const _a = props, {
      name: name2,
      onChangeAdapter,
      valueAdapter,
      inline,
      label,
      labelHidden: labelHidden2,
      helpText,
      alignment,
      distribution,
      validate: validate3,
      required,
      size,
      wrapper: wrapper2 = true,
      debounceTime = 0
    } = _a, rest = __objRest(_a, [
      "name",
      "onChangeAdapter",
      "valueAdapter",
      "inline",
      "label",
      "labelHidden",
      "helpText",
      "alignment",
      "distribution",
      "validate",
      "required",
      "size",
      "wrapper",
      "debounceTime"
    ]);
    const {
      input: { value, onChange }
    } = useField(name2, {
      validate: validate3,
      parse: (v) => v
    });
    const [currentValue, setCurrentValue] = useState(value);
    const debounceCallbackChange = useCallback(lodash.exports.debounce((val) => {
      onChange(val);
    }, 500, {}), [onChange]);
    useEffect(() => {
      setCurrentValue(value);
    }, [value]);
    const id = useMemo(() => {
      return `enhancer-${primaryId++}`;
    }, []);
    return /* @__PURE__ */ React__default.createElement(Field, {
      name: name2,
      validate: validate3,
      parse
    }, ({ input: { onBlur: onBlur3 }, meta: { touched, error: error2 } }) => {
      const onFieldChange = useCallback((e) => {
        const newVal = onChangeAdapter ? onChangeAdapter(changeAdapter(e)) : changeAdapter(e);
        setCurrentValue(newVal);
        debounceCallbackChange(newVal);
        onBlur3();
      }, [onBlur3]);
      if (!wrapper2)
        return /* @__PURE__ */ React__default.createElement(Component2, __spreadProps(__spreadValues({}, rest), {
          id,
          name: name2,
          checked: valueAdapter ? valueAdapter(currentValue) : currentValue,
          value: valueAdapter ? valueAdapter(currentValue) : currentValue,
          onChange: onFieldChange
        }));
      const wrapperStyle = inline ? {
        label: {
          span: 7,
          offset: 0
        },
        value: {
          span: 16,
          offset: 1
        },
        textAlign: "right"
      } : {
        label: {
          span: 24,
          offset: 0
        },
        value: {
          span: 24,
          offset: 0
        },
        textAlign: "left"
      };
      return /* @__PURE__ */ React__default.createElement(Form.Item, {
        noStyle: true,
        validateStatus: touched && error2 ? "error" : void 0,
        help: touched && error2
      }, /* @__PURE__ */ React__default.createElement(Space$1, {
        direction: "vertical",
        style: { width: "100%" }
      }, /* @__PURE__ */ React__default.createElement(Grid.Row, {
        align: "center"
      }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
        span: wrapperStyle.label.span,
        offset: wrapperStyle.label.offset,
        style: { textAlign: wrapperStyle.textAlign }
      }, /* @__PURE__ */ React__default.createElement("label", {
        className: labelHidden2 ? styles$7["label-hidden"] : void 0,
        style: { width: "100%", display: "flex" },
        htmlFor: id
      }, required && /* @__PURE__ */ React__default.createElement("span", {
        style: { color: "#ff4d4f", marginRight: 4 }
      }, "*", " "), /* @__PURE__ */ React__default.createElement("div", {
        style: { flex: 1 }
      }, " ", label))), /* @__PURE__ */ React__default.createElement(Grid.Col, {
        style: {
          textAlign: "left"
        },
        offset: wrapperStyle.value.offset,
        span: wrapperStyle.value.span
      }, /* @__PURE__ */ React__default.createElement(Component2, __spreadProps(__spreadValues({
        size
      }, rest), {
        id,
        name: name2,
        checked: valueAdapter ? valueAdapter(currentValue) : currentValue,
        value: valueAdapter ? valueAdapter(currentValue) : currentValue,
        onChange: onFieldChange
      })))), helpText && /* @__PURE__ */ React__default.createElement("div", {
        className: styles$7.helperText
      }, /* @__PURE__ */ React__default.createElement("small", null, helpText))));
    });
  };
}
function Input(props) {
  const {
    quickchange,
    value = "",
    onKeyDown: onPropsKeyDown,
    onChange: propsOnChange
  } = props;
  const onChange = useCallback((val) => {
    propsOnChange(val);
  }, [propsOnChange]);
  const onKeyDown = useCallback((ev) => {
    if (onPropsKeyDown) {
      onPropsKeyDown == null ? void 0 : onPropsKeyDown(ev);
    }
    if (quickchange) {
      let step = 0;
      if (ev.key === "ArrowUp") {
        step = 1;
      }
      if (ev.key === "ArrowDown") {
        step = -1;
      }
      if (step) {
        if (/^\d+/.test(value)) {
          ev.preventDefault();
          onChange(String(value).replace(/^(\d+)/, (_, match) => {
            return (Number(match) + step).toString();
          }));
        }
      }
    }
  }, [onPropsKeyDown, quickchange, value, onChange]);
  return /* @__PURE__ */ React__default.createElement(Input$5, __spreadProps(__spreadValues({}, __spreadProps(__spreadValues({}, props), { quickchange: void 0 })), {
    onChange: (value2) => onChange(value2),
    onKeyDown
  }));
}
function InputWithUnit(props) {
  const _a = props, {
    value = "",
    onKeyDown: onPropsKeyDown,
    unitOptions: propsUnitOptions
  } = _a, restProps = __objRest(_a, [
    "value",
    "onKeyDown",
    "unitOptions"
  ]);
  return /* @__PURE__ */ React__default.createElement(Input, __spreadProps(__spreadValues({
    value
  }, restProps), {
    quickchange: true
  }));
}
function CheckBoxGroup(props) {
  const _a = props, { vertical = false } = _a, rest = __objRest(_a, ["vertical"]);
  return /* @__PURE__ */ React__default.createElement(Checkbox$1.Group, {
    style: lodash.exports.merge({ width: "100%" }, rest.style),
    value: rest.value,
    onChange: rest.onChange
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical,
    spacing: "extraTight"
  }, rest.options.map((item2, index2) => /* @__PURE__ */ React__default.createElement(Checkbox$1, {
    style: rest.checkboxStyle,
    key: index2,
    value: item2.value
  }, item2.label))));
}
function classnames(...rest) {
  return rest.filter((item2) => typeof item2 === "string").join(" ");
}
const { TabPane: TabPane$1 } = Tabs$1;
function EditTab(props) {
  const { value, additionItem } = props;
  const [activeTab, setActiveTab] = useState("0");
  const onAddTab = () => {
    setActiveTab(value.length.toString());
    props.onChange([...value, additionItem]);
  };
  const onDeleteTab = (index2) => {
    if (index2 < activeTab) {
      setActiveTab((Number(activeTab) - 1).toString());
    }
    if (index2 === activeTab) {
      setActiveTab(Number(index2) > 0 ? `${Number(index2) - 1}` : "0");
    }
    props.onChange(value.filter((_, vIndex) => Number(index2) !== vIndex));
  };
  return /* @__PURE__ */ React__default.createElement(Tabs$1, {
    destroyOnHide: true,
    className: classnames(styles$7.editTab),
    style: { border: "none" },
    type: "card",
    activeTab,
    tabPosition: props.tabPosition,
    editable: true,
    onAddTab,
    onDeleteTab,
    onChange: setActiveTab
  }, (Array.isArray(value) ? value : []).map((item2, index2) => /* @__PURE__ */ React__default.createElement(TabPane$1, {
    style: { paddingLeft: 12 },
    title: `${props.label || "Tab"} ${index2 + 1}`,
    key: index2
  }, props.renderItem(item2, index2))));
}
function EditGridTab(props) {
  const { value, additionItem } = props;
  const onAdd = (index2) => {
    let newItem = additionItem || lodash.exports.cloneDeep(value[index2]);
    value.splice(index2 + 1, 0, newItem);
    props.onChange([...value]);
  };
  const onDelete = (index2) => {
    props.onChange(value.filter((_, vIndex) => Number(index2) !== vIndex));
  };
  return /* @__PURE__ */ React__default.createElement(Card$1, {
    bordered: false
  }, (Array.isArray(value) ? value : []).map((item2, index2) => /* @__PURE__ */ React__default.createElement(Card$1.Grid, {
    style: { width: "100%" },
    key: index2
  }, /* @__PURE__ */ React__default.createElement(Card$1, {
    title: /* @__PURE__ */ React__default.createElement(Space$1, null, /* @__PURE__ */ React__default.createElement(Typography$1.Text, null, "Item ", index2 + 1)),
    extra: /* @__PURE__ */ React__default.createElement(Space$1, {
      size: "large"
    }, /* @__PURE__ */ React__default.createElement(IconPlus$1, {
      style: { color: "#000", cursor: "pointer" },
      onClick: () => onAdd(index2)
    }), /* @__PURE__ */ React__default.createElement(IconClose$1, {
      style: { color: "#000", cursor: "pointer" },
      onClick: () => onDelete(index2)
    }))
  }, props.renderItem(item2, index2)))));
}
function InlineText({ idx, onChange, children }) {
  const {
    mutators: { setFieldTouched }
  } = useForm$1();
  useField(idx);
  useEffect(() => {
    const shadowRoot = getShadowRoot();
    const onPaste = (e) => {
      var _a, _b;
      if (!(e.target instanceof Element) || !e.target.getAttribute("contenteditable"))
        return;
      e.preventDefault();
      const text = ((_a = e.clipboardData) == null ? void 0 : _a.getData("text/plain")) || "";
      document.execCommand("insertHTML", false, text);
      const contentEditableType = e.target.getAttribute(DATA_CONTENT_EDITABLE_TYPE);
      if (contentEditableType === ContentEditableType.RichText) {
        onChange(e.target.innerHTML || "");
      } else if (contentEditableType === ContentEditableType.Text) {
        onChange(((_b = e.target.textContent) == null ? void 0 : _b.trim()) || "");
      }
    };
    const onInput = (e) => {
      var _a;
      if (e.target instanceof Element && e.target.getAttribute("contenteditable")) {
        const contentEditableType = e.target.getAttribute(DATA_CONTENT_EDITABLE_TYPE);
        if (contentEditableType === ContentEditableType.RichText) {
          onChange(e.target.innerHTML || "");
        } else if (contentEditableType === ContentEditableType.Text) {
          onChange(((_a = e.target.textContent) == null ? void 0 : _a.trim()) || "");
        }
      }
    };
    shadowRoot.addEventListener("paste", onPaste, true);
    shadowRoot.addEventListener("input", onInput);
    return () => {
      shadowRoot.removeEventListener("paste", onPaste, true);
      shadowRoot.removeEventListener("input", onInput);
    };
  }, [onChange, setFieldTouched]);
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, children);
}
function AutoComplete(props) {
  const options2 = useMemo(() => {
    const selectedValue = (props.value || "").toLowerCase();
    return props.options.filter((item2) => {
      return lodash.exports.isString(item2.value) && item2.value.toLowerCase().startsWith(selectedValue) || lodash.exports.isString(item2.label) && item2.label.toLowerCase().startsWith(selectedValue);
    }).map((item2) => __spreadProps(__spreadValues({}, item2), { name: item2.label }));
  }, [props.options, props.value]);
  return /* @__PURE__ */ React__default.createElement(ArcoAutoComplete, __spreadProps(__spreadValues({}, props), {
    data: options2
  }));
}
const ToolItem$1 = (props) => {
  if (!props.title) {
    return /* @__PURE__ */ React__default.createElement("button", {
      tabIndex: -1,
      className: "easy-email-extensions-emailToolItem",
      title: props.title,
      onClick: props.onClick,
      style: props.style
    }, props.icon);
  }
  return /* @__PURE__ */ React__default.createElement(Tooltip$1, {
    mini: true,
    position: "bottom",
    content: props.title
  }, /* @__PURE__ */ React__default.createElement("button", {
    tabIndex: -1,
    className: classnames("easy-email-extensions-emailToolItem", props.isActive && "easy-email-extensions-emailToolItem-active"),
    title: props.title,
    onClick: props.onClick,
    style: props.style
  }, props.icon));
};
function getAnchorElement$1(node) {
  if (!node)
    return null;
  if (node instanceof HTMLAnchorElement) {
    return node;
  }
  if (node instanceof Element && node.classList.contains(EMAIL_BLOCK_CLASS_NAME))
    return null;
  return getAnchorElement$1(node.parentNode);
}
function getLinkNode$1(currentRange) {
  let linkNode = null;
  if (!currentRange)
    return null;
  linkNode = getAnchorElement$1(currentRange.startContainer);
  return linkNode;
}
function Link$1(props) {
  const initialValues = useMemo(() => {
    let link2 = "";
    let blank = true;
    let underline = true;
    let linkNode = getLinkNode$1(props.currentRange);
    if (linkNode) {
      link2 = linkNode.getAttribute("href") || "";
      blank = linkNode.getAttribute("target") === "_blank";
      underline = linkNode.style.textDecoration === "underline";
    }
    return {
      link: link2,
      blank,
      underline,
      linkNode
    };
  }, [props.currentRange]);
  const onSubmit = useCallback((values2) => {
    props.onChange(values2);
  }, [props]);
  return /* @__PURE__ */ React__default.createElement(Form$3, {
    key: initialValues.link,
    enableReinitialize: true,
    initialValues,
    onSubmit
  }, ({ handleSubmit }) => {
    return /* @__PURE__ */ React__default.createElement(Tooltip$1, __spreadProps(__spreadValues({}, props), {
      trigger: "click",
      color: "#fff",
      position: "tl",
      content: /* @__PURE__ */ React__default.createElement("div", {
        style: { color: "#333" }
      }, /* @__PURE__ */ React__default.createElement(Stack$4, {
        vertical: true,
        spacing: "none"
      }, /* @__PURE__ */ React__default.createElement(SearchField, {
        size: "small",
        name: "link",
        label: "Link",
        labelHidden: true,
        searchButton: "Apply",
        placeholder: "https://www.example.com",
        onSearch: () => handleSubmit()
      })), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
        span: 12
      }, /* @__PURE__ */ React__default.createElement(Space$1, {
        align: "center",
        size: "mini"
      }, /* @__PURE__ */ React__default.createElement(TextStyle, {
        size: "smallest"
      }, "Target"), /* @__PURE__ */ React__default.createElement(SwitchField, {
        size: "small",
        label: "Target",
        labelHidden: true,
        name: "blank",
        checkedText: "blank",
        uncheckedText: "self",
        inline: true
      }))), /* @__PURE__ */ React__default.createElement(Grid.Col, {
        span: 12
      }, /* @__PURE__ */ React__default.createElement(Space$1, {
        align: "center",
        size: "mini"
      }, /* @__PURE__ */ React__default.createElement(TextStyle, {
        size: "smallest"
      }, "Underline"), /* @__PURE__ */ React__default.createElement(SwitchField, {
        size: "small",
        label: "Underline",
        labelHidden: true,
        name: "underline",
        checkedText: "off",
        uncheckedText: "on",
        inline: true
      })))))
    }), /* @__PURE__ */ React__default.createElement(ToolItem$1, {
      isActive: Boolean(initialValues.link),
      title: "Link",
      icon: /* @__PURE__ */ React__default.createElement(IconFont, {
        iconName: "icon-link"
      })
    }));
  });
}
function useFontFamily() {
  const { fontList: defaultFontList } = useEditorProps();
  const { pageData: pageData2 } = useEditorContext();
  const addFonts = pageData2.data.value.fonts;
  const fontList2 = useMemo(() => {
    const fonts = [];
    if (defaultFontList) {
      fonts.push(...defaultFontList);
    }
    if (addFonts) {
      const options2 = addFonts.map((item2) => ({ value: item2.name, label: item2.name }));
      fonts.unshift(...options2);
    }
    return fonts.map((item2) => ({ value: item2.value, label: /* @__PURE__ */ React__default.createElement("span", {
      style: { fontFamily: item2.value }
    }, item2.label) }));
  }, [addFonts, defaultFontList]);
  return {
    fontList: fontList2
  };
}
var styleText$1 = ".easy-email-extensions-Tools-Popover .arco-popover-content{padding:0}.easy-email-extensions-Tools-Popover .arco-popover-content-inner *::-webkit-scrollbar{-webkit-appearance:none;width:5px}.easy-email-extensions-Tools-Popover .arco-popover-content-inner *::-webkit-scrollbar-thumb{border-radius:5px;background-color:#00000080;box-shadow:0 0 1px #ffffff80;-webkit-box-shadow:0 0 1px rgba(255,255,255,.5)}\n";
function FontFamily$1(props) {
  const { fontList: fontList2 } = useFontFamily();
  const { execCommand } = props;
  const [visible, setVisible] = React__default.useState(false);
  const onChange = useCallback((val) => {
    execCommand("fontName", val);
    setVisible(false);
  }, [execCommand]);
  const onVisibleChange = useCallback((v) => {
    setVisible(v);
  }, []);
  return /* @__PURE__ */ React__default.createElement(Popover$1, {
    trigger: "click",
    color: "#fff",
    position: "left",
    className: "easy-email-extensions-Tools-Popover",
    popupVisible: visible,
    onVisibleChange,
    content: /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("style", null, styleText$1), /* @__PURE__ */ React__default.createElement("div", {
      style: {
        maxWidth: 150,
        maxHeight: 350,
        overflowY: "auto",
        overflowX: "hidden"
      }
    }, /* @__PURE__ */ React__default.createElement(Menu$1, {
      onClickMenuItem: onChange,
      selectedKeys: [],
      style: { border: "none", padding: 0 }
    }, fontList2.map((item2) => /* @__PURE__ */ React__default.createElement(Menu$1.Item, {
      style: { lineHeight: "30px", height: 30 },
      key: item2.value
    }, item2.label))))),
    getPopupContainer: props.getPopupContainer
  }, /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    title: t("Font family"),
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-font-family"
    })
  }));
}
var ARRAY_ERROR = "FINAL_FORM/array-error";
var fieldSubscriptionItems = ["active", "data", "dirty", "dirtySinceLastSubmit", "error", "initial", "invalid", "length", "modified", "modifiedSinceLastSubmit", "pristine", "submitError", "submitFailed", "submitSucceeded", "submitting", "touched", "valid", "value", "visited", "validating"];
var version$1 = "4.20.4";
function renderComponent(props, name2) {
  var render = props.render, children = props.children, component = props.component, rest = _objectWithoutPropertiesLoose(props, ["render", "children", "component"]);
  if (component) {
    return /* @__PURE__ */ createElement(component, _extends({}, rest, {
      children,
      render
    }));
  }
  if (render) {
    return render(children === void 0 ? rest : _extends({}, rest, {
      children
    }));
  }
  if (typeof children !== "function") {
    throw new Error("Must specify either a render prop, a render function as children, or a component prop to " + name2);
  }
  return children(rest);
}
var defaultIsEqual = function defaultIsEqual2(aArray, bArray) {
  return aArray === bArray || Array.isArray(aArray) && Array.isArray(bArray) && aArray.length === bArray.length && !aArray.some(function(a, index2) {
    return a !== bArray[index2];
  });
};
function useConstant(init) {
  var ref = React__default.useRef();
  if (!ref.current) {
    ref.current = init();
  }
  return ref.current;
}
var all = fieldSubscriptionItems.reduce(function(result, key) {
  result[key] = true;
  return result;
}, {});
var useFieldArray = function useFieldArray2(name2, _temp) {
  var _ref2 = _temp === void 0 ? {} : _temp, _ref$subscription = _ref2.subscription, subscription = _ref$subscription === void 0 ? all : _ref$subscription, defaultValue = _ref2.defaultValue, initialValue = _ref2.initialValue, _ref$isEqual = _ref2.isEqual, isEqual2 = _ref$isEqual === void 0 ? defaultIsEqual : _ref$isEqual, validateProp = _ref2.validate;
  var form = useForm$1("useFieldArray");
  var formMutators = form.mutators;
  var hasMutators = !!(formMutators && formMutators.push && formMutators.pop);
  if (!hasMutators) {
    throw new Error("Array mutators not found. You need to provide the mutators from final-form-arrays to your form");
  }
  var mutators = useConstant(function() {
    return Object.keys(formMutators).reduce(function(result, key) {
      result[key] = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return formMutators[key].apply(formMutators, [name2].concat(args));
      };
      return result;
    }, {});
  });
  var validate3 = useConstant(function() {
    return function(value, allValues, meta2) {
      if (!validateProp)
        return void 0;
      var error2 = validateProp(value, allValues, meta2);
      if (!error2 || Array.isArray(error2)) {
        return error2;
      } else {
        var arrayError = [];
        arrayError[ARRAY_ERROR] = error2;
        return arrayError;
      }
    };
  });
  var _useField = useField(name2, {
    subscription: _extends({}, subscription, {
      length: true
    }),
    defaultValue,
    initialValue,
    isEqual: isEqual2,
    validate: validate3,
    format: function format(v) {
      return v;
    }
  }), _useField$meta = _useField.meta, length2 = _useField$meta.length, meta = _objectWithoutPropertiesLoose(_useField$meta, ["length"]), input = _useField.input, fieldState = _objectWithoutPropertiesLoose(_useField, ["meta", "input"]);
  var forEach = function forEach2(iterator) {
    var len = length2 || 0;
    for (var i2 = 0; i2 < len; i2++) {
      iterator(name2 + "[" + i2 + "]", i2);
    }
  };
  var map = function map2(iterator) {
    var len = length2 || 0;
    var results = [];
    for (var i2 = 0; i2 < len; i2++) {
      results.push(iterator(name2 + "[" + i2 + "]", i2));
    }
    return results;
  };
  return {
    fields: _extends({
      name: name2,
      forEach,
      length: length2 || 0,
      map
    }, mutators, fieldState, {
      value: input.value
    }),
    meta
  };
};
var version = "3.1.2";
var versions = {
  "final-form": version$1,
  "react-final-form": version$2,
  "react-final-form-arrays": version
};
var FieldArray = function FieldArray2(_ref2) {
  var name2 = _ref2.name, subscription = _ref2.subscription, defaultValue = _ref2.defaultValue, initialValue = _ref2.initialValue, isEqual2 = _ref2.isEqual, validate3 = _ref2.validate, rest = _objectWithoutPropertiesLoose(_ref2, ["name", "subscription", "defaultValue", "initialValue", "isEqual", "validate"]);
  var _useFieldArray = useFieldArray(name2, {
    subscription,
    defaultValue,
    initialValue,
    isEqual: isEqual2,
    validate: validate3
  }), fields = _useFieldArray.fields, meta = _useFieldArray.meta;
  return renderComponent(_extends({
    fields,
    meta: _extends({}, meta, {
      __versions: versions
    })
  }, rest), "FieldArray(" + name2 + ")");
};
function Help(props) {
  return /* @__PURE__ */ React__default.createElement(Tooltip$1, __spreadProps(__spreadValues({}, __spreadProps(__spreadValues({}, props), { style: void 0 })), {
    content: props.title
  }), /* @__PURE__ */ React__default.createElement("span", {
    style: { cursor: "pointer" }
  }, /* @__PURE__ */ React__default.createElement(IconQuestionCircle$1, {
    style: props.style
  })));
}
function AddFont() {
  const { focusBlock: focusBlock2 } = useBlock();
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const value = focusBlock2 == null ? void 0 : focusBlock2.data.value;
  return /* @__PURE__ */ React__default.createElement(FieldArray, {
    name: `${focusIdx2}.data.value.fonts`,
    render: (arrayHelpers) => {
      var _a;
      return /* @__PURE__ */ React__default.createElement("div", null, /* @__PURE__ */ React__default.createElement(Stack$4, {
        vertical: true,
        spacing: "tight"
      }, /* @__PURE__ */ React__default.createElement(Stack$4, {
        distribution: "equalSpacing"
      }, /* @__PURE__ */ React__default.createElement(TextStyle, {
        variation: "strong"
      }, t("Import font"), " ", /* @__PURE__ */ React__default.createElement(Help, {
        title: t("Points to a hosted css file")
      })), /* @__PURE__ */ React__default.createElement(Stack$4, null, /* @__PURE__ */ React__default.createElement(Button$4, {
        size: "small",
        icon: /* @__PURE__ */ React__default.createElement(IconPlus$1, null),
        onClick: () => arrayHelpers.fields.push({ name: "", href: "" })
      }))), /* @__PURE__ */ React__default.createElement(Stack$4, {
        vertical: true,
        spacing: "extraTight"
      }, (_a = value.fonts) == null ? void 0 : _a.map((item2, index2) => {
        return /* @__PURE__ */ React__default.createElement("div", {
          key: index2
        }, /* @__PURE__ */ React__default.createElement(Stack$4, {
          alignment: "center",
          wrap: false
        }, /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
          fill: true
        }, /* @__PURE__ */ React__default.createElement(TextField, {
          name: `${focusIdx2}.data.value.fonts.${index2}.name`,
          label: "Name"
        })), /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
          fill: true
        }, /* @__PURE__ */ React__default.createElement(TextField, {
          name: `${focusIdx2}.data.value.fonts.${index2}.href`,
          label: "Href"
        })), /* @__PURE__ */ React__default.createElement(Stack$4, {
          vertical: true,
          spacing: "loose"
        }, /* @__PURE__ */ React__default.createElement(Stack$4.Item, null), /* @__PURE__ */ React__default.createElement(Button$4, {
          icon: /* @__PURE__ */ React__default.createElement(IconDelete$1, null),
          onClick: () => arrayHelpers.fields.remove(index2)
        }))));
      }))));
    }
  });
}
const AttributesPanelWrapper = (props) => {
  const { focusBlock: focusBlock2, setFocusBlock } = useBlock();
  const block2 = focusBlock2 && BlockManager.getBlockByType(focusBlock2.type);
  useCallback((val) => {
    if (!focusBlock2)
      return;
    focusBlock2.data.hidden = val;
    setFocusBlock(__spreadValues({}, focusBlock2));
  }, [focusBlock2, setFocusBlock]);
  if (!focusBlock2 || !block2)
    return null;
  return /* @__PURE__ */ React__default.createElement("div", null, /* @__PURE__ */ React__default.createElement("div", {
    style: {
      border: "1px solid var(--color-neutral-3, rgb(229, 230, 235))",
      borderBottom: "none",
      padding: "12px 24px"
    }
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
    fill: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    wrap: false,
    distribution: "equalSpacing",
    alignment: "center"
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    spacing: "extraTight",
    alignment: "center"
  }, /* @__PURE__ */ React__default.createElement(EyeIcon, null), /* @__PURE__ */ React__default.createElement(TextStyle, {
    variation: "strong",
    size: "large"
  }, `${block2.name} `, " ", t("attributes"))), /* @__PURE__ */ React__default.createElement(Stack$4.Item, null, props.extra))))), /* @__PURE__ */ React__default.createElement("div", {
    style: __spreadValues({ padding: "0px" }, props.style)
  }, props.children));
};
function EyeIcon() {
  const { setFocusBlock, focusBlock: focusBlock2 } = useBlock();
  const onToggleVisible = useCallback((e) => {
    if (!focusBlock2)
      return null;
    e.stopPropagation();
    setFocusBlock(__spreadProps(__spreadValues({}, focusBlock2), {
      data: __spreadProps(__spreadValues({}, focusBlock2.data), {
        hidden: !focusBlock2.data.hidden
      })
    }));
  }, [focusBlock2, setFocusBlock]);
  if (!focusBlock2)
    return null;
  if (focusBlock2.type === BasicType.PAGE)
    return null;
  return focusBlock2.data.hidden ? /* @__PURE__ */ React__default.createElement(IconEyeInvisible$1, {
    style: { cursor: "pointer", fontSize: 18 },
    onClick: onToggleVisible
  }) : /* @__PURE__ */ React__default.createElement(IconEye$1, {
    style: { cursor: "pointer", fontSize: 18 },
    onClick: onToggleVisible
  });
}
function FontFamily({ name: name2 }) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const { fontList: fontList2 } = useFontFamily();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(AutoCompleteField, {
      style: { minWidth: 100, flex: 1 },
      showSearch: true,
      label: t("Font family"),
      name: name2 || `${focusIdx2}.attributes.font-family`,
      options: fontList2
    });
  }, [focusIdx2, fontList2, name2]);
}
function Page() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  if (!focusIdx2)
    return null;
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, {
    style: { padding: 0 }
  }, /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
    fill: true
  }, /* @__PURE__ */ React__default.createElement(Collapse$1, {
    defaultActiveKey: ["0", "1"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "0",
    header: t("Email Setting")
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: t("Subject"),
    name: "subject",
    inline: true
  }), /* @__PURE__ */ React__default.createElement(TextField, {
    label: t("SubTitle"),
    name: "subTitle",
    inline: true
  }), /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    label: t("Width"),
    name: `${focusIdx2}.attributes.width`,
    inline: true
  }), /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    label: t("Breakpoint"),
    helpText: t("Allows you to control on which breakpoint the layout should go desktop/mobile."),
    name: `${focusIdx2}.data.value.breakpoint`,
    inline: true
  }))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "1",
    header: t("Theme Setting")
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true,
    spacing: "tight"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontFamily, {
    name: `${focusIdx2}.data.value.font-family`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    label: t("Font size"),
    name: `${focusIdx2}.data.value.font-size`
  }))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    label: "Line height",
    unitOptions: "percent",
    name: `${focusIdx2}.data.value.line-height`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    label: t("Font weight"),
    unitOptions: "percent",
    name: `${focusIdx2}.data.value.font-weight`
  }))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(ColorPickerField, {
    label: t("Text color"),
    name: `${focusIdx2}.data.value.text-color`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(ColorPickerField, {
    label: t("Background"),
    name: `${focusIdx2}.attributes.background-color`
  }))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(ColorPickerField, {
    label: t("Content background"),
    name: `${focusIdx2}.data.value.content-background-color`
  })), /* @__PURE__ */ React__default.createElement(TextAreaField, {
    autoSize: true,
    label: t("User style"),
    name: `${focusIdx2}.data.value.user-style.content`
  }), /* @__PURE__ */ React__default.createElement(Stack$4.Item, null), /* @__PURE__ */ React__default.createElement(Stack$4.Item, null), /* @__PURE__ */ React__default.createElement(AddFont, null), /* @__PURE__ */ React__default.createElement(Stack$4.Item, null), /* @__PURE__ */ React__default.createElement(Stack$4.Item, null))))));
}
function Padding(props = {}) {
  const { title: title2 = "Padding", attributeName = "padding", name: name2 } = props;
  const { focusBlock: focusBlock2, change, values: values2 } = useBlock();
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const type = focusBlock2 && focusBlock2.type;
  const defaultConfig = useMemo(() => type ? createBlockDataByType(type) : void 0, [type]);
  const paddingValue = useMemo(() => {
    if (name2) {
      return lodash.exports.get(values2, name2);
    }
    return focusBlock2 == null ? void 0 : focusBlock2.attributes[attributeName];
  }, [attributeName, focusBlock2 == null ? void 0 : focusBlock2.attributes, name2, values2]);
  const defaultPaddingValue = useMemo(() => {
    if (name2) {
      return null;
    }
    return defaultConfig == null ? void 0 : defaultConfig.attributes[attributeName];
  }, [attributeName, defaultConfig == null ? void 0 : defaultConfig.attributes, name2]);
  const paddingFormValues = useMemo(() => {
    const paddingList = paddingValue == null ? void 0 : paddingValue.split(" ");
    const defaultPaddingList = defaultPaddingValue == null ? void 0 : defaultPaddingValue.split(" ");
    const top = paddingList ? paddingList[0] : (defaultPaddingList == null ? void 0 : defaultPaddingList[0]) || "";
    const right = paddingList ? paddingList[1] : (defaultPaddingList == null ? void 0 : defaultPaddingList[1]) || "";
    const bottom = paddingList ? paddingList[2] : (defaultPaddingList == null ? void 0 : defaultPaddingList[2]) || "";
    const left = paddingList ? paddingList[3] : (defaultPaddingList == null ? void 0 : defaultPaddingList[3]) || "";
    return {
      top,
      left,
      bottom,
      right
    };
  }, [defaultPaddingValue, paddingValue]);
  const onChancePadding = useCallback((val) => {
    if (name2) {
      change(name2, val);
    } else {
      change(focusIdx2 + `.attributes[${attributeName}]`, val);
    }
  }, [name2, change, focusIdx2, attributeName]);
  return /* @__PURE__ */ React__default.createElement(Form$3, {
    initialValues: paddingFormValues,
    subscription: { submitting: true, pristine: true },
    enableReinitialize: true,
    onSubmit: () => {
    }
  }, () => {
    return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(Stack$4, {
      vertical: true,
      spacing: "extraTight"
    }, /* @__PURE__ */ React__default.createElement(TextStyle, {
      variation: "strong"
    }, title2), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
      span: 11
    }, /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
      label: "Top",
      name: "top"
    })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
      offset: 1,
      span: 11
    }, /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
      label: "Left",
      name: "left"
    }))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
      span: 11
    }, /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
      label: "Bottom",
      name: "bottom"
    })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
      offset: 1,
      span: 11
    }, /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
      label: "Right",
      name: "right"
    })))), /* @__PURE__ */ React__default.createElement(PaddingChangeWrapper, {
      onChange: onChancePadding
    }));
  });
}
const PaddingChangeWrapper = (props) => {
  const {
    values: { top, right, bottom, left }
  } = useFormState();
  const { onChange } = props;
  useEffect(() => {
    onChange([top, right, bottom, left].join(" "));
  }, [top, right, bottom, left, onChange]);
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null);
};
function BackgroundColor({
  title: title2 = "Background color"
}) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(ColorPickerField, {
      label: title2,
      name: `${focusIdx2}.attributes.background-color`,
      alignment: "center"
    });
  }, [focusIdx2, title2]);
}
const backgroundRepeatOptions = [
  {
    value: "no-repeat",
    label: "No repeat"
  },
  {
    value: "repeat",
    label: "Repeat"
  },
  {
    value: "repeat-x",
    label: "Repeat X"
  },
  {
    value: "repeat-y",
    label: "Repeat Y"
  }
];
function Background() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const { onUploadImage } = useEditorProps();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(Space$1, {
      key: focusIdx2,
      direction: "vertical"
    }, /* @__PURE__ */ React__default.createElement(ImageUploaderField, {
      label: "Background image",
      name: `${focusIdx2}.attributes.background-url`,
      helpText: "The image suffix should be .jpg, jpeg, png, gif, etc. Otherwise, the picture may not be displayed normally.",
      uploadHandler: onUploadImage
    }), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
      span: 11
    }, /* @__PURE__ */ React__default.createElement(BackgroundColor, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
      offset: 1,
      span: 11
    }, /* @__PURE__ */ React__default.createElement(SelectField, {
      label: "Background repeat",
      name: `${focusIdx2}.attributes.background-repeat`,
      options: backgroundRepeatOptions
    }))), /* @__PURE__ */ React__default.createElement(TextField, {
      label: "Background size",
      name: `${focusIdx2}.attributes.background-size`
    }));
  }, [focusIdx2, onUploadImage]);
}
function Border() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
      span: 11
    }, /* @__PURE__ */ React__default.createElement(TextField, {
      label: "Border",
      name: `${focusIdx2}.attributes.border`
    })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
      offset: 1,
      span: 11
    }, /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
      label: "Border radius",
      name: `${focusIdx2}.attributes.border-radius`,
      unitOptions: "percent"
    })));
  }, [focusIdx2]);
}
function ClassName() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(TextField, {
      label: "Class name",
      name: `${focusIdx2}.attributes.css-class`
    });
  }, [focusIdx2]);
}
function Iteration() {
  var _a;
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const { focusBlock: focusBlock2, change } = useBlock();
  const iteration = (_a = focusBlock2 == null ? void 0 : focusBlock2.data.value) == null ? void 0 : _a.iteration;
  Boolean(iteration && iteration.enabled);
  const onIterationToggle = useCallback((enabled2) => {
    if (enabled2) {
      if (!iteration) {
        change(`${focusIdx2}.data.value.iteration`, {
          enabled: true,
          dataSource: "",
          itemName: "item",
          limit: 9999,
          mockQuantity: 1
        });
      }
    }
    change(`${focusIdx2}.data.value.iteration.enabled`, enabled2);
  }, [change, focusIdx2, iteration]);
  if (!(focusBlock2 == null ? void 0 : focusBlock2.type) || !Object.values(AdvancedType).includes(focusBlock2 == null ? void 0 : focusBlock2.type)) {
    return null;
  }
  return /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    className: "iteration",
    destroyOnHide: true,
    name: "Iteration",
    header: "Iteration",
    extra: /* @__PURE__ */ React__default.createElement("div", {
      style: { marginRight: 10 }
    }, /* @__PURE__ */ React__default.createElement(Switch$1, {
      checked: iteration == null ? void 0 : iteration.enabled,
      onChange: onIterationToggle
    }))
  }, (iteration == null ? void 0 : iteration.enabled) && /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement("div", null, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Data source",
    name: `${focusIdx2}.data.value.iteration.dataSource`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Item name",
    name: `${focusIdx2}.data.value.iteration.itemName`
  }))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Limit",
    name: `${focusIdx2}.data.value.iteration.limit`,
    quickchange: true,
    type: "number",
    onChangeAdapter: (v) => Number(v)
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Mock quantity",
    max: iteration == null ? void 0 : iteration.limit,
    name: `${focusIdx2}.data.value.iteration.mockQuantity`,
    type: "number",
    onChangeAdapter: (v) => Number(v),
    quickchange: true
  }))))));
}
function Condition() {
  var _a;
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const { focusBlock: focusBlock2, change, values: values2 } = useBlock();
  const condition = (_a = focusBlock2 == null ? void 0 : focusBlock2.data.value) == null ? void 0 : _a.condition;
  Boolean(condition && condition.enabled);
  const onConditionToggle = useCallback((enabled2) => {
    if (enabled2) {
      if (!condition) {
        change(`${focusIdx2}.data.value.condition`, {
          enabled: true,
          symbol: OperatorSymbol.AND,
          groups: [
            {
              symbol: OperatorSymbol.AND,
              groups: [
                {
                  left: "",
                  operator: Operator.TRUTHY,
                  right: ""
                }
              ]
            }
          ]
        });
      }
    }
    change(`${focusIdx2}.data.value.condition.enabled`, enabled2);
  }, [change, condition, focusIdx2]);
  const onAddCondition = useCallback((path) => {
    const groups = lodash.exports.get(values2, path);
    groups.push({
      symbol: OperatorSymbol.AND,
      groups: [
        {
          left: "",
          operator: Operator.TRUTHY,
          right: ""
        }
      ]
    });
    change(path, [...groups]);
  }, [change, values2]);
  const onAddSubCondition = useCallback((path) => {
    const groups = lodash.exports.get(values2, path);
    groups.push({
      left: "",
      operator: Operator.TRUTHY,
      right: ""
    });
    change(path, [...groups]);
  }, [change, values2]);
  const onDelete = useCallback((path, gIndex, ggIndex) => {
    if (!condition)
      return;
    const subPath = `${path}.${gIndex}.groups`;
    const groups = lodash.exports.cloneDeep(lodash.exports.get(values2, path));
    const subGroups = lodash.exports.cloneDeep(lodash.exports.get(values2, subPath));
    subGroups.splice(ggIndex, 1);
    if (subGroups.length === 0) {
      if (groups.length === 1) {
        Message$1.warning("At least one condition");
        return;
      }
      groups.splice(gIndex, 1);
      change(path, [...groups]);
    } else {
      change(subPath, [...subGroups]);
    }
  }, [change, condition, values2]);
  if (!(focusBlock2 == null ? void 0 : focusBlock2.type) || !Object.values(AdvancedType).includes(focusBlock2 == null ? void 0 : focusBlock2.type)) {
    return null;
  }
  !(condition == null ? void 0 : condition.groups.length);
  return /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    contentStyle: {
      paddingLeft: 10
    },
    className: "condition",
    destroyOnHide: true,
    name: "Condition",
    header: "Condition",
    extra: /* @__PURE__ */ React__default.createElement("div", {
      style: { marginRight: 10 }
    }, /* @__PURE__ */ React__default.createElement(Switch$1, {
      checked: condition == null ? void 0 : condition.enabled,
      onChange: onConditionToggle
    }))
  }, (condition == null ? void 0 : condition.enabled) && /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical",
    size: "large"
  }, /* @__PURE__ */ React__default.createElement(List$1, {
    header: /* @__PURE__ */ React__default.createElement(Grid.Row, {
      justify: "space-between"
    }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
      span: 16
    }, condition.groups.length > 1 && /* @__PURE__ */ React__default.createElement(SelectField, {
      inline: true,
      name: `${focusIdx2}.data.value.condition.symbol`,
      label: "Symbol",
      options: [
        {
          label: "And",
          value: OperatorSymbol.AND
        },
        {
          label: "Or",
          value: OperatorSymbol.OR
        }
      ]
    })), /* @__PURE__ */ React__default.createElement(Button$4, {
      onClick: () => onAddCondition(`${focusIdx2}.data.value.condition.groups`),
      size: "small",
      icon: /* @__PURE__ */ React__default.createElement(IconPlus$1, null)
    })),
    dataSource: condition.groups,
    render: (group, gIndex) => {
      return /* @__PURE__ */ React__default.createElement(List$1.Item, {
        key: gIndex
      }, /* @__PURE__ */ React__default.createElement("div", null, /* @__PURE__ */ React__default.createElement(Grid.Row, {
        justify: "space-between"
      }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
        span: 16
      }, group.groups.length > 1 && /* @__PURE__ */ React__default.createElement(SelectField, {
        inline: true,
        name: `${focusIdx2}.data.value.condition.symbol`,
        label: "Symbol",
        options: [
          {
            label: "And",
            value: OperatorSymbol.AND
          },
          {
            label: "Or",
            value: OperatorSymbol.OR
          }
        ]
      })), /* @__PURE__ */ React__default.createElement(Button$4, {
        size: "small",
        icon: /* @__PURE__ */ React__default.createElement(IconPlus$1, null),
        onClick: () => onAddSubCondition(`${focusIdx2}.data.value.condition.groups.${gIndex}.groups`)
      })), group.groups.map((item2, ggIndex) => /* @__PURE__ */ React__default.createElement(ConditionItem, {
        onDelete,
        path: `${focusIdx2}.data.value.condition.groups`,
        gIndex,
        ggIndex,
        key: ggIndex
      }))));
    }
  })));
}
const options$b = Object.values(Operator).map((item2) => ({ label: lodash.exports.upperFirst(item2), value: item2 }));
function ConditionItem({ path, onDelete, gIndex, ggIndex }) {
  const name2 = `${path}.${gIndex}.groups.${ggIndex}`;
  const { input: { value } } = useField(name2);
  const hideRight = value.operator === Operator.TRUTHY || value.operator === Operator.FALSY;
  return /* @__PURE__ */ React__default.createElement(Grid.Row, {
    align: "end"
  }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 7
  }, " ", /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Variable path",
    name: `${name2}.left`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 7
  }, " ", /* @__PURE__ */ React__default.createElement(SelectField, {
    label: "Operator",
    name: `${name2}.operator`,
    options: options$b
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 7
  }, " ", !hideRight && /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Right",
    name: `${name2}.right`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 3
  }, /* @__PURE__ */ React__default.createElement(Button$4, {
    onClick: () => onDelete(path, gIndex, ggIndex),
    icon: /* @__PURE__ */ React__default.createElement(IconDelete$1, null)
  })));
}
function I18n() {
  var _a;
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const { focusBlock: focusBlock2, change } = useBlock();
  const i18n = (_a = focusBlock2 == null ? void 0 : focusBlock2.data.value) == null ? void 0 : _a.i18n;
  Boolean(i18n && i18n.enabled);
  const onI18nToggle = useCallback((enabled2) => {
    if (enabled2) {
      if (!i18n) {
        change(`${focusIdx2}.data.value.i18n`, {
          enabled: true,
          context: "",
          type: I18nType.I18N
        });
      }
    }
    change(`${focusIdx2}.data.value.i18n.enabled`, enabled2);
  }, [change, focusIdx2, i18n]);
  if (!(focusBlock2 == null ? void 0 : focusBlock2.type) || !Object.values(AdvancedType).includes(focusBlock2 == null ? void 0 : focusBlock2.type)) {
    return null;
  }
  const options2 = [
    {
      value: I18nType.I18N,
      label: "i18n"
    },
    {
      value: I18nType.CI18N,
      label: "ci18n"
    },
    {
      value: I18nType.NI18N,
      label: "ni18n"
    },
    {
      value: I18nType.CNI18N,
      label: "cni18n"
    }
  ];
  return /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    className: "I18N",
    destroyOnHide: true,
    name: "I18N",
    header: "I18N",
    extra: /* @__PURE__ */ React__default.createElement("div", {
      style: { marginRight: 10 }
    }, /* @__PURE__ */ React__default.createElement(Switch$1, {
      checked: i18n == null ? void 0 : i18n.enabled,
      onChange: onI18nToggle
    }))
  }, (i18n == null ? void 0 : i18n.enabled) && /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement("div", null, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 22
  }, /* @__PURE__ */ React__default.createElement(RadioGroupField, {
    label: "I18n Type",
    name: `${focusIdx2}.data.value.i18n.type`,
    options: options2
  })), (focusBlock2.data.value.i18n.type === "ci18n" || focusBlock2.data.value.i18n.type === "cni18n") && /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Context",
    name: `${focusIdx2}.data.value.i18n.context`
  })), (focusBlock2.data.value.i18n.type === "ni18n" || focusBlock2.data.value.i18n.type === "cni18n") && /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Singular Text",
    name: `${focusIdx2}.data.value.i18n.singularText`
  }))))));
}
const CollapseWrapper = (props) => {
  var _a, _b, _c;
  const { enabledLogic } = useEditorProps();
  const [activeKeys, setActiveKeys] = useState(props.defaultActiveKey);
  const { focusBlock: focusBlock2 } = useBlock();
  const value = focusBlock2 == null ? void 0 : focusBlock2.data.value;
  const isAdvancedBlockType = isAdvancedBlock(focusBlock2 == null ? void 0 : focusBlock2.type);
  const iterationEnabled = isAdvancedBlockType && Boolean((value == null ? void 0 : value.iteration) && ((_a = value == null ? void 0 : value.iteration) == null ? void 0 : _a.enabled));
  const conditionEnabled = isAdvancedBlockType && Boolean((value == null ? void 0 : value.condition) && ((_b = value == null ? void 0 : value.condition) == null ? void 0 : _b.enabled));
  const i18nEnabled = isAdvancedBlockType && Boolean((value == null ? void 0 : value.i18n) && ((_c = value == null ? void 0 : value.i18n) == null ? void 0 : _c.enabled));
  const onChange = useCallback((key, keys2) => {
    setActiveKeys(keys2);
  }, []);
  useEffect(() => {
    if (!isAdvancedBlockType)
      return;
    if (iterationEnabled) {
      setActiveKeys((keys2) => [...keys2, "Iteration"]);
    } else {
      setActiveKeys((keys2) => keys2.filter((k) => k !== "Iteration"));
    }
  }, [iterationEnabled, isAdvancedBlockType]);
  useEffect(() => {
    if (!isAdvancedBlockType)
      return;
    if (conditionEnabled) {
      setActiveKeys((keys2) => [...keys2, "Condition"]);
    } else {
      setActiveKeys((keys2) => keys2.filter((k) => k !== "Condition"));
    }
  }, [conditionEnabled, isAdvancedBlockType]);
  useEffect(() => {
    if (!isAdvancedBlockType)
      return;
    if (i18nEnabled) {
      setActiveKeys((keys2) => [...keys2, "I18N"]);
    } else {
      setActiveKeys((keys2) => keys2.filter((k) => k !== "I18N"));
    }
  }, [i18nEnabled, isAdvancedBlockType]);
  return /* @__PURE__ */ React__default.createElement(Space$1, {
    size: "large",
    direction: "vertical",
    style: { width: "100%" }
  }, /* @__PURE__ */ React__default.createElement(Collapse$1, {
    onChange,
    activeKey: activeKeys
  }, enabledLogic && /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(Iteration, null), /* @__PURE__ */ React__default.createElement(Condition, null), /* @__PURE__ */ React__default.createElement(I18n, null)), props.children), /* @__PURE__ */ React__default.createElement("div", null), /* @__PURE__ */ React__default.createElement("div", null), /* @__PURE__ */ React__default.createElement("div", null));
};
function Section() {
  const { focusBlock: focusBlock2, setFocusBlock } = useBlock();
  const noWrap = focusBlock2 == null ? void 0 : focusBlock2.data.value.noWrap;
  const onChange = useCallback((checked) => {
    var _a;
    if (!focusBlock2)
      return;
    focusBlock2.data.value.noWrap = checked;
    if (checked) {
      const children = [...focusBlock2.children];
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (!child)
          continue;
        if (child.type === BasicType.GROUP) {
          children.splice(i2, 1, ...child.children);
        }
      }
      focusBlock2.children = [
        BlockManager.getBlockByType(BasicType.GROUP).create({
          children
        })
      ];
    } else {
      if (focusBlock2.children.length === 1 && focusBlock2.children[0].type === BasicType.GROUP) {
        focusBlock2.children = ((_a = focusBlock2.children[0]) == null ? void 0 : _a.children) || [];
      }
    }
    setFocusBlock(__spreadValues({}, focusBlock2));
  }, [focusBlock2, setFocusBlock]);
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, {
    style: { padding: 0 }
  }, /* @__PURE__ */ React__default.createElement(CollapseWrapper, {
    defaultActiveKey: ["0", "1", "2"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "0",
    header: "Dimension"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 12
  }, /* @__PURE__ */ React__default.createElement("label", {
    style: { width: "100%", display: "flex" }
  }, /* @__PURE__ */ React__default.createElement("div", {
    style: { flex: 1 }
  }, "Group")), /* @__PURE__ */ React__default.createElement(Switch$1, {
    checked: noWrap,
    checkedText: "True",
    uncheckedText: "False",
    onChange
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 12
  })), /* @__PURE__ */ React__default.createElement(Padding, null))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "1",
    header: "Background"
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true,
    spacing: "tight"
  }, /* @__PURE__ */ React__default.createElement(Background, null))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "2",
    header: "Border"
  }, /* @__PURE__ */ React__default.createElement(Border, null)), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "4",
    header: "Extra"
  }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement(ClassName, null)))));
}
function Width({
  inline = false,
  unitOptions
}) {
  var _a;
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const { focusBlock: focusBlock2, values: values2 } = useBlock();
  const parentType = (_a = getParentByIdx(values2, focusIdx2)) == null ? void 0 : _a.type;
  const validate3 = useCallback((val) => {
    if ((focusBlock2 == null ? void 0 : focusBlock2.type) === BasicType.COLUMN && parentType === BasicType.GROUP) {
      return /(\d)*%/.test(val) ? void 0 : "Column inside a group must have a width in percentage, not in pixel";
    }
    return void 0;
  }, [focusBlock2 == null ? void 0 : focusBlock2.type, parentType]);
  return /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    validate: validate3,
    label: "Width",
    inline,
    name: `${focusIdx2}.attributes.width`,
    unitOptions
  });
}
const options$a = [
  {
    value: "top",
    label: "top"
  },
  {
    value: "middle",
    label: "middle"
  },
  {
    value: "bottom",
    label: "bottom"
  }
];
function VerticalAlign({
  attributeName = "vertical-align"
}) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(Stack$4, null, /* @__PURE__ */ React__default.createElement(SelectField, {
      style: { width: 120 },
      label: "Vertical align",
      name: `${focusIdx2}.attributes.${attributeName}`,
      options: options$a
    }));
  }, [attributeName, focusIdx2]);
}
function Column() {
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, null, /* @__PURE__ */ React__default.createElement(CollapseWrapper, {
    defaultActiveKey: ["0", "1", "2"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "0",
    header: "Dimension"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(Width, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(VerticalAlign, null))), /* @__PURE__ */ React__default.createElement(Padding, null))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "1",
    header: "Background"
  }, /* @__PURE__ */ React__default.createElement(Background, null)), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "2",
    header: "Border"
  }, /* @__PURE__ */ React__default.createElement(Border, null)), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "4",
    header: "Extra"
  }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement(ClassName, null)))));
}
const options$9 = [
  {
    value: "",
    label: "None"
  },
  {
    value: "underline",
    label: "Underline"
  },
  {
    value: "overline",
    label: "Overline"
  },
  {
    value: "line-through",
    label: "Line through"
  },
  {
    value: "blink",
    label: "Blink"
  },
  {
    value: "inherit",
    label: "Inherit"
  }
];
function TextDecoration({ name: name2 }) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(SelectField, {
      label: "Text decoration",
      name: name2 || `${focusIdx2}.attributes.text-decoration`,
      options: options$9
    });
  }, [focusIdx2, name2]);
}
const options$8 = [
  {
    value: "normal",
    label: "Normal"
  },
  {
    value: "bold",
    label: "Bold"
  },
  {
    value: "100",
    label: "100"
  },
  {
    value: "200",
    label: "200"
  },
  {
    value: "300",
    label: "300"
  },
  {
    value: "400",
    label: "400"
  },
  {
    value: "500",
    label: "500"
  },
  {
    value: "600",
    label: "600"
  },
  {
    value: "700",
    label: "700"
  },
  {
    value: "800",
    label: "800"
  },
  {
    value: "900",
    label: "900"
  }
];
function FontWeight({ name: name2 }) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(SelectField, {
      label: "Font weight",
      name: name2 || `${focusIdx2}.attributes.font-weight`,
      options: options$8
    });
  }, [focusIdx2, name2]);
}
const options$7 = [
  {
    value: "normal",
    label: "Normal"
  },
  {
    value: "italic",
    label: "Italic"
  }
];
function FontStyle({ name: name2 }) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return /* @__PURE__ */ React__default.createElement(RadioGroupField, {
    label: "Font style",
    name: name2 || `${focusIdx2}.attributes.font-style`,
    options: options$7
  });
}
function Height({ inline }) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(Stack$4, {
      wrap: false
    }, /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
      fill: true
    }, /* @__PURE__ */ React__default.createElement(TextField, {
      label: "Height",
      name: `${focusIdx2}.attributes.height`,
      quickchange: true,
      inline
    })));
  }, [focusIdx2, inline]);
}
function ContainerBackgroundColor({
  title: title2 = "Container background color"
}) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(ColorPickerField, {
      label: title2,
      name: `${focusIdx2}.attributes.container-background-color`,
      alignment: "center"
    });
  }, [focusIdx2, title2]);
}
function FontSize$1() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    label: "Font size",
    name: `${focusIdx2}.attributes.font-size`
  });
}
function Color({
  title: title2 = "Color"
}) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return /* @__PURE__ */ React__default.createElement(ColorPickerField, {
    label: title2,
    name: `${focusIdx2}.attributes.color`,
    alignment: "center"
  });
}
const options$6 = [
  {
    value: "left",
    label: "left"
  },
  {
    value: "center",
    label: "center"
  },
  {
    value: "right",
    label: "right"
  }
];
function Align({ inline }) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return /* @__PURE__ */ React__default.createElement(RadioGroupField, {
    label: "Align",
    name: `${focusIdx2}.attributes.align`,
    options: options$6
  });
}
function LineHeight({ name: name2 }) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    label: "Line height",
    unitOptions: "percent",
    name: name2 || `${focusIdx2}.attributes.line-height`
  });
}
function LetterSpacing({ name: name2 }) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    label: "Letter spacing",
    name: name2 || `${focusIdx2}.attributes.letter-spacing`
  });
}
const ShadowDom = (props) => {
  const [root2, setRoot] = useState(null);
  const [ref, setRef] = useState(null);
  useEffect(() => {
    if (ref) {
      const root22 = ref.attachShadow({ mode: "open" });
      setRoot(root22);
    }
  }, [ref]);
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("div", __spreadProps(__spreadValues({}, props), {
    ref: setRef
  }), root2 && ReactDOM.createPortal(props.children, root2)));
};
const CodeMirrorEditorPromise = import("./index3.js");
const CodeMirrorEditor = React__default.lazy(() => CodeMirrorEditorPromise);
const HtmlEditor = (props) => {
  const { visible, setVisible } = props;
  const { focusBlock: focusBlock2, setValueByIdx: setValueByIdx2 } = useBlock();
  const { pageData: pageData2 } = useEditorContext();
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const [content, setContent] = useState(focusBlock2 == null ? void 0 : focusBlock2.data.value.content);
  const isTable = (focusBlock2 == null ? void 0 : focusBlock2.type) === BasicType.TABLE;
  useEffect(() => {
    setContent(focusBlock2 == null ? void 0 : focusBlock2.data.value.content);
  }, [focusBlock2 == null ? void 0 : focusBlock2.data.value.content]);
  const onClose = () => {
    setVisible(false);
  };
  const onSave = () => {
    if (!focusBlock2)
      return;
    focusBlock2.data.value.content = content;
    setValueByIdx2(focusIdx2, __spreadValues({}, focusBlock2));
    onClose();
  };
  const styles2 = useMemo(() => {
    if (!focusBlock2)
      return {};
    const attributes = focusBlock2.attributes;
    return {
      color: attributes.color || pageData2.data.value["text-color"],
      fontSize: attributes["font-size"] || pageData2.data.value["font-size"],
      fontFamily: attributes["font-family"] || pageData2.data.value["font-family"],
      fontWeight: attributes["font-weight"] || pageData2.data.value["font-weight"],
      backgroundColor: attributes["container-background-color"],
      padding: attributes.padding
    };
  }, [focusBlock2, pageData2.data.value]);
  return /* @__PURE__ */ React__default.createElement(Drawer$1, {
    placement: "left",
    headerStyle: { display: "block", lineHeight: "48px" },
    title: /* @__PURE__ */ React__default.createElement(Stack$4, {
      distribution: "equalSpacing"
    }, /* @__PURE__ */ React__default.createElement(TextStyle, {
      variation: "strong",
      size: "large"
    }, "Html"), /* @__PURE__ */ React__default.createElement(Stack$4, null, /* @__PURE__ */ React__default.createElement(Button$4, {
      type: "primary",
      onClick: onSave
    }, "Save"))),
    closable: false,
    escToExit: false,
    width: "100vw",
    visible,
    footer: null,
    bodyStyle: { padding: 0, overflow: "hidden" }
  }, /* @__PURE__ */ React__default.createElement("div", {
    style: { display: "flex", height: "100%" }
  }, /* @__PURE__ */ React__default.createElement("div", {
    style: { flex: 1, height: "100%" }
  }, /* @__PURE__ */ React__default.createElement(Suspense, {
    fallback: /* @__PURE__ */ React__default.createElement("div", {
      style: {
        height: "100%",
        width: "100%",
        display: "flex",
        alignItems: "center",
        backgroundColor: "#263238",
        justifyContent: "center",
        fontSize: 24,
        color: "#fff"
      }
    }, "Editor Loading...")
  }, /* @__PURE__ */ React__default.createElement(CodeMirrorEditor, {
    value: content,
    onChange: setContent
  }))), /* @__PURE__ */ React__default.createElement("div", {
    style: { flex: 1, height: "100%", overflow: "auto", marginRight: 10 }
  }, /* @__PURE__ */ React__default.createElement(ShadowDom, {
    style: __spreadProps(__spreadValues({}, styles2), {
      width: pageData2.attributes.width || "600px",
      margin: "auto"
    })
  }, isTable ? /* @__PURE__ */ React__default.createElement("table", null, /* @__PURE__ */ React__default.createElement("tbody", {
    dangerouslySetInnerHTML: { __html: content }
  })) : /* @__PURE__ */ React__default.createElement("div", {
    dangerouslySetInnerHTML: { __html: content }
  })))));
};
function Text() {
  const [visible, setVisible] = useState(false);
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, {
    extra: /* @__PURE__ */ React__default.createElement(Tooltip$1, {
      content: "Html mode"
    }, /* @__PURE__ */ React__default.createElement(Button$4, {
      onClick: () => setVisible(true),
      icon: /* @__PURE__ */ React__default.createElement(IconFont, {
        iconName: "icon-html"
      })
    }))
  }, /* @__PURE__ */ React__default.createElement(CollapseWrapper, {
    defaultActiveKey: ["0", "1", "2"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "0",
    header: "Dimension"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(Height, null), /* @__PURE__ */ React__default.createElement(Padding, null))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "1",
    header: "Color"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(Color, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(ContainerBackgroundColor, {
    title: "Background color"
  })))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "2",
    header: "Typography"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontFamily, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontSize$1, null))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(LineHeight, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(LetterSpacing, null))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextDecoration, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontWeight, null))), /* @__PURE__ */ React__default.createElement(Align, null), /* @__PURE__ */ React__default.createElement(FontStyle, null), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  })))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "4",
    header: "Extra"
  }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement(ClassName, null)))), /* @__PURE__ */ React__default.createElement(HtmlEditor, {
    visible,
    setVisible
  }));
}
function Link() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
      span: 11
    }, /* @__PURE__ */ React__default.createElement(TextField, {
      prefix: /* @__PURE__ */ React__default.createElement(IconLink$1, null),
      label: /* @__PURE__ */ React__default.createElement("span", null, "Href\xA0\xA0\xA0"),
      name: `${focusIdx2}.attributes.href`
    })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
      offset: 1,
      span: 11
    }, /* @__PURE__ */ React__default.createElement(SelectField, {
      label: "Target",
      name: `${focusIdx2}.attributes.target`,
      options: [
        {
          value: "",
          label: "_self"
        },
        {
          value: "_blank",
          label: "_blank"
        }
      ]
    })));
  }, [focusIdx2]);
}
function Image$1() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const { onUploadImage } = useEditorProps();
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, {
    style: { padding: 0 }
  }, /* @__PURE__ */ React__default.createElement(CollapseWrapper, {
    defaultActiveKey: ["0", "1", "2", "3", "4"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "1",
    header: "Setting"
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true,
    spacing: "tight"
  }, /* @__PURE__ */ React__default.createElement(ImageUploaderField, {
    label: "src",
    labelHidden: true,
    name: `${focusIdx2}.attributes.src`,
    helpText: "The image suffix should be .jpg, jpeg, png, gif, etc. Otherwise, the picture may not be displayed normally.",
    uploadHandler: onUploadImage
  }), /* @__PURE__ */ React__default.createElement(ColorPickerField, {
    label: "Background color",
    name: `${focusIdx2}.attributes.container-background-color`,
    inline: true,
    alignment: "center"
  }))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "0",
    header: "Dimension"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(Width, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(Height, null))), /* @__PURE__ */ React__default.createElement(Padding, null), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement(Align, null))))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "2",
    header: "Link"
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true,
    spacing: "tight"
  }, /* @__PURE__ */ React__default.createElement(Link, null))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "3",
    header: "Border"
  }, /* @__PURE__ */ React__default.createElement(Border, null)), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "4",
    header: "Extra"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "title",
    name: `${focusIdx2}.attributes.title`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "alt",
    name: `${focusIdx2}.attributes.alt`
  }))), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "class name",
    name: `${focusIdx2}.attributes.css-class`
  })))));
}
function Group() {
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, null, /* @__PURE__ */ React__default.createElement(CollapseWrapper, {
    defaultActiveKey: ["0", "1", "2"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "0",
    header: "Dimension"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(Width, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(VerticalAlign, null)))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "1",
    header: "Background"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(BackgroundColor, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "4",
    header: "Extra"
  }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement(ClassName, null)))));
}
const options$5 = [
  {
    value: "left",
    label: "Left"
  },
  {
    value: "center",
    label: "Center"
  },
  {
    value: "right",
    label: "Right"
  }
];
function TextAlign({ name: name2 }) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(Stack$4, null, /* @__PURE__ */ React__default.createElement(RadioGroupField, {
      label: "Text align",
      name: name2 || `${focusIdx2}.attributes.text-align`,
      options: options$5
    }));
  }, [focusIdx2, name2]);
}
function Decoration() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(Stack$4, {
      key: focusIdx2,
      vertical: true,
      spacing: "extraTight"
    }, /* @__PURE__ */ React__default.createElement(TextStyle, {
      variation: "strong",
      size: "large"
    }, "Decoration"), /* @__PURE__ */ React__default.createElement(TextField, {
      label: "Border radius",
      name: `${focusIdx2}.attributes.borderRadius`,
      inline: true
    }), /* @__PURE__ */ React__default.createElement(TextField, {
      label: "Border",
      name: `${focusIdx2}.attributes.border`,
      inline: true,
      alignment: "center"
    }), /* @__PURE__ */ React__default.createElement(NumberField, {
      label: "Opacity",
      max: 1,
      min: 0,
      step: 0.1,
      name: `${focusIdx2}.attributes.opacity`,
      inline: true,
      alignment: "center"
    }));
  }, [focusIdx2]);
}
const options$4 = [
  {
    value: "initial",
    label: "none"
  },
  {
    value: "uppercase",
    label: "uppercase"
  },
  {
    value: "lowercase",
    label: "lowercase"
  },
  {
    value: "capitalize",
    label: "capitalize"
  }
];
function TextTransform({ name: name2 }) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(SelectField, {
      label: "Text transform",
      name: name2 || `${focusIdx2}.attributes.text-transform`,
      options: options$4
    });
  }, [focusIdx2, name2]);
}
const options$3 = [
  {
    value: "ltr",
    label: "ltr"
  },
  {
    value: "rtl",
    label: "rtl"
  }
];
function Direction() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(Stack$4, null, /* @__PURE__ */ React__default.createElement(RadioGroupField, {
      label: "Direction",
      name: `${focusIdx2}.attributes.direction`,
      options: options$3,
      inline: true
    }));
  }, [focusIdx2]);
}
function Margin() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(Stack$4, {
      vertical: true,
      spacing: "extraTight"
    }, /* @__PURE__ */ React__default.createElement(TextStyle, {
      size: "large"
    }, "Margin"), /* @__PURE__ */ React__default.createElement(Stack$4, {
      wrap: false
    }, /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
      fill: true
    }, /* @__PURE__ */ React__default.createElement(TextField, {
      label: "Top",
      quickchange: true,
      name: `${focusIdx2}.attributes.marginTop`,
      inline: true
    })), /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
      fill: true
    }, /* @__PURE__ */ React__default.createElement(TextField, {
      label: "Bottom",
      quickchange: true,
      name: `${focusIdx2}.attributes.marginBottom`,
      inline: true
    }))), /* @__PURE__ */ React__default.createElement(Stack$4, {
      wrap: false
    }, /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
      fill: true
    }, /* @__PURE__ */ React__default.createElement(TextField, {
      label: "Left",
      quickchange: true,
      name: `${focusIdx2}.attributes.marginLeft`,
      inline: true
    })), /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
      fill: true
    }, /* @__PURE__ */ React__default.createElement(TextField, {
      label: "Right",
      quickchange: true,
      name: `${focusIdx2}.attributes.marginRight`,
      inline: true
    }))));
  }, [focusIdx2]);
}
function BorderColor() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(ColorPickerField, {
      label: "Color",
      name: `${focusIdx2}.attributes.border-color`
    });
  }, [focusIdx2]);
}
function getContextMergeTags(mergeTags2, context, idx) {
  const loop = (currentIdx, combineMergeTags) => {
    var _a, _b;
    const parentBlockData = lodash.exports.get(context, currentIdx);
    if (!parentBlockData)
      return combineMergeTags;
    const parentBlock = BlockManager.getBlockByType(parentBlockData.type);
    if (parentBlock && parentBlock.render) {
      const dataSource = (_b = (_a = parentBlockData.data) == null ? void 0 : _a.value) == null ? void 0 : _b.dataSource;
      if (!dataSource)
        return combineMergeTags;
      Object.keys(dataSource).forEach((key) => {
        let formatKey = dataSource[key];
        const loopFormatKey = (currentLoopKeyIdx) => {
          const currentParentIdx = getParentIdx(currentLoopKeyIdx);
          if (currentParentIdx) {
            const currentBlockData = lodash.exports.get(context, currentParentIdx);
            if (!currentBlockData)
              return formatKey;
            currentBlockData.data.value.dataSource && Object.keys(currentBlockData.data.value.dataSource).forEach((item2) => {
              formatKey = formatKey.replace(item2, currentBlockData.data.value.dataSource[item2].replace(/{{([^}}]+)}}/g, "$1"));
            });
            loopFormatKey(currentParentIdx);
          }
        };
        loopFormatKey(currentIdx);
        const dataSourcePath = formatKey.replace(/{{([^}}]+)}}/g, "$1");
        combineMergeTags = __spreadValues({
          [key]: lodash.exports.get(combineMergeTags, dataSourcePath)
        }, combineMergeTags);
      });
    }
    const parentIdx = getParentIdx(currentIdx);
    if (!parentIdx)
      return combineMergeTags;
    return loop(parentIdx, combineMergeTags);
  };
  return loop(idx, lodash.exports.cloneDeep(mergeTags2));
}
const MergeTags$1 = React__default.memo((props) => {
  const [expandedKeys, setExpandedKeys] = useState([]);
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const {
    mergeTags: mergeTags2 = {},
    mergeTagGenerate,
    renderMergeTagContent
  } = useEditorProps();
  const { values: values2 } = useBlock();
  const contextMergeTags = useMemo(() => getContextMergeTags(mergeTags2, values2, focusIdx2), [mergeTags2, values2, focusIdx2]);
  const treeOptions = useMemo(() => {
    const treeData = [];
    const deep = (key, title2, parent2, mapData = []) => {
      const currentMapData = {
        key,
        value: key,
        title: title2,
        children: []
      };
      mapData.push(currentMapData);
      const current = parent2[title2];
      if (current && typeof current === "object") {
        Object.keys(current).map((childKey) => deep(key + "." + childKey, childKey, current, currentMapData.children));
      }
    };
    Object.keys(contextMergeTags).map((key) => deep(key, key, contextMergeTags, treeData));
    return treeData;
  }, [contextMergeTags]);
  const onSelect = useCallback((key) => {
    const value = lodash.exports.get(contextMergeTags, key);
    if (lodash.exports.isObject(value)) {
      setExpandedKeys((keys2) => {
        if (keys2.includes(key)) {
          return keys2.filter((k) => k !== key);
        } else {
          return [...keys2, key];
        }
      });
      return;
    }
    return props.onChange(mergeTagGenerate(key));
  }, [contextMergeTags, props, mergeTagGenerate]);
  const mergeTagContent = useMemo(() => renderMergeTagContent ? renderMergeTagContent({
    onChange: props.onChange,
    isSelect: Boolean(props.isSelect),
    value: props.value
  }) : /* @__PURE__ */ React__default.createElement(React__default.Fragment, null), [renderMergeTagContent, props.onChange, props.isSelect, props.value]);
  if (renderMergeTagContent) {
    return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, mergeTagContent);
  }
  return /* @__PURE__ */ React__default.createElement("div", {
    style: { color: "#333" }
  }, props.isSelect ? /* @__PURE__ */ React__default.createElement(TreeSelect$1, {
    value: props.value,
    size: "small",
    dropdownMenuStyle: { maxHeight: 400, overflow: "auto" },
    placeholder: "Please select",
    treeData: treeOptions,
    onChange: (val) => onSelect(val)
  }) : /* @__PURE__ */ React__default.createElement(Tree$1, {
    expandedKeys,
    onExpand: setExpandedKeys,
    selectedKeys: [],
    treeData: treeOptions,
    onSelect: (vals) => onSelect(vals[0]),
    style: {
      maxHeight: 400,
      overflow: "auto"
    }
  }));
});
const borderStyleOptions = [
  {
    value: "dashed",
    label: "Dashed"
  },
  {
    value: "dotted",
    label: "Dotted"
  },
  {
    value: "solid",
    label: "Solid"
  },
  {
    value: "double",
    label: "double"
  },
  {
    value: "ridge",
    label: "ridge"
  },
  {
    value: "groove",
    label: "groove"
  },
  {
    value: "inset",
    label: "inset"
  },
  {
    value: "outset",
    label: "outset"
  }
];
function BorderStyle() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(SelectField, {
      label: "Style",
      name: `${focusIdx2}.attributes.border-style`,
      options: borderStyleOptions
    });
  }, [focusIdx2]);
}
function NavbarLinkPadding({ name: name2 }) {
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(Stack$4, {
      vertical: true,
      spacing: "extraTight"
    }, /* @__PURE__ */ React__default.createElement(Padding, {
      name: name2
    }));
  }, [name2]);
}
function BorderWidth() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(TextField, {
      label: "Width",
      quickchange: true,
      name: `${focusIdx2}.attributes.border-width`
    });
  }, [focusIdx2]);
}
function Button() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const { input } = useField(`${focusIdx2}.data.value.content`, {
    parse: (v) => v
  });
  const { mergeTags: mergeTags2 } = useEditorProps();
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, null, /* @__PURE__ */ React__default.createElement(CollapseWrapper, {
    defaultActiveKey: ["-1", "0", "1", "2", "3"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "-1",
    header: "Setting"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: /* @__PURE__ */ React__default.createElement(Space$1, null, /* @__PURE__ */ React__default.createElement("span", null, "Content"), mergeTags2 && /* @__PURE__ */ React__default.createElement(Popover$1, {
      trigger: "click",
      content: /* @__PURE__ */ React__default.createElement(MergeTags$1, {
        value: input.value,
        onChange: input.onChange
      })
    }, /* @__PURE__ */ React__default.createElement(Button$4, {
      type: "text",
      icon: /* @__PURE__ */ React__default.createElement(IconFont, {
        iconName: "icon-merge-tags"
      })
    }))),
    name: `${focusIdx2}.data.value.content`
  }), /* @__PURE__ */ React__default.createElement(Link, null))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "0",
    header: "Dimension"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(Width, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontWeight, null))), /* @__PURE__ */ React__default.createElement(Padding, {
    title: "Padding",
    attributeName: "padding"
  }), /* @__PURE__ */ React__default.createElement(Padding, {
    title: "Inner padding",
    attributeName: "inner-padding"
  }))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "1",
    header: "Color"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(Color, {
    title: "Text color"
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(BackgroundColor, {
    title: "Button color"
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(ContainerBackgroundColor, {
    title: "Background color"
  }))))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "2",
    header: "Typography"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontFamily, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontSize$1, null))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontWeight, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(LineHeight, null))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextDecoration, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(LetterSpacing, null))), /* @__PURE__ */ React__default.createElement(Align, null), /* @__PURE__ */ React__default.createElement(FontStyle, null))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "3",
    header: "Border"
  }, /* @__PURE__ */ React__default.createElement(Border, null)), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "4",
    header: "Extra"
  }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement(ClassName, null)))));
}
function Divider() {
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, null, /* @__PURE__ */ React__default.createElement(CollapseWrapper, {
    defaultActiveKey: ["-1", "0", "1", "2", "3"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "1",
    header: "Dimension"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(Width, {
    unitOptions: "percent"
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  })), /* @__PURE__ */ React__default.createElement(Align, null), /* @__PURE__ */ React__default.createElement(Padding, null))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "2",
    header: "Border"
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    wrap: false,
    spacing: "tight"
  }, /* @__PURE__ */ React__default.createElement("div", {
    style: { width: 50 }
  }, /* @__PURE__ */ React__default.createElement(BorderWidth, null)), /* @__PURE__ */ React__default.createElement("div", {
    style: { width: 100 }
  }, /* @__PURE__ */ React__default.createElement(BorderStyle, null)), /* @__PURE__ */ React__default.createElement("div", {
    style: { width: 100 }
  }, /* @__PURE__ */ React__default.createElement(BorderColor, null)))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "3",
    header: "Background"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(ContainerBackgroundColor, {
    title: "Background"
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "4",
    header: "Extra"
  }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement(ClassName, null)))));
}
function Wrapper() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, {
    style: { padding: 0 }
  }, /* @__PURE__ */ React__default.createElement(CollapseWrapper, {
    defaultActiveKey: ["0", "1", "2"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "0",
    header: "Dimension"
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true,
    spacing: "tight"
  }, /* @__PURE__ */ React__default.createElement(Padding, null))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "1",
    header: "Background"
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true,
    spacing: "tight"
  }, /* @__PURE__ */ React__default.createElement(Background, null))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "2",
    header: "Border"
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true,
    spacing: "tight"
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Border",
    name: `${focusIdx2}.attributes.border`,
    inline: true
  }), /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Background border radius",
    name: `${focusIdx2}.attributes.border-radius`,
    inline: true
  }))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "4",
    header: "Extra"
  }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement(ClassName, null)))));
}
function Spacer() {
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, null, /* @__PURE__ */ React__default.createElement(CollapseWrapper, {
    defaultActiveKey: ["-1", "0", "1", "2", "3"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "1",
    header: "Dimension"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(Height, null), /* @__PURE__ */ React__default.createElement(Padding, null))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "2",
    header: "Background"
  }, /* @__PURE__ */ React__default.createElement(ContainerBackgroundColor, {
    title: "Background color"
  })), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "4",
    header: "Extra"
  }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement(ClassName, null)))));
}
function Raw() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const [visible, setVisible] = useState(false);
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, {
    style: { padding: 20 },
    extra: /* @__PURE__ */ React__default.createElement(Tooltip$1, {
      content: "Html mode"
    }, /* @__PURE__ */ React__default.createElement(Button$4, {
      onClick: () => setVisible(true),
      icon: /* @__PURE__ */ React__default.createElement(IconFont, {
        iconName: "icon-html"
      })
    }))
  }, /* @__PURE__ */ React__default.createElement(TextAreaField, {
    label: "",
    name: `${focusIdx2}.data.value.content`,
    rows: 5
  }), /* @__PURE__ */ React__default.createElement(HtmlEditor, {
    visible,
    setVisible
  }));
}
const positionOptions = [
  {
    value: "left",
    label: "Left"
  },
  {
    value: "right",
    label: "Right"
  }
];
const alignOptions = [
  {
    value: "top",
    label: "top"
  },
  {
    value: "middle",
    label: "middle"
  },
  {
    value: "bottom",
    label: "bottom"
  }
];
function Accordion() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const { onUploadImage } = useEditorProps();
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, null, /* @__PURE__ */ React__default.createElement(CollapseWrapper, {
    defaultActiveKey: ["0", "1", "2"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "0",
    header: "Setting"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(BackgroundColor, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontFamily, null))), /* @__PURE__ */ React__default.createElement(Padding, null), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    label: "Icon width",
    name: `${focusIdx2}.attributes.icon-width`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    label: "Icon height",
    name: `${focusIdx2}.attributes.icon-height`
  }))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(ImageUploaderField, {
    label: "Unwrapped icon",
    name: `${focusIdx2}.attributes.icon-unwrapped-url`,
    uploadHandler: onUploadImage
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(ImageUploaderField, {
    label: "Wrapped icon",
    name: `${focusIdx2}.attributes.icon-wrapped-url`,
    uploadHandler: onUploadImage
  }))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(RadioGroupField, {
    label: "Icon position",
    name: `${focusIdx2}.attributes.icon-position`,
    options: positionOptions
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(SelectField, {
    style: { width: 120 },
    label: "Icon align",
    name: `${focusIdx2}.attributes.icon-align`,
    options: alignOptions
  }))), /* @__PURE__ */ React__default.createElement(TextField, {
    label: "border",
    name: `${focusIdx2}.attributes.border`
  }))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "4",
    header: "Extra"
  }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement(ClassName, null)))));
}
function AccordionElement() {
  useFocusIdx();
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, null, /* @__PURE__ */ React__default.createElement(Collapse$1, {
    defaultActiveKey: ["0", "1", "2"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "0",
    header: "Setting"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(Border, null), /* @__PURE__ */ React__default.createElement(BackgroundColor, null), /* @__PURE__ */ React__default.createElement(FontFamily, null)))));
}
function AccordionTitle() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, null, /* @__PURE__ */ React__default.createElement(Collapse$1, {
    defaultActiveKey: ["0", "1", "2"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "0",
    header: "Setting"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(TextAreaField, {
    label: "Content",
    name: `${focusIdx2}.data.value.content`
  }), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(Color, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(BackgroundColor, null))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontSize$1, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontFamily, null))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontWeight, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  })), /* @__PURE__ */ React__default.createElement(Padding, {
    title: "Padding",
    attributeName: "padding"
  })))));
}
function AccordionText() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, null, /* @__PURE__ */ React__default.createElement(Collapse$1, {
    defaultActiveKey: ["0", "1", "2"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "0",
    header: "Setting"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(TextAreaField, {
    label: "Content",
    name: `${focusIdx2}.data.value.content`,
    autoSize: { minRows: 5 }
  }), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(Color, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontSize$1, null))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(LineHeight, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontWeight, null))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontFamily, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(BackgroundColor, null))), /* @__PURE__ */ React__default.createElement(Padding, {
    title: "Padding",
    attributeName: "padding"
  })))));
}
const options$2 = [
  {
    value: "hidden",
    label: "hidden"
  },
  {
    value: "visible",
    label: "visible"
  }
];
function Carousel() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, {
    style: { padding: 0 }
  }, /* @__PURE__ */ React__default.createElement(CollapseWrapper, {
    defaultActiveKey: ["0", "1", "2", "3", "4"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "0",
    header: "Dimension"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    label: "Thumbnail width",
    name: `${focusIdx2}.attributes.tb-width`,
    quickchange: true,
    inline: true
  }), /* @__PURE__ */ React__default.createElement(RadioGroupField, {
    label: "Thumbnails",
    name: `${focusIdx2}.attributes.thumbnails`,
    options: options$2,
    inline: true
  }), /* @__PURE__ */ React__default.createElement(Align, {
    inline: true
  }))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "4",
    contentStyle: { padding: 0 },
    header: "Images"
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true,
    spacing: "tight"
  }, /* @__PURE__ */ React__default.createElement(EditTabField, {
    tabPosition: "top",
    name: `${focusIdx2}.data.value.images`,
    label: "",
    labelHidden: true,
    renderItem: (item2, index2) => /* @__PURE__ */ React__default.createElement(CarouselImage, {
      item: item2,
      index: index2
    }),
    additionItem: {
      src: "https://www.mailjet.com/wp-content/uploads/2016/11/ecommerce-guide.jpg",
      target: "_blank"
    }
  }))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "3",
    header: "Icon"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Left icon",
    name: `${focusIdx2}.attributes.left-icon`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Right icon",
    name: `${focusIdx2}.attributes.right-icon`
  }))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    label: "Icon width",
    name: `${focusIdx2}.attributes.icon-width`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "1",
    header: "Border"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(ColorPickerField, {
    label: "Hovered border",
    name: `${focusIdx2}.attributes.tb-hover-border-color`,
    alignment: "center"
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(ColorPickerField, {
    label: "Selected Border",
    name: `${focusIdx2}.attributes.tb-selected-border-color`,
    alignment: "center"
  }))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Border of the thumbnails",
    name: `${focusIdx2}.attributes.tb-border`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Border radius of the thumbnails",
    name: `${focusIdx2}.attributes.tb-border-radius`
  })))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "4",
    header: "Extra"
  }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement(ClassName, null)))));
}
function CarouselImage({
  item: item2,
  index: index2
}) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const { onUploadImage } = useEditorProps();
  return /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(ImageUploaderField, {
    label: "Image",
    labelHidden: true,
    name: `${focusIdx2}.data.value.images.[${index2}].src`,
    helpText: "The image suffix should be .jpg, jpeg, png, gif, etc. Otherwise, the picture may not be displayed normally.",
    uploadHandler: onUploadImage
  }), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    prefix: /* @__PURE__ */ React__default.createElement(IconLink$1, null),
    label: "Url",
    name: `${focusIdx2}.data.value.images.[${index2}].href`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(SelectField, {
    label: "Target",
    name: `${focusIdx2}.data.value.images.[${index2}].target`,
    options: [
      {
        value: "",
        label: "_self"
      },
      {
        value: "_blank",
        label: "_blank"
      }
    ]
  }))), /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Title",
    name: `${focusIdx2}.data.value.image.[${index2}].title`
  }));
}
const options$1 = [
  {
    value: "fluid-height",
    label: "Fluid height"
  },
  {
    value: "fixed-height",
    label: "Fixed height"
  }
];
function Hero() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const { onUploadImage } = useEditorProps();
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, null, /* @__PURE__ */ React__default.createElement(CollapseWrapper, {
    defaultActiveKey: ["0", "1", "2"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "0",
    header: "Dimension"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(RadioGroupField, {
    label: "Mode",
    name: `${focusIdx2}.attributes.mode`,
    options: options$1
  }), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(Width, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(Height, null))), /* @__PURE__ */ React__default.createElement(Padding, null), /* @__PURE__ */ React__default.createElement(VerticalAlign, null))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "1",
    header: "Background"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(ImageUploaderField, {
    label: "src",
    name: `${focusIdx2}.attributes.background-url`,
    helpText: "The image suffix should be .jpg, jpeg, png, gif, etc. Otherwise, the picture may not be displayed normally.",
    uploadHandler: onUploadImage
  }), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    label: "Background width",
    name: `${focusIdx2}.attributes.background-width`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    label: "Background height",
    name: `${focusIdx2}.attributes.background-height`
  }))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Background position",
    name: `${focusIdx2}.attributes.background-position`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    label: "Border radius",
    name: `${focusIdx2}.attributes.border-radius`,
    unitOptions: "percent"
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(BackgroundColor, null))))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "4",
    header: "Extra"
  }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement(ClassName, null)))));
}
function Navbar() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, {
    style: { padding: 0 }
  }, /* @__PURE__ */ React__default.createElement(CollapseWrapper, {
    defaultActiveKey: ["0", "1", "2"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "0",
    header: "Layout"
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true,
    spacing: "tight"
  }, /* @__PURE__ */ React__default.createElement(Align, null))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    contentStyle: { padding: 0 },
    name: "1",
    header: "Navbar links"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical",
    style: { width: "100%" }
  }, /* @__PURE__ */ React__default.createElement(EditTabField, {
    tabPosition: "top",
    name: `${focusIdx2}.data.value.links`,
    label: "Links",
    labelHidden: true,
    renderItem: (item2, index2) => /* @__PURE__ */ React__default.createElement(NavbarLink, {
      item: item2,
      index: index2
    }),
    additionItem: {
      src: "https://www.mailjet.com/wp-content/uploads/2016/11/ecommerce-guide.jpg",
      target: "_blank",
      content: "New link",
      color: "#1890ff",
      "font-size": "13px"
    }
  }), /* @__PURE__ */ React__default.createElement("div", null))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "4",
    header: "Extra"
  }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement(ClassName, null)))));
}
function NavbarLink({
  item: item2,
  index: index2
}) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  return /* @__PURE__ */ React__default.createElement("div", {
    className: "NavbarLink"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical",
    style: { width: "100%" }
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Content",
    name: `${focusIdx2}.data.value.links.[${index2}].content`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(ColorPickerField, {
    label: "Color",
    name: `${focusIdx2}.data.value.links.[${index2}].color`,
    alignment: "center"
  }))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontFamily, {
    name: `${focusIdx2}.data.value.links.[${index2}].font-family`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Font size",
    quickchange: true,
    name: `${focusIdx2}.data.value.links.[${index2}].font-size`
  }))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(LineHeight, {
    name: `${focusIdx2}.data.value.links.[${index2}].line-height`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(LetterSpacing, {
    name: `${focusIdx2}.data.value.links.[${index2}].letter-spacing`
  }))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextDecoration, {
    name: `${focusIdx2}.data.value.links.[${index2}].text-decoration`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontWeight, {
    name: `${focusIdx2}.data.value.links.[${index2}].font-weight`
  }))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextTransform, {
    name: `${focusIdx2}.data.value.links.[${index2}].text-transform`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  })), /* @__PURE__ */ React__default.createElement(FontStyle, {
    name: `${focusIdx2}.data.value.links.[${index2}].font-style`
  }), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    prefix: /* @__PURE__ */ React__default.createElement(IconLink$1, null),
    label: /* @__PURE__ */ React__default.createElement("span", null, "Url"),
    name: `${focusIdx2}.data.value.links.[${index2}].href`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(SelectField, {
    style: { minWidth: 65 },
    label: "Target",
    name: `${focusIdx2}.data.value.links.[${index2}].target`,
    options: [
      {
        value: "_blank",
        label: "_blank"
      },
      {
        value: "_self",
        label: "_self"
      }
    ]
  }))), /* @__PURE__ */ React__default.createElement(NavbarLinkPadding, {
    key: index2,
    name: `${focusIdx2}.data.value.links.[${index2}].padding`
  }), /* @__PURE__ */ React__default.createElement("div", null)));
}
const options = [
  {
    value: "vertical",
    label: "vertical"
  },
  {
    value: "horizontal",
    label: "horizontal"
  }
];
function Social() {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const { focusBlock: focusBlock2 } = useBlock();
  const value = focusBlock2 == null ? void 0 : focusBlock2.data.value;
  if (!value)
    return null;
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, {
    style: { padding: 0 }
  }, /* @__PURE__ */ React__default.createElement(CollapseWrapper, {
    defaultActiveKey: ["0", "1", "2", "3"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "1",
    header: "Setting"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(RadioGroupField, {
    label: "Mode",
    name: `${focusIdx2}.attributes.mode`,
    options
  }), /* @__PURE__ */ React__default.createElement(Align, null))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "3",
    header: "Typography"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontFamily, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontSize$1, null))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontWeight, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(LineHeight, null))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(Color, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(ContainerBackgroundColor, {
    title: "Background color"
  }))), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextDecoration, null)), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(FontStyle, null))))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "2",
    header: "Social item",
    contentStyle: { padding: 10 }
  }, /* @__PURE__ */ React__default.createElement(EditGridTabField, {
    tabPosition: "top",
    name: `${focusIdx2}.data.value.elements`,
    label: "",
    labelHidden: true,
    renderItem: (item2, index2) => /* @__PURE__ */ React__default.createElement(SocialElement, {
      item: item2,
      index: index2
    })
  })), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "0",
    header: "Dimension"
  }, /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical",
    size: "large"
  }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(InputWithUnitField, {
    label: "Icon width",
    name: `${focusIdx2}.attributes.icon-size`
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Border radius",
    name: `${focusIdx2}.attributes.border-radius`
  }))), /* @__PURE__ */ React__default.createElement(Padding, null), /* @__PURE__ */ React__default.createElement(Padding, {
    attributeName: "inner-padding",
    title: "Icon padding"
  }), /* @__PURE__ */ React__default.createElement(Padding, {
    attributeName: "text-padding",
    title: "Text padding"
  }))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "4",
    header: "Extra"
  }, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 24
  }, /* @__PURE__ */ React__default.createElement(ClassName, null)))));
}
function SocialElement({
  index: index2
}) {
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const { onUploadImage, socialIcons } = useEditorProps();
  const autoCompleteOptions = useMemo(() => {
    if (!socialIcons)
      return void 0;
    return socialIcons.map((icon) => {
      return {
        label: icon.content,
        value: icon.image
      };
    });
  }, [socialIcons]);
  return /* @__PURE__ */ React__default.createElement(Space$1, {
    direction: "vertical"
  }, /* @__PURE__ */ React__default.createElement(ImageUploaderField, {
    label: "Image",
    autoCompleteOptions,
    labelHidden: true,
    name: `${focusIdx2}.data.value.elements.[${index2}].src`,
    uploadHandler: onUploadImage
  }), /* @__PURE__ */ React__default.createElement(Grid.Row, null, /* @__PURE__ */ React__default.createElement(Grid.Col, {
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Content",
    name: `${focusIdx2}.data.value.elements.[${index2}].content`,
    quickchange: true
  })), /* @__PURE__ */ React__default.createElement(Grid.Col, {
    offset: 1,
    span: 11
  }, /* @__PURE__ */ React__default.createElement(TextField, {
    prefix: /* @__PURE__ */ React__default.createElement(IconLink$1, null),
    label: "Link",
    name: `${focusIdx2}.data.value.elements.[${index2}].href`
  }))));
}
function Table() {
  const [visible, setVisible] = useState(false);
  return /* @__PURE__ */ React__default.createElement(AttributesPanelWrapper, {
    extra: /* @__PURE__ */ React__default.createElement(Tooltip$1, {
      content: "Edit"
    }, /* @__PURE__ */ React__default.createElement(Button$4, {
      onClick: () => setVisible(true),
      icon: /* @__PURE__ */ React__default.createElement(IconFont, {
        iconName: "icon-html"
      })
    }))
  }, /* @__PURE__ */ React__default.createElement(CollapseWrapper, {
    defaultActiveKey: ["-1", "0", "1", "2", "3"]
  }, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "1",
    header: "Dimension"
  }, /* @__PURE__ */ React__default.createElement(Stack$4, null, /* @__PURE__ */ React__default.createElement(Width, null), /* @__PURE__ */ React__default.createElement(Stack$4.Item, null)), /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, /* @__PURE__ */ React__default.createElement(Padding, null))), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "2",
    header: "Decoration"
  }, /* @__PURE__ */ React__default.createElement(Color, null), /* @__PURE__ */ React__default.createElement(ContainerBackgroundColor, null), /* @__PURE__ */ React__default.createElement(Border, null)), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "2",
    header: "Typography"
  }, /* @__PURE__ */ React__default.createElement(Stack$4, null, /* @__PURE__ */ React__default.createElement(FontFamily, null), /* @__PURE__ */ React__default.createElement(FontSize$1, null)), /* @__PURE__ */ React__default.createElement(FontStyle, null), /* @__PURE__ */ React__default.createElement(TextAlign, null))), /* @__PURE__ */ React__default.createElement(HtmlEditor, {
    visible,
    setVisible
  }));
}
const blocks = {
  [BasicType.PAGE]: Page,
  [BasicType.SECTION]: Section,
  [BasicType.COLUMN]: Column,
  [BasicType.TEXT]: Text,
  [BasicType.IMAGE]: Image$1,
  [BasicType.GROUP]: Group,
  [BasicType.BUTTON]: Button,
  [BasicType.DIVIDER]: Divider,
  [BasicType.WRAPPER]: Wrapper,
  [BasicType.SPACER]: Spacer,
  [BasicType.RAW]: Raw,
  [BasicType.ACCORDION]: Accordion,
  [BasicType.ACCORDION_ELEMENT]: AccordionElement,
  [BasicType.ACCORDION_TITLE]: AccordionTitle,
  [BasicType.ACCORDION_TEXT]: AccordionText,
  [BasicType.CAROUSEL]: Carousel,
  [BasicType.HERO]: Hero,
  [BasicType.NAVBAR]: Navbar,
  [BasicType.SOCIAL]: Social,
  [BasicType.TABLE]: Table,
  [AdvancedType.TEXT]: Text,
  [AdvancedType.IMAGE]: Image$1,
  [AdvancedType.BUTTON]: Button,
  [AdvancedType.DIVIDER]: Divider,
  [AdvancedType.SPACER]: Spacer,
  [AdvancedType.ACCORDION]: Accordion,
  [AdvancedType.CAROUSEL]: Carousel,
  [AdvancedType.NAVBAR]: Navbar,
  [AdvancedType.SOCIAL]: Social,
  [AdvancedType.HERO]: Hero,
  [AdvancedType.WRAPPER]: Wrapper,
  [AdvancedType.SECTION]: Section,
  [AdvancedType.GROUP]: Group,
  [AdvancedType.COLUMN]: Column
};
class BlockAttributeConfigurationManager {
  static add(componentMap) {
    Object.keys(componentMap).forEach((name2) => {
      this.map[name2] = componentMap[name2];
    });
  }
  static get(name2) {
    return this.map[name2];
  }
  static getMap() {
    return this.map;
  }
}
__publicField(BlockAttributeConfigurationManager, "map", __spreadValues({}, blocks));
const RICH_TEXT_TOOL_BAR = "Tools";
const SelectionRangeContext = React__default.createContext({
  selectionRange: null,
  setSelectionRange: () => {
  }
});
const SelectionRangeProvider = (props) => {
  const [selectionRange, setSelectionRange] = useState(null);
  useEffect(() => {
    const onSelectionChange = () => {
      try {
        const range2 = getShadowRoot().getSelection().getRangeAt(0);
        if (range2) {
          const toolbar = getShadowRoot().getElementById(RICH_TEXT_TOOL_BAR);
          if (toolbar && toolbar.contains(range2.commonAncestorContainer))
            return;
          setSelectionRange(range2);
        }
      } catch (error2) {
      }
    };
    document.addEventListener("selectionchange", onSelectionChange);
    return () => {
      document.removeEventListener("selectionchange", onSelectionChange);
    };
  }, []);
  const value = useMemo(() => {
    return {
      selectionRange,
      setSelectionRange
    };
  }, [selectionRange]);
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(SelectionRangeContext.Provider, {
      value
    }, props.children);
  }, [props.children, value]);
};
function AttributePanel() {
  const { values: values2, focusBlock: focusBlock2 } = useBlock();
  const { initialized } = useEditorContext();
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const Com = focusBlock2 && BlockAttributeConfigurationManager.get(focusBlock2.type);
  const shadowRoot = getShadowRoot();
  if (!initialized)
    return null;
  return /* @__PURE__ */ React__default.createElement(SelectionRangeProvider, null, /* @__PURE__ */ React__default.createElement(PresetColorsProvider, null, Com ? /* @__PURE__ */ React__default.createElement(Com, {
    key: focusIdx2
  }) : /* @__PURE__ */ React__default.createElement("div", {
    style: { marginTop: 200, padding: "0 50px" }
  }, /* @__PURE__ */ React__default.createElement(TextStyle, {
    size: "extraLarge"
  }, t("No matching components"))), /* @__PURE__ */ React__default.createElement("div", {
    style: { position: "absolute" }
  }, /* @__PURE__ */ React__default.createElement(RichTextField, {
    idx: focusIdx2
  })), shadowRoot && ReactDOM.createPortal(/* @__PURE__ */ React__default.createElement("style", null, `
              .email-block [contentEditable="true"],
              .email-block [contentEditable="true"] * {
                outline: none;
                cursor: text;
              }
              `), shadowRoot)));
}
function MergeTags(props) {
  const { execCommand } = props;
  const [visible, setVisible] = React__default.useState(false);
  const onChange = useCallback((val) => {
    execCommand("insertHTML", val);
    setVisible(false);
  }, [execCommand]);
  const onVisibleChange = useCallback((v) => {
    setVisible(v);
  }, []);
  return /* @__PURE__ */ React__default.createElement(Popover$1, {
    trigger: "click",
    color: "#fff",
    position: "left",
    popupVisible: visible,
    onVisibleChange,
    style: { zIndex: 10 },
    content: /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(MergeTags$1, {
      value: "",
      onChange
    })),
    getPopupContainer: props.getPopupContainer
  }, /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    title: "Merge tag",
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-merge-tags"
    })
  }));
}
function useSelectionRange() {
  const { selectionRange, setSelectionRange } = useContext(SelectionRangeContext);
  const restoreRange = useCallback((range2) => {
    const selection = getShadowRoot().getSelection();
    selection.removeAllRanges();
    const newRange = document.createRange();
    newRange.setStart(range2.startContainer, range2.startOffset);
    newRange.setEnd(range2.endContainer, range2.endOffset);
    selection.addRange(newRange);
  }, []);
  const setRangeByElement = useCallback((element) => {
    const selection = getShadowRoot().getSelection();
    selection.removeAllRanges();
    const newRange = document.createRange();
    newRange.selectNode(element);
    setSelectionRange(newRange);
    selection.addRange(newRange);
  }, [setSelectionRange]);
  return {
    selectionRange,
    setSelectionRange,
    restoreRange,
    setRangeByElement
  };
}
function IconBgColor({ selectionRange, execCommand, getPopoverMountNode }) {
  const color2 = useMemo(() => {
    if (!selectionRange)
      return void 0;
    if (selectionRange.commonAncestorContainer instanceof HTMLElement) {
      return getComputedStyle(selectionRange.commonAncestorContainer).backgroundColor;
    } else if (selectionRange.commonAncestorContainer.parentNode instanceof HTMLElement) {
      return getComputedStyle(selectionRange.commonAncestorContainer.parentNode).backgroundColor;
    }
    return void 0;
  }, [selectionRange]);
  return /* @__PURE__ */ React__default.createElement(ColorPicker, {
    label: "",
    showInput: false,
    position: "tl",
    onChange: (color22) => execCommand("hiliteColor", color22),
    getPopupContainer: getPopoverMountNode
  }, /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    icon: /* @__PURE__ */ React__default.createElement("div", {
      style: {
        position: "relative"
      }
    }, /* @__PURE__ */ React__default.createElement(IconFont, {
      size: 12,
      iconName: "icon-bg-color",
      style: { position: "relative", top: "-1px" }
    }), /* @__PURE__ */ React__default.createElement("div", {
      style: { borderBottom: `2px solid ${color2}`, position: "absolute", width: "130%", left: "-15%", top: 16 }
    })),
    title: "Background color"
  }));
}
function IconFontColor({ selectionRange, execCommand, getPopoverMountNode }) {
  const color2 = useMemo(() => {
    if (!selectionRange)
      return void 0;
    if (selectionRange.commonAncestorContainer instanceof HTMLElement) {
      return getComputedStyle(selectionRange.commonAncestorContainer).color;
    } else if (selectionRange.commonAncestorContainer.parentNode instanceof HTMLElement) {
      return getComputedStyle(selectionRange.commonAncestorContainer.parentNode).color;
    }
    return void 0;
  }, [selectionRange]);
  return /* @__PURE__ */ React__default.createElement(ColorPicker, {
    label: "",
    position: "tl",
    onChange: (color22) => execCommand("foreColor", color22),
    getPopupContainer: getPopoverMountNode,
    showInput: false
  }, /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    icon: /* @__PURE__ */ React__default.createElement("div", {
      style: {
        position: "relative"
      }
    }, /* @__PURE__ */ React__default.createElement(IconFont, {
      size: 12,
      iconName: "icon-font-color",
      style: { position: "relative", top: "-1px" }
    }), /* @__PURE__ */ React__default.createElement("div", {
      style: { borderBottom: `2px solid ${color2}`, position: "absolute", width: "130%", left: "-15%", top: 16 }
    })),
    title: "Text color"
  }));
}
function BasicTools() {
  const { copyBlock, removeBlock } = useBlock();
  const { focusIdx: focusIdx2, setFocusIdx } = useFocusIdx();
  const { modal, setModalVisible } = useAddToCollection();
  const { onAddCollection } = useEditorProps();
  const handleAddToCollection = () => {
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
    setModalVisible(true);
  };
  const handleCopy = (ev) => {
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
    copyBlock(focusIdx2);
  };
  const handleDelete = () => {
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
    removeBlock(focusIdx2);
  };
  const handleSelectParent = () => {
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
    setFocusIdx(getParentIdx(focusIdx2));
  };
  return /* @__PURE__ */ React__default.createElement("div", {
    style: { marginRight: 40 }
  }, /* @__PURE__ */ React__default.createElement("span", {
    style: { position: "relative", marginRight: 10, color: "#fff", fontFamily: "-apple-system, BlinkMacSystemFont, San Francisco, Segoe UI" }
  }, "Text"), /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    onClick: handleSelectParent,
    title: "Select parent block",
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-back-parent"
    })
  }), /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    onClick: handleCopy,
    title: "Copy",
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-copy"
    })
  }), onAddCollection && /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    onClick: handleAddToCollection,
    title: "Add to collection",
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-collection"
    })
  }), /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    onClick: handleDelete,
    title: "Delete",
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-delete"
    })
  }), modal);
}
function getAnchorElement(node) {
  if (!node)
    return null;
  if (node instanceof HTMLAnchorElement) {
    return node;
  }
  if (node instanceof Element && node.classList.contains(EMAIL_BLOCK_CLASS_NAME))
    return null;
  return getAnchorElement(node.parentNode);
}
function getLinkNode(currentRange) {
  let linkNode = null;
  if (!currentRange)
    return null;
  linkNode = getAnchorElement(currentRange.commonAncestorContainer);
  return linkNode;
}
function Unlink(props) {
  const { onChange } = props;
  const linkNode = useMemo(() => {
    return getLinkNode(props.currentRange);
  }, [props.currentRange]);
  const onUnlink = useCallback(() => {
    if (linkNode == null ? void 0 : linkNode.parentNode) {
      linkNode == null ? void 0 : linkNode.replaceWith(...linkNode.childNodes);
      onChange();
    }
  }, [linkNode, onChange]);
  return /* @__PURE__ */ React__default.createElement(Tooltip$1, {
    color: "#fff",
    position: "tl",
    content: "Unlink"
  }, /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    title: "Unlink",
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-unlink"
    }),
    onClick: onUnlink
  }));
}
function getStrikeThroughNode(node) {
  if (!node)
    return null;
  if (node instanceof Element && node.classList.contains(EMAIL_BLOCK_CLASS_NAME))
    return null;
  if (node instanceof Element && node.tagName.toLocaleLowerCase() === "strike")
    return node;
  return getStrikeThroughNode(node.parentNode);
}
function StrikeThrough(props) {
  const { onChange } = props;
  const { setRangeByElement } = useSelectionRange();
  const node = useMemo(() => {
    var _a;
    return getStrikeThroughNode((_a = props.currentRange) == null ? void 0 : _a.commonAncestorContainer);
  }, [props.currentRange]);
  const onClick = useCallback(() => {
    if (node) {
      setRangeByElement(node);
    }
    onChange();
  }, [node, onChange, setRangeByElement]);
  return /* @__PURE__ */ React__default.createElement(Tooltip$1, {
    color: "#fff",
    position: "tl",
    content: "Strikethrough"
  }, /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    title: "Strikethrough",
    isActive: Boolean(node),
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-strikethrough"
    }),
    onClick
  }));
}
function getUnderlineNode(node) {
  if (!node)
    return null;
  if (node instanceof Element && node.classList.contains(EMAIL_BLOCK_CLASS_NAME))
    return null;
  if (node instanceof Element && node.tagName.toLocaleLowerCase() === "u")
    return node;
  return getUnderlineNode(node.parentNode);
}
function Underline(props) {
  const { onChange } = props;
  const { setRangeByElement } = useSelectionRange();
  const node = useMemo(() => {
    var _a;
    return getUnderlineNode((_a = props.currentRange) == null ? void 0 : _a.commonAncestorContainer);
  }, [props.currentRange]);
  const onClick = useCallback(() => {
    if (node) {
      setRangeByElement(node);
    }
    onChange();
  }, [node, onChange, setRangeByElement]);
  return /* @__PURE__ */ React__default.createElement(Tooltip$1, {
    color: "#fff",
    position: "tl",
    content: "Underline"
  }, /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    title: "Underline",
    isActive: Boolean(node),
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-underline"
    }),
    onClick
  }));
}
function getItalicNode(node) {
  if (!node)
    return null;
  if (node instanceof Element && node.classList.contains(EMAIL_BLOCK_CLASS_NAME))
    return null;
  if (node instanceof Element && node.tagName.toLocaleLowerCase() === "i")
    return node;
  return getItalicNode(node.parentNode);
}
function Italic(props) {
  const { onChange } = props;
  const { setRangeByElement } = useSelectionRange();
  const node = useMemo(() => {
    var _a;
    return getItalicNode((_a = props.currentRange) == null ? void 0 : _a.commonAncestorContainer);
  }, [props.currentRange]);
  const onClick = useCallback(() => {
    if (node) {
      setRangeByElement(node);
    }
    onChange();
  }, [node, onChange, setRangeByElement]);
  return /* @__PURE__ */ React__default.createElement(Tooltip$1, {
    color: "#fff",
    position: "tl",
    content: "Italic"
  }, /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    title: "Italic",
    isActive: Boolean(node),
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-italic"
    }),
    onClick
  }));
}
function getBoldNode(node) {
  if (!node)
    return null;
  if (node instanceof Element && node.classList.contains(EMAIL_BLOCK_CLASS_NAME))
    return null;
  if (node instanceof Element && node.tagName.toLocaleLowerCase() === "b")
    return node;
  return getBoldNode(node.parentNode);
}
function Bold(props) {
  const { onChange } = props;
  const { setRangeByElement } = useSelectionRange();
  const node = useMemo(() => {
    var _a;
    return getBoldNode((_a = props.currentRange) == null ? void 0 : _a.commonAncestorContainer);
  }, [props.currentRange]);
  const onClick = useCallback(() => {
    if (node) {
      setRangeByElement(node);
    }
    onChange();
  }, [node, onChange, setRangeByElement]);
  return /* @__PURE__ */ React__default.createElement(Tooltip$1, {
    color: "#fff",
    position: "tl",
    content: "Bold"
  }, /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    title: "Bold",
    isActive: Boolean(node),
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-bold"
    }),
    onClick
  }));
}
const list$8 = [
  {
    value: "1",
    label: "12px"
  },
  {
    value: "2",
    label: "13px"
  },
  {
    value: "3",
    label: "16px"
  },
  {
    value: "4",
    label: "18px"
  },
  {
    value: "5",
    label: "24px"
  },
  {
    value: "6",
    label: "32px"
  },
  {
    value: "7",
    label: "48px"
  }
];
function FontSize(props) {
  const { execCommand } = props;
  const [visible, setVisible] = React__default.useState(false);
  const onChange = useCallback((val) => {
    execCommand("fontSize", val);
    setVisible(false);
  }, [execCommand]);
  const onVisibleChange = useCallback((v) => {
    setVisible(v);
  }, []);
  return /* @__PURE__ */ React__default.createElement(Popover$1, {
    trigger: "click",
    color: "#fff",
    position: "left",
    className: "easy-email-extensions-Tools-Popover",
    popupVisible: visible,
    onVisibleChange,
    content: /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("style", null, styleText$1), /* @__PURE__ */ React__default.createElement("div", {
      style: {
        maxWidth: 150,
        maxHeight: 350,
        overflowY: "auto",
        overflowX: "hidden"
      }
    }, /* @__PURE__ */ React__default.createElement(Menu$1, {
      onClickMenuItem: onChange,
      selectedKeys: [],
      style: { border: "none", padding: 0 }
    }, list$8.map((item2) => /* @__PURE__ */ React__default.createElement(Menu$1.Item, {
      style: { lineHeight: "30px", height: 30 },
      key: item2.value
    }, item2.label))))),
    getPopupContainer: props.getPopupContainer
  }, /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    title: t("Font size"),
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-font-color"
    })
  }));
}
function Tools(props) {
  const { mergeTags: mergeTags2, enabledMergeTagsBadge } = useEditorProps();
  const { focusBlockNode } = useFocusBlockLayout();
  const { selectionRange, restoreRange, setRangeByElement } = useSelectionRange();
  const execCommand = useCallback((cmd, val) => {
    var _a;
    if (!selectionRange) {
      console.error("No selectionRange");
      return;
    }
    if (!(focusBlockNode == null ? void 0 : focusBlockNode.contains(selectionRange == null ? void 0 : selectionRange.commonAncestorContainer))) {
      console.error("Not commonAncestorContainer");
      return;
    }
    restoreRange(selectionRange);
    const uuid2 = (+new Date()).toString();
    if (cmd === "createLink") {
      const linkData = val;
      const target2 = linkData.blank ? "_blank" : "";
      let link2;
      if (linkData.linkNode) {
        link2 = linkData.linkNode;
      } else {
        document.execCommand(cmd, false, uuid2);
        link2 = getShadowRoot().querySelector(`a[href="${uuid2}"`);
      }
      if (target2) {
        link2.setAttribute("target", target2);
      }
      link2.style.color = "inherit";
      link2.style.textDecoration = linkData.underline ? "underline" : "none";
      link2.setAttribute("href", linkData.link);
    } else if (cmd === "insertHTML") {
      let newContent = val;
      if (enabledMergeTagsBadge) {
        newContent = MergeTagBadge.transform(val, uuid2);
      }
      document.execCommand(cmd, false, newContent);
      const insertMergeTagEle = getShadowRoot().getElementById(uuid2);
      if (insertMergeTagEle) {
        insertMergeTagEle.focus();
        setRangeByElement(insertMergeTagEle);
      }
    } else {
      document.execCommand(cmd, false, val);
    }
    const contenteditableElement = getShadowRoot().activeElement;
    if ((contenteditableElement == null ? void 0 : contenteditableElement.getAttribute("contenteditable")) === "true") {
      const html = ((_a = getShadowRoot().activeElement) == null ? void 0 : _a.innerHTML) || "";
      props.onChange(html);
    }
  }, [
    enabledMergeTagsBadge,
    focusBlockNode,
    props,
    restoreRange,
    selectionRange,
    setRangeByElement
  ]);
  const execCommandWithRange = useCallback((cmd, val) => {
    var _a;
    document.execCommand(cmd, false, val);
    const contenteditableElement = getShadowRoot().activeElement;
    if ((contenteditableElement == null ? void 0 : contenteditableElement.getAttribute("contenteditable")) === "true") {
      const html = ((_a = getShadowRoot().activeElement) == null ? void 0 : _a.innerHTML) || "";
      props.onChange(html);
    }
  }, [props.onChange]);
  const getPopoverMountNode = () => document.getElementById(FIXED_CONTAINER_ID);
  return /* @__PURE__ */ React__default.createElement("div", {
    id: RICH_TEXT_TOOL_BAR,
    style: { display: "flex", flexWrap: "nowrap" }
  }, /* @__PURE__ */ React__default.createElement("div", {
    style: {
      display: "flex",
      alignItems: "center"
    }
  }, /* @__PURE__ */ React__default.createElement(BasicTools, null), mergeTags2 && /* @__PURE__ */ React__default.createElement(MergeTags, {
    execCommand,
    getPopupContainer: getPopoverMountNode
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-extensions-divider"
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-extensions-divider"
  }), /* @__PURE__ */ React__default.createElement(FontFamily$1, {
    execCommand,
    getPopupContainer: getPopoverMountNode
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-extensions-divider"
  }), /* @__PURE__ */ React__default.createElement(FontSize, {
    execCommand,
    getPopupContainer: getPopoverMountNode
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-extensions-divider"
  }), /* @__PURE__ */ React__default.createElement(Bold, {
    currentRange: selectionRange,
    onChange: () => execCommandWithRange("bold")
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-extensions-divider"
  }), /* @__PURE__ */ React__default.createElement(Italic, {
    currentRange: selectionRange,
    onChange: () => execCommandWithRange("italic")
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-extensions-divider"
  }), /* @__PURE__ */ React__default.createElement(StrikeThrough, {
    currentRange: selectionRange,
    onChange: () => execCommandWithRange("strikeThrough")
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-extensions-divider"
  }), /* @__PURE__ */ React__default.createElement(Underline, {
    currentRange: selectionRange,
    onChange: () => execCommandWithRange("underline")
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-extensions-divider"
  }), /* @__PURE__ */ React__default.createElement(IconFontColor, {
    selectionRange,
    execCommand,
    getPopoverMountNode
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-extensions-divider"
  }), /* @__PURE__ */ React__default.createElement(IconBgColor, {
    selectionRange,
    execCommand,
    getPopoverMountNode
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-extensions-divider"
  }), /* @__PURE__ */ React__default.createElement(Link$1, {
    currentRange: selectionRange,
    onChange: (values2) => execCommand("createLink", values2),
    getPopupContainer: getPopoverMountNode
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-extensions-divider"
  }), /* @__PURE__ */ React__default.createElement(Unlink, {
    currentRange: selectionRange,
    onChange: () => execCommand("")
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-extensions-divider"
  }), /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    onClick: () => execCommand("justifyLeft"),
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-align-left"
    }),
    title: "Align left"
  }), /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    onClick: () => execCommand("justifyCenter"),
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-align-center"
    }),
    title: "Align center"
  }), /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    onClick: () => execCommand("justifyRight"),
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-align-right"
    }),
    title: "Align right"
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-extensions-divider"
  }), /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    onClick: () => execCommand("insertOrderedList"),
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-list-ol"
    }),
    title: "Orderlist"
  }), /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    onClick: () => execCommand("insertUnorderedList"),
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-list-ul"
    }),
    title: "Unorderlist"
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-extensions-divider"
  }), /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    onClick: () => execCommand("insertHorizontalRule"),
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-line"
    }),
    title: "Line"
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-extensions-divider"
  }), /* @__PURE__ */ React__default.createElement(ToolItem$1, {
    onClick: () => execCommand("removeFormat"),
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-close"
    }),
    title: "Remove format"
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-extensions-divider"
  })));
}
var styleText = ".easy-email-extensions-emailToolItem{display:inline-flex;align-items:center;justify-content:center;position:relative;outline:none;font-weight:400;appearance:none;cursor:pointer!important;white-space:nowrap;transition:all .1s linear;box-sizing:border-box;border-radius:2px;border:none;background-color:transparent;color:#fff;width:28px;height:27px}.easy-email-extensions-emailToolItem:hover,.easy-email-extensions-emailToolItem-active{background-color:#f2f3f5;color:#4e5969}.easy-email-extensions-divider{position:relative;display:inline-flex;width:1px;height:16px;background-color:#808080e6}\n";
function RichTextToolBar(props) {
  const { initialized } = useEditorContext();
  const root2 = initialized && getPluginElement();
  if (!root2)
    return null;
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, createPortal(/* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("style", {
    dangerouslySetInnerHTML: { __html: styleText }
  }), /* @__PURE__ */ React__default.createElement("div", {
    id: RICH_TEXT_BAR_ID,
    style: {
      transform: "translate(0,0)",
      padding: "4px 8px",
      boxSizing: "border-box",
      position: "absolute",
      left: 8,
      top: 0,
      zIndex: 100,
      width: "calc(100% - 16px)"
    }
  }, /* @__PURE__ */ React__default.createElement("div", {
    style: {
      position: "absolute",
      backgroundColor: "#41444d",
      height: "100%",
      width: "100%",
      left: 0,
      top: 0
    }
  }), /* @__PURE__ */ React__default.createElement(Tools, {
    onChange: props.onChange
  }))), root2));
}
const RichTextField = (props) => {
  const [contentEditableName, setContentEditableName] = useState("");
  const [contentEditableType, setContentEditableType] = useState(CONTENT_EDITABLE_CLASS_NAME);
  useEffect(() => {
    const onClick = (e) => {
      var _a;
      if ((_a = getEditorRoot()) == null ? void 0 : _a.contains(e.target)) {
        return;
      }
      const fixedContainer = document.getElementById(FIXED_CONTAINER_ID);
      if (fixedContainer == null ? void 0 : fixedContainer.contains(e.target)) {
        return;
      }
      setContentEditableName("");
    };
    window.addEventListener("click", onClick);
    return () => {
      window.removeEventListener("click", onClick);
    };
  }, []);
  useEffect(() => {
    const root2 = getShadowRoot();
    if (!root2)
      return;
    const onClick = (e) => {
      const target2 = e.target;
      const fixedContainer = document.getElementById(FIXED_CONTAINER_ID);
      const richTextBar = root2.getElementById(RICH_TEXT_BAR_ID);
      if ((fixedContainer == null ? void 0 : fixedContainer.contains(target2)) || (richTextBar == null ? void 0 : richTextBar.contains(target2))) {
        return;
      }
      const activeElement = getShadowRoot().activeElement;
      if (!activeElement) {
        setContentEditableName("");
      } else {
        const idxName = activeElement.getAttribute(DATA_CONTENT_EDITABLE_IDX);
        const type = activeElement.getAttribute(DATA_CONTENT_EDITABLE_TYPE);
        setContentEditableType(type);
        if (idxName) {
          setContentEditableName(idxName);
        } else {
          setContentEditableName("");
        }
      }
    };
    root2.addEventListener("click", onClick);
    return () => {
      root2.removeEventListener("click", onClick);
    };
  }, []);
  if (!contentEditableName)
    return null;
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(Field, {
    name: contentEditableName,
    parse: (v) => v
  }, ({ input }) => /* @__PURE__ */ React__default.createElement(FieldWrapper, __spreadProps(__spreadValues({}, props), {
    contentEditableType,
    input
  }))));
};
function FieldWrapper(props) {
  const _a = props, { input, contentEditableType } = _a, rest = __objRest(_a, ["input", "contentEditableType"]);
  const { mergeTagGenerate, enabledMergeTagsBadge } = useEditorProps();
  const debounceCallbackChange = useCallback(lodash.exports.debounce((val) => {
    if (enabledMergeTagsBadge) {
      input.onChange(MergeTagBadge.revert(val, mergeTagGenerate));
    } else {
      input.onChange(val);
    }
    input.onBlur();
  }, 200), [input]);
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, contentEditableType === ContentEditableType.RichText && /* @__PURE__ */ React__default.createElement(RichTextToolBar, {
    onChange: debounceCallbackChange
  }), /* @__PURE__ */ React__default.createElement(InlineText, __spreadProps(__spreadValues({}, rest), {
    onChange: debounceCallbackChange
  })), ";");
}
const TextField = enhancer(Input, (value) => value);
const InputWithUnitField = enhancer(InputWithUnit, (value) => value);
const SearchField = enhancer(Input$5.Search, (val) => val);
const TextAreaField = enhancer(Input$5.TextArea, (val) => val);
const NumberField = enhancer(InputNumber$1, (e) => e);
const SliderField = enhancer(Slider$1, (e) => e);
const ColorPickerField = enhancer(ColorPicker, (e) => e);
const UploadField = enhancer(UploadField$1, (val) => val);
const ImageUploaderField = enhancer(ImageUploader, (url) => url);
const SelectField = enhancer(Select, (e) => e);
const TreeSelectField = enhancer(TreeSelect$1, (e) => e);
const AutoCompleteField = enhancer(AutoComplete, (e) => e);
const RadioGroupField = enhancer(RadioGroup, (value) => value);
const SwitchField = enhancer(Switch$1, (e) => e);
const DatePickerField = enhancer(DatePicker$1, (date) => date);
const CheckboxField = enhancer(CheckBoxGroup, (e) => e);
const EditTabField = enhancer(EditTab, (e) => e);
const EditGridTabField = enhancer(EditGridTab, (e) => e);
const InlineTextField = enhancer(InlineText, (value) => value);
const AddToCollection = ({ visible, setVisible }) => {
  const { focusBlock: focusBlockData } = useBlock();
  const { onAddCollection, onUploadImage } = useEditorProps();
  const onSubmit = (values2) => {
    if (!values2.label)
      return;
    const uuid2 = uuid_1.v4();
    onAddCollection == null ? void 0 : onAddCollection({
      label: values2.label,
      helpText: values2.helpText,
      data: focusBlockData,
      thumbnail: values2.thumbnail,
      id: uuid2
    });
    setVisible(false);
  };
  return /* @__PURE__ */ React__default.createElement(Form$3, {
    initialValues: { label: "", helpText: "", thumbnail: "" },
    onSubmit
  }, ({ handleSubmit }) => /* @__PURE__ */ React__default.createElement(Modal$1, {
    maskClosable: false,
    style: { zIndex: 2e3 },
    visible,
    title: "Add to collection",
    onOk: () => handleSubmit(),
    onCancel: () => setVisible(false)
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4.Item, null), /* @__PURE__ */ React__default.createElement(TextField, {
    label: "Title",
    name: "label",
    validate: (val) => {
      if (!val)
        return "Title required!";
      return void 0;
    }
  }), /* @__PURE__ */ React__default.createElement(TextAreaField, {
    label: "Description",
    name: "helpText"
  }), /* @__PURE__ */ React__default.createElement(ImageUploaderField, {
    label: "Thumbnail",
    name: "thumbnail",
    uploadHandler: onUploadImage,
    validate: (val) => {
      if (!val)
        return "Thumbnail required!";
      return void 0;
    }
  }))));
};
function useAddToCollection() {
  const [modalVisible, setModalVisible] = useState(false);
  const modal = useMemo(() => /* @__PURE__ */ React__default.createElement(AddToCollection, {
    visible: modalVisible,
    setVisible: setModalVisible
  }), [modalVisible]);
  return {
    modal,
    modalVisible,
    setModalVisible
  };
}
function ContextMenu({
  moveBlock,
  copyBlock,
  removeBlock,
  contextMenuData,
  onClose
}) {
  const { blockData, left, top } = contextMenuData;
  const idx = blockData.id;
  const { modal, modalVisible, setModalVisible } = useAddToCollection();
  const props = useEditorProps();
  const ref = useRef(null);
  const handleMoveUp = () => {
    moveBlock(idx, getSiblingIdx(idx, -1));
    scrollBlockEleIntoView({
      idx: getSiblingIdx(idx, -1)
    });
    onClose();
  };
  const handleMoveDown = () => {
    moveBlock(idx, getSiblingIdx(idx, 1));
    scrollBlockEleIntoView({
      idx: getSiblingIdx(idx, 1)
    });
    onClose();
  };
  const handleCopy = (ev) => {
    copyBlock(idx);
    scrollBlockEleIntoView({
      idx: getSiblingIdx(idx, 1)
    });
    onClose();
  };
  const handleAddToCollection = () => {
    setModalVisible(true);
  };
  const handleDelete = () => {
    removeBlock(idx);
    onClose();
  };
  const isFirst = getIndexByIdx(idx) === 0;
  return /* @__PURE__ */ React__default.createElement("div", {
    ref,
    style: { visibility: modalVisible ? "hidden" : void 0 }
  }, /* @__PURE__ */ React__default.createElement("div", {
    style: {
      left,
      top
    },
    className: styles$9.wrap,
    onClick: (e) => e.stopPropagation()
  }, !isFirst && /* @__PURE__ */ React__default.createElement("div", {
    className: styles$9.listItem,
    onClick: handleMoveUp
  }, /* @__PURE__ */ React__default.createElement(IconFont, {
    iconName: "icon-top",
    style: { marginRight: 10 }
  }), " ", /* @__PURE__ */ React__default.createElement(TextStyle, null, "Move up")), /* @__PURE__ */ React__default.createElement("div", {
    className: styles$9.listItem,
    onClick: handleMoveDown
  }, /* @__PURE__ */ React__default.createElement(IconFont, {
    iconName: "icon-bottom",
    style: { marginRight: 10 }
  }), " ", /* @__PURE__ */ React__default.createElement(TextStyle, null, "Move down")), /* @__PURE__ */ React__default.createElement("div", {
    className: styles$9.listItem,
    onClick: handleCopy
  }, /* @__PURE__ */ React__default.createElement(IconFont, {
    iconName: "icon-copy",
    style: { marginRight: 10 }
  }), " ", /* @__PURE__ */ React__default.createElement(TextStyle, null, "Copy")), props.onAddCollection && /* @__PURE__ */ React__default.createElement("div", {
    className: styles$9.listItem,
    onClick: handleAddToCollection
  }, /* @__PURE__ */ React__default.createElement(IconFont, {
    iconName: "icon-start",
    style: { marginRight: 10 }
  }), " ", /* @__PURE__ */ React__default.createElement(TextStyle, null, "Add to collection")), /* @__PURE__ */ React__default.createElement("div", {
    className: styles$9.listItem,
    onClick: handleDelete
  }, /* @__PURE__ */ React__default.createElement(IconFont, {
    iconName: "icon-delete",
    style: { marginRight: 10 }
  }), " ", /* @__PURE__ */ React__default.createElement(TextStyle, null, "Delete"))), /* @__PURE__ */ React__default.createElement("div", {
    className: styles$9.contextmenuMark,
    onClick: onClose,
    onContextMenu: (e) => {
      e.preventDefault();
      onClose(e);
    }
  }), modal);
}
function useAvatarWrapperDrop() {
  const [blockLayerRef, setBlockLayerRef] = useState(null);
  const { setHoverIdx, setDirection } = useHoverIdx();
  const { dataTransfer, setDataTransfer } = useDataTransfer();
  const {
    formState: { values: values2 }
  } = useEditorContext();
  const valuesRef = useRefState(values2);
  const dataTransferRef = useRefState(dataTransfer);
  function isKeyObject(o) {
    return o.key !== void 0;
  }
  const removeHightLightClassName = useCallback(() => {
    if (!blockLayerRef)
      return;
    blockLayerRef.querySelectorAll(".arco-tree-node-title-gap-top, .arco-tree-node-title-gap-bottom, .arco-tree-node-title-highlight").forEach((item2) => {
      item2.classList.remove("arco-tree-node-title-gap-top", "arco-tree-node-title-gap-bottom", "arco-tree-node-title-highlight");
    });
  }, [blockLayerRef]);
  const allowDrop = useCallback((params) => {
    const { dragNode, dropNode, dropPosition } = params;
    let dragType;
    if (isKeyObject(dragNode)) {
      const blockData = lodash.exports.get(valuesRef.current, dragNode.key);
      if (!blockData)
        return false;
      dragType = blockData.type;
    } else {
      dragType = dragNode.type;
    }
    const dragBlock = BlockManager.getBlockByType(dragType);
    if (!dragBlock)
      return false;
    if (dropPosition === 0) {
      if (BlockManager.getAutoCompletePath(dragBlock.type, dropNode.dataRef.type) && dropNode.dataRef.children.length === 0) {
        return {
          position: 0,
          key: dropNode.key
        };
      } else if (dropNode.parent && dragBlock.validParentType.includes(dropNode.parent.type)) {
        return {
          position: -1,
          key: dropNode.key
        };
      }
    } else {
      if (dropNode.parent && dragBlock.validParentType.includes(dropNode.parent.type)) {
        return {
          position: dropPosition,
          key: dropNode.key
        };
      }
    }
    setDirection("");
    setHoverIdx("");
    return false;
  }, [setDirection, setHoverIdx, valuesRef]);
  useEffect(() => {
    if (blockLayerRef) {
      const onDragOver = lodash.exports.debounce((ev) => {
        var _a, _b, _c, _d;
        if (!dataTransferRef.current)
          return;
        const blockNode = getBlockNodeByChildEle(ev.target);
        if (!blockNode || !ev.target)
          return;
        const directionPosition = getDirectionPosition(ev, 5);
        const treeNodeEle = (_b = (_a = blockNode.parentNode) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.parentNode;
        if (!treeNodeEle)
          return;
        removeHightLightClassName();
        const dropIdx = getNodeIdxFromClassName(blockNode.classList);
        if (!dropIdx)
          return;
        const dropParentIdx = getParentIdx(dropIdx);
        const dropBlockData = lodash.exports.get(valuesRef.current, dropIdx);
        const dropParentBlockData = dropParentIdx ? lodash.exports.get(valuesRef.current, dropParentIdx) : null;
        let dropPosition = 0;
        if (directionPosition.vertical.direction === "top" && directionPosition.vertical.isEdge) {
          dropPosition = -1;
        } else if (directionPosition.vertical.direction === "bottom" && directionPosition.vertical.isEdge) {
          dropPosition = 1;
        }
        const dropResult = allowDrop({
          dragNode: {
            type: dataTransferRef.current.type
          },
          dropNode: {
            dataRef: dropBlockData,
            key: dropIdx,
            parent: dropParentBlockData
          },
          dropPosition
        });
        if (!dropResult)
          return;
        const node = (_d = (_c = document.querySelector(`[data-tree-idx="${dropResult.key}"]`)) == null ? void 0 : _c.parentNode) == null ? void 0 : _d.parentNode;
        if (node instanceof HTMLElement) {
          removeHightLightClassName();
          node.classList.add("arco-tree-node-title-gap-bottom");
        }
        setDirection(getDirectionFormDropPosition(dropResult.position));
        setHoverIdx(dropResult.key);
        if (dropResult.position === -1) {
          treeNodeEle.classList.add("arco-tree-node-title-gap-top");
          setDataTransfer((dataTransfer2) => {
            return __spreadProps(__spreadValues({}, dataTransfer2), {
              parentIdx: dropParentIdx,
              positionIndex: getIndexByIdx(dropIdx)
            });
          });
        } else if (dropResult.position === 1) {
          setDataTransfer((dataTransfer2) => {
            return __spreadProps(__spreadValues({}, dataTransfer2), {
              parentIdx: dropParentIdx,
              positionIndex: getIndexByIdx(dropIdx) + 1
            });
          });
          treeNodeEle.classList.add("arco-tree-node-title-gap-bottom");
        } else {
          treeNodeEle.classList.add("arco-tree-node-title-highlight");
          setDataTransfer((dataTransfer2) => {
            return __spreadProps(__spreadValues({}, dataTransfer2), {
              parentIdx: dropIdx,
              positionIndex: 0
            });
          });
        }
      });
      const onDragend = (ev) => {
        removeHightLightClassName();
      };
      const onDrop = (ev) => {
        setTimeout(() => {
          removeHightLightClassName();
        }, 0);
      };
      blockLayerRef.addEventListener("dragover", onDragOver);
      blockLayerRef.addEventListener("drop", onDrop);
      blockLayerRef.addEventListener("dragleave", onDragend);
      return () => {
        blockLayerRef.removeEventListener("dragover", onDragOver);
        blockLayerRef.removeEventListener("drop", onDrop);
        blockLayerRef.removeEventListener("dragleave", onDragend);
      };
    }
  }, [
    blockLayerRef,
    dataTransferRef,
    valuesRef,
    removeHightLightClassName,
    allowDrop,
    setDirection,
    setHoverIdx,
    setDataTransfer
  ]);
  return {
    setBlockLayerRef,
    blockLayerRef,
    allowDrop,
    removeHightLightClassName
  };
}
function getDirectionFormDropPosition(position) {
  if (position === -1)
    return "top";
  if (position === 1)
    return "bottom";
  return "";
}
const iconsMap = {
  [BasicType.TEXT]: "icon-text",
  [BasicType.SECTION]: "icon-section",
  [BasicType.COLUMN]: "icon-column",
  [BasicType.DIVIDER]: "icon-divider",
  [BasicType.IMAGE]: "icon-img",
  [BasicType.BUTTON]: "icon-button",
  [BasicType.GROUP]: "icon-group",
  [BasicType.PAGE]: "icon-page",
  [BasicType.WRAPPER]: "icon-wrapper",
  [BasicType.NAVBAR]: "icon-navbar",
  [BasicType.HERO]: "icon-hero",
  [BasicType.SPACER]: "icon-spacing",
  [BasicType.SOCIAL]: "icon-social",
  [BasicType.CAROUSEL]: "icon-carousel",
  [BasicType.ACCORDION]: "icon-accordion",
  [AdvancedType.TEXT]: "icon-text",
  [AdvancedType.DIVIDER]: "icon-divider",
  [AdvancedType.IMAGE]: "icon-img",
  [AdvancedType.BUTTON]: "icon-button",
  [AdvancedType.NAVBAR]: "icon-navbar",
  [AdvancedType.SPACER]: "icon-spacing",
  [AdvancedType.SOCIAL]: "icon-social",
  [AdvancedType.CAROUSEL]: "icon-carousel",
  [AdvancedType.ACCORDION]: "icon-accordion",
  [AdvancedType.WRAPPER]: "icon-wrapper",
  [AdvancedType.SECTION]: "icon-section",
  [AdvancedType.COLUMN]: "icon-column",
  [AdvancedType.GROUP]: "icon-group",
  [AdvancedType.HERO]: "icon-hero"
};
function getIconNameByBlockType(type) {
  return lodash.exports.get(iconsMap, type) || "icon-number";
}
const tempEle = document.createElement("div");
function getBlockTitle(blockData, isFromContent = true) {
  var _a;
  if (blockData.title)
    return blockData.title;
  if (isFromContent && (blockData.type === BasicType.TEXT || blockData.type === BasicType.BUTTON)) {
    tempEle.innerHTML = blockData.data.value.content;
    return tempEle.innerText;
  }
  const blockName = ((_a = BlockManager.getBlockByType(blockData.type)) == null ? void 0 : _a.name) || "";
  return blockName;
}
function BlockLayer(props) {
  const { pageData: pageData2 } = useEditorContext();
  const { renderTitle: propsRenderTitle } = props;
  const { focusIdx: focusIdx2, setFocusIdx } = useFocusIdx();
  const { setHoverIdx, setIsDragging, setDirection } = useHoverIdx();
  const { moveBlock, setValueByIdx: setValueByIdx2, copyBlock, removeBlock, values: values2 } = useBlock();
  const { setBlockLayerRef, allowDrop, removeHightLightClassName } = useAvatarWrapperDrop();
  const valueRef = useRefState(values2);
  const [contextMenuData, setContextMenuData] = useState(null);
  const onToggleVisible = useCallback(({ id }, e) => {
    e.stopPropagation();
    const blockData = lodash.exports.get(valueRef.current, id);
    if (blockData) {
      blockData.data.hidden = !Boolean(blockData.data.hidden);
      setValueByIdx2(id, blockData);
    }
  }, [setValueByIdx2, valueRef]);
  const renderTitle = useCallback((data) => {
    const isPage = data.type === BasicType.PAGE;
    const title2 = propsRenderTitle ? propsRenderTitle(data) : getBlockTitle(data);
    return /* @__PURE__ */ React__default.createElement("div", {
      "data-tree-idx": data.id,
      className: classnames(styles$a.title, !isPage && getNodeIdxClassName(data.id), !isPage && "email-block")
    }, /* @__PURE__ */ React__default.createElement(Space$1, {
      align: "center",
      size: "mini"
    }, /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: getIconNameByBlockType(data.type),
      style: { fontSize: 12, color: "#999" }
    }), /* @__PURE__ */ React__default.createElement("div", {
      title: lodash.exports.isString(title2) ? title2 : "",
      style: {
        overflow: "hidden",
        whiteSpace: "nowrap",
        width: "5em",
        textOverflow: "ellipsis"
      }
    }, /* @__PURE__ */ React__default.createElement(TextStyle, {
      size: "smallest"
    }, title2))), /* @__PURE__ */ React__default.createElement("div", {
      className: styles$a.eyeIcon
    }, /* @__PURE__ */ React__default.createElement(EyeIcon$1, {
      blockData: data,
      onToggleVisible
    })));
  }, [onToggleVisible, propsRenderTitle]);
  const treeData = useMemo(() => {
    const copyData = lodash.exports.cloneDeep(pageData2);
    const loop = (item2, id, parent2) => {
      item2.id = id;
      item2.parent = parent2;
      item2.children.map((child, index2) => loop(child, getChildIdx(id, index2), item2));
    };
    loop(copyData, getPageIdx(), null);
    return [copyData];
  }, [pageData2]);
  const onSelect = useCallback((selectedId) => {
    setFocusIdx(selectedId);
    setTimeout(() => {
      scrollBlockEleIntoView({ idx: selectedId });
    }, 50);
  }, [setFocusIdx]);
  const onContextMenu = useCallback((blockData, ev) => {
    ev.preventDefault();
    setContextMenuData({ blockData, left: ev.clientX, top: ev.clientY });
  }, []);
  const onCloseContextMenu = useCallback((ev) => {
    setContextMenuData(null);
  }, []);
  const onMouseEnter = useCallback((id) => {
    setHoverIdx(id);
  }, [setHoverIdx]);
  const onMouseLeave = useCallback(() => {
    setHoverIdx("");
  }, [setHoverIdx]);
  const onDragStart = useCallback(() => {
    setIsDragging(true);
  }, [setIsDragging]);
  const onDragEnd = useCallback(() => {
    setIsDragging(false);
  }, [setIsDragging]);
  const onDrop = useCallback((params) => {
    const { dragNode, dropNode, dropPosition } = params;
    const dragBlock = BlockManager.getBlockByType(dragNode.dataRef.type);
    if (!dragBlock)
      return false;
    const dropIndex = getIndexByIdx(dropNode.key);
    if (dropPosition === 0) {
      if (dragBlock.validParentType.includes(dropNode.dataRef.type) && dropNode.dataRef.children.length === 0) {
        moveBlock(dragNode.key, getChildIdx(dropNode.key, 0));
      } else if (dropNode.parent && dragBlock.validParentType.includes(dropNode.parent.type)) {
        moveBlock(dragNode.key, getChildIdx(dropNode.parentKey, dropIndex));
      }
    } else {
      moveBlock(dragNode.key, getChildIdx(dropNode.parentKey, dropPosition > 0 ? dropIndex + 1 : dropIndex));
    }
  }, [moveBlock]);
  const blockTreeAllowDrop = useCallback((() => {
    let lastDropResult = false;
    return (data) => {
      var _a, _b;
      const dropResult = allowDrop(data);
      if (lodash.exports.isEqual(lastDropResult, dropResult)) {
        return dropResult;
      }
      lastDropResult = dropResult;
      if (dropResult) {
        const node = (_b = (_a = document.querySelector(`[data-tree-idx="${dropResult.key}"]`)) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.parentNode;
        if (node instanceof HTMLElement) {
          removeHightLightClassName();
          node.classList.add("arco-tree-node-title-gap-bottom");
        }
        setDirection(getDirectionFormDropPosition(dropResult.position));
        setHoverIdx(dropResult.key);
      }
      return dropResult;
    };
  })(), [allowDrop, removeHightLightClassName, setDirection, setHoverIdx]);
  const selectedKeys = useMemo(() => {
    if (!focusIdx2)
      return [];
    return [focusIdx2];
  }, [focusIdx2]);
  const expandedKeys = useMemo(() => {
    if (!focusIdx2)
      return [];
    let currentIdx = getParentIdx(focusIdx2);
    const keys2 = [];
    while (currentIdx) {
      keys2.push(currentIdx);
      currentIdx = getParentIdx(currentIdx);
    }
    return keys2;
  }, [focusIdx2]);
  const hasFocus = Boolean(focusIdx2);
  if (!hasFocus)
    return null;
  return /* @__PURE__ */ React__default.createElement("div", __spreadValues({
    ref: setBlockLayerRef,
    id: "BlockLayerManager"
  }, {
    [DATA_ATTRIBUTE_DROP_CONTAINER]: "true"
  }), /* @__PURE__ */ React__default.createElement(BlockTree, {
    selectedKeys,
    expandedKeys,
    defaultExpandAll: true,
    treeData,
    renderTitle,
    allowDrop: blockTreeAllowDrop,
    onContextMenu,
    onDrop,
    onDragStart,
    onDragEnd,
    onSelect,
    onMouseEnter,
    onMouseLeave
  }), contextMenuData && /* @__PURE__ */ React__default.createElement(ContextMenu, {
    onClose: onCloseContextMenu,
    moveBlock,
    copyBlock,
    removeBlock,
    contextMenuData
  }));
}
const BlocksPanel$1 = "_BlocksPanel_15fho_1";
const blockItem$1 = "_blockItem_15fho_5";
const closeBtn = "_closeBtn_15fho_12";
var styles$6 = {
  BlocksPanel: BlocksPanel$1,
  blockItem: blockItem$1,
  closeBtn
};
class BlockMarketManager {
  static subscribe(fn) {
    return this.subscriptHandles.push(fn);
  }
  static unsubscribe(fn) {
    return this.subscriptHandles = this.subscriptHandles.filter((item2) => item2 === fn);
  }
  static notify() {
    this.subscriptHandles.forEach((fn) => fn(this.category));
  }
  static getCategory(name2) {
    return this.category.find((item2) => item2.name === name2);
  }
  static getCategories() {
    return this.category;
  }
  static addCategories(list2) {
    list2.forEach((item2) => {
      const index2 = this.category.findIndex((c) => c.name === item2.name);
      if (index2 !== -1) {
        this.category.splice(index2, 1);
      }
      this.category.push(item2);
    });
    this.notify();
  }
  static addCategory(name2, title2, blocks2) {
    const index2 = this.category.findIndex((item2) => item2.name === name2);
    if (index2 !== -1) {
      this.category.splice(index2, 1);
    }
    this.category.push({
      name: name2,
      title: title2,
      blocks: blocks2
    });
    this.notify();
  }
  static removeCategories(list2) {
    list2.forEach((item2) => {
      this.category = this.category.filter((c) => c.name !== item2.name);
    });
    this.notify();
  }
  static removeCategory(name2) {
    this.category = this.category.filter((item2) => item2.name !== name2);
    this.notify();
  }
}
__publicField(BlockMarketManager, "category", []);
__publicField(BlockMarketManager, "subscriptHandles", []);
const mask = "_mask_1a0xw_1";
const drag = "_drag_1a0xw_12";
var styles$5 = {
  mask,
  drag
};
const BlockMaskWrapper = (props) => {
  const ref = useRef(null);
  const dragRef = useRef(null);
  const { type, payload } = props;
  const onMouseDown = useCallback(() => {
    if (ref.current) {
      ref.current.classList.add(styles$5.drag);
    }
  }, []);
  const onMaskMouseDown = useCallback((ev) => {
    if (!dragRef.current || !dragRef.current.contains(ev.target)) {
      ev.preventDefault();
      ev.stopPropagation();
    }
  }, []);
  useEffect(() => {
    const mouseup = () => {
      if (ref.current) {
        ref.current.classList.remove(styles$5.drag);
      }
    };
    document.addEventListener("mouseup", mouseup);
    return () => {
      document.removeEventListener("mouseup", mouseup);
    };
  }, []);
  return /* @__PURE__ */ React__default.createElement("div", {
    style: { position: "relative" }
  }, props.children, /* @__PURE__ */ React__default.createElement("div", {
    className: styles$5.wrapper,
    style: {
      position: "absolute",
      height: "100%",
      transform: "translate(32px)",
      top: 0,
      right: 0,
      display: "flex",
      justifyContent: "flex-end"
    }
  }, /* @__PURE__ */ React__default.createElement(BlockAvatarWrapper, {
    type,
    payload
  }, /* @__PURE__ */ React__default.createElement("div", {
    ref,
    className: styles$5.mask,
    onMouseDown: onMaskMouseDown
  }, /* @__PURE__ */ React__default.createElement("div", {
    ref: dragRef,
    style: {
      position: "relative",
      zIndex: 10
    },
    onMouseDown
  }, /* @__PURE__ */ React__default.createElement(IconFont, {
    iconName: "icon-drag",
    style: { fontSize: 25, lineHeight: "25px", cursor: "grab" }
  }))))));
};
const fontList = [48, 32, 27, 24, 18, 16, 14];
function TextBlockItem() {
  return /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
    fill: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, fontList.map((item2, index2) => {
    return /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
      fill: true,
      key: index2
    }, /* @__PURE__ */ React__default.createElement(BlockMaskWrapper, {
      type: AdvancedType.TEXT,
      payload: {
        attributes: {
          "font-size": item2 + "px",
          padding: "0px 0px 0px 0px"
        },
        data: {
          value: {
            content: item2 + "px"
          }
        }
      }
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: { fontSize: item2, width: "100%", paddingLeft: 20 }
    }, item2, "px")));
  })));
}
const defaultImagesMap = {
  IMAGE_08: "https://easy-email-m-ryan.vercel.app/images/0046b247-3647-491f-afe1-cb0dd2a3c21c-ef84b752-f827-4546-89bf-6b63dfb67a4d.png",
  IMAGE_09: "https://easy-email-m-ryan.vercel.app/images/be34fb18-32ad-441c-84d8-3c0e9ba9f742-ad2ea5ff-5d0b-446b-bd7d-8e2ab5afdd16.png",
  IMAGE_10: "https://easy-email-m-ryan.vercel.app/images/6a1e6292-469e-452a-bbae-44e4b5ff7463-05e543b6-c951-44ce-ae27-ca1282c77f52.png",
  IMAGE_11: "https://easy-email-m-ryan.vercel.app/images/39b25f35-7ca9-4264-8502-41f430f89cf5-bcdc91c2-da3c-4fef-99c0-62b77c5a0f1f.png",
  IMAGE_12: "https://easy-email-m-ryan.vercel.app/images/eaa83007-f6f5-47d9-acbe-bb98065eaf20-b7c46090-73bd-4d4b-bd31-2368f7b4064f.png",
  IMAGE_13: "https://easy-email-m-ryan.vercel.app/images/9dec87bb-0a6d-429f-ac23-0ee636e6428d-219dee7e-85bb-4fba-9bf3-e98762e80409.png",
  IMAGE_14: "https://easy-email-m-ryan.vercel.app/images/d285da5e-b0c0-4895-84ac-42f83b4d603b-64042d20-be6a-45de-819c-8312f778a38d.png",
  IMAGE_15: "https://easy-email-m-ryan.vercel.app/images/f69f48af-5b15-40aa-91c4-81d601d1357b-083dc99d-02a6-40d9-ae28-0662bd078b5d.png",
  IMAGE_16: "https://easy-email-m-ryan.vercel.app/images/9cce6b16-5a98-4ddb-b1a1-6cec2cf56891-c3acb856-8ab8-4cfb-93f9-2a0747678b8b.png",
  IMAGE_17: "https://easy-email-m-ryan.vercel.app/images/d9795c1d-fa32-4adb-ab25-30b7cfe87936-df21314f-6f05-4550-80b3-9ab1107e8fbe.png",
  IMAGE_18: "https://easy-email-m-ryan.vercel.app/images/82f6f893-43ed-4f3d-9a17-4740bda844de-3318b36c-199d-46fe-96b8-38d1f17ef0c1.png",
  IMAGE_19: "https://easy-email-m-ryan.vercel.app/images/f1ece227-e050-4751-b064-aaeeabd5bfde-d459e9a2-b192-417b-8a77-2297b29e814e.png",
  IMAGE_20: "https://easy-email-m-ryan.vercel.app/images/585b48f6-ee7c-4d1a-8619-4d2edea09be6-07113335-5d19-464a-adef-2be50682ce72.png",
  IMAGE_21: "https://easy-email-m-ryan.vercel.app/images/9755d667-289e-405c-b84a-adf5db91ea4d-c03c409b-dd9b-40e9-840a-6a64e1df594e.png",
  IMAGE_22: "https://easy-email-m-ryan.vercel.app/images/7487ce49-cd69-4651-8da3-807c54357258-defaaf0a-1756-4b83-9a94-51dcdbfeb84f.png",
  IMAGE_23: "https://easy-email-m-ryan.vercel.app/images/c3463b9e-baff-41c8-95ee-01c5a79259bd-8062ab05-baa5-45d2-9959-4935d4ff2005.png",
  IMAGE_24: "https://easy-email-m-ryan.vercel.app/images/1f45e84a-5c84-45ce-9d27-df6ffb55bcdd-cbf126f4-b372-4ea9-a354-0dc27be4ce2f.png",
  IMAGE_25: "https://easy-email-m-ryan.vercel.app/images/6b8b234e-2306-48f9-90ed-056c13201a83-492073c3-258f-4f1b-91fa-4a8ae723aa2c.png",
  IMAGE_26: "https://easy-email-m-ryan.vercel.app/images/aa50c2c9-8e3b-4af2-b029-337ec549ec10-baacd015-2e3f-4326-b3ab-bde84a7c456b.png",
  IMAGE_27: "https://easy-email-m-ryan.vercel.app/images/9e935e54-a97e-4fbb-a2fb-73e351a35eed-479ef4d1-9460-48b2-934d-84d77044b98d.png",
  IMAGE_28: "https://easy-email-m-ryan.vercel.app/images/799564d8-3082-4fdc-86ed-8c4b3510934f-3f8ccbaa-7b6b-49b7-a836-21fa88f996fc.png",
  IMAGE_29: "https://easy-email-m-ryan.vercel.app/images/af34a548-c339-4a9e-85fe-11bf90c083eb-46fef91d-7307-4e91-aae0-460da1c48629.png",
  IMAGE_30: "https://easy-email-m-ryan.vercel.app/images/84014a93-429c-479c-b9ed-0c568f58a288-ca76cdf2-92d3-4552-bc95-3a8dd4c9cd0b.png",
  IMAGE_31: "https://easy-email-m-ryan.vercel.app/images/dd1584fb-cb60-42c9-80c7-5545e16130ca-226ba72b-ce9e-4948-ad0d-347381fb96c5.png",
  IMAGE_32: "https://easy-email-m-ryan.vercel.app/images/76e3d8e2-697d-484c-a989-715bd234b575-37bde239-2e2d-450a-8e93-d62c39cb94a3.png",
  IMAGE_33: "https://easy-email-m-ryan.vercel.app/images/898b791e-c8fc-4bc5-bf1e-47a0351284ce-fdee9617-9848-49e7-82b6-36095f417a3e.png",
  IMAGE_34: "https://easy-email-m-ryan.vercel.app/images/49662d27-6e14-4e75-a942-946f0af25a51-e9aa2ead-98e4-4f70-8073-7b5aaafaa367.png",
  IMAGE_35: "https://easy-email-m-ryan.vercel.app/images/d2905fb1-9fc1-49c0-90b0-806877c38cd2-f2e05655-4e6c-41b0-a028-990448a716dc.png",
  IMAGE_36: "https://easy-email-m-ryan.vercel.app/images/9c3e9949-1be7-42b5-ad48-44f0e1c89c2e-2ee3cbac-e45e-414d-96ad-9dae3621cf14.png",
  IMAGE_37: "https://easy-email-m-ryan.vercel.app/images/1865e3a6-a762-4bd9-9644-96ae6b27a83a-176a20c7-5768-400c-b2eb-701500cee17c.png",
  IMAGE_38: "https://easy-email-m-ryan.vercel.app/images/2a6d82e2-d1f6-4e30-ae05-1afe3cd03e70-22d186b0-c2f1-4aee-b33b-869cae26412e.png",
  IMAGE_39: "https://easy-email-m-ryan.vercel.app/images/9f97bda2-82d6-47e7-80c1-40be94d5491f-88233d55-8715-43cd-9232-246440e33cd6.png",
  IMAGE_40: "https://easy-email-m-ryan.vercel.app/images/b8f00c77-12b0-4e61-a85e-96918c0035dc-b8344b64-8e79-424d-a974-8e13e6b1e7f8.png",
  IMAGE_41: "https://easy-email-m-ryan.vercel.app/images/5fc6be85-0205-4ca9-bb9a-eb9335f94af2-2d41c4bb-2c00-4fe7-8b32-067e92df3ab3.png",
  IMAGE_42: "https://easy-email-m-ryan.vercel.app/images/f6c9c054-f35a-4af7-957f-c7a6209972eb-7e3b42bf-8d97-466d-8662-8d3b1786e8b8.png",
  IMAGE_43: "https://easy-email-m-ryan.vercel.app/images/80e108b0-3d70-442a-93c1-3fcc091253c6-3dc61b44-6072-413a-ae28-a551577b7677.png",
  IMAGE_44: "https://easy-email-m-ryan.vercel.app/images/14b9e878-7208-48f4-94d0-51161b79010a-fb55ae68-a7ce-4bae-830d-331d368f0f32.png",
  IMAGE_45: "https://easy-email-m-ryan.vercel.app/images/b42f3cd8-01fc-4650-a32d-b584b05e78c3-5e408f98-e9e6-43de-97af-91b2732760df.png",
  IMAGE_46: "https://easy-email-m-ryan.vercel.app/images/e737972a-d884-440b-96d3-66f703dd110b-9f1d0d18-fb45-4a54-a2d0-65bc5b168f8a.png",
  IMAGE_47: "https://easy-email-m-ryan.vercel.app/images/0e3ae071-247a-4e69-8b60-8009477180b9-197205c2-2ae7-420f-94aa-78440226beaa.png",
  IMAGE_48: "https://easy-email-m-ryan.vercel.app/images/0ec46619-4dd0-4293-88fb-14656ac7d33c-0936deed-a88c-4e3d-90bf-4fe67b295659.png",
  IMAGE_49: "https://easy-email-m-ryan.vercel.app/images/01830aec-d044-4d2a-9519-aac2901f4760-776602f7-021b-4142-a2d0-446aca5e0418.png",
  IMAGE_50: "https://easy-email-m-ryan.vercel.app/images/9f1cee25-f9b4-4539-b4ea-3109584c0a54-0692c4fb-46ce-452c-8573-fcce74852cba.png",
  IMAGE_51: "https://easy-email-m-ryan.vercel.app/images/e138143f-7071-44bc-8470-7d56850e527c-f515254e-67b8-4b68-b86f-7993e960d893.png",
  IMAGE_52: "https://easy-email-m-ryan.vercel.app/images/ac75b655-b57d-40b9-a201-8163eeb6a579-1f894e6f-18ac-42c4-9227-7488433586bc.png",
  IMAGE_53: "https://easy-email-m-ryan.vercel.app/images/3c505a1b-575a-40fb-83c1-6c4a11a6d478-9e466e35-af9e-406a-b4cc-b86f9d0b0419.png",
  IMAGE_54: "https://easy-email-m-ryan.vercel.app/images/7f98eeec-9422-48b5-9b57-939a24418b92-a6346a63-b393-49c2-9911-ee1a9a1ffd02.png",
  IMAGE_55: "https://easy-email-m-ryan.vercel.app/images/a7f5ae44-418b-40e1-b8a5-8162cf8bbd87-156cc8dd-3a19-4638-8c26-e28783e50952.png",
  IMAGE_56: "https://easy-email-m-ryan.vercel.app/images/efdeeced-1eb7-465f-8370-a3b000634ba2-0a4d1794-6ca7-44fa-a1c6-04e3bde8eb56.png",
  IMAGE_57: "https://easy-email-m-ryan.vercel.app/images/425c6017-2c30-41d7-8930-08300492c6d4-a0859ca3-5213-484c-9170-2d51329407cc.png",
  IMAGE_58: "https://easy-email-m-ryan.vercel.app/images/858ea699-cf65-469d-bd9e-70adea729bb4-c4e7a711-27b6-4865-9b32-516c41cebddf.png",
  IMAGE_59: "https://easy-email-m-ryan.vercel.app/images/06ca521d-9728-4de6-a709-1b75a828bfc3-2a9b1224-3d71-43b8-b52f-e7cdcdc9107b.png",
  IMAGE_60: "https://easy-email-m-ryan.vercel.app/images/199eacfa-daf8-4dd1-a356-225a265a88a4-e8432435-a2bb-4ec2-a3e9-ee1757d8b44b.png",
  IMAGE_61: "https://easy-email-m-ryan.vercel.app/images/f43b67dc-cc30-4533-b2ca-4689292aab4d-40bc844d-5362-451f-a839-69e86f7a3113.png",
  IMAGE_62: "https://easy-email-m-ryan.vercel.app/images/318e911c-a57b-4768-9c79-0e49c2953e7a-dbe0eb3c-0b4b-495a-a469-a15b46c5a0cc.png",
  IMAGE_63: "https://easy-email-m-ryan.vercel.app/images/ed70ddb1-1344-4245-ab1e-beae36ed44b4-21a80cb3-a928-4857-973b-98992fdec74f.png",
  IMAGE_64: "https://easy-email-m-ryan.vercel.app/images/fb7dd6fa-12c1-41e1-8744-91d0f861ec57-0fee9bda-2381-4c54-a24d-bd644384b9aa.png",
  IMAGE_65: "https://easy-email-m-ryan.vercel.app/images/7bf8c363-17bd-472d-8cca-96f5d4b64292-9ab34957-15d3-4068-8e83-cc283d8e400d.png",
  IMAGE_66: "https://easy-email-m-ryan.vercel.app/images/0330a1e9-e814-4be8-83f0-ee1dbabf44a0-6e35a585-92ec-4570-875b-866b59927583.png",
  IMAGE_67: "https://easy-email-m-ryan.vercel.app/images/a7deb6bc-db2b-4273-bf25-002bb148bf5a-ed5e9b17-15a9-4e0f-9874-c3219d48b2b4.png",
  IMAGE_68: "https://easy-email-m-ryan.vercel.app/images/52c50319-e3a9-401b-9057-bd6531870f10-aa79ec5d-76d2-4d48-a99e-2ccd9d9c285b.png",
  IMAGE_69: "https://easy-email-m-ryan.vercel.app/images/9994cef3-6205-4013-8993-b037d067df64-f5d03db4-6bb4-4af4-b35a-0b6d512eaff4.png",
  IMAGE_70: "https://easy-email-m-ryan.vercel.app/images/e5dd7a7e-70d7-483f-80cc-0c5b41107101-75dcedc7-4a34-4d03-97ee-bf32163afa0a.png",
  IMAGE_71: "https://easy-email-m-ryan.vercel.app/images/53277265-8e54-43d0-b9d0-d34cd1639861-adb7a48a-8382-43a1-ad59-7c84764a3b21.png"
};
ImageManager.add(defaultImagesMap);
function getImg(name2) {
  return ImageManager.get(name2);
}
function Picture(props) {
  var _a, _b;
  const [url, setUrl] = useState(props.src);
  useEffect(() => {
    setUrl(props.src);
  }, [props.src]);
  return /* @__PURE__ */ React__default.createElement("picture", __spreadValues(__spreadValues({}, __spreadValues({}, props)), {
    src: void 0,
    style: __spreadValues({
      display: "inline-block"
    }, props.style)
  }), /* @__PURE__ */ React__default.createElement("source", {
    type: "image/webp",
    srcSet: url + "?imageView2/3/q/70/w/750/format/webp"
  }), /* @__PURE__ */ React__default.createElement("img", {
    crossOrigin: "",
    style: {
      width: ((_a = props.style) == null ? void 0 : _a.width) || "100%",
      height: ((_b = props.style) == null ? void 0 : _b.height) || "100%",
      maxWidth: "100%",
      maxHeight: "100%"
    },
    src: url,
    alt: ""
  }));
}
const imageList = [
  getImg("IMAGE_39"),
  getImg("IMAGE_40"),
  getImg("IMAGE_41"),
  getImg("IMAGE_42"),
  getImg("IMAGE_43"),
  getImg("IMAGE_44"),
  getImg("IMAGE_45")
];
function ImageBlockItem() {
  return /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
    fill: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, imageList.map((item2, index2) => {
    return /* @__PURE__ */ React__default.createElement(BlockMaskWrapper, {
      key: index2,
      type: AdvancedType.IMAGE,
      payload: {
        attributes: {
          src: item2,
          padding: "0px 0px 0px 0px"
        }
      }
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: { position: "relative" }
    }, /* @__PURE__ */ React__default.createElement(Picture, {
      src: item2
    }), /* @__PURE__ */ React__default.createElement("div", {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        zIndex: 2
      }
    })));
  })));
}
const spacerList = [10, 15, 20, 30, 50, 60, 100];
function SpacerBlockItem() {
  return /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
    fill: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, spacerList.map((item2, index2) => {
    return /* @__PURE__ */ React__default.createElement(BlockMaskWrapper, {
      key: index2,
      type: AdvancedType.SPACER,
      payload: {
        attributes: {
          height: item2 + "px"
        }
      }
    }, /* @__PURE__ */ React__default.createElement(Stack$4, {
      alignment: "center"
    }, /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
      fill: true
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: {
        marginBottom: 20,
        backgroundColor: "#efeeea",
        position: "relative",
        height: item2,
        boxShadow: " 3px 3px 3px rgb(0 0 0 / 0.2)"
      }
    })), /* @__PURE__ */ React__default.createElement(TextStyle, null, item2, " px")));
  })));
}
const dividerList = [
  {
    "border-width": "2px",
    "border-style": "solid",
    "border-color": "lightgrey"
  },
  {
    "border-width": "2px",
    "border-style": "dashed",
    "border-color": "lightgrey"
  },
  {
    "border-width": "2px",
    "border-style": "dotted",
    "border-color": "lightgrey"
  }
];
function DividerBlockItem() {
  return /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
    fill: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4.Item, null), /* @__PURE__ */ React__default.createElement(Stack$4.Item, null), dividerList.map((item2, index2) => {
    return /* @__PURE__ */ React__default.createElement(BlockMaskWrapper, {
      key: index2,
      type: AdvancedType.DIVIDER,
      payload: {
        attributes: __spreadProps(__spreadValues({}, item2), { padding: "10px 0px" })
      }
    }, /* @__PURE__ */ React__default.createElement(Stack$4, {
      alignment: "center"
    }, /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
      fill: true
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: {
        backgroundColor: "#fff",
        padding: "10px 0px 10px 0px"
      }
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: {
        borderTopWidth: item2["border-width"],
        borderTopStyle: item2["border-style"],
        borderTopColor: item2["border-color"],
        boxSizing: "content-box"
      }
    }))), /* @__PURE__ */ React__default.createElement(TextStyle, null, item2["border-style"])));
  })));
}
function HeroBlockItem() {
  return /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
    fill: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, heroList.map((item2, index2) => {
    return /* @__PURE__ */ React__default.createElement(BlockMaskWrapper, {
      key: index2,
      type: AdvancedType.HERO,
      payload: item2.payload
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: { position: "relative" }
    }, /* @__PURE__ */ React__default.createElement(Picture, {
      src: item2.thumbnail
    }), /* @__PURE__ */ React__default.createElement("div", {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        zIndex: 2
      }
    })));
  })));
}
const heroList = [
  {
    thumbnail: getImg("IMAGE_30"),
    payload: {
      type: "hero",
      data: {
        value: {}
      },
      attributes: {
        "background-color": "#ffffff",
        "background-position": "center center",
        mode: "fluid-height",
        padding: "100px 0px 100px 0px",
        "vertical-align": "top",
        "background-url": getImg("IMAGE_31")
      },
      children: [
        {
          type: "text",
          data: {
            value: {
              content: "We Serve Healthy &amp; Delicious Foods"
            }
          },
          attributes: {
            "font-size": "45px",
            padding: "10px 25px 10px 25px",
            "line-height": "45px",
            align: "center",
            color: "#ffffff"
          },
          children: []
        },
        {
          type: "text",
          data: {
            value: {
              content: "A small river named Duden flows by their place and supplies it with the necessary regelialia. It is a paradisematic country, in which roasted parts of sentences fly into your mouth.<br>"
            }
          },
          attributes: {
            "font-size": "14px",
            padding: "10px 25px 10px 25px",
            "line-height": "1.5",
            align: "center",
            color: "#ffffff"
          },
          children: []
        },
        {
          type: "button",
          data: {
            value: {
              content: "Get Your Order Here!"
            }
          },
          attributes: {
            align: "center",
            "background-color": "#f3a333",
            color: "#ffffff",
            "font-size": "13px",
            "font-weight": "normal",
            "border-radius": "30px",
            padding: "10px 25px 10px 25px",
            "inner-padding": "10px 25px 10px 25px",
            "line-height": "120%",
            target: "_blank",
            "vertical-align": "middle",
            border: "none",
            "text-align": "center",
            href: "#"
          },
          children: []
        }
      ]
    }
  },
  {
    thumbnail: getImg("IMAGE_32"),
    payload: {
      type: "hero",
      data: {
        value: {
          content: "WINTER\n      \n      \n        WINTER IS COMING\n      \n\n\n      \n        A small river named Duden flows by their place and supplies it with the necessary regelialia.\n      \n\n      \n        Read more"
        }
      },
      attributes: {
        "background-color": "#ffffff",
        "background-position": "center center",
        mode: "fluid-height",
        padding: "0px 0px 100px 0px",
        "vertical-align": "top",
        "background-url": getImg("IMAGE_33"),
        "padding-bottom": "100px"
      },
      children: [
        {
          type: "button",
          data: {
            value: {
              content: "WINTER"
            }
          },
          attributes: {
            "font-size": "24px",
            padding: "10px 25px 10px 25px",
            "line-height": "45px",
            align: "center",
            color: "#ffffff",
            border: "2px solid #ffffff",
            "font-weight": "500",
            "background-color": "transparent",
            "inner-padding": "10px 15px 4px 15px",
            "font-family": "'Josefin Sans', sans-serif",
            "border-radius": "0px"
          },
          children: []
        },
        {
          type: "text",
          data: {
            value: {
              content: "\n        WINTER IS COMING\n      "
            }
          },
          attributes: {
            align: "center",
            "background-color": "#414141",
            color: "#ffffff",
            "font-size": "30px",
            "font-weight": "normal",
            "border-radius": "3px",
            padding: "10px 25px 10px 25px",
            "inner-padding": "10px 25px 10px 25px",
            "line-height": "54px",
            target: "_blank",
            "vertical-align": "middle",
            border: "none",
            "text-align": "center",
            href: "#"
          },
          children: []
        },
        {
          type: "text",
          attributes: {
            "font-size": "16px",
            padding: "10px 25px 10px 25px",
            "line-height": "1.5",
            align: "center",
            color: "#ffffff"
          },
          data: {
            value: {
              content: "\n        A small river named Duden flows by their place and supplies it with the necessary regelialia.\n      "
            }
          },
          children: []
        },
        {
          type: "button",
          attributes: {
            "border-radius": "30px",
            "font-weight": "500",
            "background-color": "#448ef6",
            padding: "30px 25px 10px 25px"
          },
          data: {
            value: {
              content: "Read more"
            }
          },
          children: []
        }
      ]
    }
  },
  {
    thumbnail: getImg("IMAGE_34"),
    payload: {
      type: "hero",
      data: {
        value: {
          content: "WINTER\n      \n      \n        WINTER IS COMING\n      \n\n\n      \n        A small river named Duden flows by their place and supplies it with the necessary regelialia.\n      \n\n      \n        Read more"
        }
      },
      attributes: {
        "background-color": "#ffffff",
        "background-position": "center center",
        mode: "fluid-height",
        padding: "0px 0px 100px 0px",
        "vertical-align": "top",
        "background-url": getImg("IMAGE_35"),
        "padding-bottom": "100px"
      },
      children: [
        {
          type: "text",
          data: {
            value: {
              content: "Up to 50% off Selected<div>&nbsp;Womens Items</div>"
            }
          },
          attributes: {
            align: "center",
            "background-color": "#414141",
            color: "#ffffff",
            "font-size": "30px",
            "font-weight": "normal",
            "border-radius": "3px",
            padding: "80px 25px 10px 25px",
            "inner-padding": "10px 25px 10px 25px",
            "line-height": "1.4",
            target: "_blank",
            "vertical-align": "middle",
            border: "none",
            "text-align": "center",
            href: "#",
            "font-family": '"Playfair Display", sans-serif'
          },
          children: []
        },
        {
          type: "text",
          attributes: {
            "font-size": "16px",
            padding: "10px 25px 10px 25px",
            "line-height": "1.5",
            align: "center",
            color: "#ffffff"
          },
          data: {
            value: {
              content: "A small river named Duden flows by their place and supplies it with the necessary regelialia."
            }
          },
          children: []
        },
        {
          type: "button",
          attributes: {
            "border-radius": "5px",
            "font-weight": "500",
            "background-color": "#ffc0d0",
            padding: "30px 25px 10px 25px"
          },
          data: {
            value: {
              content: "Start Shoping"
            }
          },
          children: []
        }
      ]
    }
  },
  {
    thumbnail: getImg("IMAGE_36"),
    payload: {
      type: "hero",
      attributes: {
        "background-color": "#ffffff",
        "background-position": "center center",
        mode: "fluid-height",
        padding: "100px 0px 100px 0px",
        "vertical-align": "top",
        "background-url": getImg("IMAGE_38")
      },
      data: {
        value: {
          content: "We We Create Modern Website\n          \n        \n\n          \n           A small river named Duden flows by their place and supplies it with the necessary regelialia. It is a paradisematic country, in which roasted parts of sentences fly into your mouth."
        }
      },
      children: [
        {
          type: "text",
          attributes: {
            "font-size": "30px",
            padding: "10px 25px 10px 25px",
            "line-height": "54px",
            align: "center",
            color: "#ffffff"
          },
          data: {
            value: {
              content: "We We Create Modern Website"
            }
          },
          children: []
        },
        {
          type: "text",
          attributes: {
            "font-size": "16px",
            padding: "10px 25px 10px 25px",
            "line-height": "1.5",
            align: "center",
            color: "#ffffff"
          },
          data: {
            value: {
              content: "A small river named Duden flows by their place and supplies it with the necessary regelialia. It is a paradisematic country, in which roasted parts of sentences fly into your mouth."
            }
          },
          children: []
        },
        {
          type: "image",
          attributes: {
            width: "60px",
            "padding-top": "30px",
            src: getImg("IMAGE_37"),
            target: "_blank",
            href: "https://easy-email-m-ryan.vercel.app/"
          },
          data: {
            value: {
              content: ""
            }
          },
          children: []
        }
      ]
    }
  }
];
const buttonList = [
  {
    thumbnail: getImg("IMAGE_11"),
    payload: {
      attributes: {
        align: "center",
        "background-color": "#8ccaca",
        color: "#ffffff",
        "font-size": "12px",
        "font-weight": "normal",
        "border-radius": "0px",
        padding: "10px 25px 10px 25px",
        "inner-padding": "10px 25px 10px 25px",
        "line-height": "120%",
        target: "_blank",
        "vertical-align": "middle",
        border: "none",
        "text-align": "center",
        href: "#"
      },
      data: {
        value: {
          content: "READ MORE"
        }
      }
    }
  },
  {
    thumbnail: getImg("IMAGE_12"),
    payload: {
      type: "button",
      attributes: {
        align: "center",
        "background-color": "transparent",
        color: "#000000",
        "font-size": "12px",
        "font-weight": "normal",
        "border-radius": "0px",
        padding: "10px 25px 10px 25px",
        "inner-padding": "10px 25px 10px 25px",
        "line-height": "120%",
        target: "_blank",
        "vertical-align": "middle",
        border: "2px solid #000",
        "text-align": "center",
        href: "#"
      },
      data: {
        value: {
          content: "READ MORE"
        }
      },
      children: []
    }
  },
  {
    thumbnail: getImg("IMAGE_13"),
    payload: {
      type: "button",
      attributes: {
        align: "center",
        "background-color": "transparent",
        color: "#ffffff",
        "font-size": "12px",
        "font-weight": "normal",
        "border-radius": "0px",
        padding: "10px 25px 10px 25px",
        "inner-padding": "10px 25px 10px 25px",
        "line-height": "120%",
        target: "_blank",
        "vertical-align": "middle",
        border: "2px dashed #ffffff",
        "text-align": "center",
        href: "#",
        "container-background-color": "#97c0f0"
      },
      data: {
        value: {
          content: "Let's Go"
        }
      },
      children: []
    }
  }
];
function ButtonBlockItem() {
  return /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
    fill: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, buttonList.map((item2, index2) => {
    return /* @__PURE__ */ React__default.createElement(Stack$4, {
      key: index2,
      alignment: "center"
    }, /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
      fill: true
    }, /* @__PURE__ */ React__default.createElement(BlockMaskWrapper, {
      type: AdvancedType.BUTTON,
      payload: __spreadValues({}, item2.payload)
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: { position: "relative", overflow: "hidden" }
    }, /* @__PURE__ */ React__default.createElement(Picture, {
      src: item2.thumbnail
    }), /* @__PURE__ */ React__default.createElement("div", {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        zIndex: 2
      }
    })))));
  })));
}
const list$7 = [
  {
    thumbnail: getImg("IMAGE_08"),
    payload: {
      type: AdvancedType.ACCORDION,
      data: {
        value: {}
      },
      attributes: {
        "icon-height": "32px",
        "icon-width": "32px",
        "icon-align": "middle",
        "icon-position": "right",
        "icon-unwrapped-url": getImg("IMAGE_09"),
        "icon-wrapped-url": getImg("IMAGE_10"),
        padding: "10px 25px 10px 25px",
        border: "1px solid #d9d9d9"
      },
      children: [
        {
          type: "accordion-element",
          data: {
            value: {}
          },
          attributes: {
            "icon-align": "middle",
            "icon-height": "32px",
            "icon-width": "32px",
            "icon-position": "right",
            padding: "10px 25px 10px 25px"
          },
          children: [
            {
              type: "accordion-title",
              data: {
                value: {
                  content: "Why use an accordion?"
                }
              },
              attributes: {
                "font-size": "13px",
                padding: "16px 16px 16px 16px"
              },
              children: []
            },
            {
              type: "accordion-text",
              data: {
                value: {
                  content: '<span style="line-height:20px">\n                Because emails with a lot of content are most of the time a very bad experience on mobile, mj-accordion comes handy when you want to deliver a lot of information in a concise way.\n              </span>'
                }
              },
              attributes: {
                "font-size": "13px",
                padding: "16px 16px 16px 16px",
                "line-height": "1"
              },
              children: []
            }
          ]
        },
        {
          type: "accordion-element",
          data: {
            value: {}
          },
          attributes: {
            "icon-align": "middle",
            "icon-height": "32px",
            "icon-width": "32px",
            "icon-position": "right",
            padding: "10px 25px 10px 25px"
          },
          children: [
            {
              type: "accordion-title",
              data: {
                value: {
                  content: "How it works"
                }
              },
              attributes: {
                "font-size": "13px",
                padding: "16px 16px 16px 16px"
              },
              children: []
            },
            {
              type: "accordion-text",
              data: {
                value: {
                  content: '<span style="line-height:20px">\n                Content is stacked into tabs and users can expand them at will. If responsive styles are not supported (mostly on desktop clients), tabs are then expanded and your content is readable at once.\n              </span>'
                }
              },
              attributes: {
                "font-size": "13px",
                padding: "16px 16px 16px 16px",
                "line-height": "1"
              },
              children: []
            }
          ]
        }
      ]
    }
  }
];
function AccordionBlockItem() {
  return /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
    fill: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, list$7.map((item2, index2) => {
    return /* @__PURE__ */ React__default.createElement(BlockMaskWrapper, {
      key: index2,
      type: AdvancedType.ACCORDION,
      payload: item2.payload
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: { position: "relative" }
    }, /* @__PURE__ */ React__default.createElement(Picture, {
      src: item2.thumbnail
    }), /* @__PURE__ */ React__default.createElement("div", {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        zIndex: 2
      }
    })));
  })));
}
const list$6 = [
  {
    thumbnail: getImg("IMAGE_14"),
    payload: {
      type: AdvancedType.CAROUSEL,
      data: {
        value: {
          images: [
            {
              src: getImg("IMAGE_15"),
              target: "_blank"
            },
            {
              src: getImg("IMAGE_16"),
              target: "_blank"
            },
            {
              src: getImg("IMAGE_17"),
              target: "_blank"
            }
          ]
        }
      },
      attributes: {
        align: "center",
        "left-icon": getImg("IMAGE_18"),
        "right-icon": getImg("IMAGE_19"),
        "icon-width": "44px",
        thumbnails: "visible"
      },
      children: []
    }
  }
];
function CarouselBlockItem() {
  return /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
    fill: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, list$6.map((item2, index2) => {
    return /* @__PURE__ */ React__default.createElement(BlockMaskWrapper, {
      key: index2,
      type: AdvancedType.CAROUSEL,
      payload: item2.payload
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: { position: "relative" }
    }, /* @__PURE__ */ React__default.createElement(Picture, {
      src: item2.thumbnail
    }), /* @__PURE__ */ React__default.createElement("div", {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        zIndex: 2
      }
    })));
  })));
}
const list$5 = [
  {
    thumbnail: getImg("IMAGE_46"),
    payload: {
      type: AdvancedType.NAVBAR,
      data: {
        value: {
          links: [
            {
              href: "/gettings-started-onboard",
              content: "HOME",
              color: "#000000",
              "font-size": "13px",
              target: "_blank",
              padding: "15px 10px 15px 10px"
            },
            {
              href: "/try-it-live",
              content: "NEW",
              color: "#000000",
              "font-size": "13px",
              target: "_blank",
              padding: "15px 10px 15px 10px"
            },
            {
              href: "/templates",
              content: "WOMEN",
              color: "#000000",
              "font-size": "13px",
              target: "_blank",
              padding: "15px 10px 15px 10px"
            },
            {
              href: "/components",
              content: "KIDS",
              color: "#000000",
              "font-size": "13px",
              target: "_blank",
              padding: "15px 10px 15px 10px"
            },
            {
              href: "/components",
              content: "BLOG",
              color: "#000000",
              "font-size": "13px",
              target: "_blank",
              padding: "15px 10px 15px 10px"
            }
          ]
        }
      },
      attributes: {
        align: "center",
        "base-url": "https://mjml.io"
      },
      children: []
    }
  }
];
function NavbarBlockItem() {
  return /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
    fill: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, list$5.map((item2, index2) => {
    return /* @__PURE__ */ React__default.createElement(BlockMaskWrapper, {
      key: index2,
      type: AdvancedType.NAVBAR,
      payload: item2.payload
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: { position: "relative" }
    }, /* @__PURE__ */ React__default.createElement(Picture, {
      src: item2.thumbnail
    }), /* @__PURE__ */ React__default.createElement("div", {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        zIndex: 2
      }
    })));
  })));
}
const list$4 = [
  {
    thumbnail: getImg("IMAGE_52"),
    payload: {
      type: AdvancedType.SOCIAL,
      data: {
        value: {
          elements: [
            {
              href: "#",
              "icon-size": "20px",
              target: "_blank",
              src: getImg("IMAGE_53"),
              content: "Facebook"
            },
            {
              href: "#",
              "icon-size": "20px",
              target: "_blank",
              src: getImg("IMAGE_54"),
              content: "Google"
            },
            {
              href: "",
              "icon-size": "20px",
              target: "_blank",
              src: getImg("IMAGE_55"),
              content: "Twitter"
            }
          ]
        }
      },
      attributes: {
        align: "center",
        color: "#333333",
        mode: "horizontal",
        "font-size": "13px",
        "font-weight": "normal",
        "border-radius": "3px",
        padding: "10px 25px 10px 25px",
        "inner-padding": "4px 4px 4px 4px",
        "line-height": "22px",
        "text-padding": "4px 4px 4px 0px",
        "icon-padding": "0px",
        "icon-size": "20px"
      },
      children: []
    }
  },
  {
    thumbnail: getImg("IMAGE_71"),
    payload: {
      type: AdvancedType.SOCIAL,
      data: {
        value: {
          elements: [
            {
              href: "#",
              "icon-size": "20px",
              target: "_blank",
              src: getImg("IMAGE_53"),
              content: ""
            },
            {
              href: "#",
              "icon-size": "20px",
              target: "_blank",
              src: getImg("IMAGE_54"),
              content: ""
            },
            {
              href: "",
              "icon-size": "20px",
              target: "_blank",
              src: getImg("IMAGE_55"),
              content: ""
            }
          ]
        }
      },
      attributes: {
        align: "center",
        color: "#333333",
        mode: "horizontal",
        "font-size": "13px",
        "font-weight": "normal",
        "border-radius": "3px",
        padding: "10px 25px 10px 25px",
        "inner-padding": "4px 4px 4px 4px",
        "line-height": "22px",
        "text-padding": "4px 4px 4px 0px",
        "icon-padding": "0px",
        "icon-size": "20px"
      },
      children: []
    }
  }
];
function SocialBlockItem() {
  return /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
    fill: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, list$4.map((item2, index2) => {
    return /* @__PURE__ */ React__default.createElement(BlockMaskWrapper, {
      key: index2,
      type: AdvancedType.SOCIAL,
      payload: item2.payload
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: { position: "relative" }
    }, /* @__PURE__ */ React__default.createElement(Picture, {
      src: item2.thumbnail
    }), /* @__PURE__ */ React__default.createElement("div", {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        zIndex: 2
      }
    })));
  })));
}
function WrapperBlockItem() {
  return /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
    fill: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, list$3.map((item2, index2) => {
    return /* @__PURE__ */ React__default.createElement(BlockMaskWrapper, {
      key: index2,
      type: AdvancedType.WRAPPER,
      payload: item2.payload
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: { position: "relative" }
    }, /* @__PURE__ */ React__default.createElement(Picture, {
      src: item2.thumbnail
    }), /* @__PURE__ */ React__default.createElement("div", {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        zIndex: 2
      }
    })));
  })));
}
const list$3 = [
  {
    thumbnail: getImg("IMAGE_56"),
    payload: {}
  },
  {
    thumbnail: getImg("IMAGE_57"),
    payload: {
      type: "advanced_section",
      data: {
        value: {}
      },
      attributes: {
        padding: "50px 30px",
        border: "1px solid #aaaaaa",
        direction: "ltr",
        "text-align": "center",
        "background-color": "#ffffff"
      },
      children: [
        {
          type: "advanced_section",
          data: {
            value: {
              noWrap: false
            }
          },
          attributes: {
            padding: "20px",
            "background-repeat": "repeat",
            "background-size": "auto",
            "background-position": "top center",
            border: "none",
            direction: "ltr",
            "text-align": "center",
            "border-top": "1px solid #aaaaaa",
            "border-left": "1px solid #aaaaaa",
            "border-right": "1px solid #aaaaaa"
          },
          children: [
            {
              type: "advanced_column",
              data: {
                value: {}
              },
              attributes: {
                padding: "0px 0px 0px 0px",
                border: "none",
                "vertical-align": "top"
              },
              children: [
                {
                  type: "image",
                  data: {
                    value: {}
                  },
                  attributes: {
                    align: "center",
                    height: "auto",
                    padding: "0",
                    src: getImg("IMAGE_58")
                  },
                  children: []
                }
              ]
            }
          ]
        },
        {
          type: "advanced_section",
          data: {
            value: {
              noWrap: false
            }
          },
          attributes: {
            padding: "20px",
            "background-repeat": "repeat",
            "background-size": "auto",
            "background-position": "top center",
            border: "none",
            direction: "ltr",
            "text-align": "center",
            "border-left": "1px solid #aaaaaa",
            "border-right": "1px solid #aaaaaa",
            "border-bottom": "1px solid #aaaaaa"
          },
          children: [
            {
              type: "advanced_column",
              data: {
                value: {}
              },
              attributes: {
                padding: "0px 0px 0px 0px",
                border: "1px solid #dddddd",
                "vertical-align": "top"
              },
              children: [
                {
                  type: "text",
                  data: {
                    value: {
                      content: "First line of text"
                    }
                  },
                  attributes: {
                    "font-size": "13px",
                    padding: "20px",
                    "line-height": 1,
                    align: "left"
                  },
                  children: []
                },
                {
                  type: "divider",
                  data: {
                    value: {}
                  },
                  attributes: {
                    align: "center",
                    "border-width": "1px",
                    "border-style": "dashed",
                    "border-color": "lightgrey",
                    padding: "0 20px"
                  },
                  children: []
                },
                {
                  type: "text",
                  data: {
                    value: {
                      content: "Second line of text"
                    }
                  },
                  attributes: {
                    "font-size": "13px",
                    padding: "20px",
                    "line-height": 1,
                    align: "left"
                  },
                  children: []
                }
              ]
            }
          ]
        }
      ]
    }
  }
];
function SectionBlockItem() {
  return /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
    fill: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, list$2.map((item2, index2) => {
    return /* @__PURE__ */ React__default.createElement(BlockMaskWrapper, {
      key: index2,
      type: AdvancedType.SECTION,
      payload: item2.payload
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: { position: "relative" }
    }, /* @__PURE__ */ React__default.createElement(Picture, {
      src: item2.thumbnail
    }), /* @__PURE__ */ React__default.createElement("div", {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        zIndex: 2
      }
    })));
  })));
}
const list$2 = [
  {
    thumbnail: getImg("IMAGE_47"),
    payload: {}
  },
  {
    thumbnail: getImg("IMAGE_48"),
    payload: {
      type: "advanced_section",
      data: {
        value: {
          noWrap: false
        }
      },
      attributes: {
        padding: "20px 0px 20px 0px",
        "background-repeat": "repeat",
        "background-size": "auto",
        "background-position": "top center",
        border: "none",
        direction: "ltr",
        "text-align": "center"
      },
      children: [
        {
          type: "advanced_column",
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 0px 0px 0px",
            border: "none",
            "vertical-align": "top"
          },
          children: []
        }
      ]
    }
  },
  {
    thumbnail: getImg("IMAGE_49"),
    payload: {
      type: "advanced_section",
      data: {
        value: {
          noWrap: false
        }
      },
      attributes: {
        padding: "20px 0px 20px 0px",
        "background-repeat": "repeat",
        "background-size": "auto",
        "background-position": "top center",
        border: "none",
        direction: "ltr",
        "text-align": "center"
      },
      children: [
        {
          type: "advanced_column",
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 0px 0px 0px",
            border: "none",
            "vertical-align": "top"
          },
          children: []
        },
        {
          type: "advanced_column",
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 0px 0px 0px",
            border: "none",
            "vertical-align": "top"
          },
          children: []
        }
      ]
    }
  },
  {
    thumbnail: getImg("IMAGE_50"),
    payload: {
      type: "advanced_section",
      data: {
        value: {
          noWrap: false
        }
      },
      attributes: {
        padding: "20px 0px 20px 0px",
        "background-repeat": "repeat",
        "background-size": "auto",
        "background-position": "top center",
        border: "none",
        direction: "ltr",
        "text-align": "center"
      },
      children: [
        {
          type: "advanced_column",
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 0px 0px 0px",
            border: "none",
            "vertical-align": "top"
          },
          children: []
        },
        {
          type: "advanced_column",
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 0px 0px 0px",
            border: "none",
            "vertical-align": "top"
          },
          children: []
        },
        {
          type: "advanced_column",
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 0px 0px 0px",
            border: "none",
            "vertical-align": "top"
          },
          children: []
        }
      ]
    }
  },
  {
    thumbnail: getImg("IMAGE_51"),
    payload: {
      type: "advanced_section",
      data: {
        value: {
          noWrap: false
        }
      },
      attributes: {
        padding: "20px 0px 20px 0px",
        "background-repeat": "repeat",
        "background-size": "auto",
        "background-position": "top center",
        border: "none",
        direction: "ltr",
        "text-align": "center"
      },
      children: [
        {
          type: "advanced_column",
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 0px 0px 0px",
            border: "none",
            "vertical-align": "top"
          },
          children: []
        },
        {
          type: "advanced_column",
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 0px 0px 0px",
            border: "none",
            "vertical-align": "top"
          },
          children: []
        },
        {
          type: "advanced_column",
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 0px 0px 0px",
            border: "none",
            "vertical-align": "top"
          },
          children: []
        },
        {
          type: "advanced_column",
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 0px 0px 0px",
            border: "none",
            "vertical-align": "top"
          },
          children: []
        }
      ]
    }
  }
];
function GroupBlockItem() {
  return /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
    fill: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, list$1.map((item2, index2) => {
    return /* @__PURE__ */ React__default.createElement(BlockMaskWrapper, {
      key: index2,
      type: AdvancedType.GROUP,
      payload: item2.payload
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: { position: "relative" }
    }, /* @__PURE__ */ React__default.createElement(Picture, {
      src: item2.thumbnail
    }), /* @__PURE__ */ React__default.createElement("div", {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        zIndex: 2
      }
    })));
  })));
}
const list$1 = [
  {
    thumbnail: getImg("IMAGE_22"),
    payload: {}
  },
  {
    thumbnail: getImg("IMAGE_23"),
    payload: {
      type: "advanced_group",
      data: {
        value: {}
      },
      attributes: {
        "vertical-align": "top",
        direction: "ltr"
      },
      children: [
        {
          type: "advanced_column",
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 0px 0px 0px",
            border: "none",
            "vertical-align": "top"
          },
          children: [
            {
              type: "image",
              data: {
                value: {}
              },
              attributes: {
                align: "center",
                height: "auto",
                padding: "0px 5px 0px 10px",
                src: getImg("IMAGE_24"),
                width: ""
              },
              children: []
            }
          ]
        },
        {
          type: "advanced_column",
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 0px 0px 0px",
            border: "none",
            "vertical-align": "top"
          },
          children: [
            {
              type: "image",
              data: {
                value: {}
              },
              attributes: {
                align: "center",
                height: "auto",
                padding: "0px 10px 0px 5px",
                src: getImg("IMAGE_25"),
                width: ""
              },
              children: []
            }
          ]
        }
      ]
    }
  },
  {
    thumbnail: getImg("IMAGE_26"),
    payload: {
      type: "advanced_group",
      data: {
        value: {}
      },
      attributes: {
        "vertical-align": "top",
        direction: "ltr",
        "background-color": "#ffffff"
      },
      children: [
        {
          type: "advanced_column",
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 5px 0px 5px",
            border: "none",
            "vertical-align": "top"
          },
          children: [
            {
              type: "image",
              data: {
                value: {}
              },
              attributes: {
                align: "center",
                height: "auto",
                padding: "0px 0px 0px 0px",
                src: getImg("IMAGE_29"),
                width: ""
              },
              children: []
            },
            {
              type: "text",
              data: {
                value: {
                  content: "Office Room\nPrinting"
                }
              },
              attributes: {
                "font-size": "18px",
                padding: "10px 5px 10px 5px",
                "line-height": 1,
                align: "center"
              },
              children: []
            }
          ]
        },
        {
          type: "advanced_column",
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 5px 0px 5px",
            border: "none",
            "vertical-align": "top"
          },
          children: [
            {
              type: "image",
              data: {
                value: {}
              },
              attributes: {
                align: "center",
                height: "auto",
                padding: "0px 0px 0px 0px",
                src: getImg("IMAGE_27"),
                width: ""
              },
              children: []
            },
            {
              type: "text",
              data: {
                value: {
                  content: "Workplace\nDesign<div><br></div>"
                }
              },
              attributes: {
                "font-size": "18px",
                padding: "10px 5px 10px 5px",
                "line-height": 1,
                align: "center"
              },
              children: []
            }
          ]
        },
        {
          type: "advanced_column",
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 5px 0px 5px",
            border: "none",
            "vertical-align": "top"
          },
          children: [
            {
              type: "image",
              data: {
                value: {}
              },
              attributes: {
                align: "center",
                height: "auto",
                padding: "0px 0px 0px 0px",
                src: getImg("IMAGE_28"),
                width: ""
              },
              children: []
            },
            {
              type: "text",
              data: {
                value: {
                  content: "Modern Design\nBranding"
                }
              },
              attributes: {
                "font-size": "18px",
                padding: "10px 5px 10px 5px",
                "line-height": 1,
                align: "center"
              },
              children: []
            }
          ]
        }
      ]
    }
  }
];
function ColumnBlockItem() {
  return /* @__PURE__ */ React__default.createElement(Stack$4.Item, {
    fill: true
  }, /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true
  }, list.map((item2, index2) => {
    return /* @__PURE__ */ React__default.createElement(BlockMaskWrapper, {
      key: index2,
      type: AdvancedType.COLUMN,
      payload: item2.payload
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: { position: "relative" }
    }, /* @__PURE__ */ React__default.createElement(Picture, {
      src: item2.thumbnail
    }), /* @__PURE__ */ React__default.createElement("div", {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        zIndex: 2
      }
    })));
  })));
}
const list = [
  {
    thumbnail: getImg("IMAGE_20"),
    payload: {
      type: "advanced_column",
      data: {
        value: {}
      },
      attributes: {
        padding: "20px 0px 20px 0px",
        border: "none",
        "vertical-align": "top",
        "background-color": "#ffffff"
      },
      children: [
        {
          type: "image",
          data: {
            value: {}
          },
          attributes: {
            align: "center",
            height: "auto",
            padding: "0px 0px 0px 0px",
            src: getImg("IMAGE_21"),
            width: "150px"
          },
          children: []
        },
        {
          type: "text",
          data: {
            value: {
              content: "Business Key to Success"
            }
          },
          attributes: {
            "font-size": "20px",
            padding: "10px 0px 10px 0px",
            "line-height": "1.7",
            align: "center",
            "font-family": '"Nunito Sans", sans-serif'
          },
          children: []
        },
        {
          type: "text",
          data: {
            value: {
              content: "POSTED ON FEB 18, 2019 FOOD"
            }
          },
          attributes: {
            "font-size": "15px",
            padding: "0px 0px 10px 0px",
            "line-height": "1.7",
            align: "center",
            color: "#9b9b9b",
            "font-family": '"Nunito Sans", sans-serif'
          },
          children: []
        },
        {
          type: "text",
          data: {
            value: {
              content: "Far far away, behind the word mountains, far from the countries"
            }
          },
          attributes: {
            "font-size": "15px",
            padding: "0px 0px 0px 0px",
            "line-height": "1.7",
            align: "center",
            color: "#9b9b9b",
            "font-family": '"Nunito Sans", sans-serif'
          },
          children: []
        }
      ]
    }
  }
];
const defaultCategories$1 = [
  {
    title: "Content",
    name: "CONTENT",
    blocks: [
      {
        type: AdvancedType.TEXT,
        title: "Text",
        description: "This block allows you to display text in your email.",
        component: TextBlockItem
      },
      {
        type: AdvancedType.IMAGE,
        title: "Image",
        description: /* @__PURE__ */ React__default.createElement(Stack$4, {
          vertical: true,
          spacing: "none"
        }, /* @__PURE__ */ React__default.createElement(TextStyle, null, 'Displays a responsive image in your email. It is similar to the HTML "<img/>" tag. Note that if no width is provided, the image will use the parent column width.')),
        component: ImageBlockItem
      },
      {
        type: AdvancedType.BUTTON,
        title: "Button",
        description: "Displays a customizable button.",
        component: ButtonBlockItem
      },
      {
        type: AdvancedType.HERO,
        title: "Hero",
        description: `This block displays a hero image. It behaves like an
        'section' with a single 'column'.`,
        component: HeroBlockItem
      },
      {
        type: AdvancedType.NAVBAR,
        title: "Navbar",
        description: `Displays a menu for navigation with an optional hamburger
        mode for mobile devices.`,
        component: NavbarBlockItem
      },
      {
        type: AdvancedType.SPACER,
        title: "Spacer",
        description: "Displays a blank space.",
        component: SpacerBlockItem
      },
      {
        type: AdvancedType.DIVIDER,
        title: "Divider",
        description: `Displays a horizontal divider that can be customized like a
        HTML border.`,
        component: DividerBlockItem
      },
      {
        type: AdvancedType.ACCORDION,
        title: "Accordion",
        description: `Accordion is an interactive component to stack content in
        tabs, so the information is collapsed and only the titles
        are visible. Readers can interact by clicking on the tabs
        to reveal the content, providing a great experience on
        mobile devices where space is scarce.`,
        component: AccordionBlockItem
      },
      {
        type: AdvancedType.CAROUSEL,
        title: "Carousel",
        description: `This block displays a gallery of images or "carousel".
        Readers can interact by hovering and clicking on
        thumbnails depending on the email client they use.`,
        component: CarouselBlockItem
      },
      {
        type: AdvancedType.SOCIAL,
        title: "Social",
        description: `Displays calls-to-action for various social networks with
        their associated logo.`,
        component: SocialBlockItem
      }
    ]
  },
  {
    title: "Layout",
    name: "LAYOUT",
    blocks: [
      {
        type: AdvancedType.WRAPPER,
        title: "Wrapper",
        description: `Wrapper enables to wrap multiple sections together. It's especially useful to achieve nested layouts with shared border or background images across sections.
        `,
        component: WrapperBlockItem
      },
      {
        type: AdvancedType.SECTION,
        title: "Section",
        description: /* @__PURE__ */ React__default.createElement(Stack$4, {
          vertical: true,
          spacing: "none"
        }, /* @__PURE__ */ React__default.createElement(TextStyle, null, "Sections are intended to be used as rows within your email. They will be used to structure the layout."), /* @__PURE__ */ React__default.createElement(TextStyle, null, "Sections cannot nest in sections. Columns can nest in sections; all content must be in a column.")),
        component: SectionBlockItem
      },
      {
        type: AdvancedType.GROUP,
        title: "Group",
        description: `Group allows you to prevent columns from stacking on
          mobile. To do so, wrap the columns inside a group
          block, so they'll stay side by side on mobile.`,
        component: GroupBlockItem
      },
      {
        type: AdvancedType.COLUMN,
        title: "Column",
        description: /* @__PURE__ */ React__default.createElement(Stack$4, {
          vertical: true,
          spacing: "none"
        }, /* @__PURE__ */ React__default.createElement(TextStyle, null, 'Columns enable you to horizontally organize the content within your sections. They must be located under "Section" block in order to be considered by the engine. To be responsive, columns are expressed in terms of percentage.'), /* @__PURE__ */ React__default.createElement(TextStyle, null, "Every single column has to contain something because they are responsive containers, and will be vertically stacked on a mobile view.")),
        component: ColumnBlockItem
      }
    ]
  }
];
BlockMarketManager.addCategories(defaultCategories$1);
const BlocksPanel = (props) => {
  const { isDragging } = useHoverIdx();
  const [visible, setVisible] = useState(false);
  const [ele, setEle] = useState(null);
  const [categories, setCategories] = useState(BlockMarketManager.getCategories());
  useEffect(() => {
    if (!isDragging) {
      setVisible(false);
    }
  }, [isDragging]);
  useEffect(() => {
    const onChange = (c) => {
      setCategories(c);
    };
    BlockMarketManager.subscribe(onChange);
    return () => {
      BlockMarketManager.subscribe(onChange);
    };
  }, []);
  const toggleVisible = useCallback(() => {
    setVisible((v) => !v);
  }, []);
  const filterCategories = useMemo(() => {
    return categories.filter((item2) => item2.blocks.length > 0);
  }, [categories]);
  return useMemo(() => /* @__PURE__ */ React__default.createElement("div", {
    ref: setEle,
    style: { position: "relative" }
  }, /* @__PURE__ */ React__default.createElement("div", {
    onClick: toggleVisible
  }, props.children), ele && visible && createPortal(/* @__PURE__ */ React__default.createElement("div", {
    className: styles$6.BlocksPanel,
    style: {
      pointerEvents: isDragging ? "none" : void 0,
      position: "fixed",
      width: isDragging ? 0 : 650,
      backgroundColor: "var(--color-bg-2)",
      zIndex: 200,
      left: 60,
      maxHeight: "85vh",
      transition: "width .5s",
      boxShadow: "0 1px 5px 0 rgb(0 0 0 / 12%), 0 2px 10px 0 rgb(0 0 0 / 8%), 0 1px 20px 0 rgb(0 0 0 / 8%)"
    }
  }, /* @__PURE__ */ React__default.createElement(Card$1, {
    bodyStyle: { padding: 0 },
    title: "Drag block",
    extra: /* @__PURE__ */ React__default.createElement("div", {
      className: styles$6.closeBtn
    }, /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: "icon-close",
      onClick: toggleVisible
    }))
  }, /* @__PURE__ */ React__default.createElement(Tabs$1, {
    tabPosition: "left",
    size: "large"
  }, filterCategories.map((category, index2) => /* @__PURE__ */ React__default.createElement(Tabs$1.TabPane, {
    style: {
      padding: 0,
      overflow: "auto",
      height: 500
    },
    key: category.title,
    title: /* @__PURE__ */ React__default.createElement("div", {
      style: {
        paddingTop: index2 === 0 ? 5 : void 0,
        paddingBottom: 10
      }
    }, category.title)
  }, /* @__PURE__ */ React__default.createElement(BlockPanelItem, {
    category
  })))))), ele)), [filterCategories, ele, isDragging, props.children, toggleVisible, visible]);
};
const BlockPanelItem = React__default.memo((props) => {
  return /* @__PURE__ */ React__default.createElement(Tabs$1, {
    tabPosition: "left"
  }, props.category.blocks.map((block2, index2) => {
    return /* @__PURE__ */ React__default.createElement(Tabs$1.TabPane, {
      style: { padding: 0, height: 500 },
      key: block2.title,
      title: /* @__PURE__ */ React__default.createElement(Stack$4, {
        alignment: "center",
        spacing: "extraTight"
      }, /* @__PURE__ */ React__default.createElement("div", {
        className: styles$6.blockItem
      }, block2.title), block2.description && /* @__PURE__ */ React__default.createElement(Help, {
        title: block2.description
      }))
    }, /* @__PURE__ */ React__default.createElement("div", {
      className: "small-scrollbar",
      style: {
        maxHeight: "100%",
        overflow: "auto",
        paddingRight: 10,
        overflowX: "hidden",
        padding: "24px 48px 24px 24px"
      }
    }, block2.component && /* @__PURE__ */ React__default.createElement(block2.component, null)));
  }));
});
function DragIcon(props) {
  const block2 = BlockManager.getBlockByType(props.type);
  return /* @__PURE__ */ React__default.createElement(BlockAvatarWrapper, {
    type: props.type,
    payload: props.payload
  }, /* @__PURE__ */ React__default.createElement(Button$4, {
    type: "text",
    title: block2 == null ? void 0 : block2.name,
    icon: /* @__PURE__ */ React__default.createElement(IconFont, {
      iconName: getIconNameByBlockType(props.type),
      style: {
        fontSize: 16,
        textAlign: "center",
        cursor: "move",
        color: props.color
      }
    })
  }));
}
function ShortcutToolbar() {
  const blocksPanelRef = useRef(null);
  return /* @__PURE__ */ React__default.createElement(Stack$4, {
    vertical: true,
    alignment: "center",
    distribution: "center"
  }, /* @__PURE__ */ React__default.createElement(BlocksPanel, null, /* @__PURE__ */ React__default.createElement("div", {
    ref: blocksPanelRef
  })), /* @__PURE__ */ React__default.createElement(DragIcon, {
    type: AdvancedType.TEXT,
    color: "rgb(110, 215, 135)",
    payload: { attributes: { padding: "0px 25px 0px 25px", "align": "center" } }
  }), /* @__PURE__ */ React__default.createElement(DragIcon, {
    payload: { attributes: { padding: "0px 0px 0px 0px" } },
    type: AdvancedType.IMAGE,
    color: "rgb(250, 208, 97)"
  }), /* @__PURE__ */ React__default.createElement(DragIcon, {
    type: AdvancedType.BUTTON,
    color: "rgb(238,144,172)"
  }), /* @__PURE__ */ React__default.createElement(DragIcon, {
    type: AdvancedType.SOCIAL,
    color: "rgb(111,206,236) "
  }), /* @__PURE__ */ React__default.createElement(DragIcon, {
    type: AdvancedType.NAVBAR,
    color: "rgb(191,24,84)"
  }), /* @__PURE__ */ React__default.createElement(DragIcon, {
    type: AdvancedType.DIVIDER,
    color: "rgb(71,67,239)"
  }), /* @__PURE__ */ React__default.createElement(DragIcon, {
    type: AdvancedType.SPACER,
    color: "#ccc"
  }), /* @__PURE__ */ React__default.createElement(DragIcon, {
    color: "rgb(24,201,137)",
    payload: {
      children: [
        {
          type: AdvancedType.COLUMN,
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 0px 0px 0px",
            border: "none",
            "vertical-align": "top"
          },
          children: []
        },
        {
          type: AdvancedType.COLUMN,
          data: {
            value: {}
          },
          attributes: {
            padding: "0px 0px 0px 0px",
            border: "none",
            "vertical-align": "top"
          },
          children: []
        }
      ]
    },
    type: AdvancedType.SECTION
  }), /* @__PURE__ */ React__default.createElement(IconFont, {
    onClick: () => {
      var _a;
      return (_a = blocksPanelRef.current) == null ? void 0 : _a.click();
    },
    iconName: "icon-more",
    style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: 30,
      height: 30,
      borderRadius: "50%",
      color: "var(--color-text-2)",
      boxShadow: "0 0 12px -3px var(--color-text-2)",
      fontSize: 18
    }
  }));
}
function SourceCodePanel() {
  const { setValueByIdx, focusBlock, values } = useBlock();
  const { focusIdx } = useFocusIdx();
  const [mjmlText, setMjmlText] = useState("");
  const { pageData } = useEditorContext();
  const { mergeTags } = useEditorProps();
  const code = useMemo(() => {
    if (!focusBlock)
      return "";
    return JSON.stringify(focusBlock, null, 2) || "";
  }, [focusBlock]);
  const onChangeCode = useCallback((event) => {
    try {
      const parseValue = JSON.parse(JSON.stringify(eval("(" + event.target.value + ")")));
      const block = BlockManager.getBlockByType(parseValue.type);
      if (!block) {
        throw new Error("Invalid content");
      }
      if (!parseValue.data || !parseValue.data.value || !parseValue.attributes || !Array.isArray(parseValue.children)) {
        throw new Error("Invalid content");
      }
      setValueByIdx(focusIdx, parseValue);
    } catch (error2) {
      Message$1.error((error2 == null ? void 0 : error2.message) || error2);
    }
  }, [focusIdx, setValueByIdx]);
  const onMjmlChange = useCallback((event2) => {
    try {
      const parseValue2 = MjmlToJson(event2.target.value);
      if (parseValue2.type !== BasicType.PAGE) {
        const parentBlock = getParentByIdx(values, focusIdx);
        const parseBlock = BlockManager.getBlockByType(parseValue2.type);
        if (!(parseBlock == null ? void 0 : parseBlock.validParentType.includes(parentBlock == null ? void 0 : parentBlock.type))) {
          throw new Error("Invalid content");
        }
      } else if (focusIdx !== getPageIdx()) {
        throw new Error("Invalid content");
      }
      setValueByIdx(focusIdx, parseValue2);
    } catch (error2) {
      Message$1.error("Invalid content");
    }
  }, [focusIdx, setValueByIdx, values]);
  const onChangeMjmlText = useCallback((value) => {
    setMjmlText(value);
  }, []);
  useEffect(() => {
    focusBlock && setMjmlText(JsonToMjml({
      idx: focusIdx,
      data: focusBlock,
      context: pageData,
      mode: "production",
      dataSource: lodash.exports.cloneDeep(mergeTags)
    }));
  }, [focusBlock, focusIdx, pageData, mergeTags]);
  if (!focusBlock)
    return null;
  return /* @__PURE__ */ React__default.createElement(Collapse$1, null, /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "json",
    header: "Json source",
    contentStyle: { padding: "8px 13px" }
  }, /* @__PURE__ */ React__default.createElement(Input$5.TextArea, {
    key: code,
    defaultValue: code,
    autoSize: { maxRows: 25 },
    onBlur: onChangeCode
  })), /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
    name: "mjml",
    header: "MJML source",
    contentStyle: { padding: "8px 13px" }
  }, /* @__PURE__ */ React__default.createElement(Input$5.TextArea, {
    key: code,
    value: mjmlText,
    autoSize: { maxRows: 25 },
    onChange: onChangeMjmlText,
    onBlur: onMjmlChange
  })));
}
function Toolbar() {
  const { moveBlock, copyBlock, removeBlock, focusBlock: focusBlock2 } = useBlock();
  const { focusIdx: focusIdx2, setFocusIdx } = useFocusIdx();
  const { modal, setModalVisible } = useAddToCollection();
  const props = useEditorProps();
  const isPage = (focusBlock2 == null ? void 0 : focusBlock2.type) === BasicType.PAGE;
  const isText = isTextBlock(focusBlock2 == null ? void 0 : focusBlock2.type);
  const handleAddToCollection = () => {
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
    setModalVisible(true);
  };
  const handleCopy = (ev) => {
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
    copyBlock(focusIdx2);
  };
  const handleDelete = () => {
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
    removeBlock(focusIdx2);
  };
  const handleSelectParent = () => {
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
    setFocusIdx(getParentIdx(focusIdx2));
  };
  if (isText)
    return null;
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("div", {
    id: "easy-email-extensions-InteractivePrompt-Toolbar",
    style: {
      height: 0,
      zIndex: 100
    }
  }, /* @__PURE__ */ React__default.createElement("div", {
    style: {
      fontSize: 14,
      lineHeight: "22px",
      pointerEvents: "auto",
      color: "#ffffff",
      transform: "translateY(-100%)",
      display: "inline-flex"
    }
  }, /* @__PURE__ */ React__default.createElement("div", {
    style: {
      color: "#ffffff",
      backgroundColor: "var(--selected-color)",
      height: "22px",
      display: "inline-flex",
      padding: "1px 5px",
      boxSizing: "border-box",
      whiteSpace: "nowrap",
      maxWidth: 300,
      overflow: "hidden"
    }
  }, focusBlock2 && getBlockTitle(focusBlock2, false)), /* @__PURE__ */ React__default.createElement("div", {
    onClick: (e) => {
      e.stopPropagation();
    },
    onMouseDown: (ev) => {
      ev.preventDefault();
    },
    style: {
      display: isPage ? "none" : "flex",
      alignItems: "center",
      justifyContent: "center",
      pointerEvents: "auto"
    }
  }, /* @__PURE__ */ React__default.createElement(ToolItem, {
    width: 12,
    iconName: "icon-back-parent",
    onClick: handleSelectParent
  }), /* @__PURE__ */ React__default.createElement(ToolItem, {
    iconName: "icon-copy",
    onClick: handleCopy
  }), props.onAddCollection && /* @__PURE__ */ React__default.createElement(ToolItem, {
    iconName: "icon-collection",
    onClick: handleAddToCollection
  }), /* @__PURE__ */ React__default.createElement(ToolItem, {
    iconName: "icon-delete",
    onClick: handleDelete
  })))), modal);
}
function ToolItem(props) {
  return /* @__PURE__ */ React__default.createElement("div", {
    onClick: props.onClick,
    style: {
      color: "#ffffff",
      backgroundColor: "var(--selected-color)",
      height: 22,
      fontSize: props.width || 14,
      lineHeight: "22px",
      width: 22,
      display: "flex",
      pointerEvents: "auto",
      cursor: "pointer",
      justifyContent: "center"
    },
    className: classnames("iconfont", props.iconName)
  });
}
function FocusTooltip() {
  const { focusBlock: focusBlock2 } = useBlock();
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const { focusBlockNode } = useFocusBlockLayout();
  const isPage = (focusBlock2 == null ? void 0 : focusBlock2.type) === BasicType.PAGE;
  if (!focusBlockNode || !focusBlock2)
    return null;
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, createPortal(/* @__PURE__ */ React__default.createElement("div", {
    id: "easy-email-extensions-InteractivePrompt-FocusTooltip",
    style: {
      position: "absolute",
      width: "100%",
      height: "100%",
      pointerEvents: "none",
      left: 0,
      top: 0,
      zIndex: 1
    }
  }, /* @__PURE__ */ React__default.createElement("style", null, `
                .email-block {
                  position: relative;
                }

            `), /* @__PURE__ */ React__default.createElement("div", {
    style: {
      position: "absolute",
      zIndex: 9999,
      right: 0,
      top: "50%",
      display: isPage ? "none" : void 0
    }
  }, /* @__PURE__ */ React__default.createElement(BlockAvatarWrapper, {
    idx: focusIdx2,
    type: focusBlock2.type,
    action: "move"
  }, /* @__PURE__ */ React__default.createElement("div", {
    style: {
      position: "absolute",
      backgroundColor: "var(--selected-color)",
      color: "#ffffff",
      height: "28px",
      width: "28px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transform: "translate(-50%, -50%)",
      borderRadius: "50%",
      cursor: "grab",
      pointerEvents: "auto",
      WebkitUserDrag: "element"
    }
  }, /* @__PURE__ */ React__default.createElement(IconFont, {
    iconName: "icon-move",
    style: { color: "#fff", cursor: "grab" }
  })))), /* @__PURE__ */ React__default.createElement("div", {
    style: {
      position: "absolute",
      fontSize: 14,
      zIndex: 2,
      left: 0,
      top: 0,
      width: "100%",
      height: "100%",
      outlineOffset: "-2px",
      outline: "2px solid var(--selected-color)"
    }
  }), /* @__PURE__ */ React__default.createElement("div", {
    style: {
      position: "absolute",
      fontSize: 14,
      zIndex: 3,
      left: 0,
      top: 0,
      width: "0%",
      height: "100%"
    }
  }, /* @__PURE__ */ React__default.createElement(Toolbar, null))), focusBlockNode));
}
function awaitForElement(idx) {
  let promiseObj = {
    cancel: () => {
    },
    promise: Promise.resolve()
  };
  promiseObj.promise = new Promise((resolve) => {
    const ele = getBlockNodeByIdx(idx);
    if (ele) {
      resolve(ele);
      return;
    }
    const timer = setInterval(() => {
      const ele2 = getBlockNodeByIdx(idx);
      if (ele2) {
        resolve(ele2);
        clearInterval(timer);
      }
    }, 50);
    promiseObj.cancel = () => {
      clearInterval(timer);
    };
  });
  return promiseObj;
}
function HoverTooltip() {
  const { hoverIdx, direction, isDragging } = useHoverIdx();
  const lazyHoverIdx = useLazyState(hoverIdx, 60);
  const { focusIdx: focusIdx2 } = useFocusIdx();
  const [isTop, setIsTop] = useState(false);
  const { initialized } = useEditorContext();
  const [blockNode, setBlockNode] = useState(null);
  const rootRef = useRef(null);
  useEffect(() => {
    if (initialized) {
      rootRef.current = getEditorRoot().getBoundingClientRect();
    }
  }, [initialized]);
  useEffect(() => {
    const rootBounds = rootRef.current;
    if (!initialized)
      return;
    if (lazyHoverIdx) {
      const promiseObj = awaitForElement(lazyHoverIdx);
      promiseObj.promise.then((blockNode2) => {
        if (rootBounds) {
          const { top } = blockNode2.getBoundingClientRect();
          setIsTop(rootBounds.top === top);
        }
        setBlockNode(blockNode2);
      });
      return () => {
        promiseObj.cancel();
      };
    } else {
      setBlockNode(null);
    }
  }, [lazyHoverIdx, initialized]);
  const block2 = useMemo(() => {
    return blockNode ? BlockManager.getBlockByType(getNodeTypeFromClassName(blockNode.classList)) : null;
  }, [blockNode]);
  if (focusIdx2 === hoverIdx && !isDragging)
    return null;
  if (!block2 || !blockNode)
    return null;
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, createPortal(/* @__PURE__ */ React__default.createElement("div", {
    id: "easy-email-extensions-InteractivePrompt-HoverTooltip",
    style: {
      position: "absolute",
      height: "100%",
      width: "100%",
      top: 0,
      left: 0,
      zIndex: 2,
      pointerEvents: "none"
    }
  }, /* @__PURE__ */ React__default.createElement(TipNode, {
    type: isDragging ? "drag" : "hover",
    lineWidth: 1,
    title: block2.name,
    direction: isTop && direction === "top" ? "noEnoughTop" : direction,
    isDragging
  })), blockNode));
}
function TipNode(props) {
  const { direction, title: title2, lineWidth, type } = props;
  const dragTitle = useMemo(() => {
    if (direction === "top" || direction === "noEnoughTop") {
      return `Insert before ${title2}`;
    } else if (direction === "bottom") {
      return `Insert after ${title2}`;
    } else if (direction === "right" || direction === "left") {
      return "Drag here";
    }
    return `Drag to ${title2}`;
  }, [direction, title2]);
  const color2 = useMemo(() => {
    if (type === "drag") {
      return "var(--hover-color)";
    } else {
      return "var(--hover-color)";
    }
  }, [type]);
  return /* @__PURE__ */ React__default.createElement("div", {
    style: {
      position: "absolute",
      left: 0,
      top: 0,
      fontSize: 14,
      zIndex: 1,
      color: "#000",
      width: "100%",
      height: "100%",
      pointerEvents: "none",
      textAlign: "left"
    }
  }, /* @__PURE__ */ React__default.createElement("style", null, `
        .email-block {
          position: relative;
        }

      `), /* @__PURE__ */ React__default.createElement("div", {
    style: {
      position: "absolute",
      left: 0,
      top: 0,
      width: "100%",
      height: "100%",
      outlineOffset: `-${lineWidth}px`,
      outline: `${lineWidth}px solid ${color2}`
    }
  }, type === "hover" && /* @__PURE__ */ React__default.createElement("div", {
    style: {
      position: "absolute",
      left: 0,
      top: 0
    }
  }, /* @__PURE__ */ React__default.createElement("div", {
    style: {
      backgroundColor: color2,
      color: "#ffffff",
      height: "22px",
      lineHeight: "22px",
      display: "inline-flex",
      padding: "1px 5px",
      boxSizing: "border-box",
      whiteSpace: "nowrap",
      fontFamily: "sans-serif",
      transform: "translateY(-100%)"
    }
  }, title2))), props.isDragging && /* @__PURE__ */ React__default.createElement("div", {
    style: __spreadValues({
      position: "absolute",
      top: 0,
      left: 0,
      width: "100%",
      height: "100%"
    }, directionImage[props.direction || "none"])
  }, /* @__PURE__ */ React__default.createElement("div", {
    style: __spreadValues({
      position: "absolute",
      color: "#ffffff",
      backgroundColor: color2,
      lineHeight: "22px",
      display: "inline-flex",
      maxWidth: "100%",
      textAlign: "center",
      whiteSpace: "nowrap",
      padding: "1px 5px"
    }, positionStyleMap[props.direction || "none"])
  }, dragTitle)));
}
const positionStyleMap = {
  noEnoughTop: {
    top: "0%",
    left: "50%",
    padding: "1px 5px",
    transform: "translate(-50%, 0%)"
  },
  top: {
    top: "0%",
    left: "50%",
    padding: "1px 5px",
    transform: "translate(-50%, -50%)"
  },
  bottom: {
    top: "100%",
    left: "50%",
    padding: "1px 5px",
    transform: "translate(-50%, -50%)"
  },
  left: {
    top: "50%",
    left: "0%",
    padding: "5px 1px",
    writingMode: "vertical-lr",
    transform: "translate(0, -50%)"
  },
  right: {
    top: "50%",
    right: "0%",
    padding: "5px 1px",
    writingMode: "vertical-lr",
    transform: "translate(0, -50%)"
  },
  none: {
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)"
  }
};
const directionImage = {
  top: {
    backgroundImage: `linear-gradient(
      to bottom,
      var(--hover-color) 3px ,
      transparent 3px
    )`
  },
  bottom: {
    backgroundImage: `linear-gradient(
      to top,
      var(--hover-color) 3px ,
      transparent 3px
    )`
  },
  left: {
    backgroundImage: `linear-gradient(
      to right,
      var(--hover-color) 3px ,
      transparent 3px
    )`
  },
  right: {
    backgroundImage: `linear-gradient(
      to left,
      var(--hover-color) 3px ,
      transparent 3px
    )`
  },
  none: {}
};
function InteractivePrompt() {
  const { activeTab } = useActiveTab();
  const isActive = activeTab === ActiveTabKeys.EDIT;
  if (!isActive)
    return null;
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(HoverTooltip, null), /* @__PURE__ */ React__default.createElement(FocusTooltip, null));
}
const SimpleLayout$1 = "_SimpleLayout_pu31r_1";
const customScrollBar = "_customScrollBar_pu31r_20";
const customScrollBarV2 = "_customScrollBarV2_pu31r_36";
var styles$4 = {
  SimpleLayout: SimpleLayout$1,
  customScrollBar,
  customScrollBarV2
};
var en = { exports: {} };
(function(module, exports) {
  !function(e, n) {
    module.exports = n();
  }(commonjsGlobal, function() {
    return { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") };
  });
})(en);
var Calendar = {
  formatYear: "YYYY",
  formatMonth: "MMM YYYY",
  today: "Today",
  view: {
    month: "Month",
    year: "Year",
    week: "Week",
    day: "Day"
  },
  month: {
    long: {
      January: "January",
      February: "February",
      March: "March",
      April: "April",
      May: "May",
      June: "June",
      July: "July",
      August: "August",
      September: "September",
      October: "October",
      November: "November",
      December: "December"
    },
    short: {
      January: "Jan",
      February: "Feb",
      March: "Mar",
      April: "Apr",
      May: "May",
      June: "Jun",
      July: "Jul",
      August: "Aug",
      September: "Sept",
      October: "Oct",
      November: "Nov",
      December: "Dec"
    }
  },
  week: {
    long: {
      self: "Week",
      monday: "Monday",
      tuesday: "Tuesday",
      wednesday: "Wednesday",
      thursday: "Thursday",
      friday: "Friday",
      saturday: "Saturday",
      sunday: "Sunday"
    },
    short: {
      self: "Week",
      monday: "Mon",
      tuesday: "Tue",
      wednesday: "Wed",
      thursday: "Thu",
      friday: "Fri",
      saturday: "Sat",
      sunday: "Sun"
    }
  }
};
var enUS = {
  locale: "en-US",
  dayjsLocale: "en",
  Calendar,
  DatePicker: {
    Calendar,
    placeholder: {
      date: "Please select date",
      week: "Please select week",
      month: "Please select month",
      year: "Please select year",
      quarter: "Please select quarter"
    },
    placeholders: {
      date: ["Start date", "End date"],
      week: ["Start week", "End week"],
      month: ["Start month", "End month"],
      year: ["Start year", "End year"],
      quarter: ["Start quarter", "End quarter"]
    },
    selectTime: "Select time",
    selectDate: "Select Date",
    today: "Today",
    now: "Now",
    ok: "Ok"
  },
  Drawer: {
    okText: "Ok",
    cancelText: "Cancel"
  },
  Empty: {
    noData: "No data"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Pagination: {
    goto: "Goto",
    page: "Page",
    countPerPage: " / Page",
    total: "Total: {0}",
    prev: "Go to previous page",
    next: "Go to next page",
    currentPage: "page {0}",
    prevSomePages: "Previous {0} pages",
    nextSomePages: "Next {0} pages",
    pageSize: "page size"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Table: {
    okText: "Ok",
    resetText: "Reset",
    sortAscend: "Click to sort ascending",
    sortDescend: "Click to sort descending",
    cancelSort: "Click to cancel sorting"
  },
  TimePicker: {
    ok: "OK",
    placeholder: "Select time",
    placeholders: ["Start time", "End time"],
    now: "Now"
  },
  Progress: {
    success: "Completed",
    error: "Failed"
  },
  Upload: {
    start: "Start",
    cancel: "Cancel",
    delete: "Delete",
    reupload: "Click to retry",
    upload: "Upload",
    preview: "Preview",
    drag: "Click or drag file to this area to upload",
    dragHover: "Release to upload",
    error: "Upload Error"
  },
  Typography: {
    copy: "Copy",
    copied: "Copied",
    edit: "Edit",
    fold: "Fold",
    unfold: "Unfold"
  },
  Transfer: {
    resetText: "Reset"
  },
  ImagePreview: {
    fullScreen: "Full Screen",
    rotateRight: "Rotate Right",
    rotateLeft: "Rotate Left",
    zoomIn: "Zoom In",
    zoomOut: "Zoom Out",
    originalSize: "Original Size"
  }
};
var stylesText = ".easy-email-merge-tag{font-size:inherit;outline:1px solid #4e5969!important;outline-offset:0px;padding:0 8px;border-radius:4px;cursor:default!important;transition:all .1s linear;border:none;font-weight:inherit;font-style:inherit;outline-color:#00a0ac!important;color:inherit;background-color:#ebf9fc}.easy-email-merge-tag-popover{position:absolute;top:-10px;left:50%;transform:translate(-50%,-100%)}.easy-email-merge-tag-popover{line-height:1.3;background-color:#fff;width:360px;border:1px solid #e5e6eb;border-radius:8px;position:absolute;top:calc(100% + 20px);left:50%;transform:translate(-50%);z-index:10;padding:20px;font-family:-apple-system,BlinkMacSystemFont,San Francisco,Segoe UI,Roboto,Helvetica Neue,sans-serif}.easy-email-merge-tag-popover h3{margin:0;font-size:12px;color:#202223;text-transform:uppercase;display:flex;justify-content:space-between;align-items:center}.easy-email-merge-tag-popover .easy-email-merge-tag-popover-desc{font-size:14px;color:#6d7175}.easy-email-merge-tag-popover .easy-email-merge-tag-popover-desc-label{font-weight:400;line-height:15px;border:1px solid #6d7175;border-radius:4px;text-transform:none;letter-spacing:normal;position:relative;display:flex;align-items:center;color:#202223;cursor:text;font-size:14px}.easy-email-merge-tag-popover input{text-transform:none;letter-spacing:normal;position:relative;z-index:20;display:block;flex:1 1;width:100%;min-width:0;min-height:25px;margin:0;padding:5px 12px;background:none;border:1px solid transparent;font-family:inherit;font-size:inherit;font-weight:inherit;appearance:none;caret-color:#202223;color:#202223}.easy-email-merge-tag-popover input:focus{outline:none}.easy-email-merge-tag-popover .easy-email-merge-tag-popover-desc-label-count{color:#6d7175;z-index:20;margin:0 12px 0 3.5px;pointer-events:none;text-align:right}.easy-email-merge-tag-popover .easy-email-merge-tag-popover-desc-label-button{font-size:14px;text-align:right;margin-top:10px;font-weight:normal;margin-bottom:5px}.easy-email-merge-tag-popover .easy-email-merge-tag-popover-desc-label-button button{color:var(--selected-color);padding:4px 8px;border-radius:4px;transition:all .1s linear;cursor:pointer;outline:none;background-color:transparent;border:1px solid transparent}.easy-email-merge-tag-popover .easy-email-merge-tag-popover-desc-label-button button:focus,.easy-email-merge-tag-popover .easy-email-merge-tag-popover-desc-label-button button:hover{color:var(--selected-color);background-color:#f2f3f5}.easy-email-merge-tag-popover .easy-email-merge-tag-popover-container{position:relative;z-index:2}\n";
const removeAllActiveBadge = () => {
  getShadowRoot().querySelectorAll(".easy-email-merge-tag").forEach((item2) => {
    item2.classList.remove("easy-email-merge-tag-focus");
  });
  getShadowRoot().querySelectorAll(".easy-email-merge-tag-popover");
};
function MergeTagBadgePrompt() {
  const { initialized } = useEditorContext();
  const popoverRef = useRef(null);
  const { onChangeMergeTag, mergeTags: mergeTags2 } = useEditorProps();
  const [text, setText] = useState("");
  const { setRangeByElement } = useSelectionRange();
  const root2 = initialized && getShadowRoot();
  const [target2, setTarget] = React__default.useState(null);
  const targetRef = useRefState(target2);
  const textContainer = getBlockNodeByChildEle(target2);
  const focusMergeTag = useCallback((ele) => {
    if (!ele)
      return;
    setRangeByElement(ele);
  }, [setRangeByElement]);
  useEffect(() => {
    const onBlur3 = (ev) => {
      if (ev.target === getEditorRoot()) {
        return;
      }
      setTarget(null);
    };
    window.addEventListener("click", onBlur3);
    return () => {
      window.removeEventListener("click", onBlur3);
    };
  }, [targetRef, popoverRef]);
  const onClose = useCallback(() => {
    let ele = targetRef.current;
    setTimeout(() => {
      if (!ele)
        return;
      focusMergeTag(ele);
    }, 100);
    setTarget(null);
  }, [focusMergeTag, targetRef]);
  useEffect(() => {
    if (!root2)
      return;
    const onClick2 = (e) => {
      var _a;
      removeAllActiveBadge();
      const target22 = e.target;
      if (target22 instanceof HTMLInputElement && target22.classList.contains("easy-email-merge-tag")) {
        target22.classList.add("easy-email-merge-tag-focus");
        const namePath = target22.value;
        if (!onChangeMergeTag) {
          focusMergeTag(target22);
          return;
        }
        setText(lodash.exports.get(mergeTags2, namePath, ""));
        setTarget(target22);
      } else {
        if ((_a = popoverRef.current) == null ? void 0 : _a.contains(e.target))
          return;
        setTarget(null);
      }
    };
    root2.addEventListener("click", onClick2);
    return () => {
      root2.removeEventListener("click", onClick2);
    };
  }, [focusMergeTag, mergeTags2, onChangeMergeTag, root2]);
  const onChange = useCallback((ev) => {
    setText(ev.target.value);
  }, []);
  const onSave = useCallback(() => {
    if (!(target2 instanceof HTMLInputElement))
      return;
    onChangeMergeTag == null ? void 0 : onChangeMergeTag(target2.value, text);
    onClose();
  }, [onChangeMergeTag, onClose, target2, text]);
  const onClick = useCallback((ev) => {
    ev.stopPropagation();
  }, []);
  useEffect(() => {
    const onKeyDown = (e) => {
      var _a;
      if (((_a = e.code) == null ? void 0 : _a.toLocaleLowerCase()) === "escape") {
        onClose();
      }
    };
    window.addEventListener("keydown", onKeyDown);
    return () => {
      window.removeEventListener("keydown", onKeyDown);
    };
  }, [onClose, onSave]);
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, root2 && createPortal(/* @__PURE__ */ React__default.createElement("style", null, stylesText), root2), textContainer && createPortal(/* @__PURE__ */ React__default.createElement("div", {
    ref: popoverRef,
    onClick,
    className: classnames("easy-email-merge-tag-popover")
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-merge-tag-popover-container"
  }, /* @__PURE__ */ React__default.createElement("h3", null, /* @__PURE__ */ React__default.createElement("span", null, "Default value"), /* @__PURE__ */ React__default.createElement(IconFont, {
    style: { color: "rgb(92, 95, 98)" },
    iconName: "icon-close",
    onClick: onClose
  })), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-merge-tag-popover-desc"
  }, /* @__PURE__ */ React__default.createElement("p", null, "If a personalized text value isn't available, then a default value is shown."), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-merge-tag-popover-desc-label"
  }, /* @__PURE__ */ React__default.createElement("input", {
    autoFocus: true,
    value: text,
    onChange,
    type: "text",
    autoComplete: "off",
    maxLength: 40
  }), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-merge-tag-popover-desc-label-count"
  }, text.length, "/40")), /* @__PURE__ */ React__default.createElement("div", {
    className: "easy-email-merge-tag-popover-desc-label-button"
  }, /* @__PURE__ */ React__default.createElement("button", {
    onClick: onSave
  }, "Save"))))), textContainer));
}
const SimpleLayout = (props) => {
  const { height: containerHeight } = useEditorProps();
  const { showSourceCode = true, defaultShowLayer = true } = props;
  const [collapsed, setCollapsed] = useState(!defaultShowLayer);
  return /* @__PURE__ */ React__default.createElement(ConfigProvider, {
    locale: enUS
  }, /* @__PURE__ */ React__default.createElement(Layout$1, {
    className: styles$4.SimpleLayout,
    style: {
      display: "flex",
      width: "100%",
      overflow: "hidden",
      minWidth: 1400
    }
  }, /* @__PURE__ */ React__default.createElement(Layout$1.Sider, {
    style: { paddingRight: 0 },
    collapsed,
    collapsible: true,
    trigger: null,
    breakpoint: "xl",
    collapsedWidth: 60,
    width: 300
  }, /* @__PURE__ */ React__default.createElement(Card$1, {
    bodyStyle: { padding: 0 },
    style: { border: "none" }
  }, /* @__PURE__ */ React__default.createElement(Card$1.Grid, {
    style: { width: 60, textAlign: "center" }
  }, /* @__PURE__ */ React__default.createElement(ShortcutToolbar, null), /* @__PURE__ */ React__default.createElement(Button$4, {
    style: {
      marginTop: 30,
      marginLeft: "auto",
      marginRight: "auto"
    },
    icon: collapsed ? /* @__PURE__ */ React__default.createElement(IconRight$1, null) : /* @__PURE__ */ React__default.createElement(IconLeft$1, null),
    shape: "round",
    onClick: () => setCollapsed((v) => !v)
  })), /* @__PURE__ */ React__default.createElement(Card$1.Grid, {
    className: styles$4.customScrollBar,
    style: {
      flex: 1,
      paddingBottom: 50,
      border: "none",
      height: containerHeight,
      overflowY: "auto",
      overflowX: "hidden"
    }
  }, /* @__PURE__ */ React__default.createElement(Card$1, {
    title: "Layout",
    style: { border: "none" },
    headerStyle: { height: 50 }
  }, !collapsed && /* @__PURE__ */ React__default.createElement(BlockLayer, {
    renderTitle: props.renderTitle
  }))))), /* @__PURE__ */ React__default.createElement(Layout$1, {
    style: { height: containerHeight }
  }, props.children), /* @__PURE__ */ React__default.createElement(Layout$1.Sider, {
    style: {
      height: containerHeight,
      minWidth: 300,
      maxWidth: 350,
      width: 350
    },
    className: styles$4.rightSide
  }, /* @__PURE__ */ React__default.createElement(Card$1, {
    size: "small",
    id: "rightSide",
    style: {
      maxHeight: "100%",
      height: "100%",
      borderLeft: "none"
    },
    bodyStyle: { padding: 0 },
    className: styles$4.customScrollBarV2
  }, /* @__PURE__ */ React__default.createElement(Tabs$1, {
    className: styles$4.layoutTabs
  }, /* @__PURE__ */ React__default.createElement(Tabs$1.TabPane, {
    title: /* @__PURE__ */ React__default.createElement("div", {
      style: { height: 31, lineHeight: "31px" }
    }, "Configuration")
  }, /* @__PURE__ */ React__default.createElement(AttributePanel, null)), showSourceCode && /* @__PURE__ */ React__default.createElement(Tabs$1.TabPane, {
    destroyOnHide: true,
    key: "Source code",
    title: /* @__PURE__ */ React__default.createElement("div", {
      style: { height: 31, lineHeight: "31px" }
    }, "Source code")
  }, /* @__PURE__ */ React__default.createElement(SourceCodePanel, null))))), /* @__PURE__ */ React__default.createElement(InteractivePrompt, null), /* @__PURE__ */ React__default.createElement(MergeTagBadgePrompt, null)));
};
const StandardLayout$1 = "_StandardLayout_xv0bc_1";
var styles$3 = {
  StandardLayout: StandardLayout$1
};
const layoutItem = "_layoutItem_1ajtj_1";
const blockItem = "_blockItem_1ajtj_6";
const blockItemContainer = "_blockItemContainer_1ajtj_16";
var styles$2 = {
  layoutItem,
  blockItem,
  blockItemContainer
};
const ExtensionContext = React__default.createContext({
  categories: []
});
const ExtensionProvider = (props) => {
  const value = lodash.exports.omit(props, "children");
  const valueRef = useRef(value);
  const cacheValue = useMemo(() => {
    if (!lodash.exports.isEqual(value, valueRef)) {
      valueRef.current = value;
    }
    return valueRef.current;
  }, [value, valueRef]);
  return /* @__PURE__ */ React__default.createElement(ExtensionContext.Provider, {
    value: cacheValue
  }, props.children);
};
function useExtensionProps() {
  return useContext(ExtensionContext);
}
function Blocks() {
  const { categories } = useExtensionProps();
  const defaultActiveKey = useMemo(() => [
    ...categories.filter((item2) => item2.active).map((item2) => item2.label)
  ], [categories]);
  return /* @__PURE__ */ React__default.createElement(Collapse$1, {
    defaultActiveKey,
    style: { paddingBottom: 30, minHeight: "100%" }
  }, categories.map((cat, index2) => {
    if (cat.displayType === "column") {
      return /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
        key: index2,
        contentStyle: { padding: "0px 20px" },
        name: cat.label,
        header: cat.label
      }, /* @__PURE__ */ React__default.createElement(Space$1, {
        direction: "vertical"
      }, /* @__PURE__ */ React__default.createElement("div", null)), cat.blocks.map((item2) => /* @__PURE__ */ React__default.createElement(LayoutItem, {
        key: item2.title,
        title: item2.title || "",
        columns: item2.payload
      })), /* @__PURE__ */ React__default.createElement(Space$1, {
        direction: "vertical"
      }, /* @__PURE__ */ React__default.createElement("div", null)));
    }
    if (cat.displayType === "custom") {
      return /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
        key: index2,
        contentStyle: { padding: 0, paddingBottom: 0, paddingTop: 20 },
        name: cat.label,
        header: cat.label
      }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, cat.blocks.map((item2, index22) => {
        return /* @__PURE__ */ React__default.createElement(React__default.Fragment, {
          key: index22
        }, item2);
      })));
    }
    return /* @__PURE__ */ React__default.createElement(Collapse$1.Item, {
      key: index2,
      contentStyle: { padding: 0, paddingBottom: 0, paddingTop: 20 },
      name: cat.label,
      header: cat.label
    }, /* @__PURE__ */ React__default.createElement(Grid.Row, null, cat.blocks.map((item2, index22) => {
      return /* @__PURE__ */ React__default.createElement(BlockItem, __spreadValues({
        key: index22
      }, item2));
    })));
  }));
}
function BlockItem({
  type,
  payload,
  title: title2,
  filterType
}) {
  const block2 = BlockManager.getBlockByType(type);
  return /* @__PURE__ */ React__default.createElement("div", {
    className: styles$2.blockItem
  }, /* @__PURE__ */ React__default.createElement(BlockAvatarWrapper, {
    type,
    payload
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: styles$2.blockItemContainer
  }, /* @__PURE__ */ React__default.createElement(IconFont, {
    style: { fontSize: 20 },
    iconName: getIconNameByBlockType(type)
  }), /* @__PURE__ */ React__default.createElement(Typography$1.Text, {
    style: { marginTop: 10 }
  }, title2 || (block2 == null ? void 0 : block2.name)))));
}
function LayoutItem({
  columns,
  title: title2
}) {
  const [visible, setVisible] = useState(false);
  return /* @__PURE__ */ React__default.createElement("div", null, /* @__PURE__ */ React__default.createElement("p", {
    onClick: () => setVisible((v) => !v),
    style: {
      display: "flex",
      justifyContent: "space-between",
      cursor: "pointer"
    }
  }, /* @__PURE__ */ React__default.createElement("span", null, title2), columns.length > 1 && /* @__PURE__ */ React__default.createElement("span", null, !visible ? /* @__PURE__ */ React__default.createElement(IconCaretRight$1, null) : /* @__PURE__ */ React__default.createElement(IconCaretUp$1, null))), columns.map((item2, index2) => {
    const hide = !visible && index2 !== 0;
    const payload = {
      type: AdvancedType.SECTION,
      attributes: {},
      children: item2.map((col) => ({
        type: AdvancedType.COLUMN,
        attributes: {
          width: col
        },
        data: {
          value: {}
        },
        children: []
      }))
    };
    return /* @__PURE__ */ React__default.createElement("div", {
      key: index2,
      style: {
        height: hide ? 0 : void 0,
        overflow: "hidden",
        marginBottom: hide ? 0 : 20
      }
    }, /* @__PURE__ */ React__default.createElement(BlockAvatarWrapper, {
      type: AdvancedType.SECTION,
      payload
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: {
        border: "1px solid rgb(229, 229, 229)",
        width: "100%",
        padding: 10
      }
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: {
        height: 16,
        border: "1px solid rgb(85, 85, 85)",
        borderRadius: 3,
        display: "flex"
      }
    }, item2.map((column, index22) => {
      return /* @__PURE__ */ React__default.createElement("div", {
        key: index22,
        style: {
          borderRight: index22 === item2.length - 1 ? void 0 : "1px solid rgb(85, 85, 85)",
          height: "100%",
          width: column
        }
      });
    })))));
  }));
}
var OverlayScrollbars$2 = "";
var OverlayScrollbars$1 = { exports: {} };
/*!
 * OverlayScrollbars
 * https://github.com/KingSora/OverlayScrollbars
 *
 * Version: 1.13.3
 *
 * Copyright KingSora | Rene Haas.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 * Date: 20.07.2022
 */
(function(module) {
  (function(global2, factory) {
    module.exports = factory(global2, global2.document, void 0);
  })(typeof window !== "undefined" ? window : commonjsGlobal, function(window2, document2, undefined$1) {
    var PLUGINNAME = "OverlayScrollbars";
    var TYPES = {
      o: "object",
      f: "function",
      a: "array",
      s: "string",
      b: "boolean",
      n: "number",
      u: "undefined",
      z: "null"
    };
    var LEXICON = {
      c: "class",
      s: "style",
      i: "id",
      l: "length",
      p: "prototype",
      ti: "tabindex",
      oH: "offsetHeight",
      cH: "clientHeight",
      sH: "scrollHeight",
      oW: "offsetWidth",
      cW: "clientWidth",
      sW: "scrollWidth",
      hOP: "hasOwnProperty",
      bCR: "getBoundingClientRect"
    };
    var VENDORS = function() {
      var jsCache = {};
      var cssCache = {};
      var cssPrefixes = ["-webkit-", "-moz-", "-o-", "-ms-"];
      var jsPrefixes = ["WebKit", "Moz", "O", "MS"];
      function firstLetterToUpper(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }
      return {
        _cssPrefixes: cssPrefixes,
        _jsPrefixes: jsPrefixes,
        _cssProperty: function(name2) {
          var result = cssCache[name2];
          if (cssCache[LEXICON.hOP](name2))
            return result;
          var uppercasedName = firstLetterToUpper(name2);
          var elmStyle = document2.createElement("div")[LEXICON.s];
          var resultPossibilities;
          var i2 = 0;
          var v;
          var currVendorWithoutDashes;
          for (; i2 < cssPrefixes.length; i2++) {
            currVendorWithoutDashes = cssPrefixes[i2].replace(/-/g, "");
            resultPossibilities = [
              name2,
              cssPrefixes[i2] + name2,
              currVendorWithoutDashes + uppercasedName,
              firstLetterToUpper(currVendorWithoutDashes) + uppercasedName
            ];
            for (v = 0; v < resultPossibilities[LEXICON.l]; v++) {
              if (elmStyle[resultPossibilities[v]] !== undefined$1) {
                result = resultPossibilities[v];
                break;
              }
            }
          }
          cssCache[name2] = result;
          return result;
        },
        _cssPropertyValue: function(property, values2, suffix) {
          var name2 = property + " " + values2;
          var result = cssCache[name2];
          if (cssCache[LEXICON.hOP](name2))
            return result;
          var dummyStyle = document2.createElement("div")[LEXICON.s];
          var possbleValues = values2.split(" ");
          var preparedSuffix = suffix || "";
          var i2 = 0;
          var v = -1;
          var prop;
          for (; i2 < possbleValues[LEXICON.l]; i2++) {
            for (; v < VENDORS._cssPrefixes[LEXICON.l]; v++) {
              prop = v < 0 ? possbleValues[i2] : VENDORS._cssPrefixes[v] + possbleValues[i2];
              dummyStyle.cssText = property + ":" + prop + preparedSuffix;
              if (dummyStyle[LEXICON.l]) {
                result = prop;
                break;
              }
            }
          }
          cssCache[name2] = result;
          return result;
        },
        _jsAPI: function(name2, isInterface, fallback) {
          var i2 = 0;
          var result = jsCache[name2];
          if (!jsCache[LEXICON.hOP](name2)) {
            result = window2[name2];
            for (; i2 < jsPrefixes[LEXICON.l]; i2++)
              result = result || window2[(isInterface ? jsPrefixes[i2] : jsPrefixes[i2].toLowerCase()) + firstLetterToUpper(name2)];
            jsCache[name2] = result;
          }
          return result || fallback;
        }
      };
    }();
    var COMPATIBILITY = function() {
      function windowSize(x) {
        return x ? window2.innerWidth || document2.documentElement[LEXICON.cW] || document2.body[LEXICON.cW] : window2.innerHeight || document2.documentElement[LEXICON.cH] || document2.body[LEXICON.cH];
      }
      function bind(func, thisObj) {
        if (typeof func != TYPES.f) {
          throw "Can't bind function!";
        }
        var proto = LEXICON.p;
        var aArgs = Array[proto].slice.call(arguments, 2);
        var fNOP = function() {
        };
        var fBound = function() {
          return func.apply(this instanceof fNOP ? this : thisObj, aArgs.concat(Array[proto].slice.call(arguments)));
        };
        if (func[proto])
          fNOP[proto] = func[proto];
        fBound[proto] = new fNOP();
        return fBound;
      }
      return {
        wW: bind(windowSize, 0, true),
        wH: bind(windowSize, 0),
        mO: bind(VENDORS._jsAPI, 0, "MutationObserver", true),
        rO: bind(VENDORS._jsAPI, 0, "ResizeObserver", true),
        rAF: bind(VENDORS._jsAPI, 0, "requestAnimationFrame", false, function(func) {
          return window2.setTimeout(func, 1e3 / 60);
        }),
        cAF: bind(VENDORS._jsAPI, 0, "cancelAnimationFrame", false, function(id) {
          return window2.clearTimeout(id);
        }),
        now: function() {
          return Date.now && Date.now() || new Date().getTime();
        },
        stpP: function(event2) {
          if (event2.stopPropagation)
            event2.stopPropagation();
          else
            event2.cancelBubble = true;
        },
        prvD: function(event2) {
          if (event2.preventDefault && event2.cancelable)
            event2.preventDefault();
          else
            event2.returnValue = false;
        },
        page: function(event2) {
          event2 = event2.originalEvent || event2;
          var strPage = "page";
          var strClient = "client";
          var strX = "X";
          var strY = "Y";
          var target2 = event2.target || event2.srcElement || document2;
          var eventDoc = target2.ownerDocument || document2;
          var doc = eventDoc.documentElement;
          var body = eventDoc.body;
          if (event2.touches !== undefined$1) {
            var touch = event2.touches[0];
            return {
              x: touch[strPage + strX],
              y: touch[strPage + strY]
            };
          }
          if (!event2[strPage + strX] && event2[strClient + strX] && event2[strClient + strX] != null) {
            return {
              x: event2[strClient + strX] + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0),
              y: event2[strClient + strY] + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)
            };
          }
          return {
            x: event2[strPage + strX],
            y: event2[strPage + strY]
          };
        },
        mBtn: function(event2) {
          var button = event2.button;
          if (!event2.which && button !== undefined$1)
            return button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
          else
            return event2.which;
        },
        inA: function(item2, arr) {
          for (var i2 = 0; i2 < arr[LEXICON.l]; i2++)
            try {
              if (arr[i2] === item2)
                return i2;
            } catch (e) {
            }
          return -1;
        },
        isA: function(arr) {
          var def = Array.isArray;
          return def ? def(arr) : this.type(arr) == TYPES.a;
        },
        type: function(obj) {
          if (obj === undefined$1)
            return obj + "";
          if (obj === null)
            return obj + "";
          return Object[LEXICON.p].toString.call(obj).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
        },
        bind
      };
    }();
    var MATH = Math;
    var JQUERY = window2.jQuery;
    var EASING = function() {
      var _easingsMath = {
        p: MATH.PI,
        c: MATH.cos,
        s: MATH.sin,
        w: MATH.pow,
        t: MATH.sqrt,
        n: MATH.asin,
        a: MATH.abs,
        o: 1.70158
      };
      return {
        swing: function(x, t2, b, c, d) {
          return 0.5 - _easingsMath.c(x * _easingsMath.p) / 2;
        },
        linear: function(x, t2, b, c, d) {
          return x;
        },
        easeInQuad: function(x, t2, b, c, d) {
          return c * (t2 /= d) * t2 + b;
        },
        easeOutQuad: function(x, t2, b, c, d) {
          return -c * (t2 /= d) * (t2 - 2) + b;
        },
        easeInOutQuad: function(x, t2, b, c, d) {
          return (t2 /= d / 2) < 1 ? c / 2 * t2 * t2 + b : -c / 2 * (--t2 * (t2 - 2) - 1) + b;
        },
        easeInCubic: function(x, t2, b, c, d) {
          return c * (t2 /= d) * t2 * t2 + b;
        },
        easeOutCubic: function(x, t2, b, c, d) {
          return c * ((t2 = t2 / d - 1) * t2 * t2 + 1) + b;
        },
        easeInOutCubic: function(x, t2, b, c, d) {
          return (t2 /= d / 2) < 1 ? c / 2 * t2 * t2 * t2 + b : c / 2 * ((t2 -= 2) * t2 * t2 + 2) + b;
        },
        easeInQuart: function(x, t2, b, c, d) {
          return c * (t2 /= d) * t2 * t2 * t2 + b;
        },
        easeOutQuart: function(x, t2, b, c, d) {
          return -c * ((t2 = t2 / d - 1) * t2 * t2 * t2 - 1) + b;
        },
        easeInOutQuart: function(x, t2, b, c, d) {
          return (t2 /= d / 2) < 1 ? c / 2 * t2 * t2 * t2 * t2 + b : -c / 2 * ((t2 -= 2) * t2 * t2 * t2 - 2) + b;
        },
        easeInQuint: function(x, t2, b, c, d) {
          return c * (t2 /= d) * t2 * t2 * t2 * t2 + b;
        },
        easeOutQuint: function(x, t2, b, c, d) {
          return c * ((t2 = t2 / d - 1) * t2 * t2 * t2 * t2 + 1) + b;
        },
        easeInOutQuint: function(x, t2, b, c, d) {
          return (t2 /= d / 2) < 1 ? c / 2 * t2 * t2 * t2 * t2 * t2 + b : c / 2 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2) + b;
        },
        easeInSine: function(x, t2, b, c, d) {
          return -c * _easingsMath.c(t2 / d * (_easingsMath.p / 2)) + c + b;
        },
        easeOutSine: function(x, t2, b, c, d) {
          return c * _easingsMath.s(t2 / d * (_easingsMath.p / 2)) + b;
        },
        easeInOutSine: function(x, t2, b, c, d) {
          return -c / 2 * (_easingsMath.c(_easingsMath.p * t2 / d) - 1) + b;
        },
        easeInExpo: function(x, t2, b, c, d) {
          return t2 == 0 ? b : c * _easingsMath.w(2, 10 * (t2 / d - 1)) + b;
        },
        easeOutExpo: function(x, t2, b, c, d) {
          return t2 == d ? b + c : c * (-_easingsMath.w(2, -10 * t2 / d) + 1) + b;
        },
        easeInOutExpo: function(x, t2, b, c, d) {
          if (t2 == 0)
            return b;
          if (t2 == d)
            return b + c;
          if ((t2 /= d / 2) < 1)
            return c / 2 * _easingsMath.w(2, 10 * (t2 - 1)) + b;
          return c / 2 * (-_easingsMath.w(2, -10 * --t2) + 2) + b;
        },
        easeInCirc: function(x, t2, b, c, d) {
          return -c * (_easingsMath.t(1 - (t2 /= d) * t2) - 1) + b;
        },
        easeOutCirc: function(x, t2, b, c, d) {
          return c * _easingsMath.t(1 - (t2 = t2 / d - 1) * t2) + b;
        },
        easeInOutCirc: function(x, t2, b, c, d) {
          return (t2 /= d / 2) < 1 ? -c / 2 * (_easingsMath.t(1 - t2 * t2) - 1) + b : c / 2 * (_easingsMath.t(1 - (t2 -= 2) * t2) + 1) + b;
        },
        easeInElastic: function(x, t2, b, c, d) {
          var s = _easingsMath.o;
          var p = 0;
          var a = c;
          if (t2 == 0)
            return b;
          if ((t2 /= d) == 1)
            return b + c;
          if (!p)
            p = d * 0.3;
          if (a < _easingsMath.a(c)) {
            a = c;
            s = p / 4;
          } else
            s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
          return -(a * _easingsMath.w(2, 10 * (t2 -= 1)) * _easingsMath.s((t2 * d - s) * (2 * _easingsMath.p) / p)) + b;
        },
        easeOutElastic: function(x, t2, b, c, d) {
          var s = _easingsMath.o;
          var p = 0;
          var a = c;
          if (t2 == 0)
            return b;
          if ((t2 /= d) == 1)
            return b + c;
          if (!p)
            p = d * 0.3;
          if (a < _easingsMath.a(c)) {
            a = c;
            s = p / 4;
          } else
            s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
          return a * _easingsMath.w(2, -10 * t2) * _easingsMath.s((t2 * d - s) * (2 * _easingsMath.p) / p) + c + b;
        },
        easeInOutElastic: function(x, t2, b, c, d) {
          var s = _easingsMath.o;
          var p = 0;
          var a = c;
          if (t2 == 0)
            return b;
          if ((t2 /= d / 2) == 2)
            return b + c;
          if (!p)
            p = d * (0.3 * 1.5);
          if (a < _easingsMath.a(c)) {
            a = c;
            s = p / 4;
          } else
            s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
          if (t2 < 1)
            return -0.5 * (a * _easingsMath.w(2, 10 * (t2 -= 1)) * _easingsMath.s((t2 * d - s) * (2 * _easingsMath.p) / p)) + b;
          return a * _easingsMath.w(2, -10 * (t2 -= 1)) * _easingsMath.s((t2 * d - s) * (2 * _easingsMath.p) / p) * 0.5 + c + b;
        },
        easeInBack: function(x, t2, b, c, d, s) {
          s = s || _easingsMath.o;
          return c * (t2 /= d) * t2 * ((s + 1) * t2 - s) + b;
        },
        easeOutBack: function(x, t2, b, c, d, s) {
          s = s || _easingsMath.o;
          return c * ((t2 = t2 / d - 1) * t2 * ((s + 1) * t2 + s) + 1) + b;
        },
        easeInOutBack: function(x, t2, b, c, d, s) {
          s = s || _easingsMath.o;
          return (t2 /= d / 2) < 1 ? c / 2 * (t2 * t2 * (((s *= 1.525) + 1) * t2 - s)) + b : c / 2 * ((t2 -= 2) * t2 * (((s *= 1.525) + 1) * t2 + s) + 2) + b;
        },
        easeInBounce: function(x, t2, b, c, d) {
          return c - this.easeOutBounce(x, d - t2, 0, c, d) + b;
        },
        easeOutBounce: function(x, t2, b, c, d) {
          var o = 7.5625;
          if ((t2 /= d) < 1 / 2.75) {
            return c * (o * t2 * t2) + b;
          } else if (t2 < 2 / 2.75) {
            return c * (o * (t2 -= 1.5 / 2.75) * t2 + 0.75) + b;
          } else if (t2 < 2.5 / 2.75) {
            return c * (o * (t2 -= 2.25 / 2.75) * t2 + 0.9375) + b;
          } else {
            return c * (o * (t2 -= 2.625 / 2.75) * t2 + 0.984375) + b;
          }
        },
        easeInOutBounce: function(x, t2, b, c, d) {
          return t2 < d / 2 ? this.easeInBounce(x, t2 * 2, 0, c, d) * 0.5 + b : this.easeOutBounce(x, t2 * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
        }
      };
    }();
    var FRAMEWORK = function() {
      var _rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
      var _strSpace = " ";
      var _strEmpty = "";
      var _strScrollLeft = "scrollLeft";
      var _strScrollTop = "scrollTop";
      var _animations = [];
      var _type = COMPATIBILITY.type;
      var _cssNumber = {
        animationIterationCount: true,
        columnCount: true,
        fillOpacity: true,
        flexGrow: true,
        flexShrink: true,
        fontWeight: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        widows: true,
        zIndex: true,
        zoom: true
      };
      function extend() {
        var src, copyIsArray, copy, name2, options2, clone, target2 = arguments[0] || {}, i2 = 1, length2 = arguments[LEXICON.l], deep = false;
        if (_type(target2) == TYPES.b) {
          deep = target2;
          target2 = arguments[1] || {};
          i2 = 2;
        }
        if (_type(target2) != TYPES.o && !_type(target2) == TYPES.f) {
          target2 = {};
        }
        if (length2 === i2) {
          target2 = FakejQuery;
          --i2;
        }
        for (; i2 < length2; i2++) {
          if ((options2 = arguments[i2]) != null) {
            for (name2 in options2) {
              src = target2[name2];
              copy = options2[name2];
              if (target2 === copy) {
                continue;
              }
              if (deep && copy && (isPlainObject2(copy) || (copyIsArray = COMPATIBILITY.isA(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && COMPATIBILITY.isA(src) ? src : [];
                } else {
                  clone = src && isPlainObject2(src) ? src : {};
                }
                target2[name2] = extend(deep, clone, copy);
              } else if (copy !== undefined$1) {
                target2[name2] = copy;
              }
            }
          }
        }
        return target2;
      }
      function inArray(item2, arr, fromIndex) {
        for (var i2 = fromIndex || 0; i2 < arr[LEXICON.l]; i2++)
          if (arr[i2] === item2)
            return i2;
        return -1;
      }
      function isFunction2(obj) {
        return _type(obj) == TYPES.f;
      }
      function isEmptyObject2(obj) {
        for (var name2 in obj)
          return false;
        return true;
      }
      function isPlainObject2(obj) {
        if (!obj || _type(obj) != TYPES.o)
          return false;
        var key;
        var proto = LEXICON.p;
        var hasOwnProperty2 = Object[proto].hasOwnProperty;
        var hasOwnConstructor = hasOwnProperty2.call(obj, "constructor");
        var hasIsPrototypeOf = obj.constructor && obj.constructor[proto] && hasOwnProperty2.call(obj.constructor[proto], "isPrototypeOf");
        if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
          return false;
        }
        for (key in obj) {
        }
        return _type(key) == TYPES.u || hasOwnProperty2.call(obj, key);
      }
      function each(obj, callback) {
        var i2 = 0;
        if (isArrayLike2(obj)) {
          for (; i2 < obj[LEXICON.l]; i2++) {
            if (callback.call(obj[i2], i2, obj[i2]) === false)
              break;
          }
        } else {
          for (i2 in obj) {
            if (callback.call(obj[i2], i2, obj[i2]) === false)
              break;
          }
        }
        return obj;
      }
      function isArrayLike2(obj) {
        var length2 = !!obj && [LEXICON.l] in obj && obj[LEXICON.l];
        var t2 = _type(obj);
        return isFunction2(t2) ? false : t2 == TYPES.a || length2 === 0 || _type(length2) == TYPES.n && length2 > 0 && length2 - 1 in obj;
      }
      function stripAndCollapse(value) {
        var tokens = value.match(_rnothtmlwhite) || [];
        return tokens.join(_strSpace);
      }
      function matches(elem, selector) {
        var nodeList = (elem.parentNode || document2).querySelectorAll(selector) || [];
        var i2 = nodeList[LEXICON.l];
        while (i2--)
          if (nodeList[i2] == elem)
            return true;
        return false;
      }
      function insertAdjacentElement(el, strategy, child) {
        if (COMPATIBILITY.isA(child)) {
          for (var i2 = 0; i2 < child[LEXICON.l]; i2++)
            insertAdjacentElement(el, strategy, child[i2]);
        } else if (_type(child) == TYPES.s)
          el.insertAdjacentHTML(strategy, child);
        else
          el.insertAdjacentElement(strategy, child.nodeType ? child : child[0]);
      }
      function setCSSVal(el, prop, val) {
        try {
          if (el[LEXICON.s][prop] !== undefined$1)
            el[LEXICON.s][prop] = parseCSSVal(prop, val);
        } catch (e) {
        }
      }
      function parseCSSVal(prop, val) {
        if (!_cssNumber[prop.toLowerCase()] && _type(val) == TYPES.n)
          val += "px";
        return val;
      }
      function startNextAnimationInQ(animObj, removeFromQ) {
        var index2;
        var nextAnim;
        if (removeFromQ !== false)
          animObj.q.splice(0, 1);
        if (animObj.q[LEXICON.l] > 0) {
          nextAnim = animObj.q[0];
          animate(animObj.el, nextAnim.props, nextAnim.duration, nextAnim.easing, nextAnim.complete, true);
        } else {
          index2 = inArray(animObj, _animations);
          if (index2 > -1)
            _animations.splice(index2, 1);
        }
      }
      function setAnimationValue(el, prop, value) {
        if (prop === _strScrollLeft || prop === _strScrollTop)
          el[prop] = value;
        else
          setCSSVal(el, prop, value);
      }
      function animate(el, props, options2, easing2, complete, guaranteedNext) {
        var hasOptions = isPlainObject2(options2);
        var from = {};
        var to = {};
        var i2 = 0;
        var key;
        var animObj;
        var progress;
        var step;
        var specialEasing;
        var duration2;
        if (hasOptions) {
          easing2 = options2.easing;
          progress = options2.progress;
          step = options2.step;
          specialEasing = options2.specialEasing;
          complete = options2.complete;
          duration2 = options2.duration;
        } else
          duration2 = options2;
        specialEasing = specialEasing || {};
        duration2 = duration2 || 400;
        easing2 = easing2 || "swing";
        guaranteedNext = guaranteedNext || false;
        for (; i2 < _animations[LEXICON.l]; i2++) {
          if (_animations[i2].el === el) {
            animObj = _animations[i2];
            break;
          }
        }
        if (!animObj) {
          animObj = {
            el,
            q: []
          };
          _animations.push(animObj);
        }
        for (key in props) {
          if (key === _strScrollLeft || key === _strScrollTop)
            from[key] = el[key];
          else
            from[key] = FakejQuery(el).css(key);
        }
        for (key in from) {
          if (from[key] !== props[key] && props[key] !== undefined$1)
            to[key] = props[key];
        }
        if (!isEmptyObject2(to)) {
          var timeNow;
          var end;
          var percent;
          var fromVal;
          var toVal;
          var easedVal;
          var timeStart;
          var frame;
          var elapsed;
          var qPos = guaranteedNext ? 0 : inArray(qObj, animObj.q);
          var qObj = {
            props: to,
            duration: hasOptions ? options2 : duration2,
            easing: easing2,
            complete
          };
          if (qPos === -1) {
            qPos = animObj.q[LEXICON.l];
            animObj.q.push(qObj);
          }
          if (qPos === 0) {
            if (duration2 > 0) {
              timeStart = COMPATIBILITY.now();
              frame = function() {
                timeNow = COMPATIBILITY.now();
                elapsed = timeNow - timeStart;
                end = qObj.stop || elapsed >= duration2;
                percent = 1 - (MATH.max(0, timeStart + duration2 - timeNow) / duration2 || 0);
                for (key in to) {
                  fromVal = parseFloat(from[key]);
                  toVal = parseFloat(to[key]);
                  easedVal = (toVal - fromVal) * EASING[specialEasing[key] || easing2](percent, percent * duration2, 0, 1, duration2) + fromVal;
                  setAnimationValue(el, key, easedVal);
                  if (isFunction2(step)) {
                    step(easedVal, {
                      elem: el,
                      prop: key,
                      start: fromVal,
                      now: easedVal,
                      end: toVal,
                      pos: percent,
                      options: {
                        easing: easing2,
                        speacialEasing: specialEasing,
                        duration: duration2,
                        complete,
                        step
                      },
                      startTime: timeStart
                    });
                  }
                }
                if (isFunction2(progress))
                  progress({}, percent, MATH.max(0, duration2 - elapsed));
                if (end) {
                  startNextAnimationInQ(animObj);
                  if (isFunction2(complete))
                    complete();
                } else
                  qObj.frame = COMPATIBILITY.rAF()(frame);
              };
              qObj.frame = COMPATIBILITY.rAF()(frame);
            } else {
              for (key in to)
                setAnimationValue(el, key, to[key]);
              startNextAnimationInQ(animObj);
            }
          }
        } else if (guaranteedNext)
          startNextAnimationInQ(animObj);
      }
      function stop2(el, clearQ, jumpToEnd) {
        var animObj;
        var qObj;
        var key;
        var i2 = 0;
        for (; i2 < _animations[LEXICON.l]; i2++) {
          animObj = _animations[i2];
          if (animObj.el === el) {
            if (animObj.q[LEXICON.l] > 0) {
              qObj = animObj.q[0];
              qObj.stop = true;
              COMPATIBILITY.cAF()(qObj.frame);
              animObj.q.splice(0, 1);
              if (jumpToEnd)
                for (key in qObj.props)
                  setAnimationValue(el, key, qObj.props[key]);
              if (clearQ)
                animObj.q = [];
              else
                startNextAnimationInQ(animObj, false);
            }
            break;
          }
        }
      }
      function elementIsVisible(el) {
        return !!(el[LEXICON.oW] || el[LEXICON.oH] || el.getClientRects()[LEXICON.l]);
      }
      function FakejQuery(selector) {
        if (arguments[LEXICON.l] === 0)
          return this;
        var base = new FakejQuery();
        var elements = selector;
        var i2 = 0;
        var elms;
        var el;
        if (_type(selector) == TYPES.s) {
          elements = [];
          if (selector.charAt(0) === "<") {
            el = document2.createElement("div");
            el.innerHTML = selector;
            elms = el.children;
          } else {
            elms = document2.querySelectorAll(selector);
          }
          for (; i2 < elms[LEXICON.l]; i2++)
            elements.push(elms[i2]);
        }
        if (elements) {
          if (_type(elements) != TYPES.s && (!isArrayLike2(elements) || elements === window2 || elements === elements.self))
            elements = [elements];
          for (i2 = 0; i2 < elements[LEXICON.l]; i2++)
            base[i2] = elements[i2];
          base[LEXICON.l] = elements[LEXICON.l];
        }
        return base;
      }
      FakejQuery[LEXICON.p] = {
        on: function(eventName, handler) {
          eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
          var eventNameLength = eventName[LEXICON.l];
          var i2 = 0;
          var el;
          return this.each(function() {
            el = this;
            try {
              if (el.addEventListener) {
                for (; i2 < eventNameLength; i2++)
                  el.addEventListener(eventName[i2], handler);
              } else if (el.detachEvent) {
                for (; i2 < eventNameLength; i2++)
                  el.attachEvent("on" + eventName[i2], handler);
              }
            } catch (e) {
            }
          });
        },
        off: function(eventName, handler) {
          eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
          var eventNameLength = eventName[LEXICON.l];
          var i2 = 0;
          var el;
          return this.each(function() {
            el = this;
            try {
              if (el.removeEventListener) {
                for (; i2 < eventNameLength; i2++)
                  el.removeEventListener(eventName[i2], handler);
              } else if (el.detachEvent) {
                for (; i2 < eventNameLength; i2++)
                  el.detachEvent("on" + eventName[i2], handler);
              }
            } catch (e) {
            }
          });
        },
        one: function(eventName, handler) {
          eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
          return this.each(function() {
            var el = FakejQuery(this);
            FakejQuery.each(eventName, function(i2, oneEventName) {
              var oneHandler = function(e) {
                handler.call(this, e);
                el.off(oneEventName, oneHandler);
              };
              el.on(oneEventName, oneHandler);
            });
          });
        },
        trigger: function(eventName) {
          var el;
          var event2;
          return this.each(function() {
            el = this;
            if (document2.createEvent) {
              event2 = document2.createEvent("HTMLEvents");
              event2.initEvent(eventName, true, false);
              el.dispatchEvent(event2);
            } else {
              el.fireEvent("on" + eventName);
            }
          });
        },
        append: function(child) {
          return this.each(function() {
            insertAdjacentElement(this, "beforeend", child);
          });
        },
        prepend: function(child) {
          return this.each(function() {
            insertAdjacentElement(this, "afterbegin", child);
          });
        },
        before: function(child) {
          return this.each(function() {
            insertAdjacentElement(this, "beforebegin", child);
          });
        },
        after: function(child) {
          return this.each(function() {
            insertAdjacentElement(this, "afterend", child);
          });
        },
        remove: function() {
          return this.each(function() {
            var el = this;
            var parentNode = el.parentNode;
            if (parentNode != null)
              parentNode.removeChild(el);
          });
        },
        unwrap: function() {
          var parents = [];
          var i2;
          var el;
          var parent2;
          this.each(function() {
            parent2 = this.parentNode;
            if (inArray(parent2, parents) === -1)
              parents.push(parent2);
          });
          for (i2 = 0; i2 < parents[LEXICON.l]; i2++) {
            el = parents[i2];
            parent2 = el.parentNode;
            while (el.firstChild)
              parent2.insertBefore(el.firstChild, el);
            parent2.removeChild(el);
          }
          return this;
        },
        wrapAll: function(wrapperHTML) {
          var i2;
          var nodes = this;
          var wrapper2 = FakejQuery(wrapperHTML)[0];
          var deepest = wrapper2;
          var parent2 = nodes[0].parentNode;
          var previousSibling = nodes[0].previousSibling;
          while (deepest.childNodes[LEXICON.l] > 0)
            deepest = deepest.childNodes[0];
          for (i2 = 0; nodes[LEXICON.l] - i2; deepest.firstChild === nodes[0] && i2++)
            deepest.appendChild(nodes[i2]);
          var nextSibling = previousSibling ? previousSibling.nextSibling : parent2.firstChild;
          parent2.insertBefore(wrapper2, nextSibling);
          return this;
        },
        wrapInner: function(wrapperHTML) {
          return this.each(function() {
            var el = FakejQuery(this);
            var contents = el.contents();
            if (contents[LEXICON.l])
              contents.wrapAll(wrapperHTML);
            else
              el.append(wrapperHTML);
          });
        },
        wrap: function(wrapperHTML) {
          return this.each(function() {
            FakejQuery(this).wrapAll(wrapperHTML);
          });
        },
        css: function(styles2, val) {
          var el;
          var key;
          var cptStyle;
          var getCptStyle = window2.getComputedStyle;
          if (_type(styles2) == TYPES.s) {
            if (val === undefined$1) {
              el = this[0];
              cptStyle = getCptStyle ? getCptStyle(el, null) : el.currentStyle[styles2];
              return getCptStyle ? cptStyle != null ? cptStyle.getPropertyValue(styles2) : el[LEXICON.s][styles2] : cptStyle;
            } else {
              return this.each(function() {
                setCSSVal(this, styles2, val);
              });
            }
          } else {
            return this.each(function() {
              for (key in styles2)
                setCSSVal(this, key, styles2[key]);
            });
          }
        },
        hasClass: function(className) {
          var elem, i2 = 0;
          var classNamePrepared = _strSpace + className + _strSpace;
          var classList;
          while (elem = this[i2++]) {
            classList = elem.classList;
            if (classList && classList.contains(className))
              return true;
            else if (elem.nodeType === 1 && (_strSpace + stripAndCollapse(elem.className + _strEmpty) + _strSpace).indexOf(classNamePrepared) > -1)
              return true;
          }
          return false;
        },
        addClass: function(className) {
          var classes;
          var elem;
          var cur;
          var curValue;
          var clazz;
          var finalValue;
          var supportClassList;
          var elmClassList;
          var i2 = 0;
          var v = 0;
          if (className) {
            classes = className.match(_rnothtmlwhite) || [];
            while (elem = this[i2++]) {
              elmClassList = elem.classList;
              if (supportClassList === undefined$1)
                supportClassList = elmClassList !== undefined$1;
              if (supportClassList) {
                while (clazz = classes[v++])
                  elmClassList.add(clazz);
              } else {
                curValue = elem.className + _strEmpty;
                cur = elem.nodeType === 1 && _strSpace + stripAndCollapse(curValue) + _strSpace;
                if (cur) {
                  while (clazz = classes[v++])
                    if (cur.indexOf(_strSpace + clazz + _strSpace) < 0)
                      cur += clazz + _strSpace;
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue)
                    elem.className = finalValue;
                }
              }
            }
          }
          return this;
        },
        removeClass: function(className) {
          var classes;
          var elem;
          var cur;
          var curValue;
          var clazz;
          var finalValue;
          var supportClassList;
          var elmClassList;
          var i2 = 0;
          var v = 0;
          if (className) {
            classes = className.match(_rnothtmlwhite) || [];
            while (elem = this[i2++]) {
              elmClassList = elem.classList;
              if (supportClassList === undefined$1)
                supportClassList = elmClassList !== undefined$1;
              if (supportClassList) {
                while (clazz = classes[v++])
                  elmClassList.remove(clazz);
              } else {
                curValue = elem.className + _strEmpty;
                cur = elem.nodeType === 1 && _strSpace + stripAndCollapse(curValue) + _strSpace;
                if (cur) {
                  while (clazz = classes[v++])
                    while (cur.indexOf(_strSpace + clazz + _strSpace) > -1)
                      cur = cur.replace(_strSpace + clazz + _strSpace, _strSpace);
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue)
                    elem.className = finalValue;
                }
              }
            }
          }
          return this;
        },
        hide: function() {
          return this.each(function() {
            this[LEXICON.s].display = "none";
          });
        },
        show: function() {
          return this.each(function() {
            this[LEXICON.s].display = "block";
          });
        },
        attr: function(attrName, value) {
          var i2 = 0;
          var el;
          while (el = this[i2++]) {
            if (value === undefined$1)
              return el.getAttribute(attrName);
            el.setAttribute(attrName, value);
          }
          return this;
        },
        removeAttr: function(attrName) {
          return this.each(function() {
            this.removeAttribute(attrName);
          });
        },
        offset: function() {
          var el = this[0];
          var rect = el[LEXICON.bCR]();
          var scrollLeft = window2.pageXOffset || document2.documentElement[_strScrollLeft];
          var scrollTop = window2.pageYOffset || document2.documentElement[_strScrollTop];
          return {
            top: rect.top + scrollTop,
            left: rect.left + scrollLeft
          };
        },
        position: function() {
          var el = this[0];
          return {
            top: el.offsetTop,
            left: el.offsetLeft
          };
        },
        scrollLeft: function(value) {
          var i2 = 0;
          var el;
          while (el = this[i2++]) {
            if (value === undefined$1)
              return el[_strScrollLeft];
            el[_strScrollLeft] = value;
          }
          return this;
        },
        scrollTop: function(value) {
          var i2 = 0;
          var el;
          while (el = this[i2++]) {
            if (value === undefined$1)
              return el[_strScrollTop];
            el[_strScrollTop] = value;
          }
          return this;
        },
        val: function(value) {
          var el = this[0];
          if (!value)
            return el.value;
          el.value = value;
          return this;
        },
        first: function() {
          return this.eq(0);
        },
        last: function() {
          return this.eq(-1);
        },
        eq: function(index2) {
          return FakejQuery(this[index2 >= 0 ? index2 : this[LEXICON.l] + index2]);
        },
        find: function(selector) {
          var children = [];
          var i2;
          this.each(function() {
            var el = this;
            var ch = el.querySelectorAll(selector);
            for (i2 = 0; i2 < ch[LEXICON.l]; i2++)
              children.push(ch[i2]);
          });
          return FakejQuery(children);
        },
        children: function(selector) {
          var children = [];
          var el;
          var ch;
          var i2;
          this.each(function() {
            ch = this.children;
            for (i2 = 0; i2 < ch[LEXICON.l]; i2++) {
              el = ch[i2];
              if (selector) {
                if (el.matches && el.matches(selector) || matches(el, selector))
                  children.push(el);
              } else
                children.push(el);
            }
          });
          return FakejQuery(children);
        },
        parent: function(selector) {
          var parents = [];
          var parent2;
          this.each(function() {
            parent2 = this.parentNode;
            if (selector ? FakejQuery(parent2).is(selector) : true)
              parents.push(parent2);
          });
          return FakejQuery(parents);
        },
        is: function(selector) {
          var el;
          var i2;
          for (i2 = 0; i2 < this[LEXICON.l]; i2++) {
            el = this[i2];
            if (selector === ":visible")
              return elementIsVisible(el);
            if (selector === ":hidden")
              return !elementIsVisible(el);
            if (el.matches && el.matches(selector) || matches(el, selector))
              return true;
          }
          return false;
        },
        contents: function() {
          var contents = [];
          var childs;
          var i2;
          this.each(function() {
            childs = this.childNodes;
            for (i2 = 0; i2 < childs[LEXICON.l]; i2++)
              contents.push(childs[i2]);
          });
          return FakejQuery(contents);
        },
        each: function(callback) {
          return each(this, callback);
        },
        animate: function(props, duration2, easing2, complete) {
          return this.each(function() {
            animate(this, props, duration2, easing2, complete);
          });
        },
        stop: function(clearQ, jump) {
          return this.each(function() {
            stop2(this, clearQ, jump);
          });
        }
      };
      extend(FakejQuery, {
        extend,
        inArray,
        isEmptyObject: isEmptyObject2,
        isPlainObject: isPlainObject2,
        each
      });
      return FakejQuery;
    }();
    var INSTANCES = function() {
      var _targets = [];
      var _instancePropertyString = "__overlayScrollbars__";
      return function(target2, instance) {
        var argLen = arguments[LEXICON.l];
        if (argLen < 1) {
          return _targets;
        } else {
          if (instance) {
            target2[_instancePropertyString] = instance;
            _targets.push(target2);
          } else {
            var index2 = COMPATIBILITY.inA(target2, _targets);
            if (index2 > -1) {
              if (argLen > 1) {
                delete target2[_instancePropertyString];
                _targets.splice(index2, 1);
              } else {
                return _targets[index2][_instancePropertyString];
              }
            }
          }
        }
      };
    }();
    var PLUGIN = function() {
      var _plugin;
      var _pluginsGlobals;
      var _pluginsAutoUpdateLoop;
      var _pluginsExtensions = [];
      var _pluginsOptions = function() {
        var type = COMPATIBILITY.type;
        var possibleTemplateTypes = [
          TYPES.b,
          TYPES.n,
          TYPES.s,
          TYPES.a,
          TYPES.o,
          TYPES.f,
          TYPES.z
        ];
        var restrictedStringsSplit = " ";
        var restrictedStringsPossibilitiesSplit = ":";
        var classNameAllowedValues = [TYPES.z, TYPES.s];
        var numberAllowedValues = TYPES.n;
        var booleanNullAllowedValues = [TYPES.z, TYPES.b];
        var booleanTrueTemplate = [true, TYPES.b];
        var booleanFalseTemplate = [false, TYPES.b];
        var callbackTemplate = [null, [TYPES.z, TYPES.f]];
        var updateOnLoadTemplate = [["img"], [TYPES.s, TYPES.a, TYPES.z]];
        var inheritedAttrsTemplate = [["style", "class"], [TYPES.s, TYPES.a, TYPES.z]];
        var resizeAllowedValues = "n:none b:both h:horizontal v:vertical";
        var overflowBehaviorAllowedValues = "v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden";
        var scrollbarsVisibilityAllowedValues = "v:visible h:hidden a:auto";
        var scrollbarsAutoHideAllowedValues = "n:never s:scroll l:leave m:move";
        var optionsDefaultsAndTemplate = {
          className: ["os-theme-dark", classNameAllowedValues],
          resize: ["none", resizeAllowedValues],
          sizeAutoCapable: booleanTrueTemplate,
          clipAlways: booleanTrueTemplate,
          normalizeRTL: booleanTrueTemplate,
          paddingAbsolute: booleanFalseTemplate,
          autoUpdate: [null, booleanNullAllowedValues],
          autoUpdateInterval: [33, numberAllowedValues],
          updateOnLoad: updateOnLoadTemplate,
          nativeScrollbarsOverlaid: {
            showNativeScrollbars: booleanFalseTemplate,
            initialize: booleanTrueTemplate
          },
          overflowBehavior: {
            x: ["scroll", overflowBehaviorAllowedValues],
            y: ["scroll", overflowBehaviorAllowedValues]
          },
          scrollbars: {
            visibility: ["auto", scrollbarsVisibilityAllowedValues],
            autoHide: ["never", scrollbarsAutoHideAllowedValues],
            autoHideDelay: [800, numberAllowedValues],
            dragScrolling: booleanTrueTemplate,
            clickScrolling: booleanFalseTemplate,
            touchSupport: booleanTrueTemplate,
            snapHandle: booleanFalseTemplate
          },
          textarea: {
            dynWidth: booleanFalseTemplate,
            dynHeight: booleanFalseTemplate,
            inheritedAttrs: inheritedAttrsTemplate
          },
          callbacks: {
            onInitialized: callbackTemplate,
            onInitializationWithdrawn: callbackTemplate,
            onDestroyed: callbackTemplate,
            onScrollStart: callbackTemplate,
            onScroll: callbackTemplate,
            onScrollStop: callbackTemplate,
            onOverflowChanged: callbackTemplate,
            onOverflowAmountChanged: callbackTemplate,
            onDirectionChanged: callbackTemplate,
            onContentSizeChanged: callbackTemplate,
            onHostSizeChanged: callbackTemplate,
            onUpdated: callbackTemplate
          }
        };
        var convert2 = function(template) {
          var recursive = function(obj) {
            var key;
            var val;
            var valType;
            for (key in obj) {
              if (!obj[LEXICON.hOP](key))
                continue;
              val = obj[key];
              valType = type(val);
              if (valType == TYPES.a)
                obj[key] = val[template ? 1 : 0];
              else if (valType == TYPES.o)
                obj[key] = recursive(val);
            }
            return obj;
          };
          return recursive(FRAMEWORK.extend(true, {}, optionsDefaultsAndTemplate));
        };
        return {
          _defaults: convert2(),
          _template: convert2(true),
          _validate: function(obj, template, writeErrors, diffObj) {
            var validatedOptions = {};
            var validatedOptionsPrepared = {};
            var objectCopy = FRAMEWORK.extend(true, {}, obj);
            var inArray = FRAMEWORK.inArray;
            var isEmptyObj = FRAMEWORK.isEmptyObject;
            var checkObjectProps = function(data, template2, diffData, validatedOptions2, validatedOptionsPrepared2, prevPropName) {
              for (var prop in template2) {
                if (template2[LEXICON.hOP](prop) && data[LEXICON.hOP](prop)) {
                  var isValid = false;
                  var isDiff = false;
                  var templateValue = template2[prop];
                  var templateValueType = type(templateValue);
                  var templateIsComplex = templateValueType == TYPES.o;
                  var templateTypes = !COMPATIBILITY.isA(templateValue) ? [templateValue] : templateValue;
                  var dataDiffValue = diffData[prop];
                  var dataValue = data[prop];
                  var dataValueType = type(dataValue);
                  var propPrefix = prevPropName ? prevPropName + "." : "";
                  var error2 = 'The option "' + propPrefix + prop + `" wasn't set, because`;
                  var errorPossibleTypes = [];
                  var errorRestrictedStrings = [];
                  var restrictedStringValuesSplit;
                  var restrictedStringValuesPossibilitiesSplit;
                  var isRestrictedValue;
                  var mainPossibility;
                  var currType;
                  var i2;
                  var v;
                  var j;
                  dataDiffValue = dataDiffValue === undefined$1 ? {} : dataDiffValue;
                  if (templateIsComplex && dataValueType == TYPES.o) {
                    validatedOptions2[prop] = {};
                    validatedOptionsPrepared2[prop] = {};
                    checkObjectProps(dataValue, templateValue, dataDiffValue, validatedOptions2[prop], validatedOptionsPrepared2[prop], propPrefix + prop);
                    FRAMEWORK.each([data, validatedOptions2, validatedOptionsPrepared2], function(index2, value) {
                      if (isEmptyObj(value[prop])) {
                        delete value[prop];
                      }
                    });
                  } else if (!templateIsComplex) {
                    for (i2 = 0; i2 < templateTypes[LEXICON.l]; i2++) {
                      currType = templateTypes[i2];
                      templateValueType = type(currType);
                      isRestrictedValue = templateValueType == TYPES.s && inArray(currType, possibleTemplateTypes) === -1;
                      if (isRestrictedValue) {
                        errorPossibleTypes.push(TYPES.s);
                        restrictedStringValuesSplit = currType.split(restrictedStringsSplit);
                        errorRestrictedStrings = errorRestrictedStrings.concat(restrictedStringValuesSplit);
                        for (v = 0; v < restrictedStringValuesSplit[LEXICON.l]; v++) {
                          restrictedStringValuesPossibilitiesSplit = restrictedStringValuesSplit[v].split(restrictedStringsPossibilitiesSplit);
                          mainPossibility = restrictedStringValuesPossibilitiesSplit[0];
                          for (j = 0; j < restrictedStringValuesPossibilitiesSplit[LEXICON.l]; j++) {
                            if (dataValue === restrictedStringValuesPossibilitiesSplit[j]) {
                              isValid = true;
                              break;
                            }
                          }
                          if (isValid)
                            break;
                        }
                      } else {
                        errorPossibleTypes.push(currType);
                        if (dataValueType === currType) {
                          isValid = true;
                          break;
                        }
                      }
                    }
                    if (isValid) {
                      isDiff = dataValue !== dataDiffValue;
                      if (isDiff)
                        validatedOptions2[prop] = dataValue;
                      if (isRestrictedValue ? inArray(dataDiffValue, restrictedStringValuesPossibilitiesSplit) < 0 : isDiff)
                        validatedOptionsPrepared2[prop] = isRestrictedValue ? mainPossibility : dataValue;
                    } else if (writeErrors) {
                      console.warn(error2 + " it doesn't accept the type [ " + dataValueType.toUpperCase() + ' ] with the value of "' + dataValue + '".\r\nAccepted types are: [ ' + errorPossibleTypes.join(", ").toUpperCase() + " ]." + (errorRestrictedStrings[length] > 0 ? "\r\nValid strings are: [ " + errorRestrictedStrings.join(", ").split(restrictedStringsPossibilitiesSplit).join(", ") + " ]." : ""));
                    }
                    delete data[prop];
                  }
                }
              }
            };
            checkObjectProps(objectCopy, template, diffObj || {}, validatedOptions, validatedOptionsPrepared);
            if (!isEmptyObj(objectCopy) && writeErrors)
              console.warn("The following options are discarded due to invalidity:\r\n" + window2.JSON.stringify(objectCopy, null, 2));
            return {
              _default: validatedOptions,
              _prepared: validatedOptionsPrepared
            };
          }
        };
      }();
      function initOverlayScrollbarsStatics() {
        if (!_pluginsGlobals)
          _pluginsGlobals = new OverlayScrollbarsGlobals(_pluginsOptions._defaults);
        if (!_pluginsAutoUpdateLoop)
          _pluginsAutoUpdateLoop = new OverlayScrollbarsAutoUpdateLoop(_pluginsGlobals);
      }
      function OverlayScrollbarsGlobals(defaultOptions) {
        var _base = this;
        var strOverflow = "overflow";
        var strHidden = "hidden";
        var strScroll = "scroll";
        var bodyElement = FRAMEWORK("body");
        var scrollbarDummyElement = FRAMEWORK('<div id="os-dummy-scrollbar-size"><div></div></div>');
        var scrollbarDummyElement0 = scrollbarDummyElement[0];
        var dummyContainerChild = FRAMEWORK(scrollbarDummyElement.children("div").eq(0));
        bodyElement.append(scrollbarDummyElement);
        scrollbarDummyElement.hide().show();
        var nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement0);
        var nativeScrollbarIsOverlaid = {
          x: nativeScrollbarSize.x === 0,
          y: nativeScrollbarSize.y === 0
        };
        var msie = function() {
          var ua = window2.navigator.userAgent;
          var strIndexOf = "indexOf";
          var strSubString = "substring";
          var msie2 = ua[strIndexOf]("MSIE ");
          var trident = ua[strIndexOf]("Trident/");
          var edge = ua[strIndexOf]("Edge/");
          var rv = ua[strIndexOf]("rv:");
          var result;
          var parseIntFunc = parseInt;
          if (msie2 > 0)
            result = parseIntFunc(ua[strSubString](msie2 + 5, ua[strIndexOf](".", msie2)), 10);
          else if (trident > 0)
            result = parseIntFunc(ua[strSubString](rv + 3, ua[strIndexOf](".", rv)), 10);
          else if (edge > 0)
            result = parseIntFunc(ua[strSubString](edge + 5, ua[strIndexOf](".", edge)), 10);
          return result;
        }();
        FRAMEWORK.extend(_base, {
          defaultOptions,
          msie,
          autoUpdateLoop: false,
          autoUpdateRecommended: !COMPATIBILITY.mO(),
          nativeScrollbarSize,
          nativeScrollbarIsOverlaid,
          nativeScrollbarStyling: function() {
            var result = false;
            scrollbarDummyElement.addClass("os-viewport-native-scrollbars-invisible");
            try {
              result = scrollbarDummyElement.css("scrollbar-width") === "none" && (msie > 9 || !msie) || window2.getComputedStyle(scrollbarDummyElement0, "::-webkit-scrollbar").getPropertyValue("display") === "none";
            } catch (ex) {
            }
            return result;
          }(),
          overlayScrollbarDummySize: { x: 30, y: 30 },
          cssCalc: VENDORS._cssPropertyValue("width", "calc", "(1px)") || null,
          restrictedMeasuring: function() {
            scrollbarDummyElement.css(strOverflow, strHidden);
            var scrollSize = {
              w: scrollbarDummyElement0[LEXICON.sW],
              h: scrollbarDummyElement0[LEXICON.sH]
            };
            scrollbarDummyElement.css(strOverflow, "visible");
            var scrollSize2 = {
              w: scrollbarDummyElement0[LEXICON.sW],
              h: scrollbarDummyElement0[LEXICON.sH]
            };
            return scrollSize.w - scrollSize2.w !== 0 || scrollSize.h - scrollSize2.h !== 0;
          }(),
          rtlScrollBehavior: function() {
            scrollbarDummyElement.css({ "overflow-y": strHidden, "overflow-x": strScroll, "direction": "rtl" }).scrollLeft(0);
            var dummyContainerOffset = scrollbarDummyElement.offset();
            var dummyContainerChildOffset = dummyContainerChild.offset();
            scrollbarDummyElement.scrollLeft(-999);
            var dummyContainerChildOffsetAfterScroll = dummyContainerChild.offset();
            return {
              i: dummyContainerOffset.left === dummyContainerChildOffset.left,
              n: dummyContainerChildOffset.left !== dummyContainerChildOffsetAfterScroll.left
            };
          }(),
          supportTransform: !!VENDORS._cssProperty("transform"),
          supportTransition: !!VENDORS._cssProperty("transition"),
          supportPassiveEvents: function() {
            var supportsPassive = false;
            try {
              window2.addEventListener("test", null, Object.defineProperty({}, "passive", {
                get: function() {
                  supportsPassive = true;
                }
              }));
            } catch (e) {
            }
            return supportsPassive;
          }(),
          supportResizeObserver: !!COMPATIBILITY.rO(),
          supportMutationObserver: !!COMPATIBILITY.mO()
        });
        scrollbarDummyElement.removeAttr(LEXICON.s).remove();
        (function() {
          if (nativeScrollbarIsOverlaid.x && nativeScrollbarIsOverlaid.y)
            return;
          var abs = MATH.abs;
          var windowWidth = COMPATIBILITY.wW();
          var windowHeight = COMPATIBILITY.wH();
          var windowDpr = getWindowDPR();
          var onResize = function() {
            if (INSTANCES().length > 0) {
              var newW = COMPATIBILITY.wW();
              var newH = COMPATIBILITY.wH();
              var deltaW = newW - windowWidth;
              var deltaH = newH - windowHeight;
              if (deltaW === 0 && deltaH === 0)
                return;
              var deltaWRatio = MATH.round(newW / (windowWidth / 100));
              var deltaHRatio = MATH.round(newH / (windowHeight / 100));
              var absDeltaW = abs(deltaW);
              var absDeltaH = abs(deltaH);
              var absDeltaWRatio = abs(deltaWRatio);
              var absDeltaHRatio = abs(deltaHRatio);
              var newDPR = getWindowDPR();
              var deltaIsBigger = absDeltaW > 2 && absDeltaH > 2;
              var difference = !differenceIsBiggerThanOne(absDeltaWRatio, absDeltaHRatio);
              var dprChanged = newDPR !== windowDpr && windowDpr > 0;
              var isZoom = deltaIsBigger && difference && dprChanged;
              var oldScrollbarSize = _base.nativeScrollbarSize;
              var newScrollbarSize;
              if (isZoom) {
                bodyElement.append(scrollbarDummyElement);
                newScrollbarSize = _base.nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement[0]);
                scrollbarDummyElement.remove();
                if (oldScrollbarSize.x !== newScrollbarSize.x || oldScrollbarSize.y !== newScrollbarSize.y) {
                  FRAMEWORK.each(INSTANCES(), function() {
                    if (INSTANCES(this))
                      INSTANCES(this).update("zoom");
                  });
                }
              }
              windowWidth = newW;
              windowHeight = newH;
              windowDpr = newDPR;
            }
          };
          function differenceIsBiggerThanOne(valOne, valTwo) {
            var absValOne = abs(valOne);
            var absValTwo = abs(valTwo);
            return !(absValOne === absValTwo || absValOne + 1 === absValTwo || absValOne - 1 === absValTwo);
          }
          function getWindowDPR() {
            var dDPI = window2.screen.deviceXDPI || 0;
            var sDPI = window2.screen.logicalXDPI || 1;
            return window2.devicePixelRatio || dDPI / sDPI;
          }
          FRAMEWORK(window2).on("resize", onResize);
        })();
        function calcNativeScrollbarSize(measureElement) {
          return {
            x: measureElement[LEXICON.oH] - measureElement[LEXICON.cH],
            y: measureElement[LEXICON.oW] - measureElement[LEXICON.cW]
          };
        }
      }
      function OverlayScrollbarsAutoUpdateLoop(globals) {
        var _base = this;
        var _inArray = FRAMEWORK.inArray;
        var _getNow = COMPATIBILITY.now;
        var _strAutoUpdate = "autoUpdate";
        var _strAutoUpdateInterval = _strAutoUpdate + "Interval";
        var _strLength = LEXICON.l;
        var _loopingInstances = [];
        var _loopingInstancesIntervalCache = [];
        var _loopIsActive = false;
        var _loopIntervalDefault = 33;
        var _loopInterval = _loopIntervalDefault;
        var _loopTimeOld = _getNow();
        var _loopID;
        var loop = function() {
          if (_loopingInstances[_strLength] > 0 && _loopIsActive) {
            _loopID = COMPATIBILITY.rAF()(function() {
              loop();
            });
            var timeNew = _getNow();
            var timeDelta = timeNew - _loopTimeOld;
            var lowestInterval;
            var instance;
            var instanceOptions;
            var instanceAutoUpdateAllowed;
            var instanceAutoUpdateInterval;
            var now2;
            if (timeDelta > _loopInterval) {
              _loopTimeOld = timeNew - timeDelta % _loopInterval;
              lowestInterval = _loopIntervalDefault;
              for (var i2 = 0; i2 < _loopingInstances[_strLength]; i2++) {
                instance = _loopingInstances[i2];
                if (instance !== undefined$1) {
                  instanceOptions = instance.options();
                  instanceAutoUpdateAllowed = instanceOptions[_strAutoUpdate];
                  instanceAutoUpdateInterval = MATH.max(1, instanceOptions[_strAutoUpdateInterval]);
                  now2 = _getNow();
                  if ((instanceAutoUpdateAllowed === true || instanceAutoUpdateAllowed === null) && now2 - _loopingInstancesIntervalCache[i2] > instanceAutoUpdateInterval) {
                    instance.update("auto");
                    _loopingInstancesIntervalCache[i2] = new Date(now2 += instanceAutoUpdateInterval);
                  }
                  lowestInterval = MATH.max(1, MATH.min(lowestInterval, instanceAutoUpdateInterval));
                }
              }
              _loopInterval = lowestInterval;
            }
          } else {
            _loopInterval = _loopIntervalDefault;
          }
        };
        _base.add = function(instance) {
          if (_inArray(instance, _loopingInstances) === -1) {
            _loopingInstances.push(instance);
            _loopingInstancesIntervalCache.push(_getNow());
            if (_loopingInstances[_strLength] > 0 && !_loopIsActive) {
              _loopIsActive = true;
              globals.autoUpdateLoop = _loopIsActive;
              loop();
            }
          }
        };
        _base.remove = function(instance) {
          var index2 = _inArray(instance, _loopingInstances);
          if (index2 > -1) {
            _loopingInstancesIntervalCache.splice(index2, 1);
            _loopingInstances.splice(index2, 1);
            if (_loopingInstances[_strLength] === 0 && _loopIsActive) {
              _loopIsActive = false;
              globals.autoUpdateLoop = _loopIsActive;
              if (_loopID !== undefined$1) {
                COMPATIBILITY.cAF()(_loopID);
                _loopID = -1;
              }
            }
          }
        };
      }
      function OverlayScrollbarsInstance(pluginTargetElement, options2, extensions, globals, autoUpdateLoop) {
        var type = COMPATIBILITY.type;
        var inArray = FRAMEWORK.inArray;
        var each = FRAMEWORK.each;
        var _base = new _plugin();
        var _frameworkProto = FRAMEWORK[LEXICON.p];
        if (!isHTMLElement(pluginTargetElement))
          return;
        if (INSTANCES(pluginTargetElement)) {
          var inst = INSTANCES(pluginTargetElement);
          inst.options(options2);
          return inst;
        }
        var _nativeScrollbarIsOverlaid;
        var _overlayScrollbarDummySize;
        var _rtlScrollBehavior;
        var _autoUpdateRecommended;
        var _msieVersion;
        var _nativeScrollbarStyling;
        var _cssCalc;
        var _nativeScrollbarSize;
        var _supportTransition;
        var _supportTransform;
        var _supportPassiveEvents;
        var _supportResizeObserver;
        var _supportMutationObserver;
        var _initialized;
        var _destroyed;
        var _isTextarea;
        var _isBody;
        var _documentMixed;
        var _domExists;
        var _isBorderBox;
        var _sizeAutoObserverAdded;
        var _paddingX;
        var _paddingY;
        var _borderX;
        var _borderY;
        var _marginX;
        var _marginY;
        var _isRTL;
        var _sleeping;
        var _contentBorderSize = {};
        var _scrollHorizontalInfo = {};
        var _scrollVerticalInfo = {};
        var _viewportSize = {};
        var _nativeScrollbarMinSize = {};
        var _strMinusHidden = "-hidden";
        var _strMarginMinus = "margin-";
        var _strPaddingMinus = "padding-";
        var _strBorderMinus = "border-";
        var _strTop = "top";
        var _strRight = "right";
        var _strBottom = "bottom";
        var _strLeft = "left";
        var _strMinMinus = "min-";
        var _strMaxMinus = "max-";
        var _strWidth = "width";
        var _strHeight = "height";
        var _strFloat = "float";
        var _strEmpty = "";
        var _strAuto = "auto";
        var _strSync = "sync";
        var _strScroll = "scroll";
        var _strHundredPercent = "100%";
        var _strX = "x";
        var _strY = "y";
        var _strDot = ".";
        var _strSpace = " ";
        var _strScrollbar = "scrollbar";
        var _strMinusHorizontal = "-horizontal";
        var _strMinusVertical = "-vertical";
        var _strScrollLeft = _strScroll + "Left";
        var _strScrollTop = _strScroll + "Top";
        var _strMouseTouchDownEvent = "mousedown touchstart";
        var _strMouseTouchUpEvent = "mouseup touchend touchcancel";
        var _strMouseTouchMoveEvent = "mousemove touchmove";
        var _strMouseEnter = "mouseenter";
        var _strMouseLeave = "mouseleave";
        var _strKeyDownEvent = "keydown";
        var _strKeyUpEvent = "keyup";
        var _strSelectStartEvent = "selectstart";
        var _strTransitionEndEvent = "transitionend webkitTransitionEnd oTransitionEnd";
        var _strResizeObserverProperty = "__overlayScrollbarsRO__";
        var _cassNamesPrefix = "os-";
        var _classNameHTMLElement = _cassNamesPrefix + "html";
        var _classNameHostElement = _cassNamesPrefix + "host";
        var _classNameHostElementForeign = _classNameHostElement + "-foreign";
        var _classNameHostTextareaElement = _classNameHostElement + "-textarea";
        var _classNameHostScrollbarHorizontalHidden = _classNameHostElement + "-" + _strScrollbar + _strMinusHorizontal + _strMinusHidden;
        var _classNameHostScrollbarVerticalHidden = _classNameHostElement + "-" + _strScrollbar + _strMinusVertical + _strMinusHidden;
        var _classNameHostTransition = _classNameHostElement + "-transition";
        var _classNameHostRTL = _classNameHostElement + "-rtl";
        var _classNameHostResizeDisabled = _classNameHostElement + "-resize-disabled";
        var _classNameHostScrolling = _classNameHostElement + "-scrolling";
        var _classNameHostOverflow = _classNameHostElement + "-overflow";
        var _classNameHostOverflow = _classNameHostElement + "-overflow";
        var _classNameHostOverflowX = _classNameHostOverflow + "-x";
        var _classNameHostOverflowY = _classNameHostOverflow + "-y";
        var _classNameTextareaElement = _cassNamesPrefix + "textarea";
        var _classNameTextareaCoverElement = _classNameTextareaElement + "-cover";
        var _classNamePaddingElement = _cassNamesPrefix + "padding";
        var _classNameViewportElement = _cassNamesPrefix + "viewport";
        var _classNameViewportNativeScrollbarsInvisible = _classNameViewportElement + "-native-scrollbars-invisible";
        var _classNameViewportNativeScrollbarsOverlaid = _classNameViewportElement + "-native-scrollbars-overlaid";
        var _classNameContentElement = _cassNamesPrefix + "content";
        var _classNameContentArrangeElement = _cassNamesPrefix + "content-arrange";
        var _classNameContentGlueElement = _cassNamesPrefix + "content-glue";
        var _classNameSizeAutoObserverElement = _cassNamesPrefix + "size-auto-observer";
        var _classNameResizeObserverElement = _cassNamesPrefix + "resize-observer";
        var _classNameResizeObserverItemElement = _cassNamesPrefix + "resize-observer-item";
        var _classNameResizeObserverItemFinalElement = _classNameResizeObserverItemElement + "-final";
        var _classNameTextInherit = _cassNamesPrefix + "text-inherit";
        var _classNameScrollbar = _cassNamesPrefix + _strScrollbar;
        var _classNameScrollbarTrack = _classNameScrollbar + "-track";
        var _classNameScrollbarTrackOff = _classNameScrollbarTrack + "-off";
        var _classNameScrollbarHandle = _classNameScrollbar + "-handle";
        var _classNameScrollbarHandleOff = _classNameScrollbarHandle + "-off";
        var _classNameScrollbarUnusable = _classNameScrollbar + "-unusable";
        var _classNameScrollbarAutoHidden = _classNameScrollbar + "-" + _strAuto + _strMinusHidden;
        var _classNameScrollbarCorner = _classNameScrollbar + "-corner";
        var _classNameScrollbarCornerResize = _classNameScrollbarCorner + "-resize";
        var _classNameScrollbarCornerResizeB = _classNameScrollbarCornerResize + "-both";
        var _classNameScrollbarCornerResizeH = _classNameScrollbarCornerResize + _strMinusHorizontal;
        var _classNameScrollbarCornerResizeV = _classNameScrollbarCornerResize + _strMinusVertical;
        var _classNameScrollbarHorizontal = _classNameScrollbar + _strMinusHorizontal;
        var _classNameScrollbarVertical = _classNameScrollbar + _strMinusVertical;
        var _classNameDragging = _cassNamesPrefix + "dragging";
        var _classNameThemeNone = _cassNamesPrefix + "theme-none";
        var _classNamesDynamicDestroy = [
          _classNameViewportNativeScrollbarsInvisible,
          _classNameViewportNativeScrollbarsOverlaid,
          _classNameScrollbarTrackOff,
          _classNameScrollbarHandleOff,
          _classNameScrollbarUnusable,
          _classNameScrollbarAutoHidden,
          _classNameScrollbarCornerResize,
          _classNameScrollbarCornerResizeB,
          _classNameScrollbarCornerResizeH,
          _classNameScrollbarCornerResizeV,
          _classNameDragging
        ].join(_strSpace);
        var _callbacksInitQeueue = [];
        var _viewportAttrsFromTarget = [LEXICON.ti];
        var _defaultOptions;
        var _currentOptions;
        var _currentPreparedOptions;
        var _extensions = {};
        var _extensionsPrivateMethods = "added removed on contract";
        var _lastUpdateTime;
        var _swallowedUpdateHints = {};
        var _swallowedUpdateTimeout;
        var _swallowUpdateLag = 42;
        var _updateOnLoadEventName = "load";
        var _updateOnLoadElms = [];
        var _windowElement;
        var _documentElement;
        var _htmlElement;
        var _bodyElement;
        var _targetElement;
        var _hostElement;
        var _sizeAutoObserverElement;
        var _sizeObserverElement;
        var _paddingElement;
        var _viewportElement;
        var _contentElement;
        var _contentArrangeElement;
        var _contentGlueElement;
        var _textareaCoverElement;
        var _scrollbarCornerElement;
        var _scrollbarHorizontalElement;
        var _scrollbarHorizontalTrackElement;
        var _scrollbarHorizontalHandleElement;
        var _scrollbarVerticalElement;
        var _scrollbarVerticalTrackElement;
        var _scrollbarVerticalHandleElement;
        var _windowElementNative;
        var _documentElementNative;
        var _targetElementNative;
        var _hostElementNative;
        var _sizeAutoObserverElementNative;
        var _sizeObserverElementNative;
        var _paddingElementNative;
        var _viewportElementNative;
        var _contentElementNative;
        var _hostSizeCache;
        var _contentScrollSizeCache;
        var _arrangeContentSizeCache;
        var _hasOverflowCache;
        var _hideOverflowCache;
        var _widthAutoCache;
        var _heightAutoCache;
        var _cssBoxSizingCache;
        var _cssPaddingCache;
        var _cssBorderCache;
        var _cssMarginCache;
        var _cssDirectionCache;
        var _cssDirectionDetectedCache;
        var _paddingAbsoluteCache;
        var _clipAlwaysCache;
        var _contentGlueSizeCache;
        var _overflowBehaviorCache;
        var _overflowAmountCache;
        var _ignoreOverlayScrollbarHidingCache;
        var _autoUpdateCache;
        var _sizeAutoCapableCache;
        var _contentElementScrollSizeChangeDetectedCache;
        var _hostElementSizeChangeDetectedCache;
        var _scrollbarsVisibilityCache;
        var _scrollbarsAutoHideCache;
        var _scrollbarsClickScrollingCache;
        var _scrollbarsDragScrollingCache;
        var _resizeCache;
        var _normalizeRTLCache;
        var _classNameCache;
        var _oldClassName;
        var _textareaAutoWrappingCache;
        var _textareaInfoCache;
        var _textareaSizeCache;
        var _textareaDynHeightCache;
        var _textareaDynWidthCache;
        var _bodyMinSizeCache;
        var _updateAutoCache = {};
        var _mutationObserverHost;
        var _mutationObserverContent;
        var _mutationObserverHostCallback;
        var _mutationObserverContentCallback;
        var _mutationObserversConnected;
        var _mutationObserverAttrsTextarea = ["wrap", "cols", "rows"];
        var _mutationObserverAttrsHost = [LEXICON.i, LEXICON.c, LEXICON.s, "open"].concat(_viewportAttrsFromTarget);
        var _destroyEvents = [];
        var _textareaHasFocus;
        var _scrollbarsAutoHideTimeoutId;
        var _scrollbarsAutoHideMoveTimeoutId;
        var _scrollbarsAutoHideDelay;
        var _scrollbarsAutoHideNever;
        var _scrollbarsAutoHideScroll;
        var _scrollbarsAutoHideMove;
        var _scrollbarsAutoHideLeave;
        var _scrollbarsHandleHovered;
        var _scrollbarsHandlesDefineScrollPos;
        var _resizeNone;
        var _resizeBoth;
        var _resizeHorizontal;
        var _resizeVertical;
        function setupResponsiveEventListener(element, eventNames, listener, remove2, passiveOrOptions) {
          var collected = COMPATIBILITY.isA(eventNames) && COMPATIBILITY.isA(listener);
          var method = remove2 ? "removeEventListener" : "addEventListener";
          var onOff = remove2 ? "off" : "on";
          var events = collected ? false : eventNames.split(_strSpace);
          var i2 = 0;
          var passiveOrOptionsIsObj = FRAMEWORK.isPlainObject(passiveOrOptions);
          var passive = _supportPassiveEvents && (passiveOrOptionsIsObj ? passiveOrOptions._passive : passiveOrOptions) || false;
          var capture = passiveOrOptionsIsObj && (passiveOrOptions._capture || false);
          var nativeParam = _supportPassiveEvents ? {
            passive,
            capture
          } : capture;
          if (collected) {
            for (; i2 < eventNames[LEXICON.l]; i2++)
              setupResponsiveEventListener(element, eventNames[i2], listener[i2], remove2, passiveOrOptions);
          } else {
            for (; i2 < events[LEXICON.l]; i2++) {
              if (_supportPassiveEvents) {
                element[0][method](events[i2], listener, nativeParam);
              } else {
                element[onOff](events[i2], listener);
              }
            }
          }
        }
        function addDestroyEventListener(element, eventNames, listener, passive) {
          setupResponsiveEventListener(element, eventNames, listener, false, passive);
          _destroyEvents.push(COMPATIBILITY.bind(setupResponsiveEventListener, 0, element, eventNames, listener, true, passive));
        }
        function setupResizeObserver(targetElement, onElementResizedCallback) {
          if (targetElement) {
            var resizeObserver = COMPATIBILITY.rO();
            var strAnimationStartEvent = "animationstart mozAnimationStart webkitAnimationStart MSAnimationStart";
            var strChildNodes = "childNodes";
            var constScroll = 3333333;
            var callback = function() {
              targetElement[_strScrollTop](constScroll)[_strScrollLeft](_isRTL ? _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll : constScroll);
              onElementResizedCallback();
            };
            if (onElementResizedCallback) {
              if (_supportResizeObserver) {
                var element = targetElement.addClass("observed").append(generateDiv(_classNameResizeObserverElement)).contents()[0];
                var observer = element[_strResizeObserverProperty] = new resizeObserver(callback);
                observer.observe(element);
              } else {
                if (_msieVersion > 9 || !_autoUpdateRecommended) {
                  targetElement.prepend(generateDiv(_classNameResizeObserverElement, generateDiv({ c: _classNameResizeObserverItemElement, dir: "ltr" }, generateDiv(_classNameResizeObserverItemElement, generateDiv(_classNameResizeObserverItemFinalElement)) + generateDiv(_classNameResizeObserverItemElement, generateDiv({ c: _classNameResizeObserverItemFinalElement, style: "width: 200%; height: 200%" })))));
                  var observerElement = targetElement[0][strChildNodes][0][strChildNodes][0];
                  var shrinkElement = FRAMEWORK(observerElement[strChildNodes][1]);
                  var expandElement = FRAMEWORK(observerElement[strChildNodes][0]);
                  var expandElementChild = FRAMEWORK(expandElement[0][strChildNodes][0]);
                  var widthCache = observerElement[LEXICON.oW];
                  var heightCache = observerElement[LEXICON.oH];
                  var isDirty;
                  var rAFId;
                  var currWidth;
                  var currHeight;
                  var factor = 2;
                  var nativeScrollbarSize = globals.nativeScrollbarSize;
                  var reset = function() {
                    expandElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                    shrinkElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                  };
                  var onResized = function() {
                    rAFId = 0;
                    if (!isDirty)
                      return;
                    widthCache = currWidth;
                    heightCache = currHeight;
                    callback();
                  };
                  var onScroll = function(event2) {
                    currWidth = observerElement[LEXICON.oW];
                    currHeight = observerElement[LEXICON.oH];
                    isDirty = currWidth != widthCache || currHeight != heightCache;
                    if (event2 && isDirty && !rAFId) {
                      COMPATIBILITY.cAF()(rAFId);
                      rAFId = COMPATIBILITY.rAF()(onResized);
                    } else if (!event2)
                      onResized();
                    reset();
                    if (event2) {
                      COMPATIBILITY.prvD(event2);
                      COMPATIBILITY.stpP(event2);
                    }
                    return false;
                  };
                  var expandChildCSS = {};
                  var observerElementCSS = {};
                  setTopRightBottomLeft(observerElementCSS, _strEmpty, [
                    -((nativeScrollbarSize.y + 1) * factor),
                    nativeScrollbarSize.x * -factor,
                    nativeScrollbarSize.y * -factor,
                    -((nativeScrollbarSize.x + 1) * factor)
                  ]);
                  FRAMEWORK(observerElement).css(observerElementCSS);
                  expandElement.on(_strScroll, onScroll);
                  shrinkElement.on(_strScroll, onScroll);
                  targetElement.on(strAnimationStartEvent, function() {
                    onScroll(false);
                  });
                  expandChildCSS[_strWidth] = constScroll;
                  expandChildCSS[_strHeight] = constScroll;
                  expandElementChild.css(expandChildCSS);
                  reset();
                } else {
                  var attachEvent = _documentElementNative.attachEvent;
                  var isIE = _msieVersion !== undefined$1;
                  if (attachEvent) {
                    targetElement.prepend(generateDiv(_classNameResizeObserverElement));
                    findFirst(targetElement, _strDot + _classNameResizeObserverElement)[0].attachEvent("onresize", callback);
                  } else {
                    var obj = _documentElementNative.createElement(TYPES.o);
                    obj.setAttribute(LEXICON.ti, "-1");
                    obj.setAttribute(LEXICON.c, _classNameResizeObserverElement);
                    obj.onload = function() {
                      var wnd = this.contentDocument.defaultView;
                      wnd.addEventListener("resize", callback);
                      wnd.document.documentElement.style.display = "none";
                    };
                    obj.type = "text/html";
                    if (isIE)
                      targetElement.prepend(obj);
                    obj.data = "about:blank";
                    if (!isIE)
                      targetElement.prepend(obj);
                    targetElement.on(strAnimationStartEvent, callback);
                  }
                }
              }
              if (targetElement[0] === _sizeObserverElementNative) {
                var directionChanged = function() {
                  var dir = _hostElement.css("direction");
                  var css = {};
                  var scrollLeftValue = 0;
                  var result = false;
                  if (dir !== _cssDirectionDetectedCache) {
                    if (dir === "ltr") {
                      css[_strLeft] = 0;
                      css[_strRight] = _strAuto;
                      scrollLeftValue = constScroll;
                    } else {
                      css[_strLeft] = _strAuto;
                      css[_strRight] = 0;
                      scrollLeftValue = _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll;
                    }
                    _sizeObserverElement.children().eq(0).css(css);
                    _sizeObserverElement[_strScrollLeft](scrollLeftValue)[_strScrollTop](constScroll);
                    _cssDirectionDetectedCache = dir;
                    result = true;
                  }
                  return result;
                };
                directionChanged();
                addDestroyEventListener(targetElement, _strScroll, function(event2) {
                  if (directionChanged())
                    update2();
                  COMPATIBILITY.prvD(event2);
                  COMPATIBILITY.stpP(event2);
                  return false;
                });
              }
            } else {
              if (_supportResizeObserver) {
                var element = targetElement.contents()[0];
                var resizeObserverObj = element[_strResizeObserverProperty];
                if (resizeObserverObj) {
                  resizeObserverObj.disconnect();
                  delete element[_strResizeObserverProperty];
                }
              } else {
                remove(targetElement.children(_strDot + _classNameResizeObserverElement).eq(0));
              }
            }
          }
        }
        function createMutationObservers() {
          if (_supportMutationObserver) {
            var mutationObserverContentLag = 11;
            var mutationObserver = COMPATIBILITY.mO();
            var contentLastUpdate = COMPATIBILITY.now();
            var mutationTarget;
            var mutationAttrName;
            var mutationIsClass;
            var oldMutationVal;
            var newClassVal;
            var hostClassNameRegex;
            var contentTimeout;
            var now2;
            var sizeAuto;
            var action;
            _mutationObserverHostCallback = function(mutations) {
              var doUpdate = false;
              var doUpdateForce = false;
              var mutation;
              var mutatedAttrs = [];
              if (_initialized && !_sleeping) {
                each(mutations, function() {
                  mutation = this;
                  mutationTarget = mutation.target;
                  mutationAttrName = mutation.attributeName;
                  mutationIsClass = mutationAttrName === LEXICON.c;
                  oldMutationVal = mutation.oldValue;
                  newClassVal = mutationTarget.className;
                  if (_domExists && mutationIsClass && !doUpdateForce) {
                    if (oldMutationVal.indexOf(_classNameHostElementForeign) > -1 && newClassVal.indexOf(_classNameHostElementForeign) < 0) {
                      hostClassNameRegex = createHostClassNameRegExp(true);
                      _hostElementNative.className = newClassVal.split(_strSpace).concat(oldMutationVal.split(_strSpace).filter(function(name2) {
                        return name2.match(hostClassNameRegex);
                      })).join(_strSpace);
                      doUpdate = doUpdateForce = true;
                    }
                  }
                  if (!doUpdate) {
                    doUpdate = mutationIsClass ? hostClassNamesChanged(oldMutationVal, newClassVal) : mutationAttrName === LEXICON.s ? oldMutationVal !== mutationTarget[LEXICON.s].cssText : true;
                  }
                  mutatedAttrs.push(mutationAttrName);
                });
                updateViewportAttrsFromTarget(mutatedAttrs);
                if (doUpdate)
                  _base.update(doUpdateForce || _strAuto);
              }
              return doUpdate;
            };
            _mutationObserverContentCallback = function(mutations) {
              var doUpdate = false;
              var mutation;
              if (_initialized && !_sleeping) {
                each(mutations, function() {
                  mutation = this;
                  doUpdate = isUnknownMutation(mutation);
                  return !doUpdate;
                });
                if (doUpdate) {
                  now2 = COMPATIBILITY.now();
                  sizeAuto = _heightAutoCache || _widthAutoCache;
                  action = function() {
                    if (!_destroyed) {
                      contentLastUpdate = now2;
                      if (_isTextarea)
                        textareaUpdate();
                      if (sizeAuto)
                        update2();
                      else
                        _base.update(_strAuto);
                    }
                  };
                  clearTimeout(contentTimeout);
                  if (mutationObserverContentLag <= 0 || now2 - contentLastUpdate > mutationObserverContentLag || !sizeAuto)
                    action();
                  else
                    contentTimeout = setTimeout(action, mutationObserverContentLag);
                }
              }
              return doUpdate;
            };
            _mutationObserverHost = new mutationObserver(_mutationObserverHostCallback);
            _mutationObserverContent = new mutationObserver(_mutationObserverContentCallback);
          }
        }
        function connectMutationObservers() {
          if (_supportMutationObserver && !_mutationObserversConnected) {
            _mutationObserverHost.observe(_hostElementNative, {
              attributes: true,
              attributeOldValue: true,
              attributeFilter: _mutationObserverAttrsHost
            });
            _mutationObserverContent.observe(_isTextarea ? _targetElementNative : _contentElementNative, {
              attributes: true,
              attributeOldValue: true,
              subtree: !_isTextarea,
              childList: !_isTextarea,
              characterData: !_isTextarea,
              attributeFilter: _isTextarea ? _mutationObserverAttrsTextarea : _mutationObserverAttrsHost
            });
            _mutationObserversConnected = true;
          }
        }
        function disconnectMutationObservers() {
          if (_supportMutationObserver && _mutationObserversConnected) {
            _mutationObserverHost.disconnect();
            _mutationObserverContent.disconnect();
            _mutationObserversConnected = false;
          }
        }
        function hostOnResized() {
          if (!_sleeping) {
            var changed;
            var hostSize = {
              w: _sizeObserverElementNative[LEXICON.sW],
              h: _sizeObserverElementNative[LEXICON.sH]
            };
            changed = checkCache(hostSize, _hostElementSizeChangeDetectedCache);
            _hostElementSizeChangeDetectedCache = hostSize;
            if (changed)
              update2({ _hostSizeChanged: true });
          }
        }
        function hostOnMouseEnter() {
          if (_scrollbarsAutoHideLeave)
            refreshScrollbarsAutoHide(true);
        }
        function hostOnMouseLeave() {
          if (_scrollbarsAutoHideLeave && !_bodyElement.hasClass(_classNameDragging))
            refreshScrollbarsAutoHide(false);
        }
        function hostOnMouseMove() {
          if (_scrollbarsAutoHideMove) {
            refreshScrollbarsAutoHide(true);
            clearTimeout(_scrollbarsAutoHideMoveTimeoutId);
            _scrollbarsAutoHideMoveTimeoutId = setTimeout(function() {
              if (_scrollbarsAutoHideMove && !_destroyed)
                refreshScrollbarsAutoHide(false);
            }, 100);
          }
        }
        function documentOnSelectStart(event2) {
          COMPATIBILITY.prvD(event2);
          return false;
        }
        function updateOnLoadCallback(event2) {
          if (!_destroyed) {
            var target2 = event2.target;
            var elm = FRAMEWORK(event2.target);
            var index2 = FRAMEWORK.inArray(target2, _updateOnLoadElms);
            if (index2 > -1) {
              _updateOnLoadElms.splice(index2, 1);
            }
            eachUpdateOnLoad(function(i2, updateOnLoadSelector) {
              if (elm.is(updateOnLoadSelector)) {
                update2({ _contentSizeChanged: true });
              }
            });
          }
        }
        function setupHostMouseTouchEvents(destroy) {
          if (!destroy)
            setupHostMouseTouchEvents(true);
          setupResponsiveEventListener(_hostElement, _strMouseTouchMoveEvent.split(_strSpace)[0], hostOnMouseMove, !_scrollbarsAutoHideMove || destroy, true);
          setupResponsiveEventListener(_hostElement, [_strMouseEnter, _strMouseLeave], [hostOnMouseEnter, hostOnMouseLeave], !_scrollbarsAutoHideLeave || destroy, true);
          if (!_initialized && !destroy)
            _hostElement.one("mouseover", hostOnMouseEnter);
        }
        function bodyMinSizeChanged() {
          var bodyMinSize = {};
          if (_isBody && _contentArrangeElement) {
            bodyMinSize.w = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strWidth));
            bodyMinSize.h = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strHeight));
            bodyMinSize.c = checkCache(bodyMinSize, _bodyMinSizeCache);
            bodyMinSize.f = true;
          }
          _bodyMinSizeCache = bodyMinSize;
          return !!bodyMinSize.c;
        }
        function hostClassNamesChanged(oldClassNames, newClassNames) {
          var currClasses = typeof newClassNames == TYPES.s ? newClassNames.split(_strSpace) : [];
          var oldClasses = typeof oldClassNames == TYPES.s ? oldClassNames.split(_strSpace) : [];
          var diff = getArrayDifferences(oldClasses, currClasses);
          var idx = inArray(_classNameThemeNone, diff);
          var i2;
          var regex;
          if (idx > -1)
            diff.splice(idx, 1);
          if (diff[LEXICON.l] > 0) {
            regex = createHostClassNameRegExp(true, true);
            for (i2 = 0; i2 < diff.length; i2++) {
              if (!diff[i2].match(regex)) {
                return true;
              }
            }
          }
          return false;
        }
        function isUnknownMutation(mutation) {
          var attributeName = mutation.attributeName;
          var mutationTarget = mutation.target;
          var mutationType = mutation.type;
          var strClosest = "closest";
          if (mutationTarget === _contentElementNative)
            return attributeName === null;
          if (mutationType === "attributes" && (attributeName === LEXICON.c || attributeName === LEXICON.s) && !_isTextarea) {
            if (attributeName === LEXICON.c && FRAMEWORK(mutationTarget).hasClass(_classNameHostElement))
              return hostClassNamesChanged(mutation.oldValue, mutationTarget.className);
            if (typeof mutationTarget[strClosest] != TYPES.f)
              return true;
            if (mutationTarget[strClosest](_strDot + _classNameResizeObserverElement) !== null || mutationTarget[strClosest](_strDot + _classNameScrollbar) !== null || mutationTarget[strClosest](_strDot + _classNameScrollbarCorner) !== null)
              return false;
          }
          return true;
        }
        function updateAutoContentSizeChanged() {
          if (_sleeping)
            return false;
          var contentMeasureElement = getContentMeasureElement();
          var textareaValueLength = _isTextarea && _widthAutoCache && !_textareaAutoWrappingCache ? _targetElement.val().length : 0;
          var setCSS = !_mutationObserversConnected && _widthAutoCache && !_isTextarea;
          var css = {};
          var float;
          var bodyMinSizeC;
          var changed;
          var contentElementScrollSize;
          if (setCSS) {
            float = _contentElement.css(_strFloat);
            css[_strFloat] = _isRTL ? _strRight : _strLeft;
            css[_strWidth] = _strAuto;
            _contentElement.css(css);
          }
          contentElementScrollSize = {
            w: contentMeasureElement[LEXICON.sW] + textareaValueLength,
            h: contentMeasureElement[LEXICON.sH] + textareaValueLength
          };
          if (setCSS) {
            css[_strFloat] = float;
            css[_strWidth] = _strHundredPercent;
            _contentElement.css(css);
          }
          bodyMinSizeC = bodyMinSizeChanged();
          changed = checkCache(contentElementScrollSize, _contentElementScrollSizeChangeDetectedCache);
          _contentElementScrollSizeChangeDetectedCache = contentElementScrollSize;
          return changed || bodyMinSizeC;
        }
        function meaningfulAttrsChanged() {
          if (_sleeping || _mutationObserversConnected)
            return;
          var elem;
          var curr;
          var cache;
          var changedAttrs = [];
          var checks = [
            {
              _elem: _hostElement,
              _attrs: _mutationObserverAttrsHost.concat(":visible")
            },
            {
              _elem: _isTextarea ? _targetElement : undefined$1,
              _attrs: _mutationObserverAttrsTextarea
            }
          ];
          each(checks, function(index2, check) {
            elem = check._elem;
            if (elem) {
              each(check._attrs, function(index3, attr) {
                curr = attr.charAt(0) === ":" ? elem.is(attr) : elem.attr(attr);
                cache = _updateAutoCache[attr];
                if (checkCache(curr, cache)) {
                  changedAttrs.push(attr);
                }
                _updateAutoCache[attr] = curr;
              });
            }
          });
          updateViewportAttrsFromTarget(changedAttrs);
          return changedAttrs[LEXICON.l] > 0;
        }
        function isSizeAffectingCSSProperty(propertyName) {
          if (!_initialized)
            return true;
          var flexGrow = "flex-grow";
          var flexShrink = "flex-shrink";
          var flexBasis = "flex-basis";
          var affectingPropsX = [
            _strWidth,
            _strMinMinus + _strWidth,
            _strMaxMinus + _strWidth,
            _strMarginMinus + _strLeft,
            _strMarginMinus + _strRight,
            _strLeft,
            _strRight,
            "font-weight",
            "word-spacing",
            flexGrow,
            flexShrink,
            flexBasis
          ];
          var affectingPropsXContentBox = [
            _strPaddingMinus + _strLeft,
            _strPaddingMinus + _strRight,
            _strBorderMinus + _strLeft + _strWidth,
            _strBorderMinus + _strRight + _strWidth
          ];
          var affectingPropsY = [
            _strHeight,
            _strMinMinus + _strHeight,
            _strMaxMinus + _strHeight,
            _strMarginMinus + _strTop,
            _strMarginMinus + _strBottom,
            _strTop,
            _strBottom,
            "line-height",
            flexGrow,
            flexShrink,
            flexBasis
          ];
          var affectingPropsYContentBox = [
            _strPaddingMinus + _strTop,
            _strPaddingMinus + _strBottom,
            _strBorderMinus + _strTop + _strWidth,
            _strBorderMinus + _strBottom + _strWidth
          ];
          var _strS = "s";
          var _strVS = "v-s";
          var checkX = _overflowBehaviorCache.x === _strS || _overflowBehaviorCache.x === _strVS;
          var checkY = _overflowBehaviorCache.y === _strS || _overflowBehaviorCache.y === _strVS;
          var sizeIsAffected = false;
          var checkPropertyName = function(arr, name2) {
            for (var i2 = 0; i2 < arr[LEXICON.l]; i2++) {
              if (arr[i2] === name2)
                return true;
            }
            return false;
          };
          if (checkY) {
            sizeIsAffected = checkPropertyName(affectingPropsY, propertyName);
            if (!sizeIsAffected && !_isBorderBox)
              sizeIsAffected = checkPropertyName(affectingPropsYContentBox, propertyName);
          }
          if (checkX && !sizeIsAffected) {
            sizeIsAffected = checkPropertyName(affectingPropsX, propertyName);
            if (!sizeIsAffected && !_isBorderBox)
              sizeIsAffected = checkPropertyName(affectingPropsXContentBox, propertyName);
          }
          return sizeIsAffected;
        }
        function updateViewportAttrsFromTarget(attrs) {
          attrs = attrs || _viewportAttrsFromTarget;
          each(attrs, function(index2, attr) {
            if (COMPATIBILITY.inA(attr, _viewportAttrsFromTarget) > -1) {
              var targetAttr = _targetElement.attr(attr);
              if (type(targetAttr) == TYPES.s) {
                _viewportElement.attr(attr, targetAttr);
              } else {
                _viewportElement.removeAttr(attr);
              }
            }
          });
        }
        function textareaUpdate() {
          if (!_sleeping) {
            var wrapAttrOff = !_textareaAutoWrappingCache;
            var minWidth = _viewportSize.w;
            var minHeight = _viewportSize.h;
            var css = {};
            var doMeasure = _widthAutoCache || wrapAttrOff;
            var origWidth;
            var width;
            var origHeight;
            var height;
            css[_strMinMinus + _strWidth] = _strEmpty;
            css[_strMinMinus + _strHeight] = _strEmpty;
            css[_strWidth] = _strAuto;
            _targetElement.css(css);
            origWidth = _targetElementNative[LEXICON.oW];
            width = doMeasure ? MATH.max(origWidth, _targetElementNative[LEXICON.sW] - 1) : 1;
            css[_strWidth] = _widthAutoCache ? _strAuto : _strHundredPercent;
            css[_strMinMinus + _strWidth] = _strHundredPercent;
            css[_strHeight] = _strAuto;
            _targetElement.css(css);
            origHeight = _targetElementNative[LEXICON.oH];
            height = MATH.max(origHeight, _targetElementNative[LEXICON.sH] - 1);
            css[_strWidth] = width;
            css[_strHeight] = height;
            _textareaCoverElement.css(css);
            css[_strMinMinus + _strWidth] = minWidth;
            css[_strMinMinus + _strHeight] = minHeight;
            _targetElement.css(css);
            return {
              _originalWidth: origWidth,
              _originalHeight: origHeight,
              _dynamicWidth: width,
              _dynamicHeight: height
            };
          }
        }
        function update2(updateHints) {
          clearTimeout(_swallowedUpdateTimeout);
          updateHints = updateHints || {};
          _swallowedUpdateHints._hostSizeChanged |= updateHints._hostSizeChanged;
          _swallowedUpdateHints._contentSizeChanged |= updateHints._contentSizeChanged;
          _swallowedUpdateHints._force |= updateHints._force;
          var now2 = COMPATIBILITY.now();
          var hostSizeChanged = !!_swallowedUpdateHints._hostSizeChanged;
          var contentSizeChanged = !!_swallowedUpdateHints._contentSizeChanged;
          var force = !!_swallowedUpdateHints._force;
          var changedOptions = updateHints._changedOptions;
          var swallow = _initialized && !_destroyed && !force && !changedOptions && now2 - _lastUpdateTime < _swallowUpdateLag && (!_heightAutoCache && !_widthAutoCache);
          var displayIsHidden;
          if (swallow)
            _swallowedUpdateTimeout = setTimeout(update2, _swallowUpdateLag);
          if (_destroyed || swallow || _sleeping && !changedOptions || _initialized && !force && (displayIsHidden = _hostElement.is(":hidden")) || _hostElement.css("display") === "inline")
            return;
          _lastUpdateTime = now2;
          _swallowedUpdateHints = {};
          if (_nativeScrollbarStyling && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
            _nativeScrollbarSize.x = 0;
            _nativeScrollbarSize.y = 0;
          } else {
            _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
          }
          _nativeScrollbarMinSize = {
            x: (_nativeScrollbarSize.x + (_nativeScrollbarIsOverlaid.x ? 0 : 3)) * 3,
            y: (_nativeScrollbarSize.y + (_nativeScrollbarIsOverlaid.y ? 0 : 3)) * 3
          };
          changedOptions = changedOptions || {};
          var checkCacheAutoForce = function() {
            return checkCache.apply(this, [].slice.call(arguments).concat([force]));
          };
          var currScroll = {
            x: _viewportElement[_strScrollLeft](),
            y: _viewportElement[_strScrollTop]()
          };
          var currentPreparedOptionsScrollbars = _currentPreparedOptions.scrollbars;
          var currentPreparedOptionsTextarea = _currentPreparedOptions.textarea;
          var scrollbarsVisibility = currentPreparedOptionsScrollbars.visibility;
          var scrollbarsVisibilityChanged = checkCacheAutoForce(scrollbarsVisibility, _scrollbarsVisibilityCache);
          var scrollbarsAutoHide = currentPreparedOptionsScrollbars.autoHide;
          var scrollbarsAutoHideChanged = checkCacheAutoForce(scrollbarsAutoHide, _scrollbarsAutoHideCache);
          var scrollbarsClickScrolling = currentPreparedOptionsScrollbars.clickScrolling;
          var scrollbarsClickScrollingChanged = checkCacheAutoForce(scrollbarsClickScrolling, _scrollbarsClickScrollingCache);
          var scrollbarsDragScrolling = currentPreparedOptionsScrollbars.dragScrolling;
          var scrollbarsDragScrollingChanged = checkCacheAutoForce(scrollbarsDragScrolling, _scrollbarsDragScrollingCache);
          var className = _currentPreparedOptions.className;
          var classNameChanged = checkCacheAutoForce(className, _classNameCache);
          var resize = _currentPreparedOptions.resize;
          var resizeChanged = checkCacheAutoForce(resize, _resizeCache) && !_isBody;
          var paddingAbsolute = _currentPreparedOptions.paddingAbsolute;
          var paddingAbsoluteChanged = checkCacheAutoForce(paddingAbsolute, _paddingAbsoluteCache);
          var clipAlways = _currentPreparedOptions.clipAlways;
          var clipAlwaysChanged = checkCacheAutoForce(clipAlways, _clipAlwaysCache);
          var sizeAutoCapable = _currentPreparedOptions.sizeAutoCapable && !_isBody;
          var sizeAutoCapableChanged = checkCacheAutoForce(sizeAutoCapable, _sizeAutoCapableCache);
          var ignoreOverlayScrollbarHiding = _currentPreparedOptions.nativeScrollbarsOverlaid.showNativeScrollbars;
          var ignoreOverlayScrollbarHidingChanged = checkCacheAutoForce(ignoreOverlayScrollbarHiding, _ignoreOverlayScrollbarHidingCache);
          var autoUpdate = _currentPreparedOptions.autoUpdate;
          var autoUpdateChanged = checkCacheAutoForce(autoUpdate, _autoUpdateCache);
          var overflowBehavior = _currentPreparedOptions.overflowBehavior;
          var overflowBehaviorChanged = checkCacheAutoForce(overflowBehavior, _overflowBehaviorCache, force);
          var textareaDynWidth = currentPreparedOptionsTextarea.dynWidth;
          var textareaDynWidthChanged = checkCacheAutoForce(_textareaDynWidthCache, textareaDynWidth);
          var textareaDynHeight = currentPreparedOptionsTextarea.dynHeight;
          var textareaDynHeightChanged = checkCacheAutoForce(_textareaDynHeightCache, textareaDynHeight);
          _scrollbarsAutoHideNever = scrollbarsAutoHide === "n";
          _scrollbarsAutoHideScroll = scrollbarsAutoHide === "s";
          _scrollbarsAutoHideMove = scrollbarsAutoHide === "m";
          _scrollbarsAutoHideLeave = scrollbarsAutoHide === "l";
          _scrollbarsAutoHideDelay = currentPreparedOptionsScrollbars.autoHideDelay;
          _oldClassName = _classNameCache;
          _resizeNone = resize === "n";
          _resizeBoth = resize === "b";
          _resizeHorizontal = resize === "h";
          _resizeVertical = resize === "v";
          _normalizeRTLCache = _currentPreparedOptions.normalizeRTL;
          ignoreOverlayScrollbarHiding = ignoreOverlayScrollbarHiding && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y);
          _scrollbarsVisibilityCache = scrollbarsVisibility;
          _scrollbarsAutoHideCache = scrollbarsAutoHide;
          _scrollbarsClickScrollingCache = scrollbarsClickScrolling;
          _scrollbarsDragScrollingCache = scrollbarsDragScrolling;
          _classNameCache = className;
          _resizeCache = resize;
          _paddingAbsoluteCache = paddingAbsolute;
          _clipAlwaysCache = clipAlways;
          _sizeAutoCapableCache = sizeAutoCapable;
          _ignoreOverlayScrollbarHidingCache = ignoreOverlayScrollbarHiding;
          _autoUpdateCache = autoUpdate;
          _overflowBehaviorCache = extendDeep({}, overflowBehavior);
          _textareaDynWidthCache = textareaDynWidth;
          _textareaDynHeightCache = textareaDynHeight;
          _hasOverflowCache = _hasOverflowCache || { x: false, y: false };
          if (classNameChanged) {
            removeClass3(_hostElement, _oldClassName + _strSpace + _classNameThemeNone);
            addClass2(_hostElement, className !== undefined$1 && className !== null && className.length > 0 ? className : _classNameThemeNone);
          }
          if (autoUpdateChanged) {
            if (autoUpdate === true || autoUpdate === null && _autoUpdateRecommended) {
              disconnectMutationObservers();
              autoUpdateLoop.add(_base);
            } else {
              autoUpdateLoop.remove(_base);
              connectMutationObservers();
            }
          }
          if (sizeAutoCapableChanged) {
            if (sizeAutoCapable) {
              if (_contentGlueElement) {
                _contentGlueElement.show();
              } else {
                _contentGlueElement = FRAMEWORK(generateDiv(_classNameContentGlueElement));
                _paddingElement.before(_contentGlueElement);
              }
              if (_sizeAutoObserverAdded) {
                _sizeAutoObserverElement.show();
              } else {
                _sizeAutoObserverElement = FRAMEWORK(generateDiv(_classNameSizeAutoObserverElement));
                _sizeAutoObserverElementNative = _sizeAutoObserverElement[0];
                _contentGlueElement.before(_sizeAutoObserverElement);
                var oldSize = { w: -1, h: -1 };
                setupResizeObserver(_sizeAutoObserverElement, function() {
                  var newSize = {
                    w: _sizeAutoObserverElementNative[LEXICON.oW],
                    h: _sizeAutoObserverElementNative[LEXICON.oH]
                  };
                  if (checkCache(newSize, oldSize)) {
                    if (_initialized && (_heightAutoCache && newSize.h > 0) || _widthAutoCache && newSize.w > 0) {
                      update2();
                    } else if (_initialized && (!_heightAutoCache && newSize.h === 0) || !_widthAutoCache && newSize.w === 0) {
                      update2();
                    }
                  }
                  oldSize = newSize;
                });
                _sizeAutoObserverAdded = true;
                if (_cssCalc !== null)
                  _sizeAutoObserverElement.css(_strHeight, _cssCalc + "(100% + 1px)");
              }
            } else {
              if (_sizeAutoObserverAdded)
                _sizeAutoObserverElement.hide();
              if (_contentGlueElement)
                _contentGlueElement.hide();
            }
          }
          if (force) {
            _sizeObserverElement.find("*").trigger(_strScroll);
            if (_sizeAutoObserverAdded)
              _sizeAutoObserverElement.find("*").trigger(_strScroll);
          }
          displayIsHidden = displayIsHidden === undefined$1 ? _hostElement.is(":hidden") : displayIsHidden;
          var textareaAutoWrapping = _isTextarea ? _targetElement.attr("wrap") !== "off" : false;
          var textareaAutoWrappingChanged = checkCacheAutoForce(textareaAutoWrapping, _textareaAutoWrappingCache);
          var cssDirection = _hostElement.css("direction");
          var cssDirectionChanged = checkCacheAutoForce(cssDirection, _cssDirectionCache);
          var boxSizing = _hostElement.css("box-sizing");
          var boxSizingChanged = checkCacheAutoForce(boxSizing, _cssBoxSizingCache);
          var padding = getTopRightBottomLeftHost(_strPaddingMinus);
          var sizeAutoObserverElementBCRect;
          try {
            sizeAutoObserverElementBCRect = _sizeAutoObserverAdded ? _sizeAutoObserverElementNative[LEXICON.bCR]() : null;
          } catch (ex) {
            return;
          }
          _isRTL = cssDirection === "rtl";
          _isBorderBox = boxSizing === "border-box";
          var isRTLLeft = _isRTL ? _strLeft : _strRight;
          var isRTLRight = _isRTL ? _strRight : _strLeft;
          var widthAutoResizeDetection = false;
          var widthAutoObserverDetection = _sizeAutoObserverAdded && _hostElement.css(_strFloat) !== "none" ? MATH.round(sizeAutoObserverElementBCRect.right - sizeAutoObserverElementBCRect.left) === 0 && (!paddingAbsolute ? _hostElementNative[LEXICON.cW] - _paddingX > 0 : true) : false;
          if (sizeAutoCapable && !widthAutoObserverDetection) {
            var tmpCurrHostWidth = _hostElementNative[LEXICON.oW];
            var tmpCurrContentGlueWidth = _contentGlueElement.css(_strWidth);
            _contentGlueElement.css(_strWidth, _strAuto);
            var tmpNewHostWidth = _hostElementNative[LEXICON.oW];
            _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);
            widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
            if (!widthAutoResizeDetection) {
              _contentGlueElement.css(_strWidth, tmpCurrHostWidth + 1);
              tmpNewHostWidth = _hostElementNative[LEXICON.oW];
              _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);
              widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
            }
          }
          var widthAuto = (widthAutoObserverDetection || widthAutoResizeDetection) && sizeAutoCapable && !displayIsHidden;
          var widthAutoChanged = checkCacheAutoForce(widthAuto, _widthAutoCache);
          var wasWidthAuto = !widthAuto && _widthAutoCache;
          var heightAuto = _sizeAutoObserverAdded && sizeAutoCapable && !displayIsHidden ? MATH.round(sizeAutoObserverElementBCRect.bottom - sizeAutoObserverElementBCRect.top) === 0 : false;
          var heightAutoChanged = checkCacheAutoForce(heightAuto, _heightAutoCache);
          var wasHeightAuto = !heightAuto && _heightAutoCache;
          var updateBorderX = widthAuto && _isBorderBox || !_isBorderBox;
          var updateBorderY = heightAuto && _isBorderBox || !_isBorderBox;
          var border = getTopRightBottomLeftHost(_strBorderMinus, "-" + _strWidth, !updateBorderX, !updateBorderY);
          var margin = getTopRightBottomLeftHost(_strMarginMinus);
          var contentElementCSS = {};
          var contentGlueElementCSS = {};
          var getHostSize = function() {
            return {
              w: _hostElementNative[LEXICON.cW],
              h: _hostElementNative[LEXICON.cH]
            };
          };
          var getViewportSize = function() {
            return {
              w: _paddingElementNative[LEXICON.oW] + MATH.max(0, _contentElementNative[LEXICON.cW] - _contentElementNative[LEXICON.sW]),
              h: _paddingElementNative[LEXICON.oH] + MATH.max(0, _contentElementNative[LEXICON.cH] - _contentElementNative[LEXICON.sH])
            };
          };
          var paddingAbsoluteX = _paddingX = padding.l + padding.r;
          var paddingAbsoluteY = _paddingY = padding.t + padding.b;
          paddingAbsoluteX *= paddingAbsolute ? 1 : 0;
          paddingAbsoluteY *= paddingAbsolute ? 1 : 0;
          padding.c = checkCacheAutoForce(padding, _cssPaddingCache);
          _borderX = border.l + border.r;
          _borderY = border.t + border.b;
          border.c = checkCacheAutoForce(border, _cssBorderCache);
          _marginX = margin.l + margin.r;
          _marginY = margin.t + margin.b;
          margin.c = checkCacheAutoForce(margin, _cssMarginCache);
          _textareaAutoWrappingCache = textareaAutoWrapping;
          _cssDirectionCache = cssDirection;
          _cssBoxSizingCache = boxSizing;
          _widthAutoCache = widthAuto;
          _heightAutoCache = heightAuto;
          _cssPaddingCache = padding;
          _cssBorderCache = border;
          _cssMarginCache = margin;
          if (cssDirectionChanged && _sizeAutoObserverAdded)
            _sizeAutoObserverElement.css(_strFloat, isRTLRight);
          if (padding.c || cssDirectionChanged || paddingAbsoluteChanged || widthAutoChanged || heightAutoChanged || boxSizingChanged || sizeAutoCapableChanged) {
            var paddingElementCSS = {};
            var textareaCSS = {};
            var paddingValues = [padding.t, padding.r, padding.b, padding.l];
            setTopRightBottomLeft(contentGlueElementCSS, _strMarginMinus, [-padding.t, -padding.r, -padding.b, -padding.l]);
            if (paddingAbsolute) {
              setTopRightBottomLeft(paddingElementCSS, _strEmpty, paddingValues);
              setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus);
            } else {
              setTopRightBottomLeft(paddingElementCSS, _strEmpty);
              setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus, paddingValues);
            }
            _paddingElement.css(paddingElementCSS);
            _targetElement.css(textareaCSS);
          }
          _viewportSize = getViewportSize();
          var textareaSize = _isTextarea ? textareaUpdate() : false;
          var textareaSizeChanged = _isTextarea && checkCacheAutoForce(textareaSize, _textareaSizeCache);
          var textareaDynOrigSize = _isTextarea && textareaSize ? {
            w: textareaDynWidth ? textareaSize._dynamicWidth : textareaSize._originalWidth,
            h: textareaDynHeight ? textareaSize._dynamicHeight : textareaSize._originalHeight
          } : {};
          _textareaSizeCache = textareaSize;
          if (heightAuto && (heightAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c)) {
            contentElementCSS[_strHeight] = _strAuto;
          } else if (heightAutoChanged || paddingAbsoluteChanged) {
            contentElementCSS[_strHeight] = _strHundredPercent;
          }
          if (widthAuto && (widthAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c || cssDirectionChanged)) {
            contentElementCSS[_strWidth] = _strAuto;
            contentGlueElementCSS[_strMaxMinus + _strWidth] = _strHundredPercent;
          } else if (widthAutoChanged || paddingAbsoluteChanged) {
            contentElementCSS[_strWidth] = _strHundredPercent;
            contentElementCSS[_strFloat] = _strEmpty;
            contentGlueElementCSS[_strMaxMinus + _strWidth] = _strEmpty;
          }
          if (widthAuto) {
            contentGlueElementCSS[_strWidth] = _strAuto;
            contentElementCSS[_strWidth] = VENDORS._cssPropertyValue(_strWidth, "max-content intrinsic") || _strAuto;
            contentElementCSS[_strFloat] = isRTLRight;
          } else {
            contentGlueElementCSS[_strWidth] = _strEmpty;
          }
          if (heightAuto) {
            contentGlueElementCSS[_strHeight] = textareaDynOrigSize.h || _contentElementNative[LEXICON.cH];
          } else {
            contentGlueElementCSS[_strHeight] = _strEmpty;
          }
          if (sizeAutoCapable)
            _contentGlueElement.css(contentGlueElementCSS);
          _contentElement.css(contentElementCSS);
          contentElementCSS = {};
          contentGlueElementCSS = {};
          if (hostSizeChanged || contentSizeChanged || textareaSizeChanged || cssDirectionChanged || boxSizingChanged || paddingAbsoluteChanged || widthAutoChanged || widthAuto || heightAutoChanged || heightAuto || ignoreOverlayScrollbarHidingChanged || overflowBehaviorChanged || clipAlwaysChanged || resizeChanged || scrollbarsVisibilityChanged || scrollbarsAutoHideChanged || scrollbarsDragScrollingChanged || scrollbarsClickScrollingChanged || textareaDynWidthChanged || textareaDynHeightChanged || textareaAutoWrappingChanged) {
            var strOverflow = "overflow";
            var strOverflowX = strOverflow + "-x";
            var strOverflowY = strOverflow + "-y";
            var strHidden = "hidden";
            var strVisible = "visible";
            if (!_nativeScrollbarStyling) {
              var viewportElementResetCSS = {};
              var resetXTmp = _hasOverflowCache.y && _hideOverflowCache.ys && !ignoreOverlayScrollbarHiding ? _nativeScrollbarIsOverlaid.y ? _viewportElement.css(isRTLLeft) : -_nativeScrollbarSize.y : 0;
              var resetBottomTmp = _hasOverflowCache.x && _hideOverflowCache.xs && !ignoreOverlayScrollbarHiding ? _nativeScrollbarIsOverlaid.x ? _viewportElement.css(_strBottom) : -_nativeScrollbarSize.x : 0;
              setTopRightBottomLeft(viewportElementResetCSS, _strEmpty);
              _viewportElement.css(viewportElementResetCSS);
            }
            var contentMeasureElement = getContentMeasureElement();
            var contentSize = {
              w: textareaDynOrigSize.w || contentMeasureElement[LEXICON.cW],
              h: textareaDynOrigSize.h || contentMeasureElement[LEXICON.cH]
            };
            var scrollSize = {
              w: contentMeasureElement[LEXICON.sW],
              h: contentMeasureElement[LEXICON.sH]
            };
            if (!_nativeScrollbarStyling) {
              viewportElementResetCSS[_strBottom] = wasHeightAuto ? _strEmpty : resetBottomTmp;
              viewportElementResetCSS[isRTLLeft] = wasWidthAuto ? _strEmpty : resetXTmp;
              _viewportElement.css(viewportElementResetCSS);
            }
            _viewportSize = getViewportSize();
            var hostSize = getHostSize();
            var hostAbsoluteRectSize = {
              w: hostSize.w - _marginX - _borderX - (_isBorderBox ? 0 : _paddingX),
              h: hostSize.h - _marginY - _borderY - (_isBorderBox ? 0 : _paddingY)
            };
            var contentGlueSize = {
              w: MATH.max((widthAuto ? contentSize.w : scrollSize.w) + paddingAbsoluteX, hostAbsoluteRectSize.w),
              h: MATH.max((heightAuto ? contentSize.h : scrollSize.h) + paddingAbsoluteY, hostAbsoluteRectSize.h)
            };
            contentGlueSize.c = checkCacheAutoForce(contentGlueSize, _contentGlueSizeCache);
            _contentGlueSizeCache = contentGlueSize;
            if (sizeAutoCapable) {
              if (contentGlueSize.c || (heightAuto || widthAuto)) {
                contentGlueElementCSS[_strWidth] = contentGlueSize.w;
                contentGlueElementCSS[_strHeight] = contentGlueSize.h;
                if (!_isTextarea) {
                  contentSize = {
                    w: contentMeasureElement[LEXICON.cW],
                    h: contentMeasureElement[LEXICON.cH]
                  };
                }
              }
              var textareaCoverCSS = {};
              var setContentGlueElementCSSfunction = function(horizontal) {
                var scrollbarVars = getScrollbarVars(horizontal);
                var wh = scrollbarVars._w_h;
                var strWH = scrollbarVars._width_height;
                var autoSize = horizontal ? widthAuto : heightAuto;
                var borderSize = horizontal ? _borderX : _borderY;
                var paddingSize = horizontal ? _paddingX : _paddingY;
                var marginSize = horizontal ? _marginX : _marginY;
                var viewportSize = _viewportSize[wh] - borderSize - marginSize - (_isBorderBox ? 0 : paddingSize);
                if (!autoSize || !autoSize && border.c)
                  contentGlueElementCSS[strWH] = hostAbsoluteRectSize[wh] - 1;
                if (autoSize && contentSize[wh] < viewportSize && (horizontal && _isTextarea ? !textareaAutoWrapping : true)) {
                  if (_isTextarea)
                    textareaCoverCSS[strWH] = parseToZeroOrNumber(_textareaCoverElement.css(strWH)) - 1;
                  contentGlueElementCSS[strWH] -= 1;
                }
                if (contentSize[wh] > 0)
                  contentGlueElementCSS[strWH] = MATH.max(1, contentGlueElementCSS[strWH]);
              };
              setContentGlueElementCSSfunction(true);
              setContentGlueElementCSSfunction(false);
              if (_isTextarea)
                _textareaCoverElement.css(textareaCoverCSS);
              _contentGlueElement.css(contentGlueElementCSS);
            }
            if (widthAuto)
              contentElementCSS[_strWidth] = _strHundredPercent;
            if (widthAuto && !_isBorderBox && !_mutationObserversConnected)
              contentElementCSS[_strFloat] = "none";
            _contentElement.css(contentElementCSS);
            contentElementCSS = {};
            var contentScrollSize = {
              w: contentMeasureElement[LEXICON.sW],
              h: contentMeasureElement[LEXICON.sH]
            };
            contentScrollSize.c = contentSizeChanged = checkCacheAutoForce(contentScrollSize, _contentScrollSizeCache);
            _contentScrollSizeCache = contentScrollSize;
            _viewportSize = getViewportSize();
            hostSize = getHostSize();
            hostSizeChanged = checkCacheAutoForce(hostSize, _hostSizeCache);
            _hostSizeCache = hostSize;
            var hideOverflowForceTextarea = _isTextarea && (_viewportSize.w === 0 || _viewportSize.h === 0);
            var previousOverflowAmount = _overflowAmountCache;
            var overflowBehaviorIsVS = {};
            var overflowBehaviorIsVH = {};
            var overflowBehaviorIsS = {};
            var overflowAmount = {};
            var hasOverflow = {};
            var hideOverflow = {};
            var canScroll = {};
            var viewportRect = _paddingElementNative[LEXICON.bCR]();
            var setOverflowVariables = function(horizontal) {
              var scrollbarVars = getScrollbarVars(horizontal);
              var scrollbarVarsInverted = getScrollbarVars(!horizontal);
              var xyI = scrollbarVarsInverted._x_y;
              var xy = scrollbarVars._x_y;
              var wh = scrollbarVars._w_h;
              var widthHeight = scrollbarVars._width_height;
              var scrollMax = _strScroll + scrollbarVars._Left_Top + "Max";
              var fractionalOverflowAmount = viewportRect[widthHeight] ? MATH.abs(viewportRect[widthHeight] - _viewportSize[wh]) : 0;
              var checkFractionalOverflowAmount = previousOverflowAmount && previousOverflowAmount[xy] > 0 && _viewportElementNative[scrollMax] === 0;
              overflowBehaviorIsVS[xy] = overflowBehavior[xy] === "v-s";
              overflowBehaviorIsVH[xy] = overflowBehavior[xy] === "v-h";
              overflowBehaviorIsS[xy] = overflowBehavior[xy] === "s";
              overflowAmount[xy] = MATH.max(0, MATH.round((contentScrollSize[wh] - _viewportSize[wh]) * 100) / 100);
              overflowAmount[xy] *= hideOverflowForceTextarea || checkFractionalOverflowAmount && fractionalOverflowAmount > 0 && fractionalOverflowAmount < 1 ? 0 : 1;
              hasOverflow[xy] = overflowAmount[xy] > 0;
              hideOverflow[xy] = overflowBehaviorIsVS[xy] || overflowBehaviorIsVH[xy] ? hasOverflow[xyI] && !overflowBehaviorIsVS[xyI] && !overflowBehaviorIsVH[xyI] : hasOverflow[xy];
              hideOverflow[xy + "s"] = hideOverflow[xy] ? overflowBehaviorIsS[xy] || overflowBehaviorIsVS[xy] : false;
              canScroll[xy] = hasOverflow[xy] && hideOverflow[xy + "s"];
            };
            setOverflowVariables(true);
            setOverflowVariables(false);
            overflowAmount.c = checkCacheAutoForce(overflowAmount, _overflowAmountCache);
            _overflowAmountCache = overflowAmount;
            hasOverflow.c = checkCacheAutoForce(hasOverflow, _hasOverflowCache);
            _hasOverflowCache = hasOverflow;
            hideOverflow.c = checkCacheAutoForce(hideOverflow, _hideOverflowCache);
            _hideOverflowCache = hideOverflow;
            if (_nativeScrollbarIsOverlaid.x || _nativeScrollbarIsOverlaid.y) {
              var borderDesign = "px solid transparent";
              var contentArrangeElementCSS = {};
              var arrangeContent = {};
              var arrangeChanged = force;
              var setContentElementCSS;
              if (hasOverflow.x || hasOverflow.y) {
                arrangeContent.w = _nativeScrollbarIsOverlaid.y && hasOverflow.y ? contentScrollSize.w + _overlayScrollbarDummySize.y : _strEmpty;
                arrangeContent.h = _nativeScrollbarIsOverlaid.x && hasOverflow.x ? contentScrollSize.h + _overlayScrollbarDummySize.x : _strEmpty;
                arrangeChanged = checkCacheAutoForce(arrangeContent, _arrangeContentSizeCache);
                _arrangeContentSizeCache = arrangeContent;
              }
              if (hasOverflow.c || hideOverflow.c || contentScrollSize.c || cssDirectionChanged || widthAutoChanged || heightAutoChanged || widthAuto || heightAuto || ignoreOverlayScrollbarHidingChanged) {
                contentElementCSS[_strMarginMinus + isRTLRight] = contentElementCSS[_strBorderMinus + isRTLRight] = _strEmpty;
                setContentElementCSS = function(horizontal) {
                  var scrollbarVars = getScrollbarVars(horizontal);
                  var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                  var xy = scrollbarVars._x_y;
                  var strDirection = horizontal ? _strBottom : isRTLLeft;
                  var invertedAutoSize = horizontal ? heightAuto : widthAuto;
                  if (_nativeScrollbarIsOverlaid[xy] && hasOverflow[xy] && hideOverflow[xy + "s"]) {
                    contentElementCSS[_strMarginMinus + strDirection] = invertedAutoSize ? ignoreOverlayScrollbarHiding ? _strEmpty : _overlayScrollbarDummySize[xy] : _strEmpty;
                    contentElementCSS[_strBorderMinus + strDirection] = (horizontal ? !invertedAutoSize : true) && !ignoreOverlayScrollbarHiding ? _overlayScrollbarDummySize[xy] + borderDesign : _strEmpty;
                  } else {
                    arrangeContent[scrollbarVarsInverted._w_h] = contentElementCSS[_strMarginMinus + strDirection] = contentElementCSS[_strBorderMinus + strDirection] = _strEmpty;
                    arrangeChanged = true;
                  }
                };
                if (_nativeScrollbarStyling) {
                  addRemoveClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible, !ignoreOverlayScrollbarHiding);
                } else {
                  setContentElementCSS(true);
                  setContentElementCSS(false);
                }
              }
              if (ignoreOverlayScrollbarHiding) {
                arrangeContent.w = arrangeContent.h = _strEmpty;
                arrangeChanged = true;
              }
              if (arrangeChanged && !_nativeScrollbarStyling) {
                contentArrangeElementCSS[_strWidth] = hideOverflow.y ? arrangeContent.w : _strEmpty;
                contentArrangeElementCSS[_strHeight] = hideOverflow.x ? arrangeContent.h : _strEmpty;
                if (!_contentArrangeElement) {
                  _contentArrangeElement = FRAMEWORK(generateDiv(_classNameContentArrangeElement));
                  _viewportElement.prepend(_contentArrangeElement);
                }
                _contentArrangeElement.css(contentArrangeElementCSS);
              }
              _contentElement.css(contentElementCSS);
            }
            var viewportElementCSS = {};
            var paddingElementCSS = {};
            var setViewportCSS;
            if (hostSizeChanged || hasOverflow.c || hideOverflow.c || contentScrollSize.c || overflowBehaviorChanged || boxSizingChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged || clipAlwaysChanged || heightAutoChanged) {
              viewportElementCSS[isRTLRight] = _strEmpty;
              setViewportCSS = function(horizontal) {
                var scrollbarVars = getScrollbarVars(horizontal);
                var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                var xy = scrollbarVars._x_y;
                var XY = scrollbarVars._X_Y;
                var strDirection = horizontal ? _strBottom : isRTLLeft;
                var reset = function() {
                  viewportElementCSS[strDirection] = _strEmpty;
                  _contentBorderSize[scrollbarVarsInverted._w_h] = 0;
                };
                if (hasOverflow[xy] && hideOverflow[xy + "s"]) {
                  viewportElementCSS[strOverflow + XY] = _strScroll;
                  if (ignoreOverlayScrollbarHiding || _nativeScrollbarStyling) {
                    reset();
                  } else {
                    viewportElementCSS[strDirection] = -(_nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[xy] : _nativeScrollbarSize[xy]);
                    _contentBorderSize[scrollbarVarsInverted._w_h] = _nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[scrollbarVarsInverted._x_y] : 0;
                  }
                } else {
                  viewportElementCSS[strOverflow + XY] = _strEmpty;
                  reset();
                }
              };
              setViewportCSS(true);
              setViewportCSS(false);
              if (!_nativeScrollbarStyling && (_viewportSize.h < _nativeScrollbarMinSize.x || _viewportSize.w < _nativeScrollbarMinSize.y) && (hasOverflow.x && hideOverflow.x && !_nativeScrollbarIsOverlaid.x || hasOverflow.y && hideOverflow.y && !_nativeScrollbarIsOverlaid.y)) {
                viewportElementCSS[_strPaddingMinus + _strTop] = _nativeScrollbarMinSize.x;
                viewportElementCSS[_strMarginMinus + _strTop] = -_nativeScrollbarMinSize.x;
                viewportElementCSS[_strPaddingMinus + isRTLRight] = _nativeScrollbarMinSize.y;
                viewportElementCSS[_strMarginMinus + isRTLRight] = -_nativeScrollbarMinSize.y;
              } else {
                viewportElementCSS[_strPaddingMinus + _strTop] = viewportElementCSS[_strMarginMinus + _strTop] = viewportElementCSS[_strPaddingMinus + isRTLRight] = viewportElementCSS[_strMarginMinus + isRTLRight] = _strEmpty;
              }
              viewportElementCSS[_strPaddingMinus + isRTLLeft] = viewportElementCSS[_strMarginMinus + isRTLLeft] = _strEmpty;
              if (hasOverflow.x && hideOverflow.x || hasOverflow.y && hideOverflow.y || hideOverflowForceTextarea) {
                if (_isTextarea && hideOverflowForceTextarea) {
                  paddingElementCSS[strOverflowX] = paddingElementCSS[strOverflowY] = strHidden;
                }
              } else {
                if (!clipAlways || (overflowBehaviorIsVH.x || overflowBehaviorIsVS.x || overflowBehaviorIsVH.y || overflowBehaviorIsVS.y)) {
                  if (_isTextarea) {
                    paddingElementCSS[strOverflowX] = paddingElementCSS[strOverflowY] = _strEmpty;
                  }
                  viewportElementCSS[strOverflowX] = viewportElementCSS[strOverflowY] = strVisible;
                }
              }
              _paddingElement.css(paddingElementCSS);
              _viewportElement.css(viewportElementCSS);
              viewportElementCSS = {};
              if ((hasOverflow.c || boxSizingChanged || widthAutoChanged || heightAutoChanged) && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                var elementStyle = _contentElementNative[LEXICON.s];
                elementStyle.webkitTransform = "scale(1)";
                elementStyle.display = "run-in";
                elementStyle.display = _strEmpty;
                elementStyle.webkitTransform = _strEmpty;
              }
            }
            contentElementCSS = {};
            if (cssDirectionChanged || widthAutoChanged || heightAutoChanged) {
              if (_isRTL && widthAuto) {
                var floatTmp = _contentElement.css(_strFloat);
                var posLeftWithoutFloat = MATH.round(_contentElement.css(_strFloat, _strEmpty).css(_strLeft, _strEmpty).position().left);
                _contentElement.css(_strFloat, floatTmp);
                var posLeftWithFloat = MATH.round(_contentElement.position().left);
                if (posLeftWithoutFloat !== posLeftWithFloat)
                  contentElementCSS[_strLeft] = posLeftWithoutFloat;
              } else {
                contentElementCSS[_strLeft] = _strEmpty;
              }
            }
            _contentElement.css(contentElementCSS);
            if (_isTextarea && contentSizeChanged) {
              var textareaInfo = getTextareaInfo();
              if (textareaInfo) {
                var textareaRowsChanged = _textareaInfoCache === undefined$1 ? true : textareaInfo._rows !== _textareaInfoCache._rows;
                var cursorRow = textareaInfo._cursorRow;
                var cursorCol = textareaInfo._cursorColumn;
                var widestRow = textareaInfo._widestRow;
                var lastRow = textareaInfo._rows;
                var lastCol = textareaInfo._columns;
                var cursorPos = textareaInfo._cursorPosition;
                var cursorMax = textareaInfo._cursorMax;
                var cursorIsLastPosition = cursorPos >= cursorMax && _textareaHasFocus;
                var textareaScrollAmount = {
                  x: !textareaAutoWrapping && (cursorCol === lastCol && cursorRow === widestRow) ? _overflowAmountCache.x : -1,
                  y: (textareaAutoWrapping ? cursorIsLastPosition || textareaRowsChanged && (previousOverflowAmount ? currScroll.y === previousOverflowAmount.y : false) : (cursorIsLastPosition || textareaRowsChanged) && cursorRow === lastRow) ? _overflowAmountCache.y : -1
                };
                currScroll.x = textareaScrollAmount.x > -1 ? _isRTL && _normalizeRTLCache && _rtlScrollBehavior.i ? 0 : textareaScrollAmount.x : currScroll.x;
                currScroll.y = textareaScrollAmount.y > -1 ? textareaScrollAmount.y : currScroll.y;
              }
              _textareaInfoCache = textareaInfo;
            }
            if (_isRTL && _rtlScrollBehavior.i && _nativeScrollbarIsOverlaid.y && hasOverflow.x && _normalizeRTLCache)
              currScroll.x += _contentBorderSize.w || 0;
            if (widthAuto)
              _hostElement[_strScrollLeft](0);
            if (heightAuto)
              _hostElement[_strScrollTop](0);
            _viewportElement[_strScrollLeft](currScroll.x)[_strScrollTop](currScroll.y);
            var scrollbarsVisibilityVisible = scrollbarsVisibility === "v";
            var scrollbarsVisibilityHidden = scrollbarsVisibility === "h";
            var scrollbarsVisibilityAuto = scrollbarsVisibility === "a";
            var refreshScrollbarsVisibility = function(showX, showY) {
              showY = showY === undefined$1 ? showX : showY;
              refreshScrollbarAppearance(true, showX, canScroll.x);
              refreshScrollbarAppearance(false, showY, canScroll.y);
            };
            addRemoveClass(_hostElement, _classNameHostOverflow, hideOverflow.x || hideOverflow.y);
            addRemoveClass(_hostElement, _classNameHostOverflowX, hideOverflow.x);
            addRemoveClass(_hostElement, _classNameHostOverflowY, hideOverflow.y);
            if (cssDirectionChanged && !_isBody) {
              addRemoveClass(_hostElement, _classNameHostRTL, _isRTL);
            }
            if (_isBody)
              addClass2(_hostElement, _classNameHostResizeDisabled);
            if (resizeChanged) {
              addRemoveClass(_hostElement, _classNameHostResizeDisabled, _resizeNone);
              addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResize, !_resizeNone);
              addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeB, _resizeBoth);
              addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeH, _resizeHorizontal);
              addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeV, _resizeVertical);
            }
            if (scrollbarsVisibilityChanged || overflowBehaviorChanged || hideOverflow.c || hasOverflow.c || ignoreOverlayScrollbarHidingChanged) {
              if (ignoreOverlayScrollbarHiding) {
                if (ignoreOverlayScrollbarHidingChanged) {
                  removeClass3(_hostElement, _classNameHostScrolling);
                  if (ignoreOverlayScrollbarHiding) {
                    refreshScrollbarsVisibility(false);
                  }
                }
              } else if (scrollbarsVisibilityAuto) {
                refreshScrollbarsVisibility(canScroll.x, canScroll.y);
              } else if (scrollbarsVisibilityVisible) {
                refreshScrollbarsVisibility(true);
              } else if (scrollbarsVisibilityHidden) {
                refreshScrollbarsVisibility(false);
              }
            }
            if (scrollbarsAutoHideChanged || ignoreOverlayScrollbarHidingChanged) {
              setupHostMouseTouchEvents(!_scrollbarsAutoHideLeave && !_scrollbarsAutoHideMove);
              refreshScrollbarsAutoHide(_scrollbarsAutoHideNever, !_scrollbarsAutoHideNever);
            }
            if (hostSizeChanged || overflowAmount.c || heightAutoChanged || widthAutoChanged || resizeChanged || boxSizingChanged || paddingAbsoluteChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged) {
              refreshScrollbarHandleLength(true);
              refreshScrollbarHandleOffset(true);
              refreshScrollbarHandleLength(false);
              refreshScrollbarHandleOffset(false);
            }
            if (scrollbarsClickScrollingChanged)
              refreshScrollbarsInteractive(true, scrollbarsClickScrolling);
            if (scrollbarsDragScrollingChanged)
              refreshScrollbarsInteractive(false, scrollbarsDragScrolling);
            dispatchCallback("onDirectionChanged", {
              isRTL: _isRTL,
              dir: cssDirection
            }, cssDirectionChanged);
            dispatchCallback("onHostSizeChanged", {
              width: _hostSizeCache.w,
              height: _hostSizeCache.h
            }, hostSizeChanged);
            dispatchCallback("onContentSizeChanged", {
              width: _contentScrollSizeCache.w,
              height: _contentScrollSizeCache.h
            }, contentSizeChanged);
            dispatchCallback("onOverflowChanged", {
              x: hasOverflow.x,
              y: hasOverflow.y,
              xScrollable: hideOverflow.xs,
              yScrollable: hideOverflow.ys,
              clipped: hideOverflow.x || hideOverflow.y
            }, hasOverflow.c || hideOverflow.c);
            dispatchCallback("onOverflowAmountChanged", {
              x: overflowAmount.x,
              y: overflowAmount.y
            }, overflowAmount.c);
          }
          if (_isBody && _bodyMinSizeCache && (_hasOverflowCache.c || _bodyMinSizeCache.c)) {
            if (!_bodyMinSizeCache.f)
              bodyMinSizeChanged();
            if (_nativeScrollbarIsOverlaid.y && _hasOverflowCache.x)
              _contentElement.css(_strMinMinus + _strWidth, _bodyMinSizeCache.w + _overlayScrollbarDummySize.y);
            if (_nativeScrollbarIsOverlaid.x && _hasOverflowCache.y)
              _contentElement.css(_strMinMinus + _strHeight, _bodyMinSizeCache.h + _overlayScrollbarDummySize.x);
            _bodyMinSizeCache.c = false;
          }
          if (_initialized && changedOptions.updateOnLoad) {
            updateElementsOnLoad();
          }
          dispatchCallback("onUpdated", { forced: force });
        }
        function updateElementsOnLoad() {
          if (!_isTextarea) {
            eachUpdateOnLoad(function(i2, updateOnLoadSelector) {
              _contentElement.find(updateOnLoadSelector).each(function(i3, el) {
                if (COMPATIBILITY.inA(el, _updateOnLoadElms) < 0) {
                  _updateOnLoadElms.push(el);
                  FRAMEWORK(el).off(_updateOnLoadEventName, updateOnLoadCallback).on(_updateOnLoadEventName, updateOnLoadCallback);
                }
              });
            });
          }
        }
        function setOptions(newOptions) {
          var validatedOpts = _pluginsOptions._validate(newOptions, _pluginsOptions._template, true, _currentOptions);
          _currentOptions = extendDeep({}, _currentOptions, validatedOpts._default);
          _currentPreparedOptions = extendDeep({}, _currentPreparedOptions, validatedOpts._prepared);
          return validatedOpts._prepared;
        }
        function setupStructureDOM(destroy) {
          var strParent = "parent";
          var classNameResizeObserverHost = "os-resize-observer-host";
          var classNameTextareaElementFull = _classNameTextareaElement + _strSpace + _classNameTextInherit;
          var textareaClass = _isTextarea ? _strSpace + _classNameTextInherit : _strEmpty;
          var adoptAttrs = _currentPreparedOptions.textarea.inheritedAttrs;
          var adoptAttrsMap = {};
          var applyAdoptedAttrs = function() {
            var applyAdoptedAttrsElm = destroy ? _targetElement : _hostElement;
            each(adoptAttrsMap, function(key, value) {
              if (type(value) == TYPES.s) {
                if (key == LEXICON.c)
                  applyAdoptedAttrsElm.addClass(value);
                else
                  applyAdoptedAttrsElm.attr(key, value);
              }
            });
          };
          var hostElementClassNames = [
            _classNameHostElement,
            _classNameHostElementForeign,
            _classNameHostTextareaElement,
            _classNameHostResizeDisabled,
            _classNameHostRTL,
            _classNameHostScrollbarHorizontalHidden,
            _classNameHostScrollbarVerticalHidden,
            _classNameHostTransition,
            _classNameHostScrolling,
            _classNameHostOverflow,
            _classNameHostOverflowX,
            _classNameHostOverflowY,
            _classNameThemeNone,
            _classNameTextareaElement,
            _classNameTextInherit,
            _classNameCache
          ].join(_strSpace);
          var hostElementCSS = {};
          _hostElement = _hostElement || (_isTextarea ? _domExists ? _targetElement[strParent]()[strParent]()[strParent]()[strParent]() : FRAMEWORK(generateDiv(_classNameHostTextareaElement)) : _targetElement);
          _contentElement = _contentElement || selectOrGenerateDivByClass(_classNameContentElement + textareaClass);
          _viewportElement = _viewportElement || selectOrGenerateDivByClass(_classNameViewportElement + textareaClass);
          _paddingElement = _paddingElement || selectOrGenerateDivByClass(_classNamePaddingElement + textareaClass);
          _sizeObserverElement = _sizeObserverElement || selectOrGenerateDivByClass(classNameResizeObserverHost);
          _textareaCoverElement = _textareaCoverElement || (_isTextarea ? selectOrGenerateDivByClass(_classNameTextareaCoverElement) : undefined$1);
          if (_domExists)
            addClass2(_hostElement, _classNameHostElementForeign);
          if (destroy)
            removeClass3(_hostElement, hostElementClassNames);
          adoptAttrs = type(adoptAttrs) == TYPES.s ? adoptAttrs.split(_strSpace) : adoptAttrs;
          if (COMPATIBILITY.isA(adoptAttrs) && _isTextarea) {
            each(adoptAttrs, function(i2, v) {
              if (type(v) == TYPES.s) {
                adoptAttrsMap[v] = destroy ? _hostElement.attr(v) : _targetElement.attr(v);
              }
            });
          }
          if (!destroy) {
            if (_isTextarea) {
              if (!_currentPreparedOptions.sizeAutoCapable) {
                hostElementCSS[_strWidth] = _targetElement.css(_strWidth);
                hostElementCSS[_strHeight] = _targetElement.css(_strHeight);
              }
              if (!_domExists)
                _targetElement.addClass(_classNameTextInherit).wrap(_hostElement);
              _hostElement = _targetElement[strParent]().css(hostElementCSS);
            }
            if (!_domExists) {
              addClass2(_targetElement, _isTextarea ? classNameTextareaElementFull : _classNameHostElement);
              _hostElement.wrapInner(_contentElement).wrapInner(_viewportElement).wrapInner(_paddingElement).prepend(_sizeObserverElement);
              _contentElement = findFirst(_hostElement, _strDot + _classNameContentElement);
              _viewportElement = findFirst(_hostElement, _strDot + _classNameViewportElement);
              _paddingElement = findFirst(_hostElement, _strDot + _classNamePaddingElement);
              if (_isTextarea) {
                _contentElement.prepend(_textareaCoverElement);
                applyAdoptedAttrs();
              }
            }
            if (_nativeScrollbarStyling)
              addClass2(_viewportElement, _classNameViewportNativeScrollbarsInvisible);
            if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)
              addClass2(_viewportElement, _classNameViewportNativeScrollbarsOverlaid);
            if (_isBody)
              addClass2(_htmlElement, _classNameHTMLElement);
            _sizeObserverElementNative = _sizeObserverElement[0];
            _hostElementNative = _hostElement[0];
            _paddingElementNative = _paddingElement[0];
            _viewportElementNative = _viewportElement[0];
            _contentElementNative = _contentElement[0];
            updateViewportAttrsFromTarget();
          } else {
            if (_domExists && _initialized) {
              _sizeObserverElement.children().remove();
              each([_paddingElement, _viewportElement, _contentElement, _textareaCoverElement], function(i2, elm) {
                if (elm) {
                  removeClass3(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                }
              });
              addClass2(_hostElement, _isTextarea ? _classNameHostTextareaElement : _classNameHostElement);
            } else {
              remove(_sizeObserverElement);
              _contentElement.contents().unwrap().unwrap().unwrap();
              if (_isTextarea) {
                _targetElement.unwrap();
                remove(_hostElement);
                remove(_textareaCoverElement);
                applyAdoptedAttrs();
              }
            }
            if (_isTextarea)
              _targetElement.removeAttr(LEXICON.s);
            if (_isBody)
              removeClass3(_htmlElement, _classNameHTMLElement);
          }
        }
        function setupStructureEvents() {
          var textareaKeyDownRestrictedKeyCodes = [
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            123,
            33,
            34,
            37,
            38,
            39,
            40,
            16,
            17,
            18,
            19,
            20,
            144
          ];
          var textareaKeyDownKeyCodesList = [];
          var textareaUpdateIntervalID;
          var scrollStopTimeoutId;
          var scrollStopDelay = 175;
          var strFocus = "focus";
          function updateTextarea(doClearInterval) {
            textareaUpdate();
            _base.update(_strAuto);
            if (doClearInterval && _autoUpdateRecommended)
              clearInterval(textareaUpdateIntervalID);
          }
          function textareaOnScroll(event2) {
            _targetElement[_strScrollLeft](_rtlScrollBehavior.i && _normalizeRTLCache ? 9999999 : 0);
            _targetElement[_strScrollTop](0);
            COMPATIBILITY.prvD(event2);
            COMPATIBILITY.stpP(event2);
            return false;
          }
          function textareaOnDrop(event2) {
            setTimeout(function() {
              if (!_destroyed)
                updateTextarea();
            }, 50);
          }
          function textareaOnFocus() {
            _textareaHasFocus = true;
            addClass2(_hostElement, strFocus);
          }
          function textareaOnFocusout() {
            _textareaHasFocus = false;
            textareaKeyDownKeyCodesList = [];
            removeClass3(_hostElement, strFocus);
            updateTextarea(true);
          }
          function textareaOnKeyDown(event2) {
            var keyCode = event2.keyCode;
            if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
              if (!textareaKeyDownKeyCodesList[LEXICON.l]) {
                updateTextarea();
                textareaUpdateIntervalID = setInterval(updateTextarea, 1e3 / 60);
              }
              if (inArray(keyCode, textareaKeyDownKeyCodesList) < 0)
                textareaKeyDownKeyCodesList.push(keyCode);
            }
          }
          function textareaOnKeyUp(event2) {
            var keyCode = event2.keyCode;
            var index2 = inArray(keyCode, textareaKeyDownKeyCodesList);
            if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
              if (index2 > -1)
                textareaKeyDownKeyCodesList.splice(index2, 1);
              if (!textareaKeyDownKeyCodesList[LEXICON.l])
                updateTextarea(true);
            }
          }
          function contentOnTransitionEnd(event2) {
            if (_autoUpdateCache === true)
              return;
            event2 = event2.originalEvent || event2;
            if (isSizeAffectingCSSProperty(event2.propertyName))
              _base.update(_strAuto);
          }
          function viewportOnScroll(event2) {
            if (!_sleeping) {
              if (scrollStopTimeoutId !== undefined$1)
                clearTimeout(scrollStopTimeoutId);
              else {
                if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                  refreshScrollbarsAutoHide(true);
                if (!nativeOverlayScrollbarsAreActive())
                  addClass2(_hostElement, _classNameHostScrolling);
                dispatchCallback("onScrollStart", event2);
              }
              if (!_scrollbarsHandlesDefineScrollPos) {
                refreshScrollbarHandleOffset(true);
                refreshScrollbarHandleOffset(false);
              }
              dispatchCallback("onScroll", event2);
              scrollStopTimeoutId = setTimeout(function() {
                if (!_destroyed) {
                  clearTimeout(scrollStopTimeoutId);
                  scrollStopTimeoutId = undefined$1;
                  if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                    refreshScrollbarsAutoHide(false);
                  if (!nativeOverlayScrollbarsAreActive())
                    removeClass3(_hostElement, _classNameHostScrolling);
                  dispatchCallback("onScrollStop", event2);
                }
              }, scrollStopDelay);
            }
          }
          if (_isTextarea) {
            if (_msieVersion > 9 || !_autoUpdateRecommended) {
              addDestroyEventListener(_targetElement, "input", updateTextarea);
            } else {
              addDestroyEventListener(_targetElement, [_strKeyDownEvent, _strKeyUpEvent], [textareaOnKeyDown, textareaOnKeyUp]);
            }
            addDestroyEventListener(_targetElement, [_strScroll, "drop", strFocus, strFocus + "out"], [textareaOnScroll, textareaOnDrop, textareaOnFocus, textareaOnFocusout]);
          } else {
            addDestroyEventListener(_contentElement, _strTransitionEndEvent, contentOnTransitionEnd);
          }
          addDestroyEventListener(_viewportElement, _strScroll, viewportOnScroll, true);
        }
        function setupScrollbarsDOM(destroy) {
          var selectOrGenerateScrollbarDOM = function(isHorizontal) {
            var scrollbarClassName = isHorizontal ? _classNameScrollbarHorizontal : _classNameScrollbarVertical;
            var scrollbar = selectOrGenerateDivByClass(_classNameScrollbar + _strSpace + scrollbarClassName, true);
            var track = selectOrGenerateDivByClass(_classNameScrollbarTrack, scrollbar);
            var handle = selectOrGenerateDivByClass(_classNameScrollbarHandle, scrollbar);
            if (!_domExists && !destroy) {
              scrollbar.append(track);
              track.append(handle);
            }
            return {
              _scrollbar: scrollbar,
              _track: track,
              _handle: handle
            };
          };
          function resetScrollbarDOM(isHorizontal) {
            var scrollbarVars = getScrollbarVars(isHorizontal);
            var scrollbar = scrollbarVars._scrollbar;
            var track = scrollbarVars._track;
            var handle = scrollbarVars._handle;
            if (_domExists && _initialized) {
              each([scrollbar, track, handle], function(i2, elm) {
                removeClass3(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
              });
            } else {
              remove(scrollbar || selectOrGenerateScrollbarDOM(isHorizontal)._scrollbar);
            }
          }
          var horizontalElements;
          var verticalElements;
          if (!destroy) {
            horizontalElements = selectOrGenerateScrollbarDOM(true);
            verticalElements = selectOrGenerateScrollbarDOM();
            _scrollbarHorizontalElement = horizontalElements._scrollbar;
            _scrollbarHorizontalTrackElement = horizontalElements._track;
            _scrollbarHorizontalHandleElement = horizontalElements._handle;
            _scrollbarVerticalElement = verticalElements._scrollbar;
            _scrollbarVerticalTrackElement = verticalElements._track;
            _scrollbarVerticalHandleElement = verticalElements._handle;
            if (!_domExists) {
              _paddingElement.after(_scrollbarVerticalElement);
              _paddingElement.after(_scrollbarHorizontalElement);
            }
          } else {
            resetScrollbarDOM(true);
            resetScrollbarDOM();
          }
        }
        function setupScrollbarEvents(isHorizontal) {
          var scrollbarVars = getScrollbarVars(isHorizontal);
          var scrollbarVarsInfo = scrollbarVars._info;
          var insideIFrame = _windowElementNative.top !== _windowElementNative;
          var xy = scrollbarVars._x_y;
          var XY = scrollbarVars._X_Y;
          var scroll = _strScroll + scrollbarVars._Left_Top;
          var strActive = "active";
          var strSnapHandle = "snapHandle";
          var strClickEvent = "click";
          var scrollDurationFactor = 1;
          var increaseDecreaseScrollAmountKeyCodes = [16, 17];
          var trackTimeout;
          var mouseDownScroll;
          var mouseDownOffset;
          var mouseDownInvertedScale;
          function getPointerPosition(event2) {
            return _msieVersion && insideIFrame ? event2["screen" + XY] : COMPATIBILITY.page(event2)[xy];
          }
          function getPreparedScrollbarsOption(name2) {
            return _currentPreparedOptions.scrollbars[name2];
          }
          function increaseTrackScrollAmount() {
            scrollDurationFactor = 0.5;
          }
          function decreaseTrackScrollAmount() {
            scrollDurationFactor = 1;
          }
          function stopClickEventPropagation(event2) {
            COMPATIBILITY.stpP(event2);
          }
          function documentKeyDown(event2) {
            if (inArray(event2.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1)
              increaseTrackScrollAmount();
          }
          function documentKeyUp(event2) {
            if (inArray(event2.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1)
              decreaseTrackScrollAmount();
          }
          function onMouseTouchDownContinue(event2) {
            var originalEvent = event2.originalEvent || event2;
            var isTouchEvent = originalEvent.touches !== undefined$1;
            return _sleeping || _destroyed || nativeOverlayScrollbarsAreActive() || !_scrollbarsDragScrollingCache || isTouchEvent && !getPreparedScrollbarsOption("touchSupport") ? false : COMPATIBILITY.mBtn(event2) === 1 || isTouchEvent;
          }
          function documentDragMove(event2) {
            if (onMouseTouchDownContinue(event2)) {
              var trackLength = scrollbarVarsInfo._trackLength;
              var handleLength = scrollbarVarsInfo._handleLength;
              var scrollRange = scrollbarVarsInfo._maxScroll;
              var scrollRaw = (getPointerPosition(event2) - mouseDownOffset) * mouseDownInvertedScale;
              var scrollDeltaPercent = scrollRaw / (trackLength - handleLength);
              var scrollDelta = scrollRange * scrollDeltaPercent;
              scrollDelta = isFinite(scrollDelta) ? scrollDelta : 0;
              if (_isRTL && isHorizontal && !_rtlScrollBehavior.i)
                scrollDelta *= -1;
              _viewportElement[scroll](MATH.round(mouseDownScroll + scrollDelta));
              if (_scrollbarsHandlesDefineScrollPos)
                refreshScrollbarHandleOffset(isHorizontal, mouseDownScroll + scrollDelta);
              if (!_supportPassiveEvents)
                COMPATIBILITY.prvD(event2);
            } else
              documentMouseTouchUp(event2);
          }
          function documentMouseTouchUp(event2) {
            event2 = event2 || event2.originalEvent;
            setupResponsiveEventListener(_documentElement, [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent], [documentDragMove, documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart], true);
            COMPATIBILITY.rAF()(function() {
              setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, true, { _capture: true });
            });
            if (_scrollbarsHandlesDefineScrollPos)
              refreshScrollbarHandleOffset(isHorizontal, true);
            _scrollbarsHandlesDefineScrollPos = false;
            removeClass3(_bodyElement, _classNameDragging);
            removeClass3(scrollbarVars._handle, strActive);
            removeClass3(scrollbarVars._track, strActive);
            removeClass3(scrollbarVars._scrollbar, strActive);
            mouseDownScroll = undefined$1;
            mouseDownOffset = undefined$1;
            mouseDownInvertedScale = 1;
            decreaseTrackScrollAmount();
            if (trackTimeout !== undefined$1) {
              _base.scrollStop();
              clearTimeout(trackTimeout);
              trackTimeout = undefined$1;
            }
            if (event2) {
              var rect = _hostElementNative[LEXICON.bCR]();
              var mouseInsideHost = event2.clientX >= rect.left && event2.clientX <= rect.right && event2.clientY >= rect.top && event2.clientY <= rect.bottom;
              if (!mouseInsideHost)
                hostOnMouseLeave();
              if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                refreshScrollbarsAutoHide(false);
            }
          }
          function onHandleMouseTouchDown(event2) {
            if (onMouseTouchDownContinue(event2))
              onHandleMouseTouchDownAction(event2);
          }
          function onHandleMouseTouchDownAction(event2) {
            mouseDownScroll = _viewportElement[scroll]();
            mouseDownScroll = isNaN(mouseDownScroll) ? 0 : mouseDownScroll;
            if (_isRTL && isHorizontal && !_rtlScrollBehavior.n || !_isRTL)
              mouseDownScroll = mouseDownScroll < 0 ? 0 : mouseDownScroll;
            mouseDownInvertedScale = getHostElementInvertedScale()[xy];
            mouseDownOffset = getPointerPosition(event2);
            _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
            addClass2(_bodyElement, _classNameDragging);
            addClass2(scrollbarVars._handle, strActive);
            addClass2(scrollbarVars._scrollbar, strActive);
            setupResponsiveEventListener(_documentElement, [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strSelectStartEvent], [documentDragMove, documentMouseTouchUp, documentOnSelectStart]);
            COMPATIBILITY.rAF()(function() {
              setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, false, { _capture: true });
            });
            if (_msieVersion || !_documentMixed)
              COMPATIBILITY.prvD(event2);
            COMPATIBILITY.stpP(event2);
          }
          function onTrackMouseTouchDown(event2) {
            if (onMouseTouchDownContinue(event2)) {
              var handleToViewportRatio = scrollbarVars._info._handleLength / Math.round(MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]) * scrollbarVars._info._trackLength);
              var scrollDistance = MATH.round(_viewportSize[scrollbarVars._w_h] * handleToViewportRatio);
              var scrollBaseDuration = 270 * handleToViewportRatio;
              var scrollFirstIterationDelay = 400 * handleToViewportRatio;
              var trackOffset = scrollbarVars._track.offset()[scrollbarVars._left_top];
              var ctrlKey = event2.ctrlKey;
              var instantScroll = event2.shiftKey;
              var instantScrollTransition = instantScroll && ctrlKey;
              var isFirstIteration = true;
              var easing2 = "linear";
              var decreaseScroll;
              var finishedCondition;
              var scrollActionFinsished = function(transition) {
                if (_scrollbarsHandlesDefineScrollPos)
                  refreshScrollbarHandleOffset(isHorizontal, transition);
              };
              var scrollActionInstantFinished = function() {
                scrollActionFinsished();
                onHandleMouseTouchDownAction(event2);
              };
              var scrollAction = function() {
                if (!_destroyed) {
                  var mouseOffset = (mouseDownOffset - trackOffset) * mouseDownInvertedScale;
                  var handleOffset = scrollbarVarsInfo._handleOffset;
                  var trackLength = scrollbarVarsInfo._trackLength;
                  var handleLength = scrollbarVarsInfo._handleLength;
                  var scrollRange = scrollbarVarsInfo._maxScroll;
                  var currScroll = scrollbarVarsInfo._currentScroll;
                  var scrollDuration = scrollBaseDuration * scrollDurationFactor;
                  var timeoutDelay = isFirstIteration ? MATH.max(scrollFirstIterationDelay, scrollDuration) : scrollDuration;
                  var instantScrollPosition = scrollRange * ((mouseOffset - handleLength / 2) / (trackLength - handleLength));
                  var rtlIsNormal = _isRTL && isHorizontal && (!_rtlScrollBehavior.i && !_rtlScrollBehavior.n || _normalizeRTLCache);
                  var decreaseScrollCondition = rtlIsNormal ? handleOffset < mouseOffset : handleOffset > mouseOffset;
                  var scrollObj = {};
                  var animationObj = {
                    easing: easing2,
                    step: function(now2) {
                      if (_scrollbarsHandlesDefineScrollPos) {
                        _viewportElement[scroll](now2);
                        refreshScrollbarHandleOffset(isHorizontal, now2);
                      }
                    }
                  };
                  instantScrollPosition = isFinite(instantScrollPosition) ? instantScrollPosition : 0;
                  instantScrollPosition = _isRTL && isHorizontal && !_rtlScrollBehavior.i ? scrollRange - instantScrollPosition : instantScrollPosition;
                  if (instantScroll) {
                    _viewportElement[scroll](instantScrollPosition);
                    if (instantScrollTransition) {
                      instantScrollPosition = _viewportElement[scroll]();
                      _viewportElement[scroll](currScroll);
                      instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.i ? scrollRange - instantScrollPosition : instantScrollPosition;
                      instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.n ? -instantScrollPosition : instantScrollPosition;
                      scrollObj[xy] = instantScrollPosition;
                      _base.scroll(scrollObj, extendDeep(animationObj, {
                        duration: 130,
                        complete: scrollActionInstantFinished
                      }));
                    } else
                      scrollActionInstantFinished();
                  } else {
                    decreaseScroll = isFirstIteration ? decreaseScrollCondition : decreaseScroll;
                    finishedCondition = rtlIsNormal ? decreaseScroll ? handleOffset + handleLength >= mouseOffset : handleOffset <= mouseOffset : decreaseScroll ? handleOffset <= mouseOffset : handleOffset + handleLength >= mouseOffset;
                    if (finishedCondition) {
                      clearTimeout(trackTimeout);
                      _base.scrollStop();
                      trackTimeout = undefined$1;
                      scrollActionFinsished(true);
                    } else {
                      trackTimeout = setTimeout(scrollAction, timeoutDelay);
                      scrollObj[xy] = (decreaseScroll ? "-=" : "+=") + scrollDistance;
                      _base.scroll(scrollObj, extendDeep(animationObj, {
                        duration: scrollDuration
                      }));
                    }
                    isFirstIteration = false;
                  }
                }
              };
              if (ctrlKey)
                increaseTrackScrollAmount();
              mouseDownInvertedScale = getHostElementInvertedScale()[xy];
              mouseDownOffset = COMPATIBILITY.page(event2)[xy];
              _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
              addClass2(_bodyElement, _classNameDragging);
              addClass2(scrollbarVars._track, strActive);
              addClass2(scrollbarVars._scrollbar, strActive);
              setupResponsiveEventListener(_documentElement, [_strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent], [documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart]);
              scrollAction();
              COMPATIBILITY.prvD(event2);
              COMPATIBILITY.stpP(event2);
            }
          }
          function onTrackMouseTouchEnter(event2) {
            _scrollbarsHandleHovered = true;
            if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
              refreshScrollbarsAutoHide(true);
          }
          function onTrackMouseTouchLeave(event2) {
            _scrollbarsHandleHovered = false;
            if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
              refreshScrollbarsAutoHide(false);
          }
          function onScrollbarMouseTouchDown(event2) {
            COMPATIBILITY.stpP(event2);
          }
          addDestroyEventListener(scrollbarVars._handle, _strMouseTouchDownEvent, onHandleMouseTouchDown);
          addDestroyEventListener(scrollbarVars._track, [_strMouseTouchDownEvent, _strMouseEnter, _strMouseLeave], [onTrackMouseTouchDown, onTrackMouseTouchEnter, onTrackMouseTouchLeave]);
          addDestroyEventListener(scrollbarVars._scrollbar, _strMouseTouchDownEvent, onScrollbarMouseTouchDown);
          if (_supportTransition) {
            addDestroyEventListener(scrollbarVars._scrollbar, _strTransitionEndEvent, function(event2) {
              if (event2.target !== scrollbarVars._scrollbar[0])
                return;
              refreshScrollbarHandleLength(isHorizontal);
              refreshScrollbarHandleOffset(isHorizontal);
            });
          }
        }
        function refreshScrollbarAppearance(isHorizontal, shallBeVisible, canScroll) {
          var scrollbarHiddenClassName = isHorizontal ? _classNameHostScrollbarHorizontalHidden : _classNameHostScrollbarVerticalHidden;
          var scrollbarElement = isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement;
          addRemoveClass(_hostElement, scrollbarHiddenClassName, !shallBeVisible);
          addRemoveClass(scrollbarElement, _classNameScrollbarUnusable, !canScroll);
        }
        function refreshScrollbarsAutoHide(shallBeVisible, delayfree) {
          clearTimeout(_scrollbarsAutoHideTimeoutId);
          if (shallBeVisible) {
            removeClass3(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
            removeClass3(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
          } else {
            var anyActive;
            var strActive = "active";
            var hide = function() {
              if (!_scrollbarsHandleHovered && !_destroyed) {
                anyActive = _scrollbarHorizontalHandleElement.hasClass(strActive) || _scrollbarVerticalHandleElement.hasClass(strActive);
                if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                  addClass2(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
                if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                  addClass2(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
              }
            };
            if (_scrollbarsAutoHideDelay > 0 && delayfree !== true)
              _scrollbarsAutoHideTimeoutId = setTimeout(hide, _scrollbarsAutoHideDelay);
            else
              hide();
          }
        }
        function refreshScrollbarHandleLength(isHorizontal) {
          var handleCSS = {};
          var scrollbarVars = getScrollbarVars(isHorizontal);
          var scrollbarVarsInfo = scrollbarVars._info;
          var digit = 1e6;
          var handleRatio = MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]);
          handleCSS[scrollbarVars._width_height] = MATH.floor(handleRatio * 100 * digit) / digit + "%";
          if (!nativeOverlayScrollbarsAreActive())
            scrollbarVars._handle.css(handleCSS);
          scrollbarVarsInfo._handleLength = scrollbarVars._handle[0]["offset" + scrollbarVars._Width_Height];
          scrollbarVarsInfo._handleLengthRatio = handleRatio;
        }
        function refreshScrollbarHandleOffset(isHorizontal, scrollOrTransition) {
          var transition = type(scrollOrTransition) == TYPES.b;
          var transitionDuration = 250;
          var isRTLisHorizontal = _isRTL && isHorizontal;
          var scrollbarVars = getScrollbarVars(isHorizontal);
          var scrollbarVarsInfo = scrollbarVars._info;
          var strTranslateBrace = "translate(";
          var strTransform = VENDORS._cssProperty("transform");
          var strTransition = VENDORS._cssProperty("transition");
          var nativeScroll = isHorizontal ? _viewportElement[_strScrollLeft]() : _viewportElement[_strScrollTop]();
          var currentScroll = scrollOrTransition === undefined$1 || transition ? nativeScroll : scrollOrTransition;
          var handleLength = scrollbarVarsInfo._handleLength;
          var trackLength = scrollbarVars._track[0]["offset" + scrollbarVars._Width_Height];
          var handleTrackDiff = trackLength - handleLength;
          var handleCSS = {};
          var transformOffset;
          var translateValue;
          var maxScroll = (_viewportElementNative[_strScroll + scrollbarVars._Width_Height] - _viewportElementNative["client" + scrollbarVars._Width_Height]) * (_rtlScrollBehavior.n && isRTLisHorizontal ? -1 : 1);
          var getScrollRatio = function(base) {
            return isNaN(base / maxScroll) ? 0 : MATH.max(0, MATH.min(1, base / maxScroll));
          };
          var getHandleOffset = function(scrollRatio2) {
            var offset = handleTrackDiff * scrollRatio2;
            offset = isNaN(offset) ? 0 : offset;
            offset = isRTLisHorizontal && !_rtlScrollBehavior.i ? trackLength - handleLength - offset : offset;
            offset = MATH.max(0, offset);
            return offset;
          };
          var scrollRatio = getScrollRatio(nativeScroll);
          var unsnappedScrollRatio = getScrollRatio(currentScroll);
          var handleOffset = getHandleOffset(unsnappedScrollRatio);
          var snappedHandleOffset = getHandleOffset(scrollRatio);
          scrollbarVarsInfo._maxScroll = maxScroll;
          scrollbarVarsInfo._currentScroll = nativeScroll;
          scrollbarVarsInfo._currentScrollRatio = scrollRatio;
          if (_supportTransform) {
            transformOffset = isRTLisHorizontal ? -(trackLength - handleLength - handleOffset) : handleOffset;
            translateValue = isHorizontal ? strTranslateBrace + transformOffset + "px, 0)" : strTranslateBrace + "0, " + transformOffset + "px)";
            handleCSS[strTransform] = translateValue;
            if (_supportTransition)
              handleCSS[strTransition] = transition && MATH.abs(handleOffset - scrollbarVarsInfo._handleOffset) > 1 ? getCSSTransitionString(scrollbarVars._handle) + ", " + (strTransform + _strSpace + transitionDuration + "ms") : _strEmpty;
          } else
            handleCSS[scrollbarVars._left_top] = handleOffset;
          if (!nativeOverlayScrollbarsAreActive()) {
            scrollbarVars._handle.css(handleCSS);
            if (_supportTransform && _supportTransition && transition) {
              scrollbarVars._handle.one(_strTransitionEndEvent, function() {
                if (!_destroyed)
                  scrollbarVars._handle.css(strTransition, _strEmpty);
              });
            }
          }
          scrollbarVarsInfo._handleOffset = handleOffset;
          scrollbarVarsInfo._snappedHandleOffset = snappedHandleOffset;
          scrollbarVarsInfo._trackLength = trackLength;
        }
        function refreshScrollbarsInteractive(isTrack, value) {
          var action = value ? "removeClass" : "addClass";
          var element1 = isTrack ? _scrollbarHorizontalTrackElement : _scrollbarHorizontalHandleElement;
          var element2 = isTrack ? _scrollbarVerticalTrackElement : _scrollbarVerticalHandleElement;
          var className = isTrack ? _classNameScrollbarTrackOff : _classNameScrollbarHandleOff;
          element1[action](className);
          element2[action](className);
        }
        function getScrollbarVars(isHorizontal) {
          return {
            _width_height: isHorizontal ? _strWidth : _strHeight,
            _Width_Height: isHorizontal ? "Width" : "Height",
            _left_top: isHorizontal ? _strLeft : _strTop,
            _Left_Top: isHorizontal ? "Left" : "Top",
            _x_y: isHorizontal ? _strX : _strY,
            _X_Y: isHorizontal ? "X" : "Y",
            _w_h: isHorizontal ? "w" : "h",
            _l_t: isHorizontal ? "l" : "t",
            _track: isHorizontal ? _scrollbarHorizontalTrackElement : _scrollbarVerticalTrackElement,
            _handle: isHorizontal ? _scrollbarHorizontalHandleElement : _scrollbarVerticalHandleElement,
            _scrollbar: isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement,
            _info: isHorizontal ? _scrollHorizontalInfo : _scrollVerticalInfo
          };
        }
        function setupScrollbarCornerDOM(destroy) {
          _scrollbarCornerElement = _scrollbarCornerElement || selectOrGenerateDivByClass(_classNameScrollbarCorner, true);
          if (!destroy) {
            if (!_domExists) {
              _hostElement.append(_scrollbarCornerElement);
            }
          } else {
            if (_domExists && _initialized) {
              removeClass3(_scrollbarCornerElement.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
            } else {
              remove(_scrollbarCornerElement);
            }
          }
        }
        function setupScrollbarCornerEvents() {
          var insideIFrame = _windowElementNative.top !== _windowElementNative;
          var mouseDownPosition = {};
          var mouseDownSize = {};
          var mouseDownInvertedScale = {};
          var reconnectMutationObserver;
          function documentDragMove(event2) {
            if (onMouseTouchDownContinue(event2)) {
              var pageOffset = getCoordinates(event2);
              var hostElementCSS = {};
              if (_resizeHorizontal || _resizeBoth)
                hostElementCSS[_strWidth] = mouseDownSize.w + (pageOffset.x - mouseDownPosition.x) * mouseDownInvertedScale.x;
              if (_resizeVertical || _resizeBoth)
                hostElementCSS[_strHeight] = mouseDownSize.h + (pageOffset.y - mouseDownPosition.y) * mouseDownInvertedScale.y;
              _hostElement.css(hostElementCSS);
              COMPATIBILITY.stpP(event2);
            } else {
              documentMouseTouchUp(event2);
            }
          }
          function documentMouseTouchUp(event2) {
            var eventIsTrusted = event2 !== undefined$1;
            setupResponsiveEventListener(_documentElement, [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent], [documentOnSelectStart, documentDragMove, documentMouseTouchUp], true);
            removeClass3(_bodyElement, _classNameDragging);
            if (_scrollbarCornerElement.releaseCapture)
              _scrollbarCornerElement.releaseCapture();
            if (eventIsTrusted) {
              if (reconnectMutationObserver)
                connectMutationObservers();
              _base.update(_strAuto);
            }
            reconnectMutationObserver = false;
          }
          function onMouseTouchDownContinue(event2) {
            var originalEvent = event2.originalEvent || event2;
            var isTouchEvent = originalEvent.touches !== undefined$1;
            return _sleeping || _destroyed ? false : COMPATIBILITY.mBtn(event2) === 1 || isTouchEvent;
          }
          function getCoordinates(event2) {
            return _msieVersion && insideIFrame ? { x: event2.screenX, y: event2.screenY } : COMPATIBILITY.page(event2);
          }
          addDestroyEventListener(_scrollbarCornerElement, _strMouseTouchDownEvent, function(event2) {
            if (onMouseTouchDownContinue(event2) && !_resizeNone) {
              if (_mutationObserversConnected) {
                reconnectMutationObserver = true;
                disconnectMutationObservers();
              }
              mouseDownPosition = getCoordinates(event2);
              mouseDownSize.w = _hostElementNative[LEXICON.oW] - (!_isBorderBox ? _paddingX : 0);
              mouseDownSize.h = _hostElementNative[LEXICON.oH] - (!_isBorderBox ? _paddingY : 0);
              mouseDownInvertedScale = getHostElementInvertedScale();
              setupResponsiveEventListener(_documentElement, [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent], [documentOnSelectStart, documentDragMove, documentMouseTouchUp]);
              addClass2(_bodyElement, _classNameDragging);
              if (_scrollbarCornerElement.setCapture)
                _scrollbarCornerElement.setCapture();
              COMPATIBILITY.prvD(event2);
              COMPATIBILITY.stpP(event2);
            }
          });
        }
        function dispatchCallback(name2, args, dependent) {
          if (dependent === false)
            return;
          if (_initialized) {
            var callback = _currentPreparedOptions.callbacks[name2];
            var extensionOnName = name2;
            var ext;
            if (extensionOnName.substr(0, 2) === "on")
              extensionOnName = extensionOnName.substr(2, 1).toLowerCase() + extensionOnName.substr(3);
            if (type(callback) == TYPES.f)
              callback.call(_base, args);
            each(_extensions, function() {
              ext = this;
              if (type(ext.on) == TYPES.f)
                ext.on(extensionOnName, args);
            });
          } else if (!_destroyed)
            _callbacksInitQeueue.push({ n: name2, a: args });
        }
        function setTopRightBottomLeft(targetCSSObject, prefix, values2) {
          prefix = prefix || _strEmpty;
          values2 = values2 || [_strEmpty, _strEmpty, _strEmpty, _strEmpty];
          targetCSSObject[prefix + _strTop] = values2[0];
          targetCSSObject[prefix + _strRight] = values2[1];
          targetCSSObject[prefix + _strBottom] = values2[2];
          targetCSSObject[prefix + _strLeft] = values2[3];
        }
        function getTopRightBottomLeftHost(prefix, suffix, zeroX, zeroY) {
          suffix = suffix || _strEmpty;
          prefix = prefix || _strEmpty;
          return {
            t: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strTop + suffix)),
            r: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strRight + suffix)),
            b: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strBottom + suffix)),
            l: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strLeft + suffix))
          };
        }
        function getCSSTransitionString(element) {
          var transitionStr = VENDORS._cssProperty("transition");
          var assembledValue = element.css(transitionStr);
          if (assembledValue)
            return assembledValue;
          var regExpString = "\\s*(([^,(]+(\\(.+?\\))?)+)[\\s,]*";
          var regExpMain = new RegExp(regExpString);
          var regExpValidate = new RegExp("^(" + regExpString + ")+$");
          var properties = "property duration timing-function delay".split(" ");
          var result = [];
          var strResult;
          var valueArray;
          var i2 = 0;
          var j;
          var splitCssStyleByComma = function(str) {
            strResult = [];
            if (!str.match(regExpValidate))
              return str;
            while (str.match(regExpMain)) {
              strResult.push(RegExp.$1);
              str = str.replace(regExpMain, _strEmpty);
            }
            return strResult;
          };
          for (; i2 < properties[LEXICON.l]; i2++) {
            valueArray = splitCssStyleByComma(element.css(transitionStr + "-" + properties[i2]));
            for (j = 0; j < valueArray[LEXICON.l]; j++)
              result[j] = (result[j] ? result[j] + _strSpace : _strEmpty) + valueArray[j];
          }
          return result.join(", ");
        }
        function createHostClassNameRegExp(withCurrClassNameOption, withOldClassNameOption) {
          var i2;
          var split;
          var appendix;
          var appendClasses = function(classes, condition) {
            appendix = "";
            if (condition && typeof classes == TYPES.s) {
              split = classes.split(_strSpace);
              for (i2 = 0; i2 < split[LEXICON.l]; i2++)
                appendix += "|" + split[i2] + "$";
            }
            return appendix;
          };
          return new RegExp("(^" + _classNameHostElement + "([-_].+|)$)" + appendClasses(_classNameCache, withCurrClassNameOption) + appendClasses(_oldClassName, withOldClassNameOption), "g");
        }
        function getHostElementInvertedScale() {
          var rect = _paddingElementNative[LEXICON.bCR]();
          return {
            x: _supportTransform ? 1 / (MATH.round(rect.width) / _paddingElementNative[LEXICON.oW]) || 1 : 1,
            y: _supportTransform ? 1 / (MATH.round(rect.height) / _paddingElementNative[LEXICON.oH]) || 1 : 1
          };
        }
        function isHTMLElement(o) {
          var strOwnerDocument = "ownerDocument";
          var strHTMLElement = "HTMLElement";
          var wnd = o && o[strOwnerDocument] ? o[strOwnerDocument].parentWindow || window2 : window2;
          return typeof wnd[strHTMLElement] == TYPES.o ? o instanceof wnd[strHTMLElement] : o && typeof o == TYPES.o && o !== null && o.nodeType === 1 && typeof o.nodeName == TYPES.s;
        }
        function getArrayDifferences(a1, a2) {
          var a = [];
          var diff = [];
          var i2;
          var k;
          for (i2 = 0; i2 < a1.length; i2++)
            a[a1[i2]] = true;
          for (i2 = 0; i2 < a2.length; i2++) {
            if (a[a2[i2]])
              delete a[a2[i2]];
            else
              a[a2[i2]] = true;
          }
          for (k in a)
            diff.push(k);
          return diff;
        }
        function parseToZeroOrNumber(value, toFloat2) {
          var num = toFloat2 ? parseFloat(value) : parseInt(value, 10);
          return isNaN(num) ? 0 : num;
        }
        function getTextareaInfo() {
          var textareaCursorPosition = _targetElementNative.selectionStart;
          if (textareaCursorPosition === undefined$1)
            return;
          var textareaValue = _targetElement.val();
          var textareaLength = textareaValue[LEXICON.l];
          var textareaRowSplit = textareaValue.split("\n");
          var textareaLastRow = textareaRowSplit[LEXICON.l];
          var textareaCurrentCursorRowSplit = textareaValue.substr(0, textareaCursorPosition).split("\n");
          var widestRow = 0;
          var textareaLastCol = 0;
          var cursorRow = textareaCurrentCursorRowSplit[LEXICON.l];
          var cursorCol = textareaCurrentCursorRowSplit[textareaCurrentCursorRowSplit[LEXICON.l] - 1][LEXICON.l];
          var rowCols;
          var i2;
          for (i2 = 0; i2 < textareaRowSplit[LEXICON.l]; i2++) {
            rowCols = textareaRowSplit[i2][LEXICON.l];
            if (rowCols > textareaLastCol) {
              widestRow = i2 + 1;
              textareaLastCol = rowCols;
            }
          }
          return {
            _cursorRow: cursorRow,
            _cursorColumn: cursorCol,
            _rows: textareaLastRow,
            _columns: textareaLastCol,
            _widestRow: widestRow,
            _cursorPosition: textareaCursorPosition,
            _cursorMax: textareaLength
          };
        }
        function nativeOverlayScrollbarsAreActive() {
          return _ignoreOverlayScrollbarHidingCache && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y);
        }
        function getContentMeasureElement() {
          return _isTextarea ? _textareaCoverElement[0] : _contentElementNative;
        }
        function generateDiv(classesOrAttrs, content) {
          return "<div " + (classesOrAttrs ? type(classesOrAttrs) == TYPES.s ? 'class="' + classesOrAttrs + '"' : function() {
            var key;
            var attrs = _strEmpty;
            if (FRAMEWORK.isPlainObject(classesOrAttrs)) {
              for (key in classesOrAttrs)
                attrs += (key === "c" ? "class" : key) + '="' + classesOrAttrs[key] + '" ';
            }
            return attrs;
          }() : _strEmpty) + ">" + (content || _strEmpty) + "</div>";
        }
        function selectOrGenerateDivByClass(className, selectParentOrOnlyChildren) {
          var onlyChildren = type(selectParentOrOnlyChildren) == TYPES.b;
          var selectParent = onlyChildren ? _hostElement : selectParentOrOnlyChildren || _hostElement;
          return _domExists && !selectParent[LEXICON.l] ? null : _domExists ? selectParent[onlyChildren ? "children" : "find"](_strDot + className.replace(/\s/g, _strDot)).eq(0) : FRAMEWORK(generateDiv(className));
        }
        function getObjectPropVal(obj, path) {
          var splits = path.split(_strDot);
          var i2 = 0;
          var val;
          for (; i2 < splits.length; i2++) {
            if (!obj[LEXICON.hOP](splits[i2]))
              return;
            val = obj[splits[i2]];
            if (i2 < splits.length && type(val) == TYPES.o)
              obj = val;
          }
          return val;
        }
        function setObjectPropVal(obj, path, val) {
          var splits = path.split(_strDot);
          var splitsLength = splits.length;
          var i2 = 0;
          var extendObj = {};
          var extendObjRoot = extendObj;
          for (; i2 < splitsLength; i2++)
            extendObj = extendObj[splits[i2]] = i2 + 1 < splitsLength ? {} : val;
          FRAMEWORK.extend(obj, extendObjRoot, true);
        }
        function eachUpdateOnLoad(action) {
          var updateOnLoad = _currentPreparedOptions.updateOnLoad;
          updateOnLoad = type(updateOnLoad) == TYPES.s ? updateOnLoad.split(_strSpace) : updateOnLoad;
          if (COMPATIBILITY.isA(updateOnLoad) && !_destroyed) {
            each(updateOnLoad, action);
          }
        }
        function checkCache(current, cache, force) {
          if (force)
            return force;
          if (type(current) == TYPES.o && type(cache) == TYPES.o) {
            for (var prop in current) {
              if (prop !== "c") {
                if (current[LEXICON.hOP](prop) && cache[LEXICON.hOP](prop)) {
                  if (checkCache(current[prop], cache[prop]))
                    return true;
                } else {
                  return true;
                }
              }
            }
          } else {
            return current !== cache;
          }
          return false;
        }
        function extendDeep() {
          return FRAMEWORK.extend.apply(this, [true].concat([].slice.call(arguments)));
        }
        function addClass2(el, classes) {
          return _frameworkProto.addClass.call(el, classes);
        }
        function removeClass3(el, classes) {
          return _frameworkProto.removeClass.call(el, classes);
        }
        function addRemoveClass(el, classes, doAdd) {
          return doAdd ? addClass2(el, classes) : removeClass3(el, classes);
        }
        function remove(el) {
          return _frameworkProto.remove.call(el);
        }
        function findFirst(el, selector) {
          return _frameworkProto.find.call(el, selector).eq(0);
        }
        _base.sleep = function() {
          _sleeping = true;
        };
        _base.update = function(force) {
          if (_destroyed)
            return;
          var attrsChanged;
          var contentSizeC;
          var isString2 = type(force) == TYPES.s;
          var doUpdateAuto;
          var mutHost;
          var mutContent;
          if (isString2) {
            if (force === _strAuto) {
              attrsChanged = meaningfulAttrsChanged();
              contentSizeC = updateAutoContentSizeChanged();
              doUpdateAuto = attrsChanged || contentSizeC;
              if (doUpdateAuto) {
                update2({
                  _contentSizeChanged: contentSizeC,
                  _changedOptions: _initialized ? undefined$1 : _currentPreparedOptions
                });
              }
            } else if (force === _strSync) {
              if (_mutationObserversConnected) {
                mutHost = _mutationObserverHostCallback(_mutationObserverHost.takeRecords());
                mutContent = _mutationObserverContentCallback(_mutationObserverContent.takeRecords());
              } else {
                mutHost = _base.update(_strAuto);
              }
            } else if (force === "zoom") {
              update2({
                _hostSizeChanged: true,
                _contentSizeChanged: true
              });
            }
          } else {
            force = _sleeping || force;
            _sleeping = false;
            if (!_base.update(_strSync) || force)
              update2({ _force: force });
          }
          updateElementsOnLoad();
          return doUpdateAuto || mutHost || mutContent;
        };
        _base.options = function(newOptions, value) {
          var option = {};
          var changedOps;
          if (FRAMEWORK.isEmptyObject(newOptions) || !FRAMEWORK.isPlainObject(newOptions)) {
            if (type(newOptions) == TYPES.s) {
              if (arguments.length > 1) {
                setObjectPropVal(option, newOptions, value);
                changedOps = setOptions(option);
              } else
                return getObjectPropVal(_currentOptions, newOptions);
            } else
              return _currentOptions;
          } else {
            changedOps = setOptions(newOptions);
          }
          if (!FRAMEWORK.isEmptyObject(changedOps)) {
            update2({ _changedOptions: changedOps });
          }
        };
        _base.destroy = function() {
          if (_destroyed)
            return;
          autoUpdateLoop.remove(_base);
          disconnectMutationObservers();
          setupResizeObserver(_sizeObserverElement);
          setupResizeObserver(_sizeAutoObserverElement);
          for (var extName in _extensions)
            _base.removeExt(extName);
          while (_destroyEvents[LEXICON.l] > 0)
            _destroyEvents.pop()();
          setupHostMouseTouchEvents(true);
          if (_contentGlueElement)
            remove(_contentGlueElement);
          if (_contentArrangeElement)
            remove(_contentArrangeElement);
          if (_sizeAutoObserverAdded)
            remove(_sizeAutoObserverElement);
          setupScrollbarsDOM(true);
          setupScrollbarCornerDOM(true);
          setupStructureDOM(true);
          for (var i2 = 0; i2 < _updateOnLoadElms[LEXICON.l]; i2++)
            FRAMEWORK(_updateOnLoadElms[i2]).off(_updateOnLoadEventName, updateOnLoadCallback);
          _updateOnLoadElms = undefined$1;
          _destroyed = true;
          _sleeping = true;
          INSTANCES(pluginTargetElement, 0);
          dispatchCallback("onDestroyed");
        };
        _base.scroll = function(coordinates, duration2, easing2, complete) {
          if (arguments.length === 0 || coordinates === undefined$1) {
            var infoX = _scrollHorizontalInfo;
            var infoY = _scrollVerticalInfo;
            var normalizeInvert = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.i;
            var normalizeNegate = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.n;
            var scrollX = infoX._currentScroll;
            var scrollXRatio = infoX._currentScrollRatio;
            var maxScrollX = infoX._maxScroll;
            scrollXRatio = normalizeInvert ? 1 - scrollXRatio : scrollXRatio;
            scrollX = normalizeInvert ? maxScrollX - scrollX : scrollX;
            scrollX *= normalizeNegate ? -1 : 1;
            maxScrollX *= normalizeNegate ? -1 : 1;
            return {
              position: {
                x: scrollX,
                y: infoY._currentScroll
              },
              ratio: {
                x: scrollXRatio,
                y: infoY._currentScrollRatio
              },
              max: {
                x: maxScrollX,
                y: infoY._maxScroll
              },
              handleOffset: {
                x: infoX._handleOffset,
                y: infoY._handleOffset
              },
              handleLength: {
                x: infoX._handleLength,
                y: infoY._handleLength
              },
              handleLengthRatio: {
                x: infoX._handleLengthRatio,
                y: infoY._handleLengthRatio
              },
              trackLength: {
                x: infoX._trackLength,
                y: infoY._trackLength
              },
              snappedHandleOffset: {
                x: infoX._snappedHandleOffset,
                y: infoY._snappedHandleOffset
              },
              isRTL: _isRTL,
              isRTLNormalized: _normalizeRTLCache
            };
          }
          _base.update(_strSync);
          var normalizeRTL = _normalizeRTLCache;
          var coordinatesXAxisProps = [_strX, _strLeft, "l"];
          var coordinatesYAxisProps = [_strY, _strTop, "t"];
          var coordinatesOperators = ["+=", "-=", "*=", "/="];
          var durationIsObject = type(duration2) == TYPES.o;
          var completeCallback = durationIsObject ? duration2.complete : complete;
          var i2;
          var finalScroll = {};
          var specialEasing = {};
          var doScrollLeft;
          var doScrollTop;
          var animationOptions;
          var strEnd = "end";
          var strBegin = "begin";
          var strCenter = "center";
          var strNearest = "nearest";
          var strAlways = "always";
          var strNever = "never";
          var strIfNeeded = "ifneeded";
          var strLength = LEXICON.l;
          var settingsAxis;
          var settingsScroll;
          var settingsBlock;
          var settingsMargin;
          var finalElement;
          var elementObjSettingsAxisValues = [_strX, _strY, "xy", "yx"];
          var elementObjSettingsBlockValues = [strBegin, strEnd, strCenter, strNearest];
          var elementObjSettingsScrollValues = [strAlways, strNever, strIfNeeded];
          var coordinatesIsElementObj = coordinates[LEXICON.hOP]("el");
          var possibleElement = coordinatesIsElementObj ? coordinates.el : coordinates;
          var possibleElementIsJQuery = possibleElement instanceof FRAMEWORK || JQUERY ? possibleElement instanceof JQUERY : false;
          var possibleElementIsHTMLElement = possibleElementIsJQuery ? false : isHTMLElement(possibleElement);
          var updateScrollbarInfos = function() {
            if (doScrollLeft)
              refreshScrollbarHandleOffset(true);
            if (doScrollTop)
              refreshScrollbarHandleOffset(false);
          };
          var proxyCompleteCallback = type(completeCallback) != TYPES.f ? undefined$1 : function() {
            updateScrollbarInfos();
            completeCallback();
          };
          function checkSettingsStringValue(currValue, allowedValues) {
            for (i2 = 0; i2 < allowedValues[strLength]; i2++) {
              if (currValue === allowedValues[i2])
                return true;
            }
            return false;
          }
          function getRawScroll(isX, coordinates2) {
            var coordinateProps = isX ? coordinatesXAxisProps : coordinatesYAxisProps;
            coordinates2 = type(coordinates2) == TYPES.s || type(coordinates2) == TYPES.n ? [coordinates2, coordinates2] : coordinates2;
            if (COMPATIBILITY.isA(coordinates2))
              return isX ? coordinates2[0] : coordinates2[1];
            else if (type(coordinates2) == TYPES.o) {
              for (i2 = 0; i2 < coordinateProps[strLength]; i2++)
                if (coordinateProps[i2] in coordinates2)
                  return coordinates2[coordinateProps[i2]];
            }
          }
          function getFinalScroll(isX, rawScroll) {
            var isString2 = type(rawScroll) == TYPES.s;
            var operator;
            var amount;
            var scrollInfo = isX ? _scrollHorizontalInfo : _scrollVerticalInfo;
            var currScroll = scrollInfo._currentScroll;
            var maxScroll = scrollInfo._maxScroll;
            var mult = " * ";
            var finalValue;
            var isRTLisX = _isRTL && isX;
            var normalizeShortcuts = isRTLisX && _rtlScrollBehavior.n && !normalizeRTL;
            var strReplace = "replace";
            var evalFunc = eval;
            var possibleOperator;
            if (isString2) {
              if (rawScroll[strLength] > 2) {
                possibleOperator = rawScroll.substr(0, 2);
                if (inArray(possibleOperator, coordinatesOperators) > -1)
                  operator = possibleOperator;
              }
              rawScroll = operator ? rawScroll.substr(2) : rawScroll;
              rawScroll = rawScroll[strReplace](/min/g, 0)[strReplace](/</g, 0)[strReplace](/max/g, (normalizeShortcuts ? "-" : _strEmpty) + _strHundredPercent)[strReplace](/>/g, (normalizeShortcuts ? "-" : _strEmpty) + _strHundredPercent)[strReplace](/px/g, _strEmpty)[strReplace](/%/g, mult + maxScroll * (isRTLisX && _rtlScrollBehavior.n ? -1 : 1) / 100)[strReplace](/vw/g, mult + _viewportSize.w)[strReplace](/vh/g, mult + _viewportSize.h);
              amount = parseToZeroOrNumber(isNaN(rawScroll) ? parseToZeroOrNumber(evalFunc(rawScroll), true).toFixed() : rawScroll);
            } else {
              amount = rawScroll;
            }
            if (amount !== undefined$1 && !isNaN(amount) && type(amount) == TYPES.n) {
              var normalizeIsRTLisX = normalizeRTL && isRTLisX;
              var operatorCurrScroll = currScroll * (normalizeIsRTLisX && _rtlScrollBehavior.n ? -1 : 1);
              var invert = normalizeIsRTLisX && _rtlScrollBehavior.i;
              var negate = normalizeIsRTLisX && _rtlScrollBehavior.n;
              operatorCurrScroll = invert ? maxScroll - operatorCurrScroll : operatorCurrScroll;
              switch (operator) {
                case "+=":
                  finalValue = operatorCurrScroll + amount;
                  break;
                case "-=":
                  finalValue = operatorCurrScroll - amount;
                  break;
                case "*=":
                  finalValue = operatorCurrScroll * amount;
                  break;
                case "/=":
                  finalValue = operatorCurrScroll / amount;
                  break;
                default:
                  finalValue = amount;
                  break;
              }
              finalValue = invert ? maxScroll - finalValue : finalValue;
              finalValue *= negate ? -1 : 1;
              finalValue = isRTLisX && _rtlScrollBehavior.n ? MATH.min(0, MATH.max(maxScroll, finalValue)) : MATH.max(0, MATH.min(maxScroll, finalValue));
            }
            return finalValue === currScroll ? undefined$1 : finalValue;
          }
          function getPerAxisValue(value, valueInternalType, defaultValue, allowedValues) {
            var resultDefault = [defaultValue, defaultValue];
            var valueType = type(value);
            var valueArrLength;
            var valueArrItem;
            if (valueType == valueInternalType) {
              value = [value, value];
            } else if (valueType == TYPES.a) {
              valueArrLength = value[strLength];
              if (valueArrLength > 2 || valueArrLength < 1)
                value = resultDefault;
              else {
                if (valueArrLength === 1)
                  value[1] = defaultValue;
                for (i2 = 0; i2 < valueArrLength; i2++) {
                  valueArrItem = value[i2];
                  if (type(valueArrItem) != valueInternalType || !checkSettingsStringValue(valueArrItem, allowedValues)) {
                    value = resultDefault;
                    break;
                  }
                }
              }
            } else if (valueType == TYPES.o)
              value = [value[_strX] || defaultValue, value[_strY] || defaultValue];
            else
              value = resultDefault;
            return { x: value[0], y: value[1] };
          }
          function generateMargin(marginTopRightBottomLeftArray) {
            var result = [];
            var currValue;
            var currValueType;
            var valueDirections = [_strTop, _strRight, _strBottom, _strLeft];
            for (i2 = 0; i2 < marginTopRightBottomLeftArray[strLength]; i2++) {
              if (i2 === valueDirections[strLength])
                break;
              currValue = marginTopRightBottomLeftArray[i2];
              currValueType = type(currValue);
              if (currValueType == TYPES.b)
                result.push(currValue ? parseToZeroOrNumber(finalElement.css(_strMarginMinus + valueDirections[i2])) : 0);
              else
                result.push(currValueType == TYPES.n ? currValue : 0);
            }
            return result;
          }
          if (possibleElementIsJQuery || possibleElementIsHTMLElement) {
            var margin = coordinatesIsElementObj ? coordinates.margin : 0;
            var axis = coordinatesIsElementObj ? coordinates.axis : 0;
            var scroll = coordinatesIsElementObj ? coordinates.scroll : 0;
            var block2 = coordinatesIsElementObj ? coordinates.block : 0;
            var marginDefault = [0, 0, 0, 0];
            var marginType = type(margin);
            var marginLength;
            finalElement = possibleElementIsJQuery ? possibleElement : FRAMEWORK(possibleElement);
            if (finalElement[strLength] > 0) {
              if (marginType == TYPES.n || marginType == TYPES.b)
                margin = generateMargin([margin, margin, margin, margin]);
              else if (marginType == TYPES.a) {
                marginLength = margin[strLength];
                if (marginLength === 2)
                  margin = generateMargin([margin[0], margin[1], margin[0], margin[1]]);
                else if (marginLength >= 4)
                  margin = generateMargin(margin);
                else
                  margin = marginDefault;
              } else if (marginType == TYPES.o)
                margin = generateMargin([margin[_strTop], margin[_strRight], margin[_strBottom], margin[_strLeft]]);
              else
                margin = marginDefault;
              settingsAxis = checkSettingsStringValue(axis, elementObjSettingsAxisValues) ? axis : "xy";
              settingsScroll = getPerAxisValue(scroll, TYPES.s, strAlways, elementObjSettingsScrollValues);
              settingsBlock = getPerAxisValue(block2, TYPES.s, strBegin, elementObjSettingsBlockValues);
              settingsMargin = margin;
              var viewportScroll = {
                l: _scrollHorizontalInfo._currentScroll,
                t: _scrollVerticalInfo._currentScroll
              };
              var viewportOffset = _paddingElement.offset();
              var elementOffset = finalElement.offset();
              var doNotScroll = {
                x: settingsScroll.x == strNever || settingsAxis == _strY,
                y: settingsScroll.y == strNever || settingsAxis == _strX
              };
              elementOffset[_strTop] -= settingsMargin[0];
              elementOffset[_strLeft] -= settingsMargin[3];
              var elementScrollCoordinates = {
                x: MATH.round(elementOffset[_strLeft] - viewportOffset[_strLeft] + viewportScroll.l),
                y: MATH.round(elementOffset[_strTop] - viewportOffset[_strTop] + viewportScroll.t)
              };
              if (_isRTL) {
                if (!_rtlScrollBehavior.n && !_rtlScrollBehavior.i)
                  elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + viewportScroll.l);
                if (_rtlScrollBehavior.n && normalizeRTL)
                  elementScrollCoordinates.x *= -1;
                if (_rtlScrollBehavior.i && normalizeRTL)
                  elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + (_scrollHorizontalInfo._maxScroll - viewportScroll.l));
              }
              if (settingsBlock.x != strBegin || settingsBlock.y != strBegin || settingsScroll.x == strIfNeeded || settingsScroll.y == strIfNeeded || _isRTL) {
                var measuringElm = finalElement[0];
                var rawElementSize = _supportTransform ? measuringElm[LEXICON.bCR]() : {
                  width: measuringElm[LEXICON.oW],
                  height: measuringElm[LEXICON.oH]
                };
                var elementSize = {
                  w: rawElementSize[_strWidth] + settingsMargin[3] + settingsMargin[1],
                  h: rawElementSize[_strHeight] + settingsMargin[0] + settingsMargin[2]
                };
                var finalizeBlock = function(isX) {
                  var vars = getScrollbarVars(isX);
                  var wh = vars._w_h;
                  var lt = vars._left_top;
                  var xy = vars._x_y;
                  var blockIsEnd = settingsBlock[xy] == (isX ? _isRTL ? strBegin : strEnd : strEnd);
                  var blockIsCenter = settingsBlock[xy] == strCenter;
                  var blockIsNearest = settingsBlock[xy] == strNearest;
                  var scrollNever = settingsScroll[xy] == strNever;
                  var scrollIfNeeded = settingsScroll[xy] == strIfNeeded;
                  var vpSize = _viewportSize[wh];
                  var vpOffset = viewportOffset[lt];
                  var elSize = elementSize[wh];
                  var elOffset = elementOffset[lt];
                  var divide2 = blockIsCenter ? 2 : 1;
                  var elementCenterOffset = elOffset + elSize / 2;
                  var viewportCenterOffset = vpOffset + vpSize / 2;
                  var isInView = elSize <= vpSize && elOffset >= vpOffset && elOffset + elSize <= vpOffset + vpSize;
                  if (scrollNever)
                    doNotScroll[xy] = true;
                  else if (!doNotScroll[xy]) {
                    if (blockIsNearest || scrollIfNeeded) {
                      doNotScroll[xy] = scrollIfNeeded ? isInView : false;
                      blockIsEnd = elSize < vpSize ? elementCenterOffset > viewportCenterOffset : elementCenterOffset < viewportCenterOffset;
                    }
                    elementScrollCoordinates[xy] -= blockIsEnd || blockIsCenter ? (vpSize / divide2 - elSize / divide2) * (isX && _isRTL && normalizeRTL ? -1 : 1) : 0;
                  }
                };
                finalizeBlock(true);
                finalizeBlock(false);
              }
              if (doNotScroll.y)
                delete elementScrollCoordinates.y;
              if (doNotScroll.x)
                delete elementScrollCoordinates.x;
              coordinates = elementScrollCoordinates;
            }
          }
          finalScroll[_strScrollLeft] = getFinalScroll(true, getRawScroll(true, coordinates));
          finalScroll[_strScrollTop] = getFinalScroll(false, getRawScroll(false, coordinates));
          doScrollLeft = finalScroll[_strScrollLeft] !== undefined$1;
          doScrollTop = finalScroll[_strScrollTop] !== undefined$1;
          if ((doScrollLeft || doScrollTop) && (duration2 > 0 || durationIsObject)) {
            if (durationIsObject) {
              duration2.complete = proxyCompleteCallback;
              _viewportElement.animate(finalScroll, duration2);
            } else {
              animationOptions = {
                duration: duration2,
                complete: proxyCompleteCallback
              };
              if (COMPATIBILITY.isA(easing2) || FRAMEWORK.isPlainObject(easing2)) {
                specialEasing[_strScrollLeft] = easing2[0] || easing2.x;
                specialEasing[_strScrollTop] = easing2[1] || easing2.y;
                animationOptions.specialEasing = specialEasing;
              } else {
                animationOptions.easing = easing2;
              }
              _viewportElement.animate(finalScroll, animationOptions);
            }
          } else {
            if (doScrollLeft)
              _viewportElement[_strScrollLeft](finalScroll[_strScrollLeft]);
            if (doScrollTop)
              _viewportElement[_strScrollTop](finalScroll[_strScrollTop]);
            updateScrollbarInfos();
          }
        };
        _base.scrollStop = function(param1, param2, param3) {
          _viewportElement.stop(param1, param2, param3);
          return _base;
        };
        _base.getElements = function(elementName) {
          var obj = {
            target: _targetElementNative,
            host: _hostElementNative,
            padding: _paddingElementNative,
            viewport: _viewportElementNative,
            content: _contentElementNative,
            scrollbarHorizontal: {
              scrollbar: _scrollbarHorizontalElement[0],
              track: _scrollbarHorizontalTrackElement[0],
              handle: _scrollbarHorizontalHandleElement[0]
            },
            scrollbarVertical: {
              scrollbar: _scrollbarVerticalElement[0],
              track: _scrollbarVerticalTrackElement[0],
              handle: _scrollbarVerticalHandleElement[0]
            },
            scrollbarCorner: _scrollbarCornerElement[0]
          };
          return type(elementName) == TYPES.s ? getObjectPropVal(obj, elementName) : obj;
        };
        _base.getState = function(stateProperty) {
          function prepare(obj2) {
            if (!FRAMEWORK.isPlainObject(obj2))
              return obj2;
            var extended = extendDeep({}, obj2);
            var changePropertyName = function(from, to) {
              if (extended[LEXICON.hOP](from)) {
                extended[to] = extended[from];
                delete extended[from];
              }
            };
            changePropertyName("w", _strWidth);
            changePropertyName("h", _strHeight);
            delete extended.c;
            return extended;
          }
          var obj = {
            destroyed: !!prepare(_destroyed),
            sleeping: !!prepare(_sleeping),
            autoUpdate: prepare(!_mutationObserversConnected),
            widthAuto: prepare(_widthAutoCache),
            heightAuto: prepare(_heightAutoCache),
            padding: prepare(_cssPaddingCache),
            overflowAmount: prepare(_overflowAmountCache),
            hideOverflow: prepare(_hideOverflowCache),
            hasOverflow: prepare(_hasOverflowCache),
            contentScrollSize: prepare(_contentScrollSizeCache),
            viewportSize: prepare(_viewportSize),
            hostSize: prepare(_hostSizeCache),
            documentMixed: prepare(_documentMixed)
          };
          return type(stateProperty) == TYPES.s ? getObjectPropVal(obj, stateProperty) : obj;
        };
        _base.ext = function(extName) {
          var result;
          var privateMethods = _extensionsPrivateMethods.split(" ");
          var i2 = 0;
          if (type(extName) == TYPES.s) {
            if (_extensions[LEXICON.hOP](extName)) {
              result = extendDeep({}, _extensions[extName]);
              for (; i2 < privateMethods.length; i2++)
                delete result[privateMethods[i2]];
            }
          } else {
            result = {};
            for (i2 in _extensions)
              result[i2] = extendDeep({}, _base.ext(i2));
          }
          return result;
        };
        _base.addExt = function(extName, extensionOptions) {
          var registeredExtensionObj = _plugin.extension(extName);
          var instance;
          var instanceAdded;
          var instanceContract;
          var contractResult;
          var contractFulfilled = true;
          if (registeredExtensionObj) {
            if (!_extensions[LEXICON.hOP](extName)) {
              instance = registeredExtensionObj.extensionFactory.call(_base, extendDeep({}, registeredExtensionObj.defaultOptions), FRAMEWORK, COMPATIBILITY);
              if (instance) {
                instanceContract = instance.contract;
                if (type(instanceContract) == TYPES.f) {
                  contractResult = instanceContract(window2);
                  contractFulfilled = type(contractResult) == TYPES.b ? contractResult : contractFulfilled;
                }
                if (contractFulfilled) {
                  _extensions[extName] = instance;
                  instanceAdded = instance.added;
                  if (type(instanceAdded) == TYPES.f)
                    instanceAdded(extensionOptions);
                  return _base.ext(extName);
                }
              }
            } else
              return _base.ext(extName);
          } else
            console.warn('A extension with the name "' + extName + `" isn't registered.`);
        };
        _base.removeExt = function(extName) {
          var instance = _extensions[extName];
          var instanceRemoved;
          if (instance) {
            delete _extensions[extName];
            instanceRemoved = instance.removed;
            if (type(instanceRemoved) == TYPES.f)
              instanceRemoved();
            return true;
          }
          return false;
        };
        function construct(targetElement, options3, extensions2) {
          _defaultOptions = globals.defaultOptions;
          _nativeScrollbarStyling = globals.nativeScrollbarStyling;
          _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
          _nativeScrollbarIsOverlaid = extendDeep({}, globals.nativeScrollbarIsOverlaid);
          _overlayScrollbarDummySize = extendDeep({}, globals.overlayScrollbarDummySize);
          _rtlScrollBehavior = extendDeep({}, globals.rtlScrollBehavior);
          setOptions(extendDeep({}, _defaultOptions, options3));
          _cssCalc = globals.cssCalc;
          _msieVersion = globals.msie;
          _autoUpdateRecommended = globals.autoUpdateRecommended;
          _supportTransition = globals.supportTransition;
          _supportTransform = globals.supportTransform;
          _supportPassiveEvents = globals.supportPassiveEvents;
          _supportResizeObserver = globals.supportResizeObserver;
          _supportMutationObserver = globals.supportMutationObserver;
          _documentElement = FRAMEWORK(targetElement.ownerDocument);
          _documentElementNative = _documentElement[0];
          _windowElement = FRAMEWORK(_documentElementNative.defaultView || _documentElementNative.parentWindow);
          _windowElementNative = _windowElement[0];
          _htmlElement = findFirst(_documentElement, "html");
          _bodyElement = findFirst(_htmlElement, "body");
          _targetElement = FRAMEWORK(targetElement);
          _targetElementNative = _targetElement[0];
          _isTextarea = _targetElement.is("textarea");
          _isBody = _targetElement.is("body");
          _documentMixed = _documentElementNative !== document2;
          _domExists = _isTextarea ? _targetElement.hasClass(_classNameTextareaElement) && _targetElement.parent().hasClass(_classNameContentElement) : _targetElement.hasClass(_classNameHostElement) && _targetElement.children(_strDot + _classNamePaddingElement)[LEXICON.l];
          var initBodyScroll;
          var bodyMouseTouchDownListener;
          if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y && !_currentPreparedOptions.nativeScrollbarsOverlaid.initialize) {
            _initialized = true;
            dispatchCallback("onInitializationWithdrawn");
            if (_domExists) {
              setupStructureDOM(true);
              setupScrollbarsDOM(true);
              setupScrollbarCornerDOM(true);
            }
            _initialized = false;
            _destroyed = true;
            _sleeping = true;
            return _base;
          }
          if (_isBody) {
            initBodyScroll = {};
            initBodyScroll.l = MATH.max(_targetElement[_strScrollLeft](), _htmlElement[_strScrollLeft](), _windowElement[_strScrollLeft]());
            initBodyScroll.t = MATH.max(_targetElement[_strScrollTop](), _htmlElement[_strScrollTop](), _windowElement[_strScrollTop]());
            bodyMouseTouchDownListener = function() {
              _viewportElement.removeAttr(LEXICON.ti);
              setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, true, true);
            };
          }
          setupStructureDOM();
          setupScrollbarsDOM();
          setupScrollbarCornerDOM();
          setupStructureEvents();
          setupScrollbarEvents(true);
          setupScrollbarEvents(false);
          setupScrollbarCornerEvents();
          createMutationObservers();
          setupResizeObserver(_sizeObserverElement, hostOnResized);
          if (_isBody) {
            _viewportElement[_strScrollLeft](initBodyScroll.l)[_strScrollTop](initBodyScroll.t);
            if (document2.activeElement == targetElement && _viewportElementNative.focus) {
              _viewportElement.attr(LEXICON.ti, "-1");
              _viewportElementNative.focus();
              setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, false, true);
            }
          }
          _base.update(_strAuto);
          _initialized = true;
          dispatchCallback("onInitialized");
          each(_callbacksInitQeueue, function(index2, value) {
            dispatchCallback(value.n, value.a);
          });
          _callbacksInitQeueue = [];
          if (type(extensions2) == TYPES.s)
            extensions2 = [extensions2];
          if (COMPATIBILITY.isA(extensions2))
            each(extensions2, function(index2, value) {
              _base.addExt(value);
            });
          else if (FRAMEWORK.isPlainObject(extensions2))
            each(extensions2, function(key, value) {
              _base.addExt(key, value);
            });
          setTimeout(function() {
            if (_supportTransition && !_destroyed)
              addClass2(_hostElement, _classNameHostTransition);
          }, 333);
          return _base;
        }
        if (_plugin.valid(construct(pluginTargetElement, options2, extensions))) {
          INSTANCES(pluginTargetElement, _base);
        }
        return _base;
      }
      _plugin = window2[PLUGINNAME] = function(pluginTargetElements, options2, extensions) {
        if (arguments[LEXICON.l] === 0)
          return this;
        var arr = [];
        var optsIsPlainObj = FRAMEWORK.isPlainObject(options2);
        var inst;
        var result;
        if (!pluginTargetElements)
          return optsIsPlainObj || !options2 ? result : arr;
        pluginTargetElements = pluginTargetElements[LEXICON.l] != undefined$1 ? pluginTargetElements : [pluginTargetElements[0] || pluginTargetElements];
        initOverlayScrollbarsStatics();
        if (pluginTargetElements[LEXICON.l] > 0) {
          if (optsIsPlainObj) {
            FRAMEWORK.each(pluginTargetElements, function(i2, v) {
              inst = v;
              if (inst !== undefined$1)
                arr.push(OverlayScrollbarsInstance(inst, options2, extensions, _pluginsGlobals, _pluginsAutoUpdateLoop));
            });
          } else {
            FRAMEWORK.each(pluginTargetElements, function(i2, v) {
              inst = INSTANCES(v);
              if (options2 === "!" && _plugin.valid(inst) || COMPATIBILITY.type(options2) == TYPES.f && options2(v, inst))
                arr.push(inst);
              else if (options2 === undefined$1)
                arr.push(inst);
            });
          }
          result = arr[LEXICON.l] === 1 ? arr[0] : arr;
        }
        return result;
      };
      _plugin.globals = function() {
        initOverlayScrollbarsStatics();
        var globals = FRAMEWORK.extend(true, {}, _pluginsGlobals);
        delete globals["msie"];
        return globals;
      };
      _plugin.defaultOptions = function(newDefaultOptions) {
        initOverlayScrollbarsStatics();
        var currDefaultOptions = _pluginsGlobals.defaultOptions;
        if (newDefaultOptions === undefined$1)
          return FRAMEWORK.extend(true, {}, currDefaultOptions);
        _pluginsGlobals.defaultOptions = FRAMEWORK.extend(true, {}, currDefaultOptions, _pluginsOptions._validate(newDefaultOptions, _pluginsOptions._template, true, currDefaultOptions)._default);
      };
      _plugin.valid = function(osInstance) {
        return osInstance instanceof _plugin && !osInstance.getState().destroyed;
      };
      _plugin.extension = function(extensionName, extension, defaultOptions) {
        var extNameTypeString = COMPATIBILITY.type(extensionName) == TYPES.s;
        var argLen = arguments[LEXICON.l];
        var i2 = 0;
        if (argLen < 1 || !extNameTypeString) {
          return FRAMEWORK.extend(true, { length: _pluginsExtensions[LEXICON.l] }, _pluginsExtensions);
        } else if (extNameTypeString) {
          if (COMPATIBILITY.type(extension) == TYPES.f) {
            _pluginsExtensions.push({
              name: extensionName,
              extensionFactory: extension,
              defaultOptions
            });
          } else {
            for (; i2 < _pluginsExtensions[LEXICON.l]; i2++) {
              if (_pluginsExtensions[i2].name === extensionName) {
                if (argLen > 1)
                  _pluginsExtensions.splice(i2, 1);
                else
                  return FRAMEWORK.extend(true, {}, _pluginsExtensions[i2]);
              }
            }
          }
        }
      };
      return _plugin;
    }();
    if (JQUERY && JQUERY.fn) {
      JQUERY.fn.overlayScrollbars = function(options2, extensions) {
        var _elements = this;
        if (JQUERY.isPlainObject(options2)) {
          JQUERY.each(_elements, function() {
            PLUGIN(this, options2, extensions);
          });
          return _elements;
        } else
          return PLUGIN(_elements, options2);
      };
    }
    return PLUGIN;
  });
})(OverlayScrollbars$1);
var OverlayScrollbars = OverlayScrollbars$1.exports;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function __rest(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
}
class OverlayScrollbarsComponent extends Component {
  constructor(props) {
    super(props);
    this._osInstance = null;
    this._osTargetRef = React__default.createRef();
  }
  osInstance() {
    return this._osInstance;
  }
  osTarget() {
    return this._osTargetRef.current || null;
  }
  componentDidMount() {
    this._osInstance = OverlayScrollbars(this.osTarget(), this.props.options || {}, this.props.extensions);
    mergeHostClassNames(this._osInstance, this.props.className);
  }
  componentWillUnmount() {
    if (OverlayScrollbars.valid(this._osInstance)) {
      this._osInstance.destroy();
      this._osInstance = null;
    }
  }
  componentDidUpdate(prevProps) {
    if (OverlayScrollbars.valid(this._osInstance)) {
      this._osInstance.options(this.props.options);
      if (prevProps.className !== this.props.className) {
        mergeHostClassNames(this._osInstance, this.props.className);
      }
    }
  }
  render() {
    const _a = this.props, divProps = __rest(_a, ["options", "extensions", "children", "className"]);
    return React__default.createElement("div", Object.assign({ className: "os-host" }, divProps, { ref: this._osTargetRef }), React__default.createElement("div", { className: "os-resize-observer-host" }), React__default.createElement("div", { className: "os-padding" }, React__default.createElement("div", { className: "os-viewport" }, React__default.createElement("div", { className: "os-content" }, this.props.children))), React__default.createElement("div", { className: "os-scrollbar os-scrollbar-horizontal " }, React__default.createElement("div", { className: "os-scrollbar-track" }, React__default.createElement("div", { className: "os-scrollbar-handle" }))), React__default.createElement("div", { className: "os-scrollbar os-scrollbar-vertical" }, React__default.createElement("div", { className: "os-scrollbar-track" }, React__default.createElement("div", { className: "os-scrollbar-handle" }))), React__default.createElement("div", { className: "os-scrollbar-corner" }));
  }
}
function mergeHostClassNames(osInstance, className) {
  if (OverlayScrollbars.valid(osInstance)) {
    const { host } = osInstance.getElements();
    const regex = new RegExp(`(^os-host([-_].+|)$)|${osInstance.options().className.replace(/\s/g, "$|")}$`, "g");
    const osClassNames = host.className.split(" ").filter((name2) => name2.match(regex)).join(" ");
    host.className = `${osClassNames} ${className || ""}`;
  }
}
const FullHeightOverlayScrollbars = (props) => {
  return /* @__PURE__ */ React__default.createElement(OverlayScrollbarsComponent, {
    options: { scrollbars: { autoHide: "scroll" } }
  }, /* @__PURE__ */ React__default.createElement("div", {
    style: { height: props.height }
  }, props.children));
};
const largeTabsHeader$1 = "_largeTabsHeader_d2sio_1";
var styles$1 = {
  largeTabsHeader: largeTabsHeader$1
};
const largeTabsHeader = "_largeTabsHeader_d2sio_1";
var styles = {
  largeTabsHeader
};
function ConfigurationPanel({
  showSourceCode,
  height,
  onBack,
  compact
}) {
  const [inited, setInited] = useState(false);
  useEffect(() => {
    let timer = setTimeout(() => {
      setInited(true);
    }, 100);
    return () => {
      clearTimeout(timer);
    };
  }, []);
  if (!inited)
    return null;
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, showSourceCode ? /* @__PURE__ */ React__default.createElement(Tabs$1, {
    className: styles.tabs,
    renderTabHeader: (_, DefaultHeader) => !compact ? /* @__PURE__ */ React__default.createElement("div", {
      className: styles.largeTabsHeader,
      style: { display: "flex", alignItems: "center" }
    }, /* @__PURE__ */ React__default.createElement("div", {
      style: { padding: 10, cursor: "pointer" },
      onClick: onBack
    }, /* @__PURE__ */ React__default.createElement(IconLeft$1, {
      fontSize: 16
    })), /* @__PURE__ */ React__default.createElement(DefaultHeader, {
      style: { flex: 1 }
    })) : /* @__PURE__ */ React__default.createElement("div", {
      className: styles.largeTabsHeader,
      style: { display: "flex", alignItems: "center" }
    }, /* @__PURE__ */ React__default.createElement(DefaultHeader, {
      style: { flex: 1 }
    }))
  }, /* @__PURE__ */ React__default.createElement(Tabs$1.TabPane, {
    title: /* @__PURE__ */ React__default.createElement("div", {
      style: { height: 40, lineHeight: "40px" }
    }, t("Configuration"))
  }, /* @__PURE__ */ React__default.createElement(FullHeightOverlayScrollbars, {
    height: `calc(${height} - 60px)`
  }, /* @__PURE__ */ React__default.createElement(AttributePanel, null))), /* @__PURE__ */ React__default.createElement(Tabs$1.TabPane, {
    destroyOnHide: true,
    key: "Source code",
    title: /* @__PURE__ */ React__default.createElement("div", {
      style: { height: 40, lineHeight: "40px" }
    }, t("Source code"))
  }, /* @__PURE__ */ React__default.createElement(FullHeightOverlayScrollbars, {
    height: `calc(${height} - 60px)`
  }, /* @__PURE__ */ React__default.createElement(SourceCodePanel, null)))) : /* @__PURE__ */ React__default.createElement(AttributePanel, null));
}
function ConfigurationDrawer({
  height,
  compact
}) {
  const refWrapper = useRef(null);
  const { focusIdx: focusIdx2, setFocusIdx } = useFocusIdx();
  const onClose = useCallback(() => {
    setFocusIdx("");
  }, [setFocusIdx]);
  const visible = Boolean(focusIdx2);
  return useMemo(() => {
    return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("div", {
      ref: refWrapper,
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        zIndex: 1,
        pointerEvents: visible ? "auto" : "none"
      }
    }), refWrapper.current && /* @__PURE__ */ React__default.createElement(Drawer$1, {
      width: "100%",
      title: null,
      closable: false,
      focusLock: false,
      placement: "right",
      bodyStyle: { padding: 0 },
      visible,
      getPopupContainer: () => refWrapper && refWrapper.current,
      footer: null,
      onCancel: onClose
    }, /* @__PURE__ */ React__default.createElement(ConfigurationPanel, {
      compact,
      showSourceCode: true,
      height,
      onBack: onClose
    })));
  }, [visible, onClose, compact, height]);
}
const TabPane = Tabs$1.TabPane;
function EditPanel() {
  const { height } = useEditorProps();
  const { compact = true } = useExtensionProps();
  return /* @__PURE__ */ React__default.createElement(Layout$1.Sider, {
    className: styles$1.blocksPanel,
    style: { paddingRight: 0, minWidth: 360 },
    collapsible: true,
    trigger: null,
    breakpoint: "xl",
    collapsedWidth: 60,
    width: 360
  }, /* @__PURE__ */ React__default.createElement(Tabs$1, {
    defaultActiveTab: "2",
    style: { width: "100%", padding: 0 },
    renderTabHeader: (_, DefaultHeader) => /* @__PURE__ */ React__default.createElement("div", {
      className: styles$1.largeTabsHeader
    }, /* @__PURE__ */ React__default.createElement(DefaultHeader, null))
  }, /* @__PURE__ */ React__default.createElement(TabPane, {
    key: "2",
    title: "Block"
  }, /* @__PURE__ */ React__default.createElement(FullHeightOverlayScrollbars, {
    height: `calc(${height} - 60px)`
  }, /* @__PURE__ */ React__default.createElement(Blocks, null))), /* @__PURE__ */ React__default.createElement(TabPane, {
    key: "1",
    title: t("Layer")
  }, /* @__PURE__ */ React__default.createElement(FullHeightOverlayScrollbars, {
    height: `calc(${height} - 60px)`
  }, /* @__PURE__ */ React__default.createElement("div", {
    style: { padding: 20 }
  }, /* @__PURE__ */ React__default.createElement(BlockLayer, null))))), !compact && /* @__PURE__ */ React__default.createElement(ConfigurationDrawer, {
    height,
    compact: Boolean(compact)
  }));
}
const defaultCategories = [
  {
    label: "Content",
    active: true,
    blocks: [
      {
        type: AdvancedType.TEXT
      },
      {
        type: AdvancedType.IMAGE,
        payload: { attributes: { padding: "0px 0px 0px 0px" } }
      },
      {
        type: AdvancedType.BUTTON
      },
      {
        type: AdvancedType.SOCIAL
      },
      {
        type: AdvancedType.DIVIDER
      },
      {
        type: AdvancedType.SPACER
      },
      {
        type: AdvancedType.HERO
      },
      {
        type: AdvancedType.WRAPPER
      }
    ]
  },
  {
    label: "Layout",
    active: true,
    displayType: "column",
    blocks: [
      {
        title: "2 columns",
        payload: [
          ["50%", "50%"],
          ["33%", "67%"],
          ["67%", "33%"],
          ["25%", "75%"],
          ["75%", "25%"]
        ]
      },
      {
        title: "3 columns",
        payload: [
          ["33.33%", "33.33%", "33.33%"],
          ["25%", "25%", "50%"],
          ["50%", "25%", "25%"]
        ]
      },
      {
        title: "4 columns",
        payload: [[["25%", "25%", "25%", "25%"]]]
      }
    ]
  }
];
const StandardLayout = (props) => {
  const { height: containerHeight } = useEditorProps();
  const { showSourceCode = true, compact = true, categories = defaultCategories } = props;
  const { setFocusIdx } = useFocusIdx();
  useEffect(() => {
    if (!compact) {
      setFocusIdx("");
    }
  }, [compact, setFocusIdx]);
  return /* @__PURE__ */ React__default.createElement(ExtensionProvider, __spreadProps(__spreadValues({}, props), {
    categories
  }), /* @__PURE__ */ React__default.createElement(ConfigProvider, {
    locale: enUS
  }, /* @__PURE__ */ React__default.createElement(Card$1, {
    style: { padding: 0 },
    bodyStyle: {
      padding: 0,
      height: containerHeight,
      overflow: "hidden"
    }
  }, /* @__PURE__ */ React__default.createElement(Layout$1, {
    className: styles$3.StandardLayout,
    style: {
      display: "flex",
      width: "100%",
      overflow: "hidden"
    }
  }, compact && /* @__PURE__ */ React__default.createElement(EditPanel, null), /* @__PURE__ */ React__default.createElement(Layout$1, {
    style: { height: containerHeight, flex: 1 }
  }, props.children), !compact && /* @__PURE__ */ React__default.createElement(EditPanel, null), compact ? /* @__PURE__ */ React__default.createElement(Layout$1.Sider, {
    style: {
      height: containerHeight,
      minWidth: 300,
      maxWidth: 350,
      width: 350
    }
  }, /* @__PURE__ */ React__default.createElement(ConfigurationPanel, {
    compact,
    height: containerHeight,
    showSourceCode
  })) : /* @__PURE__ */ React__default.createElement(Layout$1.Sider, {
    style: { width: 0, overflow: "hidden" }
  }))), /* @__PURE__ */ React__default.createElement(InteractivePrompt, null), /* @__PURE__ */ React__default.createElement(MergeTagBadgePrompt, null)));
};
export { NumberField as $, AttributePanel as A, BlockLayer as B, Color as C, Decoration as D, SourceCodePanel as E, FontFamily as F, SimpleLayout as G, Height as H, InteractivePrompt as I, StandardLayout as J, MergeTagBadgePrompt as K, LetterSpacing as L, Margin as M, NavbarLinkPadding as N, ExtensionContext as O, Padding as P, ExtensionProvider as Q, useExtensionProps as R, ShortcutToolbar as S, TextAlign as T, RICH_TEXT_TOOL_BAR as U, VerticalAlign as V, Width as W, TextField as X, InputWithUnitField as Y, SearchField as Z, TextAreaField as _, getIconNameByBlockType as a, SliderField as a0, ColorPickerField as a1, UploadField as a2, ImageUploaderField as a3, SelectField as a4, TreeSelectField as a5, AutoCompleteField as a6, RadioGroupField as a7, SwitchField as a8, DatePickerField as a9, CheckboxField as aa, EditTabField as ab, EditGridTabField as ac, InlineTextField as ad, enhancer as ae, RichTextField as af, getBlockTitle as b, commonjsGlobal as c, BlockAttributeConfigurationManager as d, Align as e, AttributesPanelWrapper as f, getContextMergeTags as g, ContainerBackgroundColor as h, TextDecoration as i, Background as j, LineHeight as k, TextTransform as l, BackgroundColor as m, Direction as n, Link as o, Border as p, BorderColor as q, FontSize$1 as r, MergeTags$1 as s, BorderStyle as t, FontStyle as u, BorderWidth as v, FontWeight as w, ClassName as x, BlockMarketManager as y, BlockMaskWrapper as z };
//# sourceMappingURL=index2.js.map
